<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="86f064f440ae5767e7b891c416e8e3b3adac224b" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57937406" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a7782-101">Le module <see langword="FileSystem" /> contient les procédures utilisées pour exécuter des opérations sur des fichiers, des répertoires ou des dossiers et les opérations système.</span><span class="sxs-lookup"><span data-stu-id="a7782-101">The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations.</span></span> <span data-ttu-id="a7782-102">La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que le module <see langword="FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-102">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module.</span></span> <span data-ttu-id="a7782-103">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-103">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-104">Ce module prend en charge les mots clés du langage Visual Basic et les membres de bibliothèque Runtime qui accèdent aux fichiers et dossiers.</span><span class="sxs-lookup"><span data-stu-id="a7782-104">This module supports the Visual Basic language keywords and run-time library members that access files and folders.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-105">Cet exemple utilise le `GetAttr` fonction permettant de déterminer les attributs d’un fichier et un répertoire ou un dossier.</span><span class="sxs-lookup"><span data-stu-id="a7782-105">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md"><span data-ttu-id="a7782-106">Liste des répertoires et des fichiers</span><span class="sxs-lookup"><span data-stu-id="a7782-106">Directories and Files Summary</span></span></related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md"><span data-ttu-id="a7782-107">Liste des entrées et sorties</span><span class="sxs-lookup"><span data-stu-id="a7782-107">Input and Output Summary</span></span></related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md"><span data-ttu-id="a7782-108">Mots clés (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-108">Keywords (Visual Basic)</span></span></related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md"><span data-ttu-id="a7782-109">Membres de la bibliothèque d’exécution Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-109">Visual Basic Run-Time Library Members</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="a7782-110">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-110">Required.</span></span> <span data-ttu-id="a7782-111">Expression de chaîne qui identifie le répertoire ou dossier qui devient le nouveau répertoire ou dossier par défaut.</span><span class="sxs-lookup"><span data-stu-id="a7782-111">A string expression that identifies which directory or folder becomes the new default directory or folder.</span></span> <span data-ttu-id="a7782-112"><paramref name="Path" /> peut inclure le lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-112"><paramref name="Path" /> may include the drive.</span></span> <span data-ttu-id="a7782-113">Si aucun lecteur n'est spécifié, <see langword="ChDir" /> modifie le répertoire ou le dossier par défaut du lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="a7782-113">If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</span></span></param>
        <summary><span data-ttu-id="a7782-114">Modifie le répertoire ou dossier actif.</span><span class="sxs-lookup"><span data-stu-id="a7782-114">Changes the current directory or folder.</span></span> <span data-ttu-id="a7782-115">La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d’E/S de fichier que la fonction <see langword="ChDir" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-115">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function.</span></span> <span data-ttu-id="a7782-116">Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-116">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-117">Le `ChDir` fonction modifie le répertoire par défaut, mais pas le lecteur par défaut.</span><span class="sxs-lookup"><span data-stu-id="a7782-117">The `ChDir` function changes the default directory, but not the default drive.</span></span> <span data-ttu-id="a7782-118">Par exemple, si le lecteur par défaut est C, l’instruction suivante change le répertoire par défaut sur le lecteur D, mais C reste le lecteur par défaut :</span><span class="sxs-lookup"><span data-stu-id="a7782-118">For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:</span></span>  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 <span data-ttu-id="a7782-119">Vous pouvez rendre relatif des changements de répertoire est en tapant les deux points, comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-119">You can make relative directory changes is by typing two periods, as follows:</span></span>  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-120">Le `ChDir` fonction nécessite une autorisation de code non managé, ce qui peut affecter son exécution dans les situations de confiance partielle.</span><span class="sxs-lookup"><span data-stu-id="a7782-120">The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="a7782-121">Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et.</span><span class="sxs-lookup"><span data-stu-id="a7782-121">For more information, see <xref:System.Security.Permissions.SecurityPermission> and .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-122">Cet exemple utilise le `ChDir` (fonction) pour modifier le répertoire ou dossier actif.</span><span class="sxs-lookup"><span data-stu-id="a7782-122">This example uses the `ChDir` function to change the current directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-123"><paramref name="Path" /> est vide.</span><span class="sxs-lookup"><span data-stu-id="a7782-123"><paramref name="Path" /> is empty.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a7782-124">Un lecteur non valide est spécifié ou le lecteur est indisponible.</span><span class="sxs-lookup"><span data-stu-id="a7782-124">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md"><span data-ttu-id="a7782-125">Comment : analyser des chemins d'accès dans Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-125">How to: Parse File Paths in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md"><span data-ttu-id="a7782-126">Création, suppression et déplacement de fichiers et de répertoires dans Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-126">Creating, Deleting, and Moving Files and Directories in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7782-127">Modifie le lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="a7782-127">Changes the current drive.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="a7782-128">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-128">Required.</span></span> <span data-ttu-id="a7782-129">Expression String qui spécifie un lecteur existant.</span><span class="sxs-lookup"><span data-stu-id="a7782-129">String expression that specifies an existing drive.</span></span> <span data-ttu-id="a7782-130">Si vous fournissez une chaîne de longueur nulle (""), le lecteur actif n'est pas modifié.</span><span class="sxs-lookup"><span data-stu-id="a7782-130">If you supply a zero-length string (""), the current drive does not change.</span></span> <span data-ttu-id="a7782-131">Si l'argument <paramref name="Drive" /> est une chaîne de plusieurs caractères, <see langword="ChDrive" /> n'utilise que la première lettre.</span><span class="sxs-lookup"><span data-stu-id="a7782-131">If the <paramref name="Drive" /> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span></span></param>
        <summary><span data-ttu-id="a7782-132">Modifie le lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="a7782-132">Changes the current drive.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-133">Le `ChDrive` fonction nécessite une autorisation de code non managé, ce qui peut affecter son exécution dans les situations de confiance partielle.</span><span class="sxs-lookup"><span data-stu-id="a7782-133">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="a7782-134">Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="a7782-134">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-135">Cet exemple utilise le `ChDrive` (fonction) pour modifier le lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="a7782-135">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="a7782-136">La fonction lève une exception si le lecteur n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-136">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-137">Un lecteur non valide est spécifié ou le lecteur est indisponible.</span><span class="sxs-lookup"><span data-stu-id="a7782-137">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-138">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-138">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="a7782-139">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-139">Required.</span></span> <span data-ttu-id="a7782-140">Expression String qui spécifie un lecteur existant.</span><span class="sxs-lookup"><span data-stu-id="a7782-140">String expression that specifies an existing drive.</span></span> <span data-ttu-id="a7782-141">Si vous fournissez une chaîne de longueur nulle (""), le lecteur actif n'est pas modifié.</span><span class="sxs-lookup"><span data-stu-id="a7782-141">If you supply a zero-length string (""), the current drive does not change.</span></span> <span data-ttu-id="a7782-142">Si l'argument <paramref name="Drive" /> est une chaîne de plusieurs caractères, <see langword="ChDrive" /> n'utilise que la première lettre.</span><span class="sxs-lookup"><span data-stu-id="a7782-142">If the <paramref name="Drive" /> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span></span></param>
        <summary><span data-ttu-id="a7782-143">Modifie le lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="a7782-143">Changes the current drive.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-144">Le `ChDrive` fonction nécessite une autorisation de code non managé, ce qui peut affecter son exécution dans les situations de confiance partielle.</span><span class="sxs-lookup"><span data-stu-id="a7782-144">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="a7782-145">Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="a7782-145">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-146">Cet exemple utilise le `ChDrive` (fonction) pour modifier le lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="a7782-146">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="a7782-147">La fonction lève une exception si le lecteur n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-147">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-148">Un lecteur non valide est spécifié ou le lecteur est indisponible.</span><span class="sxs-lookup"><span data-stu-id="a7782-148">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-149">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-149">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7782-150">Retourne une chaîne représentant le chemin d'accès en cours.</span><span class="sxs-lookup"><span data-stu-id="a7782-150">Returns a string representing the current path.</span></span> <span data-ttu-id="a7782-151">Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="CurDir" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-151">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="a7782-152">Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-152">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7782-153">Retourne une chaîne représentant le chemin d'accès en cours.</span><span class="sxs-lookup"><span data-stu-id="a7782-153">Returns a string representing the current path.</span></span> <span data-ttu-id="a7782-154">Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="CurDir" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-154">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="a7782-155">Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-155">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
        <returns><span data-ttu-id="a7782-156">Chaîne représentant le chemin d'accès actuel.</span><span class="sxs-lookup"><span data-stu-id="a7782-156">A string representing the current path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a7782-157">Cet exemple utilise le `CurDir` fonction pour retourner le chemin d’accès actuel.</span><span class="sxs-lookup"><span data-stu-id="a7782-157">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="a7782-158">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-158">Optional.</span></span> <span data-ttu-id="a7782-159">Expression <see langword="Char" /> qui spécifie un lecteur existant.</span><span class="sxs-lookup"><span data-stu-id="a7782-159"><see langword="Char" /> expression that specifies an existing drive.</span></span> <span data-ttu-id="a7782-160">Si aucun lecteur n'est spécifié ou si <paramref name="Drive" /> est une chaîne de longueur nulle (""), <see langword="CurDir" /> retourne le chemin d'accès du lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="a7782-160">If no drive is specified, or if <paramref name="Drive" /> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</span></span></param>
        <summary><span data-ttu-id="a7782-161">Retourne une chaîne représentant le chemin d'accès en cours.</span><span class="sxs-lookup"><span data-stu-id="a7782-161">Returns a string representing the current path.</span></span> <span data-ttu-id="a7782-162">Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="CurDir" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-162">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="a7782-163">Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-163">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
        <returns><span data-ttu-id="a7782-164">Chaîne représentant le chemin d'accès actuel.</span><span class="sxs-lookup"><span data-stu-id="a7782-164">A string representing the current path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a7782-165">Cet exemple utilise le `CurDir` fonction pour retourner le chemin d’accès actuel.</span><span class="sxs-lookup"><span data-stu-id="a7782-165">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7782-166">Retourne une chaîne représentant le nom d'un fichier, d'un répertoire ou d'un dossier qui correspond à un modèle ou un attribut de fichier spécifié ou au nom de volume d'un lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-166">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="a7782-167">Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que la fonction <see langword="Dir" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-167">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="a7782-168">Pour plus d'informations, voir <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-168">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7782-169">Retourne une chaîne représentant le nom d'un fichier, d'un répertoire ou d'un dossier qui correspond à un modèle ou un attribut de fichier spécifié ou au nom de volume d'un lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-169">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="a7782-170">Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que la fonction <see langword="Dir" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-170">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="a7782-171">Pour plus d'informations, voir <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-171">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="a7782-172">Chaîne représentant le nom d'un fichier, d'un répertoire ou d'un dossier qui correspond à un attribut de fichier ou de modèle spécifié ou au nom de volume d'un lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-172">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-173">Le `Dir` fonction prend en charge l’utilisation de plusieurs caractères (`*`) et le caractère unique (`?`) des caractères génériques pour spécifier plusieurs fichiers.</span><span class="sxs-lookup"><span data-stu-id="a7782-173">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="a7782-174">`VbVolume` Retourne le nom de volume pour le lecteur au lieu d’un nom de fichier spécifique.</span><span class="sxs-lookup"><span data-stu-id="a7782-174">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="a7782-175">Vous devez fournir un `PathName` la première fois que vous appelez le `Dir` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-175">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="a7782-176">Pour récupérer l’élément suivant, vous pouvez effectuer les appels suivants à la `Dir` fonction sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="a7782-176">To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-177">Pour s’exécuter correctement, le `Dir` fonction requiert le <xref:System.Security.Permissions.FileIOPermissionAccess.Read> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> indicateurs de <xref:System.Security.Permissions.FileIOPermission> à accorder à l’exécution de code.</span><span class="sxs-lookup"><span data-stu-id="a7782-177">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="a7782-178">Pour plus d’informations, consultez <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="a7782-178">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="a7782-179">Le `Attributes` des valeurs d’énumération arguments sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="a7782-179">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="a7782-180">Value</span><span class="sxs-lookup"><span data-stu-id="a7782-180">Value</span></span>|<span data-ttu-id="a7782-181">Constante</span><span class="sxs-lookup"><span data-stu-id="a7782-181">Constant</span></span>|<span data-ttu-id="a7782-182">Description </span><span class="sxs-lookup"><span data-stu-id="a7782-182">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="a7782-183">Par défaut.</span><span class="sxs-lookup"><span data-stu-id="a7782-183">Default.</span></span> <span data-ttu-id="a7782-184">Spécifie les fichiers sans attributs.</span><span class="sxs-lookup"><span data-stu-id="a7782-184">Specifies files without attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="a7782-185">Spécifie les fichiers en lecture seule et également des fichiers sans attributs.</span><span class="sxs-lookup"><span data-stu-id="a7782-185">Specifies read-only files, and also files without attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="a7782-186">Spécifie les fichiers masqués, ainsi que les fichiers sans attributs.</span><span class="sxs-lookup"><span data-stu-id="a7782-186">Specifies hidden files, and also files without attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="a7782-187">Spécifie les fichiers système et également des fichiers sans attributs.</span><span class="sxs-lookup"><span data-stu-id="a7782-187">Specifies system files, and also files without attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="a7782-188">Spécifie le nom de volume. Si aucun autre attribut est spécifié, `vbVolume` est ignoré.</span><span class="sxs-lookup"><span data-stu-id="a7782-188">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="a7782-189">Spécifie les répertoires ou des dossiers et également des fichiers sans attributs.</span><span class="sxs-lookup"><span data-stu-id="a7782-189">Specifies directories or folders, and also files without attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="a7782-190">Le fichier a été modifié depuis sa dernière sauvegarde.</span><span class="sxs-lookup"><span data-stu-id="a7782-190">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="a7782-191">Le fichier porte un nom différent.</span><span class="sxs-lookup"><span data-stu-id="a7782-191">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="a7782-192">Ces énumérations sont spécifiées par le langage Visual Basic et peuvent être utilisées partout dans votre code au lieu des valeurs réelles.</span><span class="sxs-lookup"><span data-stu-id="a7782-192">These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-193">Cet exemple utilise le `Dir` (fonction) pour vérifier si certains fichiers et répertoires existent.</span><span class="sxs-lookup"><span data-stu-id="a7782-193">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="a7782-194">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-194">Optional.</span></span> <span data-ttu-id="a7782-195">Une expression de chaîne qui spécifie un nom de fichier, de répertoire ou de dossier, ou l’étiquette du volume d’un lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-195">A string expression that specifies a file name, directory or folder name, or drive volume label.</span></span> <span data-ttu-id="a7782-196">Une chaîne de longueur nulle (<see langword="&quot;&quot;" />) est retournée si <paramref name="PathName" /> n'est pas trouvé.</span><span class="sxs-lookup"><span data-stu-id="a7782-196">A zero-length string (<see langword="&quot;&quot;" />) is returned if <paramref name="PathName" /> is not found.</span></span></param>
        <param name="Pathname"><span data-ttu-id="a7782-197">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-197">Optional.</span></span> <span data-ttu-id="a7782-198">Une expression de chaîne qui spécifie un nom de fichier, de répertoire ou de dossier, ou l’étiquette du volume d’un lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-198">A string expression that specifies a file name, directory or folder name, or drive volume label.</span></span> <span data-ttu-id="a7782-199">Une chaîne de longueur nulle (<see langword="&quot;&quot;" />) est retournée si <paramref name="Pathname" /> n'est pas trouvé.</span><span class="sxs-lookup"><span data-stu-id="a7782-199">A zero-length string (<see langword="&quot;&quot;" />) is returned if <paramref name="Pathname" /> is not found.</span></span></param>
        <param name="Attributes"><span data-ttu-id="a7782-200">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-200">Optional.</span></span> <span data-ttu-id="a7782-201">Énumération ou expression numérique dont la valeur spécifie des attributs de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-201">Enumeration or numeric expression whose value specifies file attributes.</span></span> <span data-ttu-id="a7782-202">En cas d'omission, <see langword="Dir" /> retourne des fichiers qui correspondent à <paramref name="Pathname" />, mais n'ont pas d'attributs.</span><span class="sxs-lookup"><span data-stu-id="a7782-202">If omitted, <see langword="Dir" /> returns files that match <paramref name="Pathname" /> but have no attributes.</span></span></param>
        <summary><span data-ttu-id="a7782-203">Retourne une chaîne représentant le nom d'un fichier, d'un répertoire ou d'un dossier qui correspond à un modèle ou un attribut de fichier spécifié ou au nom de volume d'un lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-203">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="a7782-204">Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que la fonction <see langword="Dir" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-204">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="a7782-205">Pour plus d'informations, voir <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-205">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="a7782-206">Chaîne représentant le nom d'un fichier, d'un répertoire ou d'un dossier qui correspond à un attribut de fichier ou de modèle spécifié ou au nom de volume d'un lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-206">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-207">Le `Dir` fonction prend en charge l’utilisation de plusieurs caractères (`*`) et le caractère unique (`?`) des caractères génériques pour spécifier plusieurs fichiers.</span><span class="sxs-lookup"><span data-stu-id="a7782-207">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="a7782-208">`VbVolume` Retourne le nom de volume pour le lecteur au lieu d’un nom de fichier spécifique.</span><span class="sxs-lookup"><span data-stu-id="a7782-208">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="a7782-209">Vous devez fournir un `PathName` la première fois que vous appelez le `Dir` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-209">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="a7782-210">Pour récupérer l’élément suivant, vous pouvez effectuer les appels suivants à la `Dir` fonction sans paramètres.</span><span class="sxs-lookup"><span data-stu-id="a7782-210">To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-211">Pour s’exécuter correctement, le `Dir` fonction requiert le <xref:System.Security.Permissions.FileIOPermissionAccess.Read> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> indicateurs de <xref:System.Security.Permissions.FileIOPermission> à accorder à l’exécution de code.</span><span class="sxs-lookup"><span data-stu-id="a7782-211">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="a7782-212">Pour plus d’informations, consultez <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="a7782-212">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="a7782-213">Le `Attributes` des valeurs d’énumération arguments sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="a7782-213">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="a7782-214">Value</span><span class="sxs-lookup"><span data-stu-id="a7782-214">Value</span></span>|<span data-ttu-id="a7782-215">Constante</span><span class="sxs-lookup"><span data-stu-id="a7782-215">Constant</span></span>|<span data-ttu-id="a7782-216">Description </span><span class="sxs-lookup"><span data-stu-id="a7782-216">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="a7782-217">Par défaut.</span><span class="sxs-lookup"><span data-stu-id="a7782-217">Default.</span></span> <span data-ttu-id="a7782-218">Spécifie les fichiers sans attributs.</span><span class="sxs-lookup"><span data-stu-id="a7782-218">Specifies files that have no attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="a7782-219">Spécifie les fichiers en lecture seule, en plus des fichiers sans attributs.</span><span class="sxs-lookup"><span data-stu-id="a7782-219">Specifies read-only files, in addition to files that have no attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="a7782-220">Spécifie les fichiers cachés, en plus des fichiers sans attributs.</span><span class="sxs-lookup"><span data-stu-id="a7782-220">Specifies hidden files, in addition to files that have no attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="a7782-221">Spécifie les fichiers système, en plus des fichiers sans attributs.</span><span class="sxs-lookup"><span data-stu-id="a7782-221">Specifies system files, in addition to files that have no attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="a7782-222">Spécifie le nom de volume. Si aucun autre attribut est spécifié, `vbVolume` est ignoré.</span><span class="sxs-lookup"><span data-stu-id="a7782-222">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="a7782-223">Spécifie les dossiers, en plus des fichiers sans attributs.</span><span class="sxs-lookup"><span data-stu-id="a7782-223">Specifies directories or folders, in addition to files that have no attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="a7782-224">Le fichier a été modifié depuis sa dernière sauvegarde.</span><span class="sxs-lookup"><span data-stu-id="a7782-224">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="a7782-225">Le fichier porte un nom différent.</span><span class="sxs-lookup"><span data-stu-id="a7782-225">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="a7782-226">Ces énumérations sont spécifiées par le langage Visual Basic et peuvent être utilisées partout dans votre code à la place les valeurs réelles.</span><span class="sxs-lookup"><span data-stu-id="a7782-226">These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-227">Cet exemple utilise le `Dir` (fonction) pour vérifier si certains fichiers et répertoires existent.</span><span class="sxs-lookup"><span data-stu-id="a7782-227">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-228">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-228">Required.</span></span> <span data-ttu-id="a7782-229"><see langword="Integer" /> qui contient un numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-229">An <see langword="Integer" /> that contains any valid file number.</span></span></param>
        <summary><span data-ttu-id="a7782-230">Retourne une valeur booléenne <see langword="True" /> lorsque la fin d'un fichier ouvert pour <see langword="Random" /> ou <see langword="Input" /> séquentiel a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="a7782-230">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span></span></summary>
        <returns><span data-ttu-id="a7782-231">Une valeur booléenne <see langword="True" /> lorsque la fin d’un fichier ouvert pour <see langword="Random" /> ou <see langword="Input" /> séquentiel a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="a7782-231">A Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-232">Utilisez `EOF` afin d’éviter l’erreur générée en tentant d’obtenir des données au-delà de la fin d’un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-232">Use `EOF` to avoid the error generated by attempting to get input past the end of a file.</span></span>  
  
 <span data-ttu-id="a7782-233">Le `EOF` fonction renvoie `False` jusqu'à ce que la fin du fichier a été atteinte.</span><span class="sxs-lookup"><span data-stu-id="a7782-233">The `EOF` function returns `False` until the end of the file has been reached.</span></span> <span data-ttu-id="a7782-234">Avec les fichiers ouverts pour `Random` ou `Binary` accès, `EOF` retourne `False` jusqu'à l’exécution de la dernière `FileGet` fonction ne peut pas lire un enregistrement entier.</span><span class="sxs-lookup"><span data-stu-id="a7782-234">With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record.</span></span>  
  
 <span data-ttu-id="a7782-235">Avec les fichiers ouverts pour `Binary` accéder, une tentative de lecture par le biais du fichier en utilisant le `Input` fonctionner jusqu'à ce que `EOF` retourne `True` génère une erreur.</span><span class="sxs-lookup"><span data-stu-id="a7782-235">With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="a7782-236">Utiliser le `LOF` et `Loc` fonctions au lieu de `EOF` lors de la lecture des fichiers binaires avec `Input`, ou utilisez `Get` lorsque vous utilisez le `EOF` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-236">Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function.</span></span> <span data-ttu-id="a7782-237">Avec les fichiers ouverts pour `Output`, `EOF` retourne toujours `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-237">With files opened for `Output`, `EOF` always returns `True`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-238">Cet exemple utilise le `EOF` fonction pour détecter la fin d’un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-238">This example uses the `EOF` function to detect the end of a file.</span></span> <span data-ttu-id="a7782-239">Cet exemple suppose que `Testfile` est un fichier texte qui contient plusieurs lignes de texte.</span><span class="sxs-lookup"><span data-stu-id="a7782-239">This example assumes that `Testfile` is a text file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-240">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-240">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-241">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-241">Required.</span></span> <span data-ttu-id="a7782-242"><see langword="Integer" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-242"><see langword="Integer" />.</span></span> <span data-ttu-id="a7782-243">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-243">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="a7782-244">Retourne une énumération qui représente le mode de fichier pour les fichiers ouverts à l'aide de la fonction <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-244">Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a7782-245">Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que la fonction <see langword="FileAttr" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-245">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function.</span></span> <span data-ttu-id="a7782-246">Pour plus d'informations, voir <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-246">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="a7782-247">Les valeurs d'énumération suivantes indiquent le mode d'accès au fichier :</span><span class="sxs-lookup"><span data-stu-id="a7782-247">The following enumeration values indicate the file access mode:</span></span> 
 <list type="table"><item><term> <span data-ttu-id="a7782-248">Value</span><span class="sxs-lookup"><span data-stu-id="a7782-248">Value</span></span> 
 </term><description> <span data-ttu-id="a7782-249">Mode</span><span class="sxs-lookup"><span data-stu-id="a7782-249">Mode</span></span> 
 </description></item><item><term> <span data-ttu-id="a7782-250">1</span><span class="sxs-lookup"><span data-stu-id="a7782-250">1</span></span> 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> <span data-ttu-id="a7782-251">2</span><span class="sxs-lookup"><span data-stu-id="a7782-251">2</span></span> 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> <span data-ttu-id="a7782-252">4</span><span class="sxs-lookup"><span data-stu-id="a7782-252">4</span></span> 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> <span data-ttu-id="a7782-253">8</span><span class="sxs-lookup"><span data-stu-id="a7782-253">8</span></span> 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> <span data-ttu-id="a7782-254">32</span><span class="sxs-lookup"><span data-stu-id="a7782-254">32</span></span> 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-255">Cette fonction retourne une énumération qui représente le mode de fichier pour les fichiers ouverts à l’aide de la `FileOpen` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-255">This function returns an enumeration representing the file mode for files opened using the `FileOpen` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-256">Cet exemple utilise le `FileAttr` fonction pour retourner le mode d’un fichier ouvert.</span><span class="sxs-lookup"><span data-stu-id="a7782-256">This example uses the `FileAttr` function to return the file mode of an open file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-257">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-257">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers"><span data-ttu-id="a7782-258">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-258">Optional.</span></span> <span data-ttu-id="a7782-259">Tableau de paramètres de 0 ou plus de canaux à fermer.</span><span class="sxs-lookup"><span data-stu-id="a7782-259">Parameter array of 0 or more channels to be closed.</span></span></param>
        <summary><span data-ttu-id="a7782-260">Termine les opérations d'entrée/sortie (E/S) dans un fichier ouvert à l'aide de la fonction <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-260">Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a7782-261"><see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-261"><see langword="My" /> gives you better productivity and performance in file I/O operations.</span></span> <span data-ttu-id="a7782-262">Pour plus d'informations, voir <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-262">See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-263">Le `FileClose` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-263">The `FileClose` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-264">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-264">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-265">Pour plus d'informations, voir [Procédure : Lire le texte à partir de fichiers avec un StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [Comment : Écrire du texte dans des fichiers à l’aide de StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), et [procédure pas à pas : Manipulation de fichiers et répertoires en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-265">For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span></span>  
  
 <span data-ttu-id="a7782-266">Si vous omettez `FileNumbers`, tous les fichiers actifs ouvrent par le `FileOpen` (fonction) sont fermés.</span><span class="sxs-lookup"><span data-stu-id="a7782-266">If you omit `FileNumbers`, all active files opened by the `FileOpen` function are closed.</span></span>  
  
 <span data-ttu-id="a7782-267">Lorsque vous fermez les fichiers qui ont été ouverts pour `Output` ou `Append`, la mémoire tampon finale de sortie est écrite dans la mémoire tampon de système d’exploitation pour ce fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-267">When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file.</span></span> <span data-ttu-id="a7782-268">Tout espace associé fermé de mémoires tampons est publié le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-268">All buffer space associated with the closed file is released.</span></span>  
  
 <span data-ttu-id="a7782-269">Lorsque le `FileClose` fonction est exécutée, l’association d’un fichier avec son fichier numéro se termine.</span><span class="sxs-lookup"><span data-stu-id="a7782-269">When the `FileClose` function is executed, the association of a file with its file number ends.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-270">Cet exemple utilise le `FileClose` (fonction) pour fermer un fichier ouvert pour `Input`.</span><span class="sxs-lookup"><span data-stu-id="a7782-270">This example uses the `FileClose` function to close a file opened for `Input`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-271"><paramref name="FileNumber" /> n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-271"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md"><span data-ttu-id="a7782-272">End, instruction</span><span class="sxs-lookup"><span data-stu-id="a7782-272">End Statement</span></span></related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md"><span data-ttu-id="a7782-273">Stop, instruction (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-273">Stop Statement (Visual Basic)</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-274">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-274">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source"><span data-ttu-id="a7782-275">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-275">Required.</span></span> <span data-ttu-id="a7782-276">Une expression de chaîne qui spécifie le nom du fichier à copier.</span><span class="sxs-lookup"><span data-stu-id="a7782-276">A string expression that specifies the name of the file to be copied.</span></span> <span data-ttu-id="a7782-277"><paramref name="Source" /> peut inclure le répertoire ou le dossier du fichier source, ainsi que son lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-277"><paramref name="Source" /> may include the directory or folder, and drive, of the source file.</span></span></param>
        <param name="Destination"><span data-ttu-id="a7782-278">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-278">Required.</span></span> <span data-ttu-id="a7782-279">Une expression de chaîne qui spécifie le nom du fichier de destination.</span><span class="sxs-lookup"><span data-stu-id="a7782-279">A string expression that specifies the destination file name.</span></span> <span data-ttu-id="a7782-280"><paramref name="Destination" /> peut inclure le répertoire ou le dossier, ainsi que le lecteur, du fichier de destination.</span><span class="sxs-lookup"><span data-stu-id="a7782-280"><paramref name="Destination" /> may include the directory or folder, and drive, of the destination file.</span></span></param>
        <summary><span data-ttu-id="a7782-281">Copie un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-281">Copies a file.</span></span> <span data-ttu-id="a7782-282">Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="FileCopy" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-282">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />.</span></span> <span data-ttu-id="a7782-283">Pour plus d'informations, voir <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-283">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-284">Si vous essayez d’utiliser le `FileCopy` fonctionnent sur un fichier ouvert, une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-284">If you try to use the `FileCopy` function on a currently open file, an error occurs.</span></span>  
  
 <span data-ttu-id="a7782-285">`FileCopy` requiert une confiance totale pour travailler sur le lecteur local.</span><span class="sxs-lookup"><span data-stu-id="a7782-285">`FileCopy` requires full trust to work on the local drive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-286">Cet exemple utilise le `FileCopy` (fonction) pour copier un fichier vers un autre.</span><span class="sxs-lookup"><span data-stu-id="a7782-286">This example uses the `FileCopy` function to copy one file to another.</span></span> <span data-ttu-id="a7782-287">Pour cet exemple, supposons que `SrcFile` est un fichier qui contient des données.</span><span class="sxs-lookup"><span data-stu-id="a7782-287">For purposes of this example, assume that `SrcFile` is a file that contains data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-288"><paramref name="Source" /> ou <paramref name="Destination" /> n'est pas valide ou n'est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="a7782-288"><paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-289">Le fichier est déjà ouvert.</span><span class="sxs-lookup"><span data-stu-id="a7782-289">File is already open.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a7782-290">Le fichier n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-290">File does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md"><span data-ttu-id="a7782-291">Guide pratique pour créer une copie d'un fichier dans un autre répertoire en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-291">How to: Create a Copy of a File in a Different Directory in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md"><span data-ttu-id="a7782-292">Guide pratique pour créer une copie d'un fichier dans le même répertoire en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-292">How to: Create a Copy of a File in the Same Directory in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md"><span data-ttu-id="a7782-293">Guide pratique pour copier un répertoire vers un autre répertoire en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-293">How to: Copy a Directory to Another Directory in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="a7782-294">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-294">Required.</span></span> <span data-ttu-id="a7782-295">Une expression de chaîne qui spécifie un nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-295">A string expression that specifies a file name.</span></span> <span data-ttu-id="a7782-296"><paramref name="PathName" /> peut inclure le répertoire ou le dossier, et le lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-296"><paramref name="PathName" /> may include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="a7782-297">Retourne une valeur <see langword="Date" /> qui indique la date et l'heure à laquelle un fichier a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-297">Returns a <see langword="Date" /> value that indicates the date and time a file was written to.</span></span> <span data-ttu-id="a7782-298">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileDateTime" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-298">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />.</span></span> <span data-ttu-id="a7782-299">Pour plus d'informations, consultez <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span><span class="sxs-lookup"><span data-stu-id="a7782-299">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span></span></summary>
        <returns><span data-ttu-id="a7782-300">Valeur <see langword="Date" /> qui indique la date et l'heure à laquelle un fichier a été créé ou modifié pour la dernière fois.</span><span class="sxs-lookup"><span data-stu-id="a7782-300"><see langword="Date" /> value that indicates the date and time a file was created or last modified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a7782-301">Cet exemple utilise le `FileDateTime` fonction pour déterminer la date et l’heure d’un fichier a été créée ou modifiée.</span><span class="sxs-lookup"><span data-stu-id="a7782-301">This example uses the `FileDateTime` function to determine the date and time a file was created or last modified.</span></span> <span data-ttu-id="a7782-302">Le format de la date et l’heure affichée est basé sur les paramètres régionaux du système.</span><span class="sxs-lookup"><span data-stu-id="a7782-302">The format of the date and time displayed is based on the locale settings of the system.</span></span>  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-303"><paramref name="PathName" /> n'est pas valide ou contient des caractères génériques.</span><span class="sxs-lookup"><span data-stu-id="a7782-303"><paramref name="PathName" /> is invalid or contains wildcards.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a7782-304">Le fichier cible n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-304">Target file does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-305">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-305">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7782-306">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-306">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-307">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-307">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-308">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-308">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-309">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-309">Required.</span></span> <span data-ttu-id="a7782-310">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-310">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-311">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-311">Required.</span></span> <span data-ttu-id="a7782-312">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-312">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-313">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-313">Optional.</span></span> <span data-ttu-id="a7782-314">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-314">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a7782-315">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-315">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-316">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-316">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-317">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span><span class="sxs-lookup"><span data-stu-id="a7782-317">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-318">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-318">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-319">Données lues avec `FileGet` sont généralement écrites dans un fichier avec `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-319">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-320">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-320">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-321">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-321">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-322">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-322">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-323">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-323">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-324">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-324">Random Mode</span></span>  
 <span data-ttu-id="a7782-325">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-325">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-326">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-326">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-327">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-327">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-328">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-328">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-329">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-329">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-330">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-330">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-331">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-331">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-332">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-332">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-333">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-333">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-334">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-334">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-335">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-335">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-336">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-336">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-337">Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-337">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-338">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-338">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-339">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-339">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-340">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-340">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-341">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-341">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-342">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-342">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-343">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-343">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-344">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-344">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-345">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-345">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-346">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-346">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-347">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-347">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-348">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-348">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-349">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-349">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-350">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-350">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-351">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-351">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-352">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-352">Binary Mode</span></span>  
 <span data-ttu-id="a7782-353">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-353">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-354">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-354">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-355">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-355">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-356">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-356">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-357">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-357">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-358">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-358">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-359">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-359">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-360">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-360">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-361">Lecture d’un fichier à l’aide de la`FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-361">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-362"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-362"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-363">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-363">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-364">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-364">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-365">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-365">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-366">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-366">Required.</span></span> <span data-ttu-id="a7782-367">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-367">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-368">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-368">Required.</span></span> <span data-ttu-id="a7782-369">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-369">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-370">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-370">Optional.</span></span> <span data-ttu-id="a7782-371">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-371">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a7782-372">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-372">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-373">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-373">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-374">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-374">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-375">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-375">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-376">Données lues avec `FileGet` sont généralement écrites dans un fichier avec `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-376">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-377">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-377">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-378">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-378">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-379">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-379">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-380">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-380">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-381">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-381">Random Mode</span></span>  
 <span data-ttu-id="a7782-382">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-382">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-383">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-383">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-384">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-384">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-385">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-385">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-386">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-386">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-387">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-387">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-388">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-388">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-389">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-389">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-390">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-390">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-391">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-391">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-392">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-392">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-393">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-393">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-394">Si le descripteur n’est pas utilisé.</span><span class="sxs-lookup"><span data-stu-id="a7782-394">If the descriptor is not used.</span></span> <span data-ttu-id="a7782-395">La taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-395">Then the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-396">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-396">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-397">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-397">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-398">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-398">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-399">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-399">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-400">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-400">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-401">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-401">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-402">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-402">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-403">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-403">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-404">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-404">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-405">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-405">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-406">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-406">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-407">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-407">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-408">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-408">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-409">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-409">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-410">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-410">Binary Mode</span></span>  
 <span data-ttu-id="a7782-411">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-411">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-412">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-412">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-413">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-413">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-414">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-414">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-415">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-415">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-416">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-416">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-417">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-417">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-418">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-418">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-419">Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-419">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-420"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-420"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-421">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-421">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-422">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-422">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-423">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-423">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-424">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-424">Required.</span></span> <span data-ttu-id="a7782-425">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-425">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-426">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-426">Required.</span></span> <span data-ttu-id="a7782-427">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-427">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-428">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-428">Optional.</span></span> <span data-ttu-id="a7782-429">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-429">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a7782-430">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-430">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-431">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-431">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-432">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-432">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-433">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-433">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-434">Données lues avec `FileGet` sont généralement écrites dans un fichier avec `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-434">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-435">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-435">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-436">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-436">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-437">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-437">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-438">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-438">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-439">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-439">Random Mode</span></span>  
 <span data-ttu-id="a7782-440">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-440">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-441">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-441">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-442">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-442">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-443">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-443">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-444">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-444">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-445">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-445">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-446">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-446">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-447">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-447">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-448">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-448">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-449">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-449">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-450">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-450">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-451">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-451">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-452">Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-452">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-453">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-453">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-454">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-454">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-455">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-455">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-456">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-456">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-457">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-457">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-458">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-458">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-459">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-459">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-460">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-460">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-461">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-461">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-462">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-462">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-463">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-463">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-464">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-464">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-465">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-465">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-466">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-466">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-467">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-467">Binary Mode</span></span>  
 <span data-ttu-id="a7782-468">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-468">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-469">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-469">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-470">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-470">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-471">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-471">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-472">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-472">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-473">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-473">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-474">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-474">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-475">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-475">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-476">Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-476">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-477"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-477"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-478">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-478">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-479">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-479">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-480">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-480">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-481">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-481">Required.</span></span> <span data-ttu-id="a7782-482">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-482">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-483">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-483">Required.</span></span> <span data-ttu-id="a7782-484">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-484">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-485">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-485">Optional.</span></span> <span data-ttu-id="a7782-486">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-486">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a7782-487">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-487">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-488">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-488">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-489">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-489">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-490">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-490">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-491">Données lues avec `FileGet` sont généralement écrites dans un fichier avec `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-491">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-492">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-492">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-493">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-493">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-494">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-494">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-495">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-495">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-496">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-496">Random Mode</span></span>  
 <span data-ttu-id="a7782-497">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-497">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-498">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction),`FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-498">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-499">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-499">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-500">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-500">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-501">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-501">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-502">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-502">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-503">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-503">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-504">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-504">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-505">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-505">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-506">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-506">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-507">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-507">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-508">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-508">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-509">Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-509">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-510">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-510">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-511">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-511">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-512">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-512">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-513">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-513">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-514">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-514">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-515">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-515">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-516">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-516">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-517">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-517">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-518">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-518">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-519">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-519">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-520">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-520">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-521">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-521">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-522">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-522">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-523">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-523">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-524">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-524">Binary Mode</span></span>  
 <span data-ttu-id="a7782-525">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-525">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-526">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-526">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-527">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-527">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-528">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-528">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-529">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-529">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-530">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-530">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-531">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-531">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-532">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-532">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-533">Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-533">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-534"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-534"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-535">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-535">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-536">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-536">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-537">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-537">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-538">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-538">Required.</span></span> <span data-ttu-id="a7782-539">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-539">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-540">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-540">Required.</span></span> <span data-ttu-id="a7782-541">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-541">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-542">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-542">Optional.</span></span> <span data-ttu-id="a7782-543">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-543">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a7782-544">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-544">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-545">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-545">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-546">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-546">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-547">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-547">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-548">Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-548">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-549">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-549">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-550">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-550">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-551">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-551">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-552">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-552">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-553">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-553">Random Mode</span></span>  
 <span data-ttu-id="a7782-554">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-554">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-555">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-555">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-556">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-556">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-557">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-557">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-558">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-558">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-559">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-559">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-560">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-560">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-561">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-561">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-562">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-562">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-563">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-563">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-564">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-564">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-565">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-565">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-566">Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-566">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-567">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-567">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-568">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-568">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-569">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-569">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-570">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-570">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-571">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-571">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-572">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-572">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-573">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-573">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-574">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-574">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-575">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-575">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-576">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-576">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-577">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-577">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-578">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-578">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-579">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-579">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-580">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-580">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-581">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-581">Binary Mode</span></span>  
 <span data-ttu-id="a7782-582">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-582">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-583">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-583">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-584">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-584">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-585">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-585">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-586">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-586">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-587">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-587">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-588">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-588">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-589">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-589">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-590">Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-590">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-591"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-591"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-592">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-592">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-593">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-593">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-594">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-594">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-595">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-595">Required.</span></span> <span data-ttu-id="a7782-596">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-596">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-597">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-597">Required.</span></span> <span data-ttu-id="a7782-598">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-598">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-599">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-599">Optional.</span></span> <span data-ttu-id="a7782-600">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-600">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a7782-601">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-601">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-602">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-602">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-603">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-603">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-604">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-604">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-605">Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-605">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-606">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-606">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-607">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-607">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-608">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-608">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-609">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-609">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-610">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-610">Random Mode</span></span>  
 <span data-ttu-id="a7782-611">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-611">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-612">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-612">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-613">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-613">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-614">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-614">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-615">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-615">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-616">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-616">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-617">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-617">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-618">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-618">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-619">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-619">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-620">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-620">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-621">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-621">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-622">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-622">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-623">Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-623">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-624">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-624">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-625">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-625">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-626">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-626">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-627">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-627">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-628">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-628">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-629">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-629">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-630">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-630">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-631">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-631">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-632">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-632">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-633">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-633">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-634">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-634">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-635">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-635">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-636">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-636">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-637">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-637">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-638">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-638">Binary Mode</span></span>  
 <span data-ttu-id="a7782-639">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-639">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-640">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-640">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-641">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-641">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-642">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-642">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-643">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-643">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-644">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-644">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-645">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-645">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-646">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-646">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-647">Lecture d’un fichier à l’aide de la`FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-647">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-648"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-648"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-649">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-649">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-650">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-650">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-651">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-651">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-652">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-652">Required.</span></span> <span data-ttu-id="a7782-653">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-653">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-654">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-654">Required.</span></span> <span data-ttu-id="a7782-655">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-655">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-656">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-656">Optional.</span></span> <span data-ttu-id="a7782-657">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-657">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a7782-658">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-658">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-659">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-659">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-660">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-660">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-661">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-661">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-662">Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-662">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-663">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-663">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-664">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-664">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-665">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-665">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-666">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-666">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-667">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-667">Random Mode</span></span>  
 <span data-ttu-id="a7782-668">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-668">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-669">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-669">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-670">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-670">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-671">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-671">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-672">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-672">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-673">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-673">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-674">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-674">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-675">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-675">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-676">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-676">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-677">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-677">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-678">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-678">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-679">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-679">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-680">Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-680">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-681">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-681">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-682">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-682">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-683">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-683">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-684">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-684">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-685">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-685">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-686">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-686">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-687">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-687">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-688">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-688">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-689">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-689">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-690">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-690">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-691">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-691">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-692">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-692">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-693">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-693">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-694">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-694">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-695">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-695">Binary Mode</span></span>  
 <span data-ttu-id="a7782-696">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-696">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-697">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-697">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-698">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-698">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-699">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-699">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-700">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-700">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-701">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-701">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-702">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-702">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-703">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-703">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-704">Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-704">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-705"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-705"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-706">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-706">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-707">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-707">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-708">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-708">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-709">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-709">Required.</span></span> <span data-ttu-id="a7782-710">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-710">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-711">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-711">Required.</span></span> <span data-ttu-id="a7782-712">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-712">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-713">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-713">Optional.</span></span> <span data-ttu-id="a7782-714">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-714">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a7782-715">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-715">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-716">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-716">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-717">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-717">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-718">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-718">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-719">Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-719">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-720">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-720">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-721">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-721">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-722">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-722">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-723">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-723">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-724">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-724">Random Mode</span></span>  
 <span data-ttu-id="a7782-725">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-725">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-726">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-726">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-727">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-727">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-728">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-728">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-729">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-729">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-730">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-730">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-731">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-731">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-732">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-732">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-733">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-733">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-734">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-734">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-735">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-735">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-736">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-736">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-737">Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-737">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-738">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-738">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-739">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-739">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-740">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-740">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-741">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-741">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-742">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-742">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-743">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-743">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-744">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-744">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-745">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-745">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-746">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-746">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-747">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-747">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-748">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-748">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-749">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-749">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-750">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-750">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-751">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-751">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-752">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-752">Binary Mode</span></span>  
 <span data-ttu-id="a7782-753">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-753">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-754">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-754">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-755">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-755">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-756">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-756">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-757">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-757">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-758">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-758">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-759">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-759">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-760">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-760">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-761">Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-761">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-762"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-762"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-763">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-763">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-764">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-764">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-765">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-765">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-766">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-766">Required.</span></span> <span data-ttu-id="a7782-767">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-767">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-768">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-768">Required.</span></span> <span data-ttu-id="a7782-769">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-769">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-770">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-770">Optional.</span></span> <span data-ttu-id="a7782-771">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-771">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a7782-772">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-772">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-773">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-773">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-774">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-774">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-775">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-775">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-776">Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-776">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-777">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-777">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-778">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-778">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-779">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-779">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-780">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-780">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-781">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-781">Random Mode</span></span>  
 <span data-ttu-id="a7782-782">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-782">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-783">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-783">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-784">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-784">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-785">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-785">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-786">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-786">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-787">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-787">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-788">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-788">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-789">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-789">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-790">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-790">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-791">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-791">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-792">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-792">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-793">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-793">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-794">Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-794">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-795">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-795">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-796">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-796">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-797">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-797">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-798">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-798">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-799">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-799">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-800">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-800">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-801">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-801">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-802">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-802">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-803">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-803">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-804">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-804">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-805">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-805">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-806">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-806">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-807">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-807">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-808">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-808">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-809">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-809">Binary Mode</span></span>  
 <span data-ttu-id="a7782-810">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-810">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-811">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-811">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-812">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-812">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-813">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-813">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-814">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-814">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-815">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-815">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-816">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-816">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-817">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-817">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-818">Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-818">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-819"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-819"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-820">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-820">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-821">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-821">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-822">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-822">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-823">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-823">Required.</span></span> <span data-ttu-id="a7782-824">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-824">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-825">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-825">Required.</span></span> <span data-ttu-id="a7782-826">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-826">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-827">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-827">Optional.</span></span> <span data-ttu-id="a7782-828">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-828">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a7782-829">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-829">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-830">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-830">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-831">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-831">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-832">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-832">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-833">Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-833">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-834">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-834">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-835">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-835">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-836">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-836">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-837">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-837">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-838">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-838">Random Mode</span></span>  
 <span data-ttu-id="a7782-839">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-839">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-840">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-840">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-841">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-841">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-842">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-842">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-843">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-843">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-844">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-844">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-845">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-845">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-846">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-846">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-847">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-847">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-848">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-848">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-849">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-849">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-850">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-850">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-851">Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-851">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-852">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-852">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-853">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-853">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-854">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-854">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-855">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-855">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-856">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-856">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-857">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-857">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-858">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-858">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-859">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-859">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-860">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-860">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-861">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-861">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-862">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-862">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-863">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-863">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-864">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-864">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-865">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-865">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-866">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-866">Binary Mode</span></span>  
 <span data-ttu-id="a7782-867">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-867">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-868">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-868">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-869">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-869">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-870">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-870">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-871">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-871">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-872">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-872">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-873">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-873">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-874">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-874">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-875">Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-875">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-876"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-876"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-877">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-877">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-878">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-878">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-879">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-879">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-880">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-880">Required.</span></span> <span data-ttu-id="a7782-881">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-881">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-882">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-882">Required.</span></span> <span data-ttu-id="a7782-883">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-883">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-884">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-884">Optional.</span></span> <span data-ttu-id="a7782-885">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-885">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a7782-886">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-886">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-887">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-887">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-888">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-888">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-889">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-889">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-890">Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-890">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-891">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-891">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-892">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-892">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-893">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-893">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-894">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-894">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-895">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-895">Random Mode</span></span>  
 <span data-ttu-id="a7782-896">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-896">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-897">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-897">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-898">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-898">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-899">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-899">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-900">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-900">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-901">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-901">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-902">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-902">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-903">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-903">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-904">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-904">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-905">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-905">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-906">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-906">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-907">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-907">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-908">Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-908">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-909">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-909">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-910">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-910">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-911">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-911">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-912">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-912">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-913">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-913">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-914">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-914">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-915">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-915">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-916">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-916">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-917">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-917">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-918">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-918">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-919">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-919">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-920">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-920">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-921">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-921">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-922">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-922">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-923">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-923">Binary Mode</span></span>  
 <span data-ttu-id="a7782-924">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-924">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-925">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-925">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-926">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-926">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-927">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-927">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-928">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-928">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-929">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-929">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-930">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-930">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-931">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-931">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-932">Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-932">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-933"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-933"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-934">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-934">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-935">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-935">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-936">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-936">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-937">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-937">Required.</span></span> <span data-ttu-id="a7782-938">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-938">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-939">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-939">Required.</span></span> <span data-ttu-id="a7782-940">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-940">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-941">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-941">Optional.</span></span> <span data-ttu-id="a7782-942">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-942">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="a7782-943">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-943">Optional.</span></span> <span data-ttu-id="a7782-944">S'applique uniquement lors de l'écriture d'une chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-944">Applies only when writing a string.</span></span> <span data-ttu-id="a7782-945">Spécifie s'il est nécessaire d'écrire un descripteur à deux octets pour la chaîne décrivant la longueur.</span><span class="sxs-lookup"><span data-stu-id="a7782-945">Specifies whether to write a two-byte descriptor for the string that describes the length.</span></span> <span data-ttu-id="a7782-946">La valeur par défaut est <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-946">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="a7782-947">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-947">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-948">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-948">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-949">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-949">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-950">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-950">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-951">Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-951">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-952">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-952">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-953">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-953">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-954">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-954">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-955">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-955">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-956">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-956">Random Mode</span></span>  
 <span data-ttu-id="a7782-957">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-957">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-958">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-958">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-959">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-959">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-960">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-960">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-961">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-961">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-962">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-962">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-963">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-963">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-964">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-964">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-965">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-965">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-966">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-966">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-967">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-967">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-968">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-968">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-969">Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-969">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-970">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-970">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-971">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-971">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-972">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-972">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-973">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-973">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-974">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-974">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-975">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-975">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-976">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-976">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-977">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-977">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-978">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-978">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-979">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-979">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-980">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-980">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-981">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-981">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-982">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-982">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-983">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-983">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-984">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-984">Binary Mode</span></span>  
 <span data-ttu-id="a7782-985">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-985">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-986">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-986">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-987">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-987">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-988">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-988">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-989">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-989">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-990">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-990">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-991">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-991">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-992">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-992">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-993">Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-993">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-994"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-994"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-995">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-995">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-996">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-996">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-997">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-997">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-998">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-998">Required.</span></span> <span data-ttu-id="a7782-999">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-999">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1000">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1000">Required.</span></span> <span data-ttu-id="a7782-1001">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-1001">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1002">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1002">Optional.</span></span> <span data-ttu-id="a7782-1003">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1003">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <param name="ArrayIsDynamic"><span data-ttu-id="a7782-1004">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1004">Optional.</span></span> <span data-ttu-id="a7782-1005">S'applique uniquement lors de l'écriture d'un tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1005">Applies only when writing an array.</span></span> <span data-ttu-id="a7782-1006">Spécifie si le tableau sera traité comme dynamique et si un descripteur de tableau décrivant la taille et les limites du tableau est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1006">Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="a7782-1007">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1007">Optional.</span></span> <span data-ttu-id="a7782-1008">S'applique uniquement lors de l'écriture d'une chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1008">Applies only when writing a string.</span></span> <span data-ttu-id="a7782-1009">Spécifie s'il est nécessaire d'écrire un descripteur à deux octets pour la chaîne décrivant la longueur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1009">Specifies whether to write a two-byte descriptor for the string that describes the length.</span></span> <span data-ttu-id="a7782-1010">La valeur par défaut est <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1010">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="a7782-1011">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1011">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a7782-1012">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1012">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a7782-1013">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1013">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1014">`FileGet` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1014">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1015">Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1015">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a7782-1016">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1016">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1017">Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1017">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-1018">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1018">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-1019">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-1019">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1020">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1020">Random Mode</span></span>  
 <span data-ttu-id="a7782-1021">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1021">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1022">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1022">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1023">L’espace entre la fin d’un enregistrement et le démarrage de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1023">The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1024">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1024">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-1025">Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1025">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1026">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1026">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1027">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1027">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-1028">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1028">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1029">Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1029">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a7782-1030">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1030">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1031">Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1031">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a7782-1032">S’il a été écrit avec le descripteur, vous devez lire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1032">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a7782-1033">Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1033">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a7782-1034">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1034">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1035">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1035">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1036">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1036">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1037">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1037">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a7782-1038">Les octets 218 sont distribués comme suit :</span><span class="sxs-lookup"><span data-stu-id="a7782-1038">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a7782-1039">18 octets pour le descripteur : (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a7782-1039">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a7782-1040">200 octets pour les données : (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-1040">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-1041">Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1041">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a7782-1042">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1042">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-1043">`FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1043">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-1044">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1044">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1045">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels.</span><span class="sxs-lookup"><span data-stu-id="a7782-1045">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a7782-1046">Cela inclut les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-1046">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-1047">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1047">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1048">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1048">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1049">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1049">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1050">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1050">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1051">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1051">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1052">`FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1052">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1053">Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1053">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a7782-1054">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1054">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a7782-1055">`FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1055">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1056">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1056">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a7782-1057">Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1057">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1058"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1058"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1059">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1059">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-1060">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1060">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1061">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1061">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1062">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1062">Required.</span></span> <span data-ttu-id="a7782-1063">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1063">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1064">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1064">Required.</span></span> <span data-ttu-id="a7782-1065">Nom de la variable valide dans laquelle les données sont lues.</span><span class="sxs-lookup"><span data-stu-id="a7782-1065">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1066">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1066">Optional.</span></span> <span data-ttu-id="a7782-1067">Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1067">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1068">Lit les données d’un fichier disque ouvert dans une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1068">Reads data from an open disk file into a variable.</span></span>  <span data-ttu-id="a7782-1069">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGetObject" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1069">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />.</span></span> <span data-ttu-id="a7782-1070">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1070">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1071">Le `FileGetObject` fonction est utilisée au lieu de `FileGet` pour éviter toute ambiguïté au moment de la compilation si type `Object` est retourné au lieu d’un autre type, tel que `Integer`, `Long`, `Short`, et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1071">The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="a7782-1072">Si vous avez l’intention d’écrire le `Variant` type, `FileGetObject` est requis.</span><span class="sxs-lookup"><span data-stu-id="a7782-1072">If you intend to write out the `Variant` type, `FileGetObject` is required.</span></span> <span data-ttu-id="a7782-1073">En cas de doute, si vous utilisez un objet pour le deuxième paramètre, il est toujours conseillé d’utiliser `FilePutObject` et `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1073">When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="a7782-1074">`FileGetObject` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1074">`FileGetObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1075">Données lues avec `FileGetObject` sont généralement écrites avec `FilePutObject`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1075">Data read with `FileGetObject` is usually written with `FilePutObject`.</span></span>  
  
 <span data-ttu-id="a7782-1076">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1076">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1077">Si vous omettez `RecordNumber`, `FileGetObject` lit l’enregistrement ou octet après le dernier `FileGetObject` ou `FilePutObject` (fonction) (ou vers lequel pointe le dernier `Seek` fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-1077">If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1078">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1078">Random Mode</span></span>  
 <span data-ttu-id="a7782-1079">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1079">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1080">Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGetObject` lit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1080">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1081">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1081">The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1082">Car il est impossible de déterminer précisément la quantité de données de la marge intérieure, il est judicieux d’avoir la longueur d’enregistrement correspond à la longueur des données en cours de lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1082">Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a7782-1083">Si la variable lue est une chaîne, par défaut `FileGetObject` lit un descripteur à deux octets contenant la longueur de chaîne, puis lit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1083">If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1084">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1084">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1085">Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe et lors de la lecture dans un fichier, le descripteur de longueur n’est pas écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1085">Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a7782-1086">Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1086">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1087">Si la variable lue est un tableau, la longueur d’enregistrement spécifié par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1087">If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1088">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1088">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1089">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : 2 + 8 \* NumberOfDimensions.</span><span class="sxs-lookup"><span data-stu-id="a7782-1089">Its length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span>  
  
     <span data-ttu-id="a7782-1090">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque :</span><span class="sxs-lookup"><span data-stu-id="a7782-1090">For example, the following array declaration requires 218 bytes when the array is written to disk:</span></span>  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     <span data-ttu-id="a7782-1091">Les octets 218 sont distribués comme suit : 18 octets pour le descripteur (2 + 8 \* 2) et 100 octets pour les données (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a7782-1091">The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 \* 2), and 100 bytes for the data (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a7782-1092">`FileGetObject` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1092">`FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a7782-1093">Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePutObject`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : 2 + 8 \* NumberOfDimensions.</span><span class="sxs-lookup"><span data-stu-id="a7782-1093">On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span> <span data-ttu-id="a7782-1094">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire des éléments individuels, y compris les tableaux et leurs descripteurs.</span><span class="sxs-lookup"><span data-stu-id="a7782-1094">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors.</span></span> <span data-ttu-id="a7782-1095">Le <xref:Microsoft.VisualBasic.VBFixedStringAttribute> classe peut être appliquée aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lorsqu’elle est écrite sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1095">The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1096">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1096">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1097">Pour les fichiers ouverts dans `Binary` mode, tous les `Random` règles s’appliquent à ces exceptions près :</span><span class="sxs-lookup"><span data-stu-id="a7782-1097">For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:</span></span>  
  
-   <span data-ttu-id="a7782-1098">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1098">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1099">`FileGetObject` lit toutes les variables à partir du disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1099">`FileGetObject` reads all variables from disk contiguously, that is, with no padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1100">Pour tout tableau autre qu’un tableau dans une structure, `FileGetObject` lit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1100">For any array other than an array in a structure, `FileGetObject` reads only the data.</span></span> <span data-ttu-id="a7782-1101">Aucun descripteur n’est en lecture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1101">No descriptor is read.</span></span>  
  
 <span data-ttu-id="a7782-1102">`FileGetObject` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1102">`FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1103">Le nombre d’octets lus est égal au nombre de caractères de la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1103">The number of bytes read equals the number of characters already in the string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-1104">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1104">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-1105">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-1105">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1106">L’exemple suivant lit un enregistrement dans un fichier de test et il récupère ensuite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1106">The following example reads a record into a test file and then retrieves it.</span></span>  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-1107">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1107">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1108">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1108">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="a7782-1109">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1109">Required.</span></span> <span data-ttu-id="a7782-1110">Une expression de chaîne qui spécifie un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1110">A string expression that specifies a file.</span></span> <span data-ttu-id="a7782-1111"><paramref name="PathName" /> peut inclure le répertoire ou le dossier, et le lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1111"><paramref name="PathName" /> may include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="a7782-1112">Retourne une valeur qui spécifie la longueur d’un fichier en octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1112">Returns a value that specifies the length of a file in bytes.</span></span> <span data-ttu-id="a7782-1113">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileLen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1113">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />.</span></span> <span data-ttu-id="a7782-1114">Pour plus d'informations, consultez <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1114">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span></span></summary>
        <returns><span data-ttu-id="a7782-1115">Longueur du fichier en octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1115">The length of a file in bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1116">Si le fichier spécifié est ouvert lorsque la `FileLen` fonction est appelée, la valeur retournée représente la taille du fichier au moment il a été ouvert.</span><span class="sxs-lookup"><span data-stu-id="a7782-1116">If the specified file is open when the `FileLen` function is called, the value returned represents the size of the file at the time it was opened.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-1117">Pour obtenir la longueur actuelle d’un fichier ouvert, utilisez la `LOF` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-1117">To obtain the current length of an open file, use the `LOF` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1118">Cet exemple utilise le `FileLen` fonction pour retourner la longueur d’un fichier en octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1118">This example uses the `FileLen` function to return the length of a file in bytes.</span></span> <span data-ttu-id="a7782-1119">Pour cet exemple, supposons que `TestFile` est un fichier qui contient des données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1119">For purposes of this example, assume that `TestFile` is a file that contains some data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a7782-1120">Le fichier n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-1120">File does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-1121">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1121">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1122">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1122">Required.</span></span> <span data-ttu-id="a7782-1123">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1123">Any valid file number.</span></span> <span data-ttu-id="a7782-1124">Utilisez la fonction <see langword="FreeFile" /> pour obtenir le numéro du prochain fichier disponible.</span><span class="sxs-lookup"><span data-stu-id="a7782-1124">Use the <see langword="FreeFile" /> function to obtain the next available file number.</span></span></param>
        <param name="FileName"><span data-ttu-id="a7782-1125">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1125">Required.</span></span> <span data-ttu-id="a7782-1126">Une expression de chaîne qui spécifie un nom de fichier. Peut inclure le répertoire ou le dossier, ainsi que le lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1126">A string expression that specifies a file name - may include directory or folder, and drive.</span></span></param>
        <param name="Mode"><span data-ttu-id="a7782-1127">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1127">Required.</span></span> <span data-ttu-id="a7782-1128">Énumération spécifiant le mode de fichier : <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> ou <see langword="Random" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1128">Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />.</span></span> <span data-ttu-id="a7782-1129">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.OpenMode" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1129">For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</span></span></param>
        <param name="Access"><span data-ttu-id="a7782-1130">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1130">Optional.</span></span> <span data-ttu-id="a7782-1131">Énumération spécifiant quelles sont les opérations autorisées sur le fichier ouvert : <see langword="Read" />, <see langword="Write" /> ou <see langword="ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1131">Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />.</span></span> <span data-ttu-id="a7782-1132">La valeur par défaut est <see langword="ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1132">Defaults to <see langword="ReadWrite" />.</span></span> <span data-ttu-id="a7782-1133">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1133">For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</span></span></param>
        <param name="Share"><span data-ttu-id="a7782-1134">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1134">Optional.</span></span> <span data-ttu-id="a7782-1135">Énumération spécifiant les opérations non autorisées sur le fichier ouvert par d'autres processus : <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> et <see langword="Lock Read Write" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1135">Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />.</span></span> <span data-ttu-id="a7782-1136">La valeur par défaut est <see langword="Lock Read Write" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1136">Defaults to <see langword="Lock Read Write" />.</span></span> <span data-ttu-id="a7782-1137">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.OpenShare" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1137">For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</span></span></param>
        <param name="RecordLength"><span data-ttu-id="a7782-1138">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1138">Optional.</span></span> <span data-ttu-id="a7782-1139">Nombre inférieur ou égal à 32 767 (octets).</span><span class="sxs-lookup"><span data-stu-id="a7782-1139">Number less than or equal to 32,767 (bytes).</span></span> <span data-ttu-id="a7782-1140">Pour les fichiers ouverts pour accès aléatoire, cette valeur est la longueur de l'enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1140">For files opened for random access, this value is the record length.</span></span> <span data-ttu-id="a7782-1141">Pour les fichiers à accès séquentiel, cette valeur est le nombre de caractères mis en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="a7782-1141">For sequential files, this value is the number of characters buffered.</span></span></param>
        <summary><span data-ttu-id="a7782-1142">Ouvre un fichier pour entrée ou sortie.</span><span class="sxs-lookup"><span data-stu-id="a7782-1142">Opens a file for input or output.</span></span> <span data-ttu-id="a7782-1143">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1143">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />.</span></span> <span data-ttu-id="a7782-1144">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1144">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1145">Le `FileOpen` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-1145">The `FileOpen` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-1146">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-1146">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-1147">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-1147">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-1148">Vous devez ouvrir un fichier avant toute opération d’e/s peut être effectuée sur celui-ci.</span><span class="sxs-lookup"><span data-stu-id="a7782-1148">You must open a file before any I/O operation can be performed on it.</span></span> <span data-ttu-id="a7782-1149">`FileOpen` alloue une mémoire tampon d’e/s au fichier et détermine le mode d’accès à utiliser avec la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="a7782-1149">`FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-1150">Lors de l’écriture dans un fichier, une application peut avoir créer un fichier, si le fichier auquel il tente d’écrire n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-1150">When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist.</span></span> <span data-ttu-id="a7782-1151">Pour ce faire, il a besoin d’autorisation pour le répertoire dans lequel le fichier doit être créé.</span><span class="sxs-lookup"><span data-stu-id="a7782-1151">To do so, it needs permission for the directory in which the file is to be created.</span></span> <span data-ttu-id="a7782-1152">Toutefois, si le fichier spécifié par `FileName` n’existe pas, l’application doit `Write` autorisation uniquement au fichier lui-même.</span><span class="sxs-lookup"><span data-stu-id="a7782-1152">However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself.</span></span> <span data-ttu-id="a7782-1153">Où que possible, afin d’améliorer la sécurité, créer le fichier pendant le déploiement et d’accorder `Write` autorisation à ce fichier uniquement, et non pour l’ensemble du répertoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1153">Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory.</span></span> <span data-ttu-id="a7782-1154">Pour aider à améliorer la sécurité, d’écrire des données dans les annuaires d’utilisateurs au lieu du répertoire racine ou le répertoire Program Files.</span><span class="sxs-lookup"><span data-stu-id="a7782-1154">To help improve security, write data to user directories instead of to the root directory or the Program Files directory.</span></span>  
  
 <span data-ttu-id="a7782-1155">Vous trouverez le canal à ouvrir à l’aide de la `FreeFile()` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-1155">The channel to open can be found by using the `FreeFile()` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-1156">Le `FileOpen` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération, qui peut affecter son exécution dans les situations de confiance partielle.</span><span class="sxs-lookup"><span data-stu-id="a7782-1156">The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations.</span></span> <span data-ttu-id="a7782-1157">Pour plus d’informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1157">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1158">Cet exemple illustre différentes utilisations de la `FileOpen` fonction pour activer l’entrée et sortie vers un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1158">This example illustrates various uses of the `FileOpen` function to enable input and output to a file.</span></span>  
  
 <span data-ttu-id="a7782-1159">Le code suivant ouvre le fichier `TestFile` dans `Input` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1159">The following code opens the file `TestFile` in `Input` mode.</span></span>  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 <span data-ttu-id="a7782-1160">Cet exemple ouvre le fichier dans `Binary` mode pour les opérations d’écriture uniquement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1160">This example opens the file in `Binary` mode for writing operations only.</span></span>  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 <span data-ttu-id="a7782-1161">L’exemple suivant ouvre le fichier dans `Random` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1161">The following example opens the file in `Random` mode.</span></span> <span data-ttu-id="a7782-1162">Le fichier contient des enregistrements de la structure `Person`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1162">The file contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 <span data-ttu-id="a7782-1163">Cet exemple de code ouvre le fichier dans `Output` mode ; toute opération qui peut lire ou écrire dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1163">This code example opens the file in `Output` mode; any process can read or write to file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 <span data-ttu-id="a7782-1164">Cet exemple de code ouvre le fichier dans `Binary` mode pour la lecture ; les autres processus ne peut pas lire le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1164">This code example opens the file in `Binary` mode for reading; other processes cannot read file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1165">La longueur d'enregistrement est négative (et différente de -1).</span><span class="sxs-lookup"><span data-stu-id="a7782-1165">Record length is negative (and not equal to -1).</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1166"><paramref name="FileName" /> est déjà ouvert ou <paramref name="FileName" /> n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1166"><paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-1167">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1167">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1168">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1168">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7782-1169">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1169">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1170">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1170">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1171">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1171">F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1172">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1172">Required.</span></span> <span data-ttu-id="a7782-1173">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1173">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1174">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1174">Required.</span></span> <span data-ttu-id="a7782-1175">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1175">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1176">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1176">Optional.</span></span> <span data-ttu-id="a7782-1177">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1177">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1178">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1178">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1179">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1179">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1180">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1180">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1181">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1181">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1182">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1182">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1183">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1183">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1184">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1184">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1185">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1185">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1186">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1186">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1187">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1187">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1188">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1188">Random Mode</span></span>  
 <span data-ttu-id="a7782-1189">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1189">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1190">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1190">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1191">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1191">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1192">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1192">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1193">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1193">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1194">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1194">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1195">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1195">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1196">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1196">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1197">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1197">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1198">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1198">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1199">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1199">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1200">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1200">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1201">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1201">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1202">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1202">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1203">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1203">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1204">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1204">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1205">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1205">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1206">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1206">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1207">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1207">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1208">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1208">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1209">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1209">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1210">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1210">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1211">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1211">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1212">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1212">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1213">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1213">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1214">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1214">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1215">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1215">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1216">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1216">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1217">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1217">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1218">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1218">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1219">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1219">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1220">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1220">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1221">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1221">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1222">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1222">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1223">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1223">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1224">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1224">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1225">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1225">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1226">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1226">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1227">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1227">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1228">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1228">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1229"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1229"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1230">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1230">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1231">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1231">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1232">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1232">Required.</span></span> <span data-ttu-id="a7782-1233">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1233">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1234">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1234">Required.</span></span> <span data-ttu-id="a7782-1235">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1235">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1236">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1236">Optional.</span></span> <span data-ttu-id="a7782-1237">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1237">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1238">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1238">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1239">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1239">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1240">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1240">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1241">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1241">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1242">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1242">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1243">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1243">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1244">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1244">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1245">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1245">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1246">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1246">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1247">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1247">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1248">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1248">Random Mode</span></span>  
 <span data-ttu-id="a7782-1249">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1249">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1250">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1250">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1251">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1251">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1252">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1252">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1253">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1253">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1254">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1254">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1255">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1255">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1256">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1256">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1257">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1257">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1258">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1258">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1259">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1259">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1260">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1260">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1261">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1261">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1262">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1262">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1263">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1263">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1264">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1264">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1265">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1265">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1266">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1266">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1267">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1267">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1268">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1268">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1269">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1269">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1270">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1270">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1271">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1271">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1272">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1272">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1273">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1273">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1274">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1274">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1275">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1275">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1276">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1276">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1277">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1277">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1278">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1278">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1279">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1279">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1280">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1280">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1281">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1281">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1282">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1282">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1283">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1283">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1284">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1284">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1285">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1285">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1286">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1286">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1287">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1287">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1288">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1288">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1289"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1289"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1290">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1290">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1291">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1291">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1292">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1292">Required.</span></span> <span data-ttu-id="a7782-1293">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1293">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1294">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1294">Required.</span></span> <span data-ttu-id="a7782-1295">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1295">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1296">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1296">Optional.</span></span> <span data-ttu-id="a7782-1297">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1297">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1298">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1298">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1299">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1299">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1300">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1300">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1301">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1301">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1302">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1302">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1303">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1303">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1304">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1304">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1305">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1305">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1306">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1306">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1307">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1307">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1308">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1308">Random Mode</span></span>  
 <span data-ttu-id="a7782-1309">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1309">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1310">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1310">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1311">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1311">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1312">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1312">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1313">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1313">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1314">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1314">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1315">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1315">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1316">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1316">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1317">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1317">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1318">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1318">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1319">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1319">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1320">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1320">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1321">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1321">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1322">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1322">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1323">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1323">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1324">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1324">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1325">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1325">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1326">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1326">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1327">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1327">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1328">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1328">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1329">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1329">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1330">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1330">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1331">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1331">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1332">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1332">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1333">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1333">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1334">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1334">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1335">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1335">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1336">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1336">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1337">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1337">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1338">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1338">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1339">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1339">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1340">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1340">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1341">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1341">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1342">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1342">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1343">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1343">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1344">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1344">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1345">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1345">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1346">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1346">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1347">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1347">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1348">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1348">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1349"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1349"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1350">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1350">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1351">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1351">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1352">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1352">Required.</span></span> <span data-ttu-id="a7782-1353">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1353">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1354">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1354">Required.</span></span> <span data-ttu-id="a7782-1355">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1355">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1356">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1356">Optional.</span></span> <span data-ttu-id="a7782-1357">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1357">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1358">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1358">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1359">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1359">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1360">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1360">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1361">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1361">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1362">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1362">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1363">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1363">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1364">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1364">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1365">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1365">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1366">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1366">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1367">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1367">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1368">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1368">Random Mode</span></span>  
 <span data-ttu-id="a7782-1369">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1369">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1370">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1370">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1371">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1371">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1372">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1372">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1373">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1373">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1374">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1374">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1375">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1375">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1376">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1376">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1377">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1377">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1378">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1378">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1379">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1379">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1380">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1380">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1381">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1381">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1382">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1382">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1383">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1383">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1384">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1384">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1385">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1385">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1386">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1386">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1387">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1387">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1388">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1388">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1389">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1389">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1390">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1390">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1391">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1391">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1392">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1392">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1393">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1393">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1394">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1394">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1395">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1395">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1396">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1396">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1397">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1397">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1398">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1398">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1399">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1399">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1400">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1400">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1401">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1401">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1402">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1402">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1403">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1403">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1404">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1404">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1405">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1405">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1406">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1406">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1407">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1407">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1408">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1408">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1409"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1409"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1410">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1410">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1411">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1411">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1412">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1412">Required.</span></span> <span data-ttu-id="a7782-1413">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1413">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1414">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1414">Required.</span></span> <span data-ttu-id="a7782-1415">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1415">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1416">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1416">Optional.</span></span> <span data-ttu-id="a7782-1417">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1417">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1418">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1418">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1419">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1419">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1420">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1420">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1421">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1421">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1422">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1422">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1423">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1423">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1424">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1424">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1425">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1425">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1426">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1426">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1427">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1427">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1428">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1428">Random Mode</span></span>  
 <span data-ttu-id="a7782-1429">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1429">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1430">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1430">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1431">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1431">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1432">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1432">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1433">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1433">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1434">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1434">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1435">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1435">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1436">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1436">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1437">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1437">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1438">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1438">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1439">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1439">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1440">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1440">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1441">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1441">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1442">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1442">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1443">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1443">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1444">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1444">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1445">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1445">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1446">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1446">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1447">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1447">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1448">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1448">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1449">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1449">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1450">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1450">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1451">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1451">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1452">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1452">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1453">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1453">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1454">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1454">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1455">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1455">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1456">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1456">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1457">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1457">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1458">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1458">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1459">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1459">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1460">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1460">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1461">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1461">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1462">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1462">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1463">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1463">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1464">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1464">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1465">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1465">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1466">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1466">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1467">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1467">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1468">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1468">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1469"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1469"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1470">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1470">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1471">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1471">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1472">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1472">Required.</span></span> <span data-ttu-id="a7782-1473">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1473">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1474">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1474">Required.</span></span> <span data-ttu-id="a7782-1475">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1475">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1476">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1476">Optional.</span></span> <span data-ttu-id="a7782-1477">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1477">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1478">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1478">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1479">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1479">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1480">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1480">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1481">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1481">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1482">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1482">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1483">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1483">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1484">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1484">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1485">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1485">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1486">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1486">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1487">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1487">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1488">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1488">Random Mode</span></span>  
 <span data-ttu-id="a7782-1489">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1489">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1490">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1490">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1491">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1491">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1492">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1492">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1493">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1493">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1494">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1494">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1495">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1495">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1496">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1496">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1497">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1497">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1498">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1498">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1499">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1499">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1500">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1500">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1501">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1501">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1502">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1502">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1503">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1503">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1504">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1504">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1505">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1505">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1506">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1506">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1507">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1507">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1508">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1508">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1509">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1509">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1510">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1510">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1511">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1511">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1512">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1512">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1513">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1513">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1514">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1514">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1515">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1515">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1516">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1516">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1517">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1517">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1518">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1518">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1519">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1519">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1520">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1520">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1521">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1521">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1522">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1522">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1523">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1523">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1524">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1524">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1525">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1525">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1526">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1526">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1527">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1527">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1528">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1528">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1529"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1529"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1530">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1530">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1531">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1531">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1532">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1532">Required.</span></span> <span data-ttu-id="a7782-1533">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1533">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1534">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1534">Required.</span></span> <span data-ttu-id="a7782-1535">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1535">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1536">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1536">Optional.</span></span> <span data-ttu-id="a7782-1537">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1537">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1538">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1538">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1539">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1539">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1540">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1540">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1541">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1541">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1542">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1542">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1543">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1543">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1544">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1544">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1545">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1545">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1546">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1546">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1547">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1547">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1548">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1548">Random Mode</span></span>  
 <span data-ttu-id="a7782-1549">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1549">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1550">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1550">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1551">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1551">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1552">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1552">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1553">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1553">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1554">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1554">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1555">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1555">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1556">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1556">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1557">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1557">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1558">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1558">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1559">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le`VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1559">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1560">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1560">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1561">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1561">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1562">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1562">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1563">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1563">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1564">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1564">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1565">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1565">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1566">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1566">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1567">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1567">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1568">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1568">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1569">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1569">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1570">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1570">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1571">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1571">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1572">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1572">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1573">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1573">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1574">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1574">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1575">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1575">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1576">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1576">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1577">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1577">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1578">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1578">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1579">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1579">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1580">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1580">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1581">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1581">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1582">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1582">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1583">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1583">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1584">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1584">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1585">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1585">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1586">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1586">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1587">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1587">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1588">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1588">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1589"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1589"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1590">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1590">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1591">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1591">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1592">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1592">Required.</span></span> <span data-ttu-id="a7782-1593">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1593">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1594">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1594">Required.</span></span> <span data-ttu-id="a7782-1595">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1595">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1596">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1596">Optional.</span></span> <span data-ttu-id="a7782-1597">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1597">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1598">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1598">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1599">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1599">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1600">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1600">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1601">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1601">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1602">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1602">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1603">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1603">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1604">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1604">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1605">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1605">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1606">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1606">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1607">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1607">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1608">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1608">Random Mode</span></span>  
 <span data-ttu-id="a7782-1609">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1609">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1610">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1610">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1611">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1611">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1612">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1612">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1613">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1613">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1614">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1614">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1615">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1615">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1616">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1616">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1617">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1617">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1618">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1618">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1619">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1619">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1620">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1620">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1621">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1621">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1622">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1622">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1623">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1623">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1624">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1624">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1625">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1625">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1626">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1626">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1627">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1627">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1628">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1628">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1629">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1629">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1630">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1630">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1631">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1631">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1632">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1632">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1633">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1633">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1634">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1634">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1635">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1635">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1636">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1636">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1637">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1637">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1638">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1638">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1639">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1639">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1640">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1640">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1641">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1641">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1642">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1642">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1643">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1643">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1644">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1644">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1645">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1645">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1646">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1646">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1647">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1647">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1648">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1648">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1649"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1649"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1650">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1650">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1651">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1651">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1652">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1652">Required.</span></span> <span data-ttu-id="a7782-1653">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1653">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1654">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1654">Required.</span></span> <span data-ttu-id="a7782-1655">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1655">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1656">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1656">Optional.</span></span> <span data-ttu-id="a7782-1657">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1657">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1658">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1658">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1659">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1659">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1660">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1660">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1661">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1661">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1662">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1662">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1663">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1663">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1664">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1664">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1665">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1665">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1666">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1666">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1667">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1667">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1668">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1668">Random Mode</span></span>  
 <span data-ttu-id="a7782-1669">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1669">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1670">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1670">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1671">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1671">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1672">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1672">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1673">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1673">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1674">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1674">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1675">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1675">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1676">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1676">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1677">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1677">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1678">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1678">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1679">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1679">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1680">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1680">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1681">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1681">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1682">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1682">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1683">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1683">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1684">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1684">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1685">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1685">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1686">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1686">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1687">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1687">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1688">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1688">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1689">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1689">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1690">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1690">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1691">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1691">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1692">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1692">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1693">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1693">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1694">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1694">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1695">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1695">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1696">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1696">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1697">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1697">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1698">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1698">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1699">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1699">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1700">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1700">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1701">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1701">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1702">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1702">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1703">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1703">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1704">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1704">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1705">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1705">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1706">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1706">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1707">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1707">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1708">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1708">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1709"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1709"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1710">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1710">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1711">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1711">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1712">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1712">Required.</span></span> <span data-ttu-id="a7782-1713">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1713">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1714">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1714">Required.</span></span> <span data-ttu-id="a7782-1715">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1715">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1716">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1716">Optional.</span></span> <span data-ttu-id="a7782-1717">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1717">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1718">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1718">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1719">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1719">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1720">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1720">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1721">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1721">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1722">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1722">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1723">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1723">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1724">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1724">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1725">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1725">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1726">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1726">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1727">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1727">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1728">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1728">Random Mode</span></span>  
 <span data-ttu-id="a7782-1729">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1729">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1730">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1730">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1731">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1731">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1732">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1732">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1733">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1733">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1734">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1734">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1735">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1735">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1736">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1736">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1737">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1737">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1738">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1738">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1739">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1739">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1740">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1740">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1741">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1741">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1742">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1742">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1743">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1743">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1744">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1744">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1745">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1745">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1746">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1746">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1747">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1747">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1748">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1748">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1749">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1749">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1750">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1750">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1751">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1751">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1752">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1752">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1753">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1753">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1754">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1754">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1755">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1755">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1756">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1756">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1757">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1757">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1758">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1758">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1759">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1759">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1760">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1760">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1761">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1761">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1762">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1762">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1763">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1763">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1764">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1764">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1765">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1765">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1766">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1766">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1767">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1767">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1768">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1768">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1769"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1769"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1770">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1770">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1771">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1771">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1772">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1772">Required.</span></span> <span data-ttu-id="a7782-1773">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1773">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1774">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1774">Required.</span></span> <span data-ttu-id="a7782-1775">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1775">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1776">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1776">Optional.</span></span> <span data-ttu-id="a7782-1777">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1777">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1778">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1778">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1779">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1779">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1780">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1780">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1781">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1781">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1782">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1782">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1783">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1783">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1784">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1784">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1785">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1785">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1786">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1786">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1787">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1787">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1788">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1788">Random Mode</span></span>  
 <span data-ttu-id="a7782-1789">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1789">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1790">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le`RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1790">If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1791">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1791">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1792">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1792">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1793">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1793">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1794">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1794">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1795">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1795">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1796">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1796">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1797">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1797">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1798">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1798">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1799">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1799">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1800">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1800">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1801">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1801">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1802">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1802">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1803">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1803">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1804">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1804">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1805">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1805">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1806">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1806">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1807">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1807">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1808">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1808">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1809">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1809">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1810">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1810">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1811">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1811">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1812">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1812">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1813">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1813">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1814">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1814">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1815">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1815">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1816">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1816">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1817">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1817">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1818">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1818">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1819">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1819">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1820">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1820">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1821">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1821">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1822">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1822">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1823">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1823">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1824">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1824">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1825">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1825">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1826">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1826">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1827">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1827">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1828">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1828">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1829"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1829"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1830">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1830">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1831">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1831">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1832">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1832">Required.</span></span> <span data-ttu-id="a7782-1833">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1833">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1834">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1834">Required.</span></span> <span data-ttu-id="a7782-1835">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1835">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1836">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1836">Optional.</span></span> <span data-ttu-id="a7782-1837">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1837">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-1838">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1838">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1839">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1839">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1840">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1840">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1841">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1841">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1842">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1842">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1843">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1843">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1844">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1844">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1845">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1845">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1846">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1846">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1847">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1847">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1848">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1848">Random Mode</span></span>  
 <span data-ttu-id="a7782-1849">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1849">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1850">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1850">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1851">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1851">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1852">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1852">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1853">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1853">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1854">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1854">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1855">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1855">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1856">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1856">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1857">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1857">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1858">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1858">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1859">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1859">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1860">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1860">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1861">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1861">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1862">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1862">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1863">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1863">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1864">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1864">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1865">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1865">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1866">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1866">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1867">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1867">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1868">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1868">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1869">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1869">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1870">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1870">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1871">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1871">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1872">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1872">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1873">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1873">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1874">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1874">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1875">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1875">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1876">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1876">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1877">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1877">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1878">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1878">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1879">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1879">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1880">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1880">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1881">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1881">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1882">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1882">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1883">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1883">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1884">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1884">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1885">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1885">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1886">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1886">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1887">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1887">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1888">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1888">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1889"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1889"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1890">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1890">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1891">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1891">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1892">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1892">Required.</span></span> <span data-ttu-id="a7782-1893">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1893">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1894">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1894">Required.</span></span> <span data-ttu-id="a7782-1895">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1895">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1896">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1896">Optional.</span></span> <span data-ttu-id="a7782-1897">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1897">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="a7782-1898">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1898">Optional.</span></span> <span data-ttu-id="a7782-1899">S'applique uniquement lors de l'écriture d'une chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1899">Applies only when writing a string.</span></span> <span data-ttu-id="a7782-1900">Spécifie s'il faut écrire, sur le fichier, un descripteur de longueur de chaîne à deux octets pour la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1900">Specifies whether to write a two-byte string length descriptor for the string to the file.</span></span> <span data-ttu-id="a7782-1901">La valeur par défaut est <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1901">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="a7782-1902">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1902">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1903">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1903">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1904">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1904">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1905">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1905">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1906">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1906">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1907">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1907">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1908">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1908">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1909">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1909">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1910">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1910">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1911">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1911">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1912">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1912">Random Mode</span></span>  
 <span data-ttu-id="a7782-1913">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1913">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1914">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1914">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1915">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1915">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1916">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1916">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1917">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1917">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1918">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1918">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1919">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1919">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1920">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1920">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1921">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1921">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1922">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1922">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1923">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1923">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1924">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1924">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1925">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1925">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1926">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1926">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1927">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1927">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1928">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1928">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1929">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1929">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1930">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1930">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1931">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1931">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1932">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1932">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-1933">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1933">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-1934">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1934">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-1935">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1935">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-1936">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1936">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-1937">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-1937">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-1938">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1938">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-1939">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-1939">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-1940">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-1940">Binary Mode</span></span>  
 <span data-ttu-id="a7782-1941">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-1941">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-1942">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-1942">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-1943">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-1943">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-1944">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-1944">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-1945">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1945">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-1946">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-1946">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-1947">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1947">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-1948">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1948">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-1949">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-1949">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-1950">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-1950">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-1951">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1951">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-1952">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1952">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-1953"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-1953"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-1954">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1954">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-1955">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-1955">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-1956">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1956">Required.</span></span> <span data-ttu-id="a7782-1957">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-1957">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-1958">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-1958">Required.</span></span> <span data-ttu-id="a7782-1959">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1959">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-1960">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1960">Optional.</span></span> <span data-ttu-id="a7782-1961">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-1961">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <param name="ArrayIsDynamic"><span data-ttu-id="a7782-1962">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1962">Optional.</span></span> <span data-ttu-id="a7782-1963">S'applique uniquement lors de l'écriture d'un tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-1963">Applies only when writing an array.</span></span> <span data-ttu-id="a7782-1964">Spécifie si le tableau est traité comme dynamique, et s'il faut écrire un descripteur de tableau pour la chaîne décrivant la longueur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1964">Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="a7782-1965">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-1965">Optional.</span></span> <span data-ttu-id="a7782-1966">S'applique uniquement lors de l'écriture d'une chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1966">Applies only when writing a string.</span></span> <span data-ttu-id="a7782-1967">Spécifie s'il faut écrire, sur le fichier, un descripteur de longueur de chaîne à deux octets pour la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1967">Specifies whether to write a two-byte string length descriptor for the string to the file.</span></span> <span data-ttu-id="a7782-1968">La valeur par défaut est <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1968">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="a7782-1969">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-1969">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a7782-1970">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1970">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a7782-1971">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-1971">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-1972">`FilePut` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-1972">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-1973">Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1973">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a7782-1974">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1974">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-1975">Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.</span><span class="sxs-lookup"><span data-stu-id="a7782-1975">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a7782-1976">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1976">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-1977">`FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1977">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-1978">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-1978">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-1979">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-1979">Random Mode</span></span>  
 <span data-ttu-id="a7782-1980">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-1980">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-1981">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-1981">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-1982">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-1982">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-1983">Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-1983">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-1984">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-1984">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a7782-1985">Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1985">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a7782-1986">Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1986">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a7782-1987">Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-1987">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-1988">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-1988">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-1989">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1989">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-1990">Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-1990">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-1991">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-1991">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-1992">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-1992">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-1993">Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non.</span><span class="sxs-lookup"><span data-stu-id="a7782-1993">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a7782-1994">Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="a7782-1994">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a7782-1995">Visual Basic 2005 par défaut n’écrit ne pas le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1995">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a7782-1996">Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-1996">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a7782-1997">Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-1997">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a7782-1998">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-1998">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-1999">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-1999">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a7782-2000">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-2000">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-2001">Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-2001">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a7782-2002">Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-2002">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a7782-2003">La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-2003">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a7782-2004">`FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments.</span><span class="sxs-lookup"><span data-stu-id="a7782-2004">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a7782-2005">Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-2005">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a7782-2006">Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,</span><span class="sxs-lookup"><span data-stu-id="a7782-2006">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-2007">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-2007">Binary Mode</span></span>  
 <span data-ttu-id="a7782-2008">Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près.</span><span class="sxs-lookup"><span data-stu-id="a7782-2008">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a7782-2009">Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :</span><span class="sxs-lookup"><span data-stu-id="a7782-2009">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a7782-2010">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2010">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-2011">`FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-2011">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a7782-2012">Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-2012">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a7782-2013">Aucun descripteur n’est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2013">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a7782-2014">`FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-2014">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a7782-2015">Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-2015">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a7782-2016">Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :</span><span class="sxs-lookup"><span data-stu-id="a7782-2016">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a7782-2017">Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2017">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2018">Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2018">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a7782-2019">Cinq enregistrements de la structure `Person` sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2019">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-2020"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</span><span class="sxs-lookup"><span data-stu-id="a7782-2020"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2021">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2021">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-2022">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2022">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2023">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2023">Required.</span></span> <span data-ttu-id="a7782-2024">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2024">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2025">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2025">Required.</span></span> <span data-ttu-id="a7782-2026">Nom de variable valide contenant les données écrites sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-2026">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a7782-2027">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2027">Optional.</span></span> <span data-ttu-id="a7782-2028">Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</span><span class="sxs-lookup"><span data-stu-id="a7782-2028">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a7782-2029">Écrit les données d'une variable dans un fichier sur disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-2029">Writes data from a variable to a disk file.</span></span>  <span data-ttu-id="a7782-2030">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePutObject" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2030">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />.</span></span> <span data-ttu-id="a7782-2031">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2031">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2032">Le `FilePutObject` fonction est utilisée au lieu de `FilePut` pour éviter toute ambiguïté au moment de la compilation si type `Object` est passée au lieu d’un autre type, tel que `Integer`, `Long`, `Short`, et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-2032">The `FilePutObject` function is used instead of `FilePut` to avoid ambiguities at compile time if type `Object` is passed instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="a7782-2033">`FilePutObject` écrit et lit des descripteurs qui décrivent l’objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2033">`FilePutObject` writes and reads descriptors that describe the object.</span></span> <span data-ttu-id="a7782-2034">Si vous avez l’intention d’écrire le `Variant` type, `FilePutObject` est requis.</span><span class="sxs-lookup"><span data-stu-id="a7782-2034">If you intend to write out the `Variant` type, `FilePutObject` is required.</span></span> <span data-ttu-id="a7782-2035">En cas de doute, si vous utilisez un objet pour le deuxième paramètre, nous vous recommandons de toujours utiliser `FilePutObject` et `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2035">When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="a7782-2036">`FilePutObject` est valide uniquement dans `Random` et `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2036">`FilePutObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-2037">Les données écrites avec `FilePutObject` sont généralement lues à partir d’un fichier à l’aide de `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2037">Data written with `FilePutObject` is usually read from a file by using `FileGetObject`.</span></span>  
  
 <span data-ttu-id="a7782-2038">Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-2038">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a7782-2039">Si vous omettez `RecordNumber`, `FilePutObject` écrit l’enregistrement ou octet après le dernier `FileGetObject` ou `FilePutObject` (fonction) (ou l’enregistrement ou octet vers lequel pointe le dernier `Seek` fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-2039">If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function).</span></span>  
  
 <span data-ttu-id="a7782-2040">Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-2040">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a7782-2041">`FilePutObject` n’écrit pas le descripteur de longueur lorsque l’argument est `True`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2041">`FilePutObject` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a7782-2042">Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePutObject`, vous devez faire de même avec `FileGetObject`, et vous devez également vous assurer que la chaîne est initialisée à la longueur attendue.</span><span class="sxs-lookup"><span data-stu-id="a7782-2042">If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a7782-2043">Mode aléatoire</span><span class="sxs-lookup"><span data-stu-id="a7782-2043">Random Mode</span></span>  
 <span data-ttu-id="a7782-2044">Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="a7782-2044">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a7782-2045">Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePutObject` écrit les enregistrements suivants sur les limites de longueur d’enregistrement.</span><span class="sxs-lookup"><span data-stu-id="a7782-2045">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a7782-2046">L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2046">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a7782-2047">Car il est impossible de déterminer précisément la quantité de données de la marge intérieure, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a7782-2047">Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a7782-2048">Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2048">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown.</span></span>  
  
-   <span data-ttu-id="a7782-2049">Si la variable écrite est un objet qui contient un type numérique, `FilePutObject` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-2049">If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a7782-2050">Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePutObject` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données.</span><span class="sxs-lookup"><span data-stu-id="a7782-2050">For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a7782-2051">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-2051">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a7782-2052">Si la variable écrite est un objet qui contient une chaîne, `FilePutObject` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a7782-2052">If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a7782-2053">La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets.</span><span class="sxs-lookup"><span data-stu-id="a7782-2053">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a7782-2054">Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.</span><span class="sxs-lookup"><span data-stu-id="a7782-2054">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a7782-2055">Si la variable écrite est un tableau, la longueur d’enregistrement spécifié par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau.</span><span class="sxs-lookup"><span data-stu-id="a7782-2055">If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a7782-2056">Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang.</span><span class="sxs-lookup"><span data-stu-id="a7782-2056">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a7782-2057">Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a7782-2057">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a7782-2058">Mode binaire</span><span class="sxs-lookup"><span data-stu-id="a7782-2058">Binary Mode</span></span>  
 <span data-ttu-id="a7782-2059">Pour les fichiers ouverts dans `Binary` mode, tous les le `Random` mode règles s’appliquent, à l’exception :</span><span class="sxs-lookup"><span data-stu-id="a7782-2059">For files opened in `Binary` mode, all the `Random` mode rules apply, except:</span></span>  
  
-   <span data-ttu-id="a7782-2060">Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2060">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a7782-2061">`FilePutObject` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.</span><span class="sxs-lookup"><span data-stu-id="a7782-2061">`FilePutObject` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2062">Cet exemple utilise le `FilePutObject` fonction pour écrire une chaîne dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2062">This example uses the `FilePutObject` function to write a string to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-2063">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2063">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2064">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2064">Required.</span></span> <span data-ttu-id="a7782-2065">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2065">Any valid file number.</span></span></param>
        <param name="RecordWidth"><span data-ttu-id="a7782-2066">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2066">Required.</span></span> <span data-ttu-id="a7782-2067">Expression numérique comprise dans la plage 0-255, limites incluses, qui indique combien de caractères apparaissent sur une ligne avant de commencer une nouvelle ligne.</span><span class="sxs-lookup"><span data-stu-id="a7782-2067">Numeric expression in the range 0-255, inclusive, which indicates how many characters appear on a line before a new line is started.</span></span> <span data-ttu-id="a7782-2068">Si <paramref name="RecordWidth" /> égale 0, il n'y a aucune limite à la longueur d'une ligne.</span><span class="sxs-lookup"><span data-stu-id="a7782-2068">If <paramref name="RecordWidth" /> equals 0, there is no limit to the length of a line.</span></span> <span data-ttu-id="a7782-2069">La valeur par défaut <paramref name="RecordWidth" /> est 0.</span><span class="sxs-lookup"><span data-stu-id="a7782-2069">The default value for <paramref name="RecordWidth" /> is 0.</span></span></param>
        <summary><span data-ttu-id="a7782-2070">Assigne une largeur de ligne de sortie à un fichier ouvert à l'aide de la fonction <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2070">Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a7782-2071">Cet exemple utilise le `FileWidth` fonction permettant de définir la largeur de ligne de sortie pour un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2071">This example uses the `FileWidth` function to set the output line width for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2072">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2072">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2073">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2073">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7782-2074">Retourne une valeur <see langword="Integer" /> qui représente le prochain numéro de fichier utilisable par la fonction <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2074">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span></span></summary>
        <returns><span data-ttu-id="a7782-2075">Une valeur entière qui représente le prochain numéro de fichier utilisable par la fonction <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2075">An integer value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2076">Utilisez `FreeFile` pour fournir un numéro de fichier qui n’est pas déjà utilisé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2076">Use `FreeFile` to supply a file number that is not already being used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2077">Cet exemple utilise le `FreeFile` fonction pour retourner le nombre de fichiers disponible suivant.</span><span class="sxs-lookup"><span data-stu-id="a7782-2077">This example uses the `FreeFile` function to return the next available file number.</span></span> <span data-ttu-id="a7782-2078">Cinq fichiers sont ouverts à l’intérieur de la boucle, et des exemples de données sont écrites dans chacun.</span><span class="sxs-lookup"><span data-stu-id="a7782-2078">Five files are opened for output within the loop, and some sample data is written to each.</span></span>  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2079">Plus de 255 fichiers sont en cours d'utilisation.</span><span class="sxs-lookup"><span data-stu-id="a7782-2079">More than 255 files are in use.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-2080">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2080">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="a7782-2081">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2081">Required.</span></span> <span data-ttu-id="a7782-2082">Une expression de chaîne qui spécifie un nom de fichier, de répertoire ou de dossier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2082">A string expression that specifies a file, directory, or folder name.</span></span> <span data-ttu-id="a7782-2083"><paramref name="PathName" /> peut inclure le répertoire ou le dossier, ainsi que le lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-2083"><paramref name="PathName" /> can include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="a7782-2084">Retourne une valeur <see langword="FileAttribute" /> qui représente les attributs d'un fichier, répertoire ou dossier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2084">Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder.</span></span> <span data-ttu-id="a7782-2085">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2085">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />.</span></span> <span data-ttu-id="a7782-2086">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2086">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="a7782-2087">La valeur retournée par <see langword="GetAttr" /> est la somme des valeurs d'énumération suivantes :</span><span class="sxs-lookup"><span data-stu-id="a7782-2087">The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:</span></span> 
 <list type="table"><item><term> <span data-ttu-id="a7782-2088">Value</span><span class="sxs-lookup"><span data-stu-id="a7782-2088">Value</span></span> 
 </term><description> <span data-ttu-id="a7782-2089">Constante</span><span class="sxs-lookup"><span data-stu-id="a7782-2089">Constant</span></span> 
 </description><description> <span data-ttu-id="a7782-2090">Description </span><span class="sxs-lookup"><span data-stu-id="a7782-2090">Description</span></span> 
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> <span data-ttu-id="a7782-2091">Normal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2091">Normal.</span></span>  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> <span data-ttu-id="a7782-2092">Lecture seule.</span><span class="sxs-lookup"><span data-stu-id="a7782-2092">Read-only.</span></span>  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> <span data-ttu-id="a7782-2093">Masqué.</span><span class="sxs-lookup"><span data-stu-id="a7782-2093">Hidden.</span></span>  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> <span data-ttu-id="a7782-2094">Fichier système.</span><span class="sxs-lookup"><span data-stu-id="a7782-2094">System file.</span></span>  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> <span data-ttu-id="a7782-2095">Répertoire ou dossier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2095">Directory or folder.</span></span>  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> <span data-ttu-id="a7782-2096">Le fichier a été modifié depuis sa dernière sauvegarde.</span><span class="sxs-lookup"><span data-stu-id="a7782-2096">File has changed since last backup.</span></span>  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> <span data-ttu-id="a7782-2097">Le fichier porte un nom différent.</span><span class="sxs-lookup"><span data-stu-id="a7782-2097">File has a different name.</span></span>  
  
 </description></item></list><block subset="none" type="note"><para>  
 <span data-ttu-id="a7782-2098">Ces énumérations sont spécifiées par le langage Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-2098">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="a7782-2099">Les noms peuvent remplacer les valeurs réelles partout dans votre code.</span><span class="sxs-lookup"><span data-stu-id="a7782-2099">The names can be used anywhere in your code in place of the actual values.</span></span>  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2100">Pour déterminer les attributs définis, utilisez la `And` opérateur pour effectuer une comparaison au niveau du bit de la valeur retournée par la `GetAttr` (fonction) et la valeur de l’attribut de fichier individuel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2100">To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want.</span></span> <span data-ttu-id="a7782-2101">Si le résultat n’est pas égal à zéro, cet attribut est défini pour le fichier nommé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2101">If the result is not zero, that attribute is set for the named file.</span></span> <span data-ttu-id="a7782-2102">Par exemple, la valeur de retour de la commande suivante `And` expression est zéro si le `Archive` attribut n’est pas défini :</span><span class="sxs-lookup"><span data-stu-id="a7782-2102">For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:</span></span>  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 <span data-ttu-id="a7782-2103">Une valeur différente de zéro est retournée si le `Archive` attribut est défini.</span><span class="sxs-lookup"><span data-stu-id="a7782-2103">A nonzero value is returned if the `Archive` attribute is set.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2104">Cet exemple utilise le `GetAttr` fonction permettant de déterminer les attributs d’un fichier et un répertoire ou un dossier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2104">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2105"><paramref name="Pathname" /> n'est pas valide ou contient des caractères génériques.</span><span class="sxs-lookup"><span data-stu-id="a7782-2105"><paramref name="Pathname" /> is invalid or contains wildcards.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a7782-2106">Le fichier cible n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-2106">Target file does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md"><span data-ttu-id="a7782-2107">And, opérateur (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2107">And Operator (Visual Basic)</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2108">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2108">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7782-2109">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2109">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2110">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2110">Required.</span></span> <span data-ttu-id="a7782-2111">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2111">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2112">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2112">Required.</span></span> <span data-ttu-id="a7782-2113">Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2113">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a7782-2114">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2114">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2115">Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2115">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2116">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2116">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2117">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2117">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2118">Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2118">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a7782-2119">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2119">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2120">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2120">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2121">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a7782-2121">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a7782-2122">Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification.</span><span class="sxs-lookup"><span data-stu-id="a7782-2122">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a7782-2123">Le tableau suivant illustre comment les autres données d’entrée sont traitées.</span><span class="sxs-lookup"><span data-stu-id="a7782-2123">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a7782-2124">Données</span><span class="sxs-lookup"><span data-stu-id="a7782-2124">Data</span></span>|<span data-ttu-id="a7782-2125">Valeur assignée à la variable</span><span class="sxs-lookup"><span data-stu-id="a7782-2125">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a7782-2126">Virgule de séparation ou ligne vierge</span><span class="sxs-lookup"><span data-stu-id="a7782-2126">Delimiting comma or blank line</span></span>|<span data-ttu-id="a7782-2127">Empty</span><span class="sxs-lookup"><span data-stu-id="a7782-2127">Empty</span></span>|  
|<span data-ttu-id="a7782-2128">#NULL#</span><span class="sxs-lookup"><span data-stu-id="a7782-2128">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a7782-2129">#TRUE # ou #FALSE #</span><span class="sxs-lookup"><span data-stu-id="a7782-2129">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a7782-2130">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="a7782-2130">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a7782-2131">La date et/ou heure représentées par l’expression</span><span class="sxs-lookup"><span data-stu-id="a7782-2131">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a7782-2132">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a7782-2132">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a7782-2133">`errornumber` (la variable est un objet marqué comme une erreur)</span><span class="sxs-lookup"><span data-stu-id="a7782-2133">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a7782-2134">Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2134">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2135">Le `Input` fonction n’est pas localisée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2135">The `Input` function is not localized.</span></span> <span data-ttu-id="a7782-2136">Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2136">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2137">Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2137">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2138">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2138">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2139">Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2139">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a7782-2140">Cet exemple suppose que `TestFile` est un fichier qui comporte quelques lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).</span><span class="sxs-lookup"><span data-stu-id="a7782-2140">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2141">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2141">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2142">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2142">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2143">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2143">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2144">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2144">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2145">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2145">Required.</span></span> <span data-ttu-id="a7782-2146">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2146">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2147">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2147">Required.</span></span> <span data-ttu-id="a7782-2148">Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2148">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a7782-2149">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2149">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2150">Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2150">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2151">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2151">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2152">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2152">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2153">Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2153">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a7782-2154">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2154">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2155">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2155">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2156">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a7782-2156">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a7782-2157">Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification.</span><span class="sxs-lookup"><span data-stu-id="a7782-2157">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a7782-2158">Le tableau suivant illustre comment les autres données d’entrée sont traitées.</span><span class="sxs-lookup"><span data-stu-id="a7782-2158">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a7782-2159">Données</span><span class="sxs-lookup"><span data-stu-id="a7782-2159">Data</span></span>|<span data-ttu-id="a7782-2160">Valeur assignée à la variable</span><span class="sxs-lookup"><span data-stu-id="a7782-2160">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a7782-2161">Virgule de séparation ou ligne vierge</span><span class="sxs-lookup"><span data-stu-id="a7782-2161">Delimiting comma or blank line</span></span>|<span data-ttu-id="a7782-2162">Empty</span><span class="sxs-lookup"><span data-stu-id="a7782-2162">Empty</span></span>|  
|<span data-ttu-id="a7782-2163">#NULL#</span><span class="sxs-lookup"><span data-stu-id="a7782-2163">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a7782-2164">#TRUE # ou #FALSE #</span><span class="sxs-lookup"><span data-stu-id="a7782-2164">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a7782-2165">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="a7782-2165">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a7782-2166">La date et/ou heure représentées par l’expression</span><span class="sxs-lookup"><span data-stu-id="a7782-2166">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a7782-2167">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a7782-2167">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a7782-2168">`errornumber` (la variable est un objet marqué comme une erreur)</span><span class="sxs-lookup"><span data-stu-id="a7782-2168">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a7782-2169">Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2169">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2170">Le `Input` fonction n’est pas localisée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2170">The `Input` function is not localized.</span></span> <span data-ttu-id="a7782-2171">Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2171">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2172">Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2172">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2173">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2173">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2174">Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2174">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a7782-2175">Cet exemple suppose que `TestFile` est un fichier qui comporte quelques lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).</span><span class="sxs-lookup"><span data-stu-id="a7782-2175">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2176">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2176">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2177">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2177">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2178">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2178">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2179">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2179">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2180">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2180">Required.</span></span> <span data-ttu-id="a7782-2181">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2181">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2182">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2182">Required.</span></span> <span data-ttu-id="a7782-2183">Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2183">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a7782-2184">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2184">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2185">Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2185">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2186">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2186">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2187">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2187">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2188">Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2188">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a7782-2189">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2189">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2190">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2190">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2191">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a7782-2191">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a7782-2192">Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification.</span><span class="sxs-lookup"><span data-stu-id="a7782-2192">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a7782-2193">Le tableau suivant illustre comment les autres données d’entrée sont traitées.</span><span class="sxs-lookup"><span data-stu-id="a7782-2193">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a7782-2194">Données</span><span class="sxs-lookup"><span data-stu-id="a7782-2194">Data</span></span>|<span data-ttu-id="a7782-2195">Valeur assignée à la variable</span><span class="sxs-lookup"><span data-stu-id="a7782-2195">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a7782-2196">Virgule de séparation ou ligne vierge</span><span class="sxs-lookup"><span data-stu-id="a7782-2196">Delimiting comma or blank line</span></span>|<span data-ttu-id="a7782-2197">Empty</span><span class="sxs-lookup"><span data-stu-id="a7782-2197">Empty</span></span>|  
|<span data-ttu-id="a7782-2198">#NULL#</span><span class="sxs-lookup"><span data-stu-id="a7782-2198">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a7782-2199">#TRUE # ou #FALSE #</span><span class="sxs-lookup"><span data-stu-id="a7782-2199">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a7782-2200">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="a7782-2200">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a7782-2201">La date et/ou heure représentées par l’expression</span><span class="sxs-lookup"><span data-stu-id="a7782-2201">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a7782-2202">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a7782-2202">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a7782-2203">`errornumber` (la variable est un objet marqué comme une erreur)</span><span class="sxs-lookup"><span data-stu-id="a7782-2203">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a7782-2204">Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2204">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2205">Le `Input` fonction n’est pas localisée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2205">The `Input` function is not localized.</span></span> <span data-ttu-id="a7782-2206">Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2206">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2207">Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2207">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2208">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2208">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2209">Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2209">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a7782-2210">Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).</span><span class="sxs-lookup"><span data-stu-id="a7782-2210">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2211">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2211">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2212">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2212">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2213">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2213">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2214">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2214">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2215">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2215">Required.</span></span> <span data-ttu-id="a7782-2216">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2216">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2217">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2217">Required.</span></span> <span data-ttu-id="a7782-2218">Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2218">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a7782-2219">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2219">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2220">Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2220">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2221">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2221">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2222">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2222">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2223">Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2223">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a7782-2224">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2224">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2225">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2225">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2226">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a7782-2226">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a7782-2227">Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification.</span><span class="sxs-lookup"><span data-stu-id="a7782-2227">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a7782-2228">Le tableau suivant illustre comment les autres données d’entrée sont traitées.</span><span class="sxs-lookup"><span data-stu-id="a7782-2228">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a7782-2229">Données</span><span class="sxs-lookup"><span data-stu-id="a7782-2229">Data</span></span>|<span data-ttu-id="a7782-2230">Valeur assignée à la variable</span><span class="sxs-lookup"><span data-stu-id="a7782-2230">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a7782-2231">Virgule de séparation ou ligne vierge</span><span class="sxs-lookup"><span data-stu-id="a7782-2231">Delimiting comma or blank line</span></span>|<span data-ttu-id="a7782-2232">Empty</span><span class="sxs-lookup"><span data-stu-id="a7782-2232">Empty</span></span>|  
|<span data-ttu-id="a7782-2233">#NULL#</span><span class="sxs-lookup"><span data-stu-id="a7782-2233">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a7782-2234">#TRUE # ou #FALSE #</span><span class="sxs-lookup"><span data-stu-id="a7782-2234">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a7782-2235">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="a7782-2235">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a7782-2236">La date et/ou heure représentées par l’expression</span><span class="sxs-lookup"><span data-stu-id="a7782-2236">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a7782-2237">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a7782-2237">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a7782-2238">`errornumber` (la variable est un objet marqué comme une erreur)</span><span class="sxs-lookup"><span data-stu-id="a7782-2238">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a7782-2239">Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2239">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2240">Le `Input` fonction n’est pas localisée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2240">The `Input` function is not localized.</span></span> <span data-ttu-id="a7782-2241">Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2241">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2242">Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2242">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2243">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2243">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2244">Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2244">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a7782-2245">Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).</span><span class="sxs-lookup"><span data-stu-id="a7782-2245">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2246">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2246">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2247">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2247">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2248">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2248">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2249">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2249">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2250">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2250">Required.</span></span> <span data-ttu-id="a7782-2251">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2251">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2252">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2252">Required.</span></span> <span data-ttu-id="a7782-2253">Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2253">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a7782-2254">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2254">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2255">Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2255">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2256">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2256">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2257">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2257">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2258">Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2258">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a7782-2259">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2259">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2260">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2260">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2261">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a7782-2261">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a7782-2262">Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification.</span><span class="sxs-lookup"><span data-stu-id="a7782-2262">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a7782-2263">Le tableau suivant illustre comment les autres données d’entrée sont traitées.</span><span class="sxs-lookup"><span data-stu-id="a7782-2263">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a7782-2264">Données</span><span class="sxs-lookup"><span data-stu-id="a7782-2264">Data</span></span>|<span data-ttu-id="a7782-2265">Valeur assignée à la variable</span><span class="sxs-lookup"><span data-stu-id="a7782-2265">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a7782-2266">Virgule de séparation ou ligne vierge</span><span class="sxs-lookup"><span data-stu-id="a7782-2266">Delimiting comma or blank line</span></span>|<span data-ttu-id="a7782-2267">Empty</span><span class="sxs-lookup"><span data-stu-id="a7782-2267">Empty</span></span>|  
|<span data-ttu-id="a7782-2268">#NULL#</span><span class="sxs-lookup"><span data-stu-id="a7782-2268">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a7782-2269">#TRUE # ou #FALSE #</span><span class="sxs-lookup"><span data-stu-id="a7782-2269">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a7782-2270">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="a7782-2270">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a7782-2271">La date et/ou heure représentées par l’expression</span><span class="sxs-lookup"><span data-stu-id="a7782-2271">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a7782-2272">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a7782-2272">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a7782-2273">`errornumber` (la variable est un objet marqué comme une erreur)</span><span class="sxs-lookup"><span data-stu-id="a7782-2273">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a7782-2274">Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2274">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2275">Le `Input` fonction n’est pas localisée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2275">The `Input` function is not localized.</span></span> <span data-ttu-id="a7782-2276">Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2276">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2277">Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2277">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2278">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2278">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2279">Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2279">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a7782-2280">Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).</span><span class="sxs-lookup"><span data-stu-id="a7782-2280">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2281">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2281">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2282">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2282">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2283">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2283">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2284">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2284">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2285">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2285">Required.</span></span> <span data-ttu-id="a7782-2286">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2286">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2287">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2287">Required.</span></span> <span data-ttu-id="a7782-2288">Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2288">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a7782-2289">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2289">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2290">Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2290">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2291">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2291">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2292">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2292">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2293">Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2293">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a7782-2294">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2294">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2295">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2295">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2296">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a7782-2296">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a7782-2297">Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification.</span><span class="sxs-lookup"><span data-stu-id="a7782-2297">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a7782-2298">Le tableau suivant illustre comment les autres données d’entrée sont traitées.</span><span class="sxs-lookup"><span data-stu-id="a7782-2298">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a7782-2299">Données</span><span class="sxs-lookup"><span data-stu-id="a7782-2299">Data</span></span>|<span data-ttu-id="a7782-2300">Valeur assignée à la variable</span><span class="sxs-lookup"><span data-stu-id="a7782-2300">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a7782-2301">Virgule de séparation ou ligne vierge</span><span class="sxs-lookup"><span data-stu-id="a7782-2301">Delimiting comma or blank line</span></span>|<span data-ttu-id="a7782-2302">Empty</span><span class="sxs-lookup"><span data-stu-id="a7782-2302">Empty</span></span>|  
|<span data-ttu-id="a7782-2303">#NULL#</span><span class="sxs-lookup"><span data-stu-id="a7782-2303">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a7782-2304">#TRUE # ou #FALSE #</span><span class="sxs-lookup"><span data-stu-id="a7782-2304">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a7782-2305">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="a7782-2305">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a7782-2306">La date et/ou heure représentées par l’expression</span><span class="sxs-lookup"><span data-stu-id="a7782-2306">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a7782-2307">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a7782-2307">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a7782-2308">`errornumber` (la variable est un objet marqué comme une erreur)</span><span class="sxs-lookup"><span data-stu-id="a7782-2308">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a7782-2309">Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2309">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2310">Le `Input` fonction n’est pas localisée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2310">The `Input` function is not localized.</span></span> <span data-ttu-id="a7782-2311">Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2311">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2312">Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2312">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2313">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2313">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2314">Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2314">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a7782-2315">Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).</span><span class="sxs-lookup"><span data-stu-id="a7782-2315">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2316">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2316">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2317">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2317">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2318">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2318">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2319">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2319">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2320">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2320">Required.</span></span> <span data-ttu-id="a7782-2321">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2321">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2322">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2322">Required.</span></span> <span data-ttu-id="a7782-2323">Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2323">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a7782-2324">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2324">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2325">Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2325">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2326">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2326">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2327">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2327">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2328">Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2328">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a7782-2329">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2329">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2330">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2330">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2331">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a7782-2331">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a7782-2332">Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification.</span><span class="sxs-lookup"><span data-stu-id="a7782-2332">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a7782-2333">Le tableau suivant illustre comment les autres données d’entrée sont traitées.</span><span class="sxs-lookup"><span data-stu-id="a7782-2333">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a7782-2334">Données</span><span class="sxs-lookup"><span data-stu-id="a7782-2334">Data</span></span>|<span data-ttu-id="a7782-2335">Valeur assignée à la variable</span><span class="sxs-lookup"><span data-stu-id="a7782-2335">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a7782-2336">Virgule de séparation ou ligne vierge</span><span class="sxs-lookup"><span data-stu-id="a7782-2336">Delimiting comma or blank line</span></span>|<span data-ttu-id="a7782-2337">Empty</span><span class="sxs-lookup"><span data-stu-id="a7782-2337">Empty</span></span>|  
|<span data-ttu-id="a7782-2338">#NULL#</span><span class="sxs-lookup"><span data-stu-id="a7782-2338">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a7782-2339">#TRUE # ou #FALSE #</span><span class="sxs-lookup"><span data-stu-id="a7782-2339">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a7782-2340">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="a7782-2340">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a7782-2341">La date et/ou heure représentées par l’expression</span><span class="sxs-lookup"><span data-stu-id="a7782-2341">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a7782-2342">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a7782-2342">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a7782-2343">`errornumber` (la variable est un objet marqué comme une erreur)</span><span class="sxs-lookup"><span data-stu-id="a7782-2343">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a7782-2344">Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2344">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2345">Le `Input` fonction n’est pas localisée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2345">The `Input` function is not localized.</span></span> <span data-ttu-id="a7782-2346">Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2346">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2347">Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2347">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2348">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2348">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2349">Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2349">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a7782-2350">Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).</span><span class="sxs-lookup"><span data-stu-id="a7782-2350">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2351">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2351">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2352">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2352">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2353">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2353">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2354">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2354">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2355">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2355">Required.</span></span> <span data-ttu-id="a7782-2356">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2356">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2357">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2357">Required.</span></span> <span data-ttu-id="a7782-2358">Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2358">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a7782-2359">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2359">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2360">Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2360">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2361">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2361">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2362">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2362">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2363">Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2363">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a7782-2364">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2364">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2365">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2365">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2366">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a7782-2366">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a7782-2367">Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification.</span><span class="sxs-lookup"><span data-stu-id="a7782-2367">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a7782-2368">Le tableau suivant illustre comment les autres données d’entrée sont traitées.</span><span class="sxs-lookup"><span data-stu-id="a7782-2368">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a7782-2369">Données</span><span class="sxs-lookup"><span data-stu-id="a7782-2369">Data</span></span>|<span data-ttu-id="a7782-2370">Valeur assignée à la variable</span><span class="sxs-lookup"><span data-stu-id="a7782-2370">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a7782-2371">Virgule de séparation ou ligne vierge</span><span class="sxs-lookup"><span data-stu-id="a7782-2371">Delimiting comma or blank line</span></span>|<span data-ttu-id="a7782-2372">Empty</span><span class="sxs-lookup"><span data-stu-id="a7782-2372">Empty</span></span>|  
|<span data-ttu-id="a7782-2373">#NULL#</span><span class="sxs-lookup"><span data-stu-id="a7782-2373">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a7782-2374">#TRUE # ou #FALSE #</span><span class="sxs-lookup"><span data-stu-id="a7782-2374">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a7782-2375">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="a7782-2375">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a7782-2376">La date et/ou heure représentées par l’expression</span><span class="sxs-lookup"><span data-stu-id="a7782-2376">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a7782-2377">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a7782-2377">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a7782-2378">`errornumber` (la variable est un objet marqué comme une erreur)</span><span class="sxs-lookup"><span data-stu-id="a7782-2378">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a7782-2379">Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2379">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2380">Le `Input` fonction n’est pas localisée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2380">The `Input` function is not localized.</span></span> <span data-ttu-id="a7782-2381">Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, étant donné que la virgule est considérée comme un séparateur au lieu de variable comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2381">For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2382">Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2382">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2383">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2383">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2384">Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2384">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a7782-2385">Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).</span><span class="sxs-lookup"><span data-stu-id="a7782-2385">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2386">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2386">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2387">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2387">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2388">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2388">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2389">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2389">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2390">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2390">Required.</span></span> <span data-ttu-id="a7782-2391">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2391">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2392">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2392">Required.</span></span> <span data-ttu-id="a7782-2393">Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2393">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a7782-2394">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2394">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2395">Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2395">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2396">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2396">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2397">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2397">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2398">Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2398">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a7782-2399">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2399">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2400">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2400">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2401">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a7782-2401">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a7782-2402">Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification.</span><span class="sxs-lookup"><span data-stu-id="a7782-2402">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a7782-2403">Le tableau suivant illustre comment les autres données d’entrée sont traitées.</span><span class="sxs-lookup"><span data-stu-id="a7782-2403">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a7782-2404">Données</span><span class="sxs-lookup"><span data-stu-id="a7782-2404">Data</span></span>|<span data-ttu-id="a7782-2405">Valeur assignée à la variable</span><span class="sxs-lookup"><span data-stu-id="a7782-2405">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a7782-2406">Virgule de séparation ou ligne vierge</span><span class="sxs-lookup"><span data-stu-id="a7782-2406">Delimiting comma or blank line</span></span>|<span data-ttu-id="a7782-2407">Empty</span><span class="sxs-lookup"><span data-stu-id="a7782-2407">Empty</span></span>|  
|<span data-ttu-id="a7782-2408">#NULL#</span><span class="sxs-lookup"><span data-stu-id="a7782-2408">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a7782-2409">#TRUE # ou #FALSE #</span><span class="sxs-lookup"><span data-stu-id="a7782-2409">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a7782-2410">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="a7782-2410">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a7782-2411">La date et/ou heure représentées par l’expression</span><span class="sxs-lookup"><span data-stu-id="a7782-2411">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a7782-2412">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a7782-2412">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a7782-2413">`errornumber` (la variable est un objet marqué comme une erreur)</span><span class="sxs-lookup"><span data-stu-id="a7782-2413">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a7782-2414">Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2414">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2415">Le `Input` fonction n’est pas localisée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2415">The `Input` function is not localized.</span></span> <span data-ttu-id="a7782-2416">Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2416">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2417">Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2417">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2418">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2418">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2419">Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2419">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a7782-2420">Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).</span><span class="sxs-lookup"><span data-stu-id="a7782-2420">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2421">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2421">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2422">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2422">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2423">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2423">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2424">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2424">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2425">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2425">Required.</span></span> <span data-ttu-id="a7782-2426">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2426">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2427">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2427">Required.</span></span> <span data-ttu-id="a7782-2428">Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2428">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a7782-2429">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2429">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2430">Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2430">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2431">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2431">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2432">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2432">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2433">Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2433">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a7782-2434">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2434">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2435">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2435">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2436">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a7782-2436">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a7782-2437">Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification.</span><span class="sxs-lookup"><span data-stu-id="a7782-2437">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a7782-2438">Le tableau suivant illustre comment les autres données d’entrée sont traitées.</span><span class="sxs-lookup"><span data-stu-id="a7782-2438">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a7782-2439">Données</span><span class="sxs-lookup"><span data-stu-id="a7782-2439">Data</span></span>|<span data-ttu-id="a7782-2440">Valeur assignée à la variable</span><span class="sxs-lookup"><span data-stu-id="a7782-2440">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a7782-2441">Virgule de séparation ou ligne vierge</span><span class="sxs-lookup"><span data-stu-id="a7782-2441">Delimiting comma or blank line</span></span>|<span data-ttu-id="a7782-2442">Empty</span><span class="sxs-lookup"><span data-stu-id="a7782-2442">Empty</span></span>|  
|<span data-ttu-id="a7782-2443">#NULL#</span><span class="sxs-lookup"><span data-stu-id="a7782-2443">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a7782-2444">#TRUE # ou #FALSE #</span><span class="sxs-lookup"><span data-stu-id="a7782-2444">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a7782-2445">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="a7782-2445">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a7782-2446">La date et/ou heure représentées par l’expression</span><span class="sxs-lookup"><span data-stu-id="a7782-2446">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a7782-2447">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a7782-2447">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a7782-2448">`errornumber` (la variable est un objet marqué comme une erreur)</span><span class="sxs-lookup"><span data-stu-id="a7782-2448">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a7782-2449">Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2449">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2450">Le `Input` fonction n’est pas localisée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2450">The `Input` function is not localized.</span></span> <span data-ttu-id="a7782-2451">Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2451">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2452">Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2452">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2453">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2453">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2454">Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2454">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a7782-2455">Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).</span><span class="sxs-lookup"><span data-stu-id="a7782-2455">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2456">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2456">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2457">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2457">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2458">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2458">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2459">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2459">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2460">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2460">Required.</span></span> <span data-ttu-id="a7782-2461">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2461">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2462">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2462">Required.</span></span> <span data-ttu-id="a7782-2463">Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2463">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a7782-2464">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2464">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2465">Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2465">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2466">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2466">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2467">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2467">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2468">Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2468">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a7782-2469">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2469">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2470">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2470">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2471">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a7782-2471">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a7782-2472">Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification.</span><span class="sxs-lookup"><span data-stu-id="a7782-2472">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a7782-2473">Le tableau suivant illustre comment les autres données d’entrée sont traitées.</span><span class="sxs-lookup"><span data-stu-id="a7782-2473">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a7782-2474">Données</span><span class="sxs-lookup"><span data-stu-id="a7782-2474">Data</span></span>|<span data-ttu-id="a7782-2475">Valeur assignée à la variable</span><span class="sxs-lookup"><span data-stu-id="a7782-2475">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a7782-2476">Virgule de séparation ou ligne vierge</span><span class="sxs-lookup"><span data-stu-id="a7782-2476">Delimiting comma or blank line</span></span>|<span data-ttu-id="a7782-2477">Empty</span><span class="sxs-lookup"><span data-stu-id="a7782-2477">Empty</span></span>|  
|<span data-ttu-id="a7782-2478">#NULL#</span><span class="sxs-lookup"><span data-stu-id="a7782-2478">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a7782-2479">#TRUE # ou #FALSE #</span><span class="sxs-lookup"><span data-stu-id="a7782-2479">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a7782-2480">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="a7782-2480">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a7782-2481">La date et/ou heure représentées par l’expression</span><span class="sxs-lookup"><span data-stu-id="a7782-2481">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a7782-2482">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a7782-2482">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a7782-2483">`errornumber` (la variable est un objet marqué comme une erreur)</span><span class="sxs-lookup"><span data-stu-id="a7782-2483">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a7782-2484">Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2484">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2485">Le `Input` fonction n’est pas localisée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2485">The `Input` function is not localized.</span></span> <span data-ttu-id="a7782-2486">Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2486">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2487">Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2487">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2488">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2488">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2489">Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2489">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a7782-2490">Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).</span><span class="sxs-lookup"><span data-stu-id="a7782-2490">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2491">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2491">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2492">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2492">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2493">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2493">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2494">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2494">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2495">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2495">Required.</span></span> <span data-ttu-id="a7782-2496">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2496">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a7782-2497">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2497">Required.</span></span> <span data-ttu-id="a7782-2498">Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</span><span class="sxs-lookup"><span data-stu-id="a7782-2498">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a7782-2499">Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2499">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2500">Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2500">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2501">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2501">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2502">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2502">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2503">Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2503">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a7782-2504">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2504">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2505">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2505">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2506">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a7782-2506">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a7782-2507">Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification.</span><span class="sxs-lookup"><span data-stu-id="a7782-2507">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a7782-2508">Le tableau suivant illustre comment les autres données d’entrée sont traitées.</span><span class="sxs-lookup"><span data-stu-id="a7782-2508">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a7782-2509">Données</span><span class="sxs-lookup"><span data-stu-id="a7782-2509">Data</span></span>|<span data-ttu-id="a7782-2510">Valeur assignée à la variable</span><span class="sxs-lookup"><span data-stu-id="a7782-2510">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a7782-2511">Virgule de séparation ou ligne vierge</span><span class="sxs-lookup"><span data-stu-id="a7782-2511">Delimiting comma or blank line</span></span>|<span data-ttu-id="a7782-2512">Empty</span><span class="sxs-lookup"><span data-stu-id="a7782-2512">Empty</span></span>|  
|<span data-ttu-id="a7782-2513">#NULL#</span><span class="sxs-lookup"><span data-stu-id="a7782-2513">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a7782-2514">#TRUE # ou #FALSE #</span><span class="sxs-lookup"><span data-stu-id="a7782-2514">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a7782-2515">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="a7782-2515">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a7782-2516">La date et/ou heure représentées par l’expression</span><span class="sxs-lookup"><span data-stu-id="a7782-2516">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a7782-2517">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a7782-2517">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a7782-2518">`errornumber` (la variable est un objet marqué comme une erreur)</span><span class="sxs-lookup"><span data-stu-id="a7782-2518">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a7782-2519">Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2519">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2520">Le `Input` fonction n’est pas localisée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2520">The `Input` function is not localized.</span></span> <span data-ttu-id="a7782-2521">Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2521">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2522">Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2522">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2523">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2523">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2524">Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2524">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a7782-2525">Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).</span><span class="sxs-lookup"><span data-stu-id="a7782-2525">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2526">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2526">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2527">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2527">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2528">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2528">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2529">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2529">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2530">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2530">Required.</span></span> <span data-ttu-id="a7782-2531">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2531">Any valid file number.</span></span></param>
        <param name="CharCount"><span data-ttu-id="a7782-2532">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2532">Required.</span></span> <span data-ttu-id="a7782-2533">Toute expression numérique valide qui spécifie le nombre de caractères à lire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2533">Any valid numeric expression specifying the number of characters to read.</span></span></param>
        <summary><span data-ttu-id="a7782-2534">Retourne une valeur <see langword="String" /> qui contient des caractères provenant d'un fichier ouvert en mode <see langword="Input" /> ou <see langword="Binary" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2534">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span></span> <span data-ttu-id="a7782-2535">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="InputString" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2535">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span></span> <span data-ttu-id="a7782-2536">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2536">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="a7782-2537">Une chaîne qui contient des caractères provenant d’un fichier ouvert en mode <see langword="Input" /> ou <see langword="Binary" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2537">A string that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span></span> <span data-ttu-id="a7782-2538">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="InputString" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2538">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2539">Le `InputString` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2539">The `InputString` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2540">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2540">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2541">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2541">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2542">Données lues avec le `InputString` (fonction) est généralement écrites dans un fichier à l’aide de `Print` ou `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2542">Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`.</span></span> <span data-ttu-id="a7782-2543">Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.</span><span class="sxs-lookup"><span data-stu-id="a7782-2543">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
 <span data-ttu-id="a7782-2544">Contrairement à la `Input` (fonction), le `InputString` fonction retourne tous les caractères lus.</span><span class="sxs-lookup"><span data-stu-id="a7782-2544">Unlike the `Input` function, the `InputString` function returns all the characters it reads.</span></span> <span data-ttu-id="a7782-2545">Cela inclut des virgules, retours-chariot imbriqués, sauts de ligne, entre guillemets et les espaces de début.</span><span class="sxs-lookup"><span data-stu-id="a7782-2545">This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.</span></span>  
  
 <span data-ttu-id="a7782-2546">Avec les fichiers ouverts pour `Binary` accéder, une tentative de lecture du fichier à l’aide de la `InputString` jusqu'à `EOF` retourne `True` génère une erreur.</span><span class="sxs-lookup"><span data-stu-id="a7782-2546">With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="a7782-2547">Utiliser le `LOF` et `Loc` fonctions au lieu de `EOF` lorsque vous lisez des fichiers binaires à l’aide de `InputString`, ou utilisez `FileGet` lorsque vous utilisez le `EOF` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-2547">Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2548">Lors de la lecture à partir de fichiers, ne faites pas de prendre des décisions de sécurité sur le contenu du fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2548">When reading from files, do not make security decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a7782-2549">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-2549">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2550">Cet exemple utilise le `InputString` fonction permettant de lire un caractère à la fois à partir d’un fichier et l’imprimer à la `Output` fenêtre.</span><span class="sxs-lookup"><span data-stu-id="a7782-2550">This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window.</span></span> <span data-ttu-id="a7782-2551">Cet exemple suppose que `MyFile` est un fichier texte qui comporte plusieurs lignes d’exemples de données.</span><span class="sxs-lookup"><span data-stu-id="a7782-2551">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2552"><paramref name="FileNumber" /> n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-2552"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-2553"><paramref name="CharCount" /> &lt; 0 ou &gt; 214.</span><span class="sxs-lookup"><span data-stu-id="a7782-2553"><paramref name="CharCount" /> &lt; 0 or &gt; 214.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2554">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2554">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2555">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2555">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2556">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2556">How to: Write Text to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="a7782-2557">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2557">Required.</span></span> <span data-ttu-id="a7782-2558">Une expression de chaîne qui spécifie un ou plusieurs noms de fichiers à supprimer.</span><span class="sxs-lookup"><span data-stu-id="a7782-2558">A string expression that specifies one or more file names to be deleted.</span></span> <span data-ttu-id="a7782-2559"><paramref name="PathName" /> peut inclure le répertoire ou le dossier, ainsi que le lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-2559"><paramref name="PathName" /> can include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="a7782-2560">Supprime des fichiers d'un disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-2560">Deletes files from a disk.</span></span> <span data-ttu-id="a7782-2561">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="Kill" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2561">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />.</span></span> <span data-ttu-id="a7782-2562">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2562">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2563">`Kill` prend en charge l’utilisation de plusieurs caractères (`*`) et le caractère unique (`?`) des caractères génériques pour spécifier plusieurs fichiers.</span><span class="sxs-lookup"><span data-stu-id="a7782-2563">`Kill` supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="a7782-2564">**Note de sécurité** afin d’exécuter, le `Kill` fonction requiert `Read` et `PathDiscovery` indicateurs de <xref:System.Security.Permissions.FileIOPermission> à accorder à l’exécution de code.</span><span class="sxs-lookup"><span data-stu-id="a7782-2564">**Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="a7782-2565">Pour plus d’informations, consultez <xref:System.Security.SecurityException> [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span><span class="sxs-lookup"><span data-stu-id="a7782-2565">For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2566">Cet exemple utilise le `Kill` (fonction) pour supprimer un fichier à partir d’un disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-2566">This example uses the `Kill` function to delete a file from a disk.</span></span>  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2567">Le ou les fichiers cibles sont ouverts.</span><span class="sxs-lookup"><span data-stu-id="a7782-2567">Target file(s) open.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a7782-2568">Le ou les fichiers cibles sont introuvables.</span><span class="sxs-lookup"><span data-stu-id="a7782-2568">Target file(s) not found.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a7782-2569">Autorisation refusée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2569">Permission denied.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2570">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2570">Required.</span></span> <span data-ttu-id="a7782-2571">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2571">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="a7782-2572">Lit une ligne seule dans un fichier à accès séquentiel ouvert et l'assigne à une variable <see langword="String" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2572">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span></span></summary>
        <returns><span data-ttu-id="a7782-2573">Lit une ligne seule dans un fichier à accès séquentiel ouvert et l'assigne à une variable <see langword="String" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2573">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2574">Le `LineInput` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2574">The `LineInput` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2575">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2575">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2576">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2576">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2577">Données lues avec `LineInput` sont généralement écrites dans un fichier à l’aide de `Print`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2577">Data read with `LineInput` is usually written to a file by using `Print`.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2578">Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2578">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a7782-2579">Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-2579">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
 <span data-ttu-id="a7782-2580">Le `LineInput` fonction lit à partir d’un fichier d’un caractère à la fois jusqu'à ce qu’il rencontre un retour chariot (`Chr(13)`) ou saut de ligne-retour chariot (`Chr(13) + Chr(10)`) séquence.</span><span class="sxs-lookup"><span data-stu-id="a7782-2580">The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence.</span></span> <span data-ttu-id="a7782-2581">Séquences retour chariot/ligne flux sont ignorées au lieu d’ajouté à la chaîne de caractères.</span><span class="sxs-lookup"><span data-stu-id="a7782-2581">Carriage return/line feed sequences are skipped instead of appended to the character string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2582">Lecture d’un fichier à l’aide de la `LineInput` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2582">Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2583">Cet exemple utilise le `LineInput` (fonction) pour lire une ligne dans un fichier séquentiel et l’affecter à une variable.</span><span class="sxs-lookup"><span data-stu-id="a7782-2583">This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable.</span></span> <span data-ttu-id="a7782-2584">Cet exemple suppose que `TestFile` est un fichier texte qui comporte plusieurs lignes d’exemples de données.</span><span class="sxs-lookup"><span data-stu-id="a7782-2584">This example assumes that `TestFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException"><span data-ttu-id="a7782-2585">La fin du fichier est atteinte.</span><span class="sxs-lookup"><span data-stu-id="a7782-2585">End of file reached.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2586"><paramref name="FileNumber" /> n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-2586"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2587">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2587">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2588">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2588">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2589">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2589">How to: Write Text to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2590">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2590">Required.</span></span> <span data-ttu-id="a7782-2591">Tout numéro de fichier <see langword="Integer" /> valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2591">Any valid <see langword="Integer" /> file number.</span></span></param>
        <summary><span data-ttu-id="a7782-2592">Retourne une valeur qui spécifie la position lecture/écriture actuelle d’un fichier ouvert.</span><span class="sxs-lookup"><span data-stu-id="a7782-2592">Returns a value that specifies the current read/write position in an open file.</span></span></summary>
        <returns><span data-ttu-id="a7782-2593">La position de lecture/écriture actuelle dans un fichier ouvert.</span><span class="sxs-lookup"><span data-stu-id="a7782-2593">The current read/write position in an open file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2594">Le `Loc` fonction est de base zéro ; son utilisation pour récupérer le premier octet dans un fichier retournera 0.</span><span class="sxs-lookup"><span data-stu-id="a7782-2594">The `Loc` function is zero-based; using it to retrieve the first byte in a file will return 0.</span></span>  
  
 <span data-ttu-id="a7782-2595">Le `Loc` fonction est fournie pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2595">The `Loc` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2596">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2596">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2597">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2597">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2598">Ce qui suit décrit la valeur de retour pour chaque mode d’accès au fichier :</span><span class="sxs-lookup"><span data-stu-id="a7782-2598">The following describes the return value for each file access mode:</span></span>  
  
|<span data-ttu-id="a7782-2599">Mode</span><span class="sxs-lookup"><span data-stu-id="a7782-2599">Mode</span></span>|<span data-ttu-id="a7782-2600">Valeur de retour</span><span class="sxs-lookup"><span data-stu-id="a7782-2600">Return value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="a7782-2601">Numéro du dernier enregistrement lu ou écrit dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2601">Number of the last record read from or written to the file.</span></span>|  
|`Sequential`|<span data-ttu-id="a7782-2602">Position d’octet actuelle dans le fichier divisé par 128.</span><span class="sxs-lookup"><span data-stu-id="a7782-2602">Current byte position in the file divided by 128.</span></span> <span data-ttu-id="a7782-2603">Toutefois, les informations retournées par `Loc` pour les fichiers à accès séquentiel n’est ni utilisé ni nécessaire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2603">However, information returned by `Loc` for sequential files is neither used nor required.</span></span>|  
|`Binary`|<span data-ttu-id="a7782-2604">Position du dernier octet lu ou écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2604">Position of the last byte read or written.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2605">Cet exemple utilise le `Loc` fonction pour retourner la position de lecture/écriture actuelle dans un fichier ouvert.</span><span class="sxs-lookup"><span data-stu-id="a7782-2605">This example uses the `Loc` function to return the current read/write position in an open file.</span></span> <span data-ttu-id="a7782-2606">Cet exemple suppose que `MyFile` est un fichier texte qui comporte plusieurs lignes d’exemples de données.</span><span class="sxs-lookup"><span data-stu-id="a7782-2606">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2607">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2607">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7782-2608">Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2608">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a7782-2609">La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2609">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a7782-2610">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2610">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2611">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2611">Required.</span></span> <span data-ttu-id="a7782-2612">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2612">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="a7782-2613">Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2613">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a7782-2614">La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2614">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a7782-2615">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2615">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2616">Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2616">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="a7782-2617">`Lock` et `Unlock` fonctions sont toujours utilisées par paires.</span><span class="sxs-lookup"><span data-stu-id="a7782-2617">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="a7782-2618">Les arguments de `Lock` et `Unlock` doivent être identiques.</span><span class="sxs-lookup"><span data-stu-id="a7782-2618">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="a7782-2619">Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2619">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="a7782-2620">Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2620">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="a7782-2621">Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2621">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2622">Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions.</span><span class="sxs-lookup"><span data-stu-id="a7782-2622">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="a7782-2623">Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2623">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2624">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2624">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2625">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2625">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2626">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2626">Required.</span></span> <span data-ttu-id="a7782-2627">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2627">Any valid file number.</span></span></param>
        <param name="Record"><span data-ttu-id="a7782-2628">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2628">Optional.</span></span> <span data-ttu-id="a7782-2629">Numéro du seul enregistrement ou octet à verrouiller ou déverrouiller.</span><span class="sxs-lookup"><span data-stu-id="a7782-2629">Number of the only record or byte to lock or unlock.</span></span></param>
        <summary><span data-ttu-id="a7782-2630">Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2630">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a7782-2631">La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2631">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a7782-2632">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2632">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2633">Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2633">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="a7782-2634">`Lock` et `Unlock` fonctions sont toujours utilisées par paires.</span><span class="sxs-lookup"><span data-stu-id="a7782-2634">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="a7782-2635">Les arguments de `Lock` et `Unlock` doivent être identiques.</span><span class="sxs-lookup"><span data-stu-id="a7782-2635">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="a7782-2636">Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2636">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="a7782-2637">Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2637">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="a7782-2638">Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2638">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2639">Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions.</span><span class="sxs-lookup"><span data-stu-id="a7782-2639">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="a7782-2640">Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2640">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2641">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2641">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2642">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2642">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2643">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2643">Required.</span></span> <span data-ttu-id="a7782-2644">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2644">Any valid file number.</span></span></param>
        <param name="FromRecord"><span data-ttu-id="a7782-2645">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2645">Optional.</span></span> <span data-ttu-id="a7782-2646">Numéro du premier enregistrement ou octet à verrouiller ou déverrouiller</span><span class="sxs-lookup"><span data-stu-id="a7782-2646">Number of the first record or byte to lock or unlock.</span></span></param>
        <param name="ToRecord"><span data-ttu-id="a7782-2647">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2647">Optional.</span></span> <span data-ttu-id="a7782-2648">Numéro du dernier enregistrement ou octet à verrouiller ou déverrouiller</span><span class="sxs-lookup"><span data-stu-id="a7782-2648">Number of the last record or byte to lock or unlock.</span></span></param>
        <summary><span data-ttu-id="a7782-2649">Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2649">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a7782-2650">La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2650">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a7782-2651">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2651">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2652">Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2652">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="a7782-2653">`Lock` et `Unlock` fonctions sont toujours utilisées par paires.</span><span class="sxs-lookup"><span data-stu-id="a7782-2653">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="a7782-2654">Les arguments de `Lock` et `Unlock` doivent être identiques.</span><span class="sxs-lookup"><span data-stu-id="a7782-2654">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="a7782-2655">Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2655">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="a7782-2656">Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2656">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="a7782-2657">Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2657">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2658">Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions.</span><span class="sxs-lookup"><span data-stu-id="a7782-2658">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="a7782-2659">Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2659">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2660">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2660">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2661">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2661">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2662">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2662">Required.</span></span> <span data-ttu-id="a7782-2663">Une entier qui contient un numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2663">An integer that contains a valid file number.</span></span></param>
        <summary><span data-ttu-id="a7782-2664">Retourne la taille, en octets, d’un fichier ouvert à l’aide de la fonction <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2664">Returns the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a7782-2665">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="LOF" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2665">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span></span> <span data-ttu-id="a7782-2666">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2666">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="a7782-2667">La taille, en octets, d’un fichier ouvert à l’aide de la fonction <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2667">The size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a7782-2668">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="LOF" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2668">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2669">Utilisez le `FileLen` fonction pour obtenir la longueur d’un fichier qui n’est pas ouvert.</span><span class="sxs-lookup"><span data-stu-id="a7782-2669">Use the `FileLen` function to obtain the length of a file that is not open.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2670">Cet exemple utilise le `LOF` fonction permettant de déterminer la taille d’un fichier ouvert.</span><span class="sxs-lookup"><span data-stu-id="a7782-2670">This example uses the `LOF` function to determine the size of an open file.</span></span> <span data-ttu-id="a7782-2671">Cet exemple suppose que `TestFile` est un fichier texte qui contient des exemples de données.</span><span class="sxs-lookup"><span data-stu-id="a7782-2671">This example assumes that `TestFile` is a text file that contains sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2672">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2672">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-2673">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2673">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-2674">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2674">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="a7782-2675">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2675">Required.</span></span> <span data-ttu-id="a7782-2676">Une expression de chaîne qui identifie le répertoire à créer.</span><span class="sxs-lookup"><span data-stu-id="a7782-2676">A string expression that identifies the directory to be created.</span></span> <span data-ttu-id="a7782-2677">Le <paramref name="Path" /> peut inclure le lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-2677">The <paramref name="Path" /> may include the drive.</span></span> <span data-ttu-id="a7782-2678">Si aucun lecteur n'est spécifié, <see langword="MkDir" /> crée le nouveau répertoire sur le lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="a7782-2678">If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</span></span></param>
        <summary><span data-ttu-id="a7782-2679">Crée un répertoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2679">Creates a new directory.</span></span> <span data-ttu-id="a7782-2680">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="MkDir" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2680">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />.</span></span> <span data-ttu-id="a7782-2681">Pour plus d'informations, consultez <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2681">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2682">Cette fonction crée un nouveau répertoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2682">This function creates a new directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2683">Cet exemple utilise le `MkDir` fonction permettant de créer un répertoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2683">This example uses the `MkDir` function to create a directory.</span></span> <span data-ttu-id="a7782-2684">Si le lecteur n’est pas spécifié, le nouveau répertoire est créé sur le lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="a7782-2684">If the drive is not specified, the new directory is created on the current drive.</span></span>  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-2685"><paramref name="Path" /> n'est pas spécifié ou il est vide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2685"><paramref name="Path" /> is not specified or is empty.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a7782-2686">Autorisation refusée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2686">Permission denied.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2687">Le répertoire existe déjà.</span><span class="sxs-lookup"><span data-stu-id="a7782-2687">Directory already exists.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md"><span data-ttu-id="a7782-2688">Guide pratique pour créer un répertoire en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2688">How to: Create a Directory in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2689">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2689">Required.</span></span> <span data-ttu-id="a7782-2690">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2690">Any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="a7782-2691">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2691">Optional.</span></span> <span data-ttu-id="a7782-2692">Zéro, une ou plusieurs expressions délimitées par des virgules à écrire dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2692">Zero or more comma-delimited expressions to write to a file.</span></span>  
  
<span data-ttu-id="a7782-2693">Les paramètres de l’argument <paramref name="Output" /> sont :</span><span class="sxs-lookup"><span data-stu-id="a7782-2693">The <paramref name="Output" /> argument settings are:</span></span> 
 <span data-ttu-id="a7782-2694"><see langword="T:System.IO.IOException" />: Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2694"><see langword="T:System.IO.IOException" />: File mode is invalid.</span></span>  
  
 <span data-ttu-id="a7782-2695"><see langword="T:System.IO.IOException" /> : <paramref name="FileNumber" /> n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-2695"><see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> does not exist.</span></span></param>
        <summary><span data-ttu-id="a7782-2696">Écrit des données formatées dans un fichier séquentiel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2696">Writes display-formatted data to a sequential file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2697">Le `Print` et `PrintLine` fonctions sont fournies pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2697">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2698">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2698">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2699">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2699">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2700">`Print` n’inclut pas de saut de ligne à la fin d’une ligne ; Toutefois, `PrintLine` inclut une saut de ligne.</span><span class="sxs-lookup"><span data-stu-id="a7782-2700">`Print` does not include a line feed at the end of a line; however, `PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="a7782-2701">Données écrites avec `Print` sont généralement lues à partir d’un fichier à l’aide de `LineInput` ou `Input`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2701">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="a7782-2702">Si vous omettez `Output` pour `PrintLine`, une ligne vide est imprimée dans le fichier ; pour `Print`, rien n’est sortie.</span><span class="sxs-lookup"><span data-stu-id="a7782-2702">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="a7782-2703">Plusieurs expressions séparées par une virgule seront alignées sur les limites des onglets, mais mélange de virgules et `TAB` peut entraîner des résultats incohérents.</span><span class="sxs-lookup"><span data-stu-id="a7782-2703">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="a7782-2704">Pour `Boolean` données, soit `True` ou `False` est imprimé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2704">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="a7782-2705">Le `True` et `False` mots clés ne sont pas traduits, quel que soit les paramètres régionaux.</span><span class="sxs-lookup"><span data-stu-id="a7782-2705">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="a7782-2706">Données de date sont écrites dans le fichier à l’aide du format de date courte standard reconnu par votre système.</span><span class="sxs-lookup"><span data-stu-id="a7782-2706">Date data is written to the file by using the standard short date format recognized by your system.</span></span> <span data-ttu-id="a7782-2707">Lorsque la date ou le composant heure manque ou est nul, seule la partie fournie est écrite dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2707">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="a7782-2708">Si rien n’est écrit dans le fichier `Output` données sont vides.</span><span class="sxs-lookup"><span data-stu-id="a7782-2708">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="a7782-2709">Toutefois, si `Output` les données de liste sont `DBNull`, `Null` est écrit dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2709">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="a7782-2710">Pour `Error` données, la sortie s’affiche en tant que `Error errorcode`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2710">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="a7782-2711">Le `Error` mot clé n’est pas traduit, quel que soit les paramètres régionaux.</span><span class="sxs-lookup"><span data-stu-id="a7782-2711">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="a7782-2712">Toutes les données écrites dans le fichier à l’aide de `Print` respectent les conventions ; autrement dit, les données sont correctement mis en forme en utilisant le séparateur décimal approprié.</span><span class="sxs-lookup"><span data-stu-id="a7782-2712">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="a7782-2713">Si l’utilisateur souhaite sortir des données pour une utilisation par plusieurs paramètres régionaux, `Write` doit être utilisé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2713">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="a7782-2714">Écriture dans un fichier à l’aide de la `Print` ou `PrintLine` functions exige `Write` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2714">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2715">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2715">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2716">Cet exemple utilise le `Print` et `PrintLine` fonctions pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2716">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2717">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2717">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2718">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2718">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2719">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2719">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2720">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2720">Required.</span></span> <span data-ttu-id="a7782-2721">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2721">Any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="a7782-2722">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2722">Optional.</span></span> <span data-ttu-id="a7782-2723">Zéro, une ou plusieurs expressions délimitées par des virgules à écrire dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2723">Zero or more comma-delimited expressions to write to a file.</span></span>  
  
<span data-ttu-id="a7782-2724">Les paramètres de l’argument <paramref name="Output" /> sont :</span><span class="sxs-lookup"><span data-stu-id="a7782-2724">The <paramref name="Output" /> argument settings are:</span></span> 
 <span data-ttu-id="a7782-2725"><see langword="T:System.IO.IOException" />: Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2725"><see langword="T:System.IO.IOException" />: File mode is invalid.</span></span>  
  
 <span data-ttu-id="a7782-2726"><see langword="T:System.IO.IOException" /> : <paramref name="FileNumber" /> n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-2726"><see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> does not exist.</span></span></param>
        <summary><span data-ttu-id="a7782-2727">Écrit des données formatées dans un fichier séquentiel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2727">Writes display-formatted data to a sequential file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2728">Le `Print` et `PrintLine` fonctions sont fournies pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2728">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2729">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2729">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2730">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2730">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2731">`Print` n’inclut pas de saut de ligne à la fin d’une ligne ; Toutefois,`PrintLine` inclut une saut de ligne.</span><span class="sxs-lookup"><span data-stu-id="a7782-2731">`Print` does not include a line feed at the end of a line; however,`PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="a7782-2732">Données écrites avec `Print` sont généralement lues à partir d’un fichier à l’aide de `LineInput` ou `Input`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2732">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="a7782-2733">Si vous omettez `Output` pour `PrintLine`, une ligne vide est imprimée dans le fichier ; pour `Print`, rien n’est sortie.</span><span class="sxs-lookup"><span data-stu-id="a7782-2733">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="a7782-2734">Plusieurs expressions séparées par une virgule seront alignées sur les limites des onglets, mais mélange de virgules et `TAB` peut entraîner des résultats incohérents.</span><span class="sxs-lookup"><span data-stu-id="a7782-2734">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="a7782-2735">Pour `Boolean` données, soit `True` ou `False` est imprimé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2735">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="a7782-2736">Le `True` et `False` mots clés ne sont pas traduits, quel que soit les paramètres régionaux.</span><span class="sxs-lookup"><span data-stu-id="a7782-2736">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="a7782-2737">Données de date sont écrites dans le fichier en utilisant le format de date courte standard reconnu par le système.</span><span class="sxs-lookup"><span data-stu-id="a7782-2737">Date data is written to the file by using the standard short date format recognized by the system.</span></span> <span data-ttu-id="a7782-2738">Lorsque la date ou le composant heure manque ou est nul, seule la partie fournie est écrite dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2738">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="a7782-2739">Si rien n’est écrit dans le fichier `Output` données sont vides.</span><span class="sxs-lookup"><span data-stu-id="a7782-2739">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="a7782-2740">Toutefois, si `Output` les données de liste sont `DBNull`, `Null` est écrit dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2740">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="a7782-2741">Pour `Error` données, la sortie s’affiche en tant que `Error errorcode`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2741">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="a7782-2742">Le `Error` mot clé n’est pas traduit, quel que soit les paramètres régionaux.</span><span class="sxs-lookup"><span data-stu-id="a7782-2742">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="a7782-2743">Toutes les données écrites dans le fichier à l’aide de `Print` respectent les conventions ; autrement dit, les données sont correctement mis en forme en utilisant le séparateur décimal approprié.</span><span class="sxs-lookup"><span data-stu-id="a7782-2743">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="a7782-2744">Si l’utilisateur souhaite sortir des données pour une utilisation par plusieurs paramètres régionaux, `Write` doit être utilisé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2744">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="a7782-2745">Écriture dans un fichier à l’aide de la `Print` ou `PrintLine` functions exige `Write` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-2745">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-2746">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2746">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2747">Cet exemple utilise le `Print` et `PrintLine` fonctions pour écrire des données dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2747">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2748">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2748">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-2749">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2749">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-2750">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2750">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath"><span data-ttu-id="a7782-2751">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2751">Required.</span></span> <span data-ttu-id="a7782-2752">Une expression de chaîne qui spécifie le nom et l’emplacement du fichier existant.</span><span class="sxs-lookup"><span data-stu-id="a7782-2752">A string expression that specifies the existing file name and location.</span></span> <span data-ttu-id="a7782-2753"><paramref name="OldPath" /> peut inclure le répertoire et le lecteur du fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2753"><paramref name="OldPath" /> may include the directory, and drive, of the file.</span></span></param>
        <param name="NewPath"><span data-ttu-id="a7782-2754">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2754">Required.</span></span> <span data-ttu-id="a7782-2755">Une expression de chaîne qui spécifie le nom et l’emplacement du nouveau fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2755">A string expression that specifies the new file name and location.</span></span> <span data-ttu-id="a7782-2756"><paramref name="NewPath" /> peut inclure le répertoire et le lecteur de l'emplacement de destination.</span><span class="sxs-lookup"><span data-stu-id="a7782-2756"><paramref name="NewPath" /> may include directory and drive of the destination location.</span></span> <span data-ttu-id="a7782-2757">Le nom de fichier spécifié par <paramref name="NewPath" /> ne peut pas déjà exister.</span><span class="sxs-lookup"><span data-stu-id="a7782-2757">The file name specified by <paramref name="NewPath" /> cannot already exist.</span></span></param>
        <summary><span data-ttu-id="a7782-2758">Renomme un fichier ou un répertoire sur un disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-2758">Renames a disk file or directory.</span></span> <span data-ttu-id="a7782-2759">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="Rename" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2759">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />.</span></span> <span data-ttu-id="a7782-2760">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2760">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2761">Le`Rename` fonction renomme un fichier et les déplace vers un autre répertoire, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2761">The`Rename` function renames a file and moves it to a different directory, if it is required.</span></span> <span data-ttu-id="a7782-2762">Le `Rename` fonction peut déplacer un fichier sur les disques, mais elle ne peut renommer un répertoire existant lorsque les deux `NewPath` et `OldPath` se trouvent sur le même lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-2762">The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive.</span></span> <span data-ttu-id="a7782-2763">`Rename` Impossible de créer un nouveau fichier ou un répertoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2763">`Rename` cannot create a new file or directory.</span></span>  
  
 <span data-ttu-id="a7782-2764">À l’aide de la `Rename` fonction sur un fichier ouvert génère une erreur.</span><span class="sxs-lookup"><span data-stu-id="a7782-2764">Using the `Rename` function on an open file produces an error.</span></span> <span data-ttu-id="a7782-2765">Vous devez fermer un fichier ouvert avant de le renommer.</span><span class="sxs-lookup"><span data-stu-id="a7782-2765">You must close an open file before renaming it.</span></span> <span data-ttu-id="a7782-2766">`Rename` arguments ne peut pas inclure plusieurs caractères (\*) et des caractères génériques ( ?) à caractère unique.</span><span class="sxs-lookup"><span data-stu-id="a7782-2766">`Rename` arguments cannot include multiple-character (\*) and single-character (?) wildcards.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a7782-2767">Lorsque vous utilisez `Rename` pour copier un fichier à partir d’un emplacement non protégé vers un emplacement protégé, le fichier conserve les droits moins restreints.</span><span class="sxs-lookup"><span data-stu-id="a7782-2767">When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights.</span></span> <span data-ttu-id="a7782-2768">Vérifiez que vous n’introduisez pas un risque de sécurité possible.</span><span class="sxs-lookup"><span data-stu-id="a7782-2768">Check to make sure that you are not introducing a possible security risk.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2769">Cet exemple utilise le `Rename` (fonction) pour renommer un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2769">This example uses the `Rename` function to rename a file.</span></span> <span data-ttu-id="a7782-2770">Pour cet exemple, supposons que les répertoires qui sont déjà spécifiés existent.</span><span class="sxs-lookup"><span data-stu-id="a7782-2770">For purposes of this example, assume that the directories that are specified already exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-2771">Le chemin n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2771">Path is invalid.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a7782-2772">Le fichier <paramref name="OldPath" /> n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-2772"><paramref name="OldPath" /> file does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2773">Impossible de renommer vers un autre périphérique.</span><span class="sxs-lookup"><span data-stu-id="a7782-2773">Cannot rename to different device.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md"><span data-ttu-id="a7782-2774">Guide pratique pour renommer un fichier en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2774">How to: Rename a File in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7782-2775">Ferme tous les fichiers disque ouverts à l'aide de la fonction <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2775">Closes all disk files opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a7782-2776">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="Reset" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2776">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />.</span></span> <span data-ttu-id="a7782-2777">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2777">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2778">Le `Reset` fonction ferme tous les fichiers actifs ouverts par le `FileOpen` de fonction et a la même fonction que `FileClose()` sans aucun paramètre.</span><span class="sxs-lookup"><span data-stu-id="a7782-2778">The `Reset` function closes all active files opened by the `FileOpen` function and has the same function as `FileClose()` without any parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2779">Cet exemple utilise le `Reset` (fonction) pour fermer tous les fichiers ouverts et écrire le contenu de toutes les mémoires tampons de fichiers sur le disque.</span><span class="sxs-lookup"><span data-stu-id="a7782-2779">This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk.</span></span> <span data-ttu-id="a7782-2780">Notez l’utilisation de la `Object` variable `FileNumber` comme une chaîne et un nombre.</span><span class="sxs-lookup"><span data-stu-id="a7782-2780">Note the use of the `Object` variable `FileNumber` as both a string and a number.</span></span>  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md"><span data-ttu-id="a7782-2781">End, instruction</span><span class="sxs-lookup"><span data-stu-id="a7782-2781">End Statement</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="a7782-2782">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2782">Required.</span></span> <span data-ttu-id="a7782-2783">Une expression de chaîne qui identifie le répertoire ou le dossier à supprimer.</span><span class="sxs-lookup"><span data-stu-id="a7782-2783">A string expression that identifies the directory or folder to be removed.</span></span> <span data-ttu-id="a7782-2784"><paramref name="Path" /> peut inclure le lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-2784"><paramref name="Path" /> can include the drive.</span></span> <span data-ttu-id="a7782-2785">Si aucun lecteur n'est spécifié, <see langword="RmDir" /> supprime le répertoire du lecteur actif.</span><span class="sxs-lookup"><span data-stu-id="a7782-2785">If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</span></span></param>
        <summary><span data-ttu-id="a7782-2786">Supprime un répertoire existant.</span><span class="sxs-lookup"><span data-stu-id="a7782-2786">Removes an existing directory.</span></span> <span data-ttu-id="a7782-2787">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="RmDir" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2787">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />.</span></span> <span data-ttu-id="a7782-2788">Pour plus d'informations, consultez <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2788">For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2789">Une erreur se produit si vous essayez d’utiliser `RmDir` sur un répertoire qui contient les fichiers.</span><span class="sxs-lookup"><span data-stu-id="a7782-2789">An error occurs if you try to use `RmDir` on a directory that contains files.</span></span> <span data-ttu-id="a7782-2790">Utilisez le `Kill` (fonction) pour supprimer tous les fichiers avant d’essayer de supprimer un répertoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2790">Use the `Kill` function to delete all files before you try to remove a directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2791">Cet exemple utilise le `RmDir` (fonction) pour supprimer un répertoire existant.</span><span class="sxs-lookup"><span data-stu-id="a7782-2791">This example uses the `RmDir` function to remove an existing directory.</span></span>  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-2792"><paramref name="Path" /> n'est pas spécifié ou il est vide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2792"><paramref name="Path" /> is not specified or is empty.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2793">Le répertoire cible contient des fichiers.</span><span class="sxs-lookup"><span data-stu-id="a7782-2793">Target directory contains files.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a7782-2794">Le répertoire n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="a7782-2794">Directory does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7782-2795">Retourne un <see langword="Long" /> qui spécifie la position de lecture/écriture actuelle dans un fichier ouvert à l'aide de la fonction <see langword="FileOpen" /> ou définit la position de la prochaine opération de lecture/écriture dans un fichier ouvert via la fonction <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2795">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a7782-2796">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="Seek" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2796">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="a7782-2797">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2797">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2798">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2798">Required.</span></span> <span data-ttu-id="a7782-2799"><see langword="Integer" /> qui contient un numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2799">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <summary><span data-ttu-id="a7782-2800">Retourne un <see langword="Long" /> qui spécifie la position de lecture/écriture actuelle dans un fichier ouvert à l'aide de la fonction <see langword="FileOpen" /> ou définit la position de la prochaine opération de lecture/écriture dans un fichier ouvert via la fonction <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2800">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a7782-2801">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="Seek" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2801">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="a7782-2802">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2802">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="a7782-2803">Un <see langword="Long" /> qui spécifie la position de lecture/écriture actuelle dans un fichier ouvert à l’aide de la fonction <see langword="FileOpen" /> ou définit la position de la prochaine opération de lecture/écriture dans un fichier ouvert via la fonction <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2803">A <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2804">`Seek` Retourne une valeur comprise entre 1 et 2 147 483 647 (équivalent à 2 ^ 31 - 1), inclus.</span><span class="sxs-lookup"><span data-stu-id="a7782-2804">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 - 1), inclusive.</span></span>  
  
 <span data-ttu-id="a7782-2805">Ce qui suit décrit les valeurs de retour pour chaque mode d’accès au fichier :</span><span class="sxs-lookup"><span data-stu-id="a7782-2805">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="a7782-2806">Mode</span><span class="sxs-lookup"><span data-stu-id="a7782-2806">Mode</span></span>|<span data-ttu-id="a7782-2807">Valeur de retour</span><span class="sxs-lookup"><span data-stu-id="a7782-2807">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="a7782-2808">Numéro de l’enregistrement suivant lues ou écrites</span><span class="sxs-lookup"><span data-stu-id="a7782-2808">Number of the next record read or written</span></span>|  
|<span data-ttu-id="a7782-2809">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="a7782-2809">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="a7782-2810">Position d’octet à partir duquel l’opération suivante se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2810">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="a7782-2811">Le premier octet dans un fichier est à la position 1, le deuxième octet est à la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-2811">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2812">Cet exemple utilise le `Seek` fonction pour retourner la position actuelle du fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2812">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="a7782-2813">L’exemple part du principe `TestFile` est un fichier qui contient les enregistrements de la structure `Record`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2813">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="a7782-2814">Pour les fichiers ouverts dans `Random` mode, `Seek` renvoie le numéro de l’enregistrement suivant.</span><span class="sxs-lookup"><span data-stu-id="a7782-2814">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="a7782-2815">Pour les fichiers ouverts dans les modes autres que `Random` mode, `Seek` retourne la position d’octet à partir duquel l’opération suivante se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2815">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="a7782-2816">Supposons que `TestFile` est un fichier qui contient plusieurs lignes de texte.</span><span class="sxs-lookup"><span data-stu-id="a7782-2816">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="a7782-2817">Cet exemple utilise le `Seek` fonction pour définir la position de la prochaine opération de lecture ou d’écrire dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2817">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="a7782-2818">Pour les fichiers ouverts dans les modes autres que `Random` mode, `Seek` définit la position d’octet à partir duquel l’opération suivante se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2818">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="a7782-2819">Supposons que `TestFile` est un fichier qui contient plusieurs lignes de texte.</span><span class="sxs-lookup"><span data-stu-id="a7782-2819">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2820">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2820">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-2821">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2821">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-2822">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2822">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2823">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2823">Required.</span></span> <span data-ttu-id="a7782-2824"><see langword="Integer" /> qui contient un numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2824">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <param name="Position"><span data-ttu-id="a7782-2825">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2825">Required.</span></span> <span data-ttu-id="a7782-2826">Nombre compris dans la plage 1-2 147 483 647 inclus, qui indique où l’opération de lecture/écriture suivante doit avoir lieu.</span><span class="sxs-lookup"><span data-stu-id="a7782-2826">Number in the range 1-2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</span></span></param>
        <summary><span data-ttu-id="a7782-2827">Retourne un <see langword="Long" /> qui spécifie la position de lecture/écriture actuelle dans un fichier ouvert à l'aide de la fonction <see langword="FileOpen" /> ou définit la position de la prochaine opération de lecture/écriture dans un fichier ouvert via la fonction <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2827">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a7782-2828">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="Seek" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2828">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="a7782-2829">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2829">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2830">`Seek` Retourne une valeur comprise entre 1 et 2 147 483 647 (équivalent à 2 ^ 31 - 1), inclus.</span><span class="sxs-lookup"><span data-stu-id="a7782-2830">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 - 1), inclusive.</span></span>  
  
 <span data-ttu-id="a7782-2831">Ce qui suit décrit les valeurs de retour pour chaque mode d’accès au fichier :</span><span class="sxs-lookup"><span data-stu-id="a7782-2831">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="a7782-2832">Mode</span><span class="sxs-lookup"><span data-stu-id="a7782-2832">Mode</span></span>|<span data-ttu-id="a7782-2833">Valeur de retour</span><span class="sxs-lookup"><span data-stu-id="a7782-2833">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="a7782-2834">Numéro de l’enregistrement suivant lues ou écrites</span><span class="sxs-lookup"><span data-stu-id="a7782-2834">Number of the next record read or written</span></span>|  
|<span data-ttu-id="a7782-2835">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="a7782-2835">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="a7782-2836">Position d’octet à partir duquel l’opération suivante se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2836">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="a7782-2837">Le premier octet dans un fichier est à la position 1, le deuxième octet est à la position 2 et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="a7782-2837">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2838">Cet exemple utilise le `Seek` fonction pour retourner la position actuelle du fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2838">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="a7782-2839">L’exemple part du principe `TestFile` est un fichier qui contient les enregistrements de la structure `Record`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2839">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="a7782-2840">Pour les fichiers ouverts dans `Random` mode, `Seek` renvoie le numéro de l’enregistrement suivant.</span><span class="sxs-lookup"><span data-stu-id="a7782-2840">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="a7782-2841">Pour les fichiers ouverts dans les modes autres que `Random` mode, `Seek` retourne la position d’octet à partir duquel l’opération suivante se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2841">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="a7782-2842">Supposons que `TestFile` est un fichier qui contient plusieurs lignes de texte.</span><span class="sxs-lookup"><span data-stu-id="a7782-2842">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="a7782-2843">Cet exemple utilise le `Seek` fonction pour définir la position de la prochaine opération de lecture ou d’écrire dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2843">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="a7782-2844">Pour les fichiers ouverts dans les modes autres que `Random` mode, `Seek` définit la position d’octet à partir duquel l’opération suivante se produit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2844">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="a7782-2845">Supposons que `TestFile` est un fichier qui contient plusieurs lignes de texte.</span><span class="sxs-lookup"><span data-stu-id="a7782-2845">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2846">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2846">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a7782-2847">Lecture à partir de fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2847">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a7782-2848">Écriture dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2848">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="a7782-2849">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2849">Required.</span></span> <span data-ttu-id="a7782-2850">Une expression de chaîne qui spécifie un nom de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2850">A string expression that specifies a file name.</span></span> <span data-ttu-id="a7782-2851"><paramref name="PathName" /> peut inclure le répertoire ou le dossier, ainsi que le lecteur.</span><span class="sxs-lookup"><span data-stu-id="a7782-2851"><paramref name="PathName" /> can include directory or folder, and drive.</span></span></param>
        <param name="Attributes"><span data-ttu-id="a7782-2852">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2852">Required.</span></span> <span data-ttu-id="a7782-2853">Constante ou expression numérique dont la somme spécifie des attributs de fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2853">Constant or numeric expression, whose sum specifies file attributes.</span></span></param>
        <summary><span data-ttu-id="a7782-2854">Définit les informations d'attribut d'un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2854">Sets attribute information for a file.</span></span> <span data-ttu-id="a7782-2855">La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="SetAttr" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2855">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />.</span></span> <span data-ttu-id="a7782-2856">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2856">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2857">Une erreur d’exécution se produit si vous essayez de définir les attributs d’un fichier ouvert.</span><span class="sxs-lookup"><span data-stu-id="a7782-2857">A run-time error occurs if you try to set the attributes of an open file.</span></span>  
  
 <span data-ttu-id="a7782-2858">Le `Attributes` des valeurs d’énumération arguments sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="a7782-2858">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="a7782-2859">Value</span><span class="sxs-lookup"><span data-stu-id="a7782-2859">Value</span></span>|<span data-ttu-id="a7782-2860">Constante</span><span class="sxs-lookup"><span data-stu-id="a7782-2860">Constant</span></span>|<span data-ttu-id="a7782-2861">Description </span><span class="sxs-lookup"><span data-stu-id="a7782-2861">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbNormal`|<span data-ttu-id="a7782-2862">Normal (valeur par défaut).</span><span class="sxs-lookup"><span data-stu-id="a7782-2862">Normal (default).</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="a7782-2863">Lecture seule.</span><span class="sxs-lookup"><span data-stu-id="a7782-2863">Read-only.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="a7782-2864">Masqué.</span><span class="sxs-lookup"><span data-stu-id="a7782-2864">Hidden.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="a7782-2865">Fichier système.</span><span class="sxs-lookup"><span data-stu-id="a7782-2865">System file.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="a7782-2866">Nom de volume</span><span class="sxs-lookup"><span data-stu-id="a7782-2866">Volume label</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="a7782-2867">Répertoire ou dossier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2867">Directory or folder.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="a7782-2868">Le fichier a été modifié depuis sa dernière sauvegarde.</span><span class="sxs-lookup"><span data-stu-id="a7782-2868">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="a7782-2869">Le fichier porte un nom différent.</span><span class="sxs-lookup"><span data-stu-id="a7782-2869">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2870">Ces énumérations sont spécifiées par le langage Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a7782-2870">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="a7782-2871">Les noms peuvent être utilisés n’importe où dans votre code au lieu des valeurs réelles.</span><span class="sxs-lookup"><span data-stu-id="a7782-2871">The names can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2872">Cet exemple utilise le `SetAttr` fonction permettant de définir les attributs d’un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2872">This example uses the `SetAttr` function to set attributes for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7782-2873">Le type <paramref name="Attribute" />' n'est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2873"><paramref name="Attribute" /> type is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count"><span data-ttu-id="a7782-2874">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2874">Required.</span></span> <span data-ttu-id="a7782-2875">Nombre d'espaces à insérer avant d'afficher ou d'écrire l'expression suivante dans une liste.</span><span class="sxs-lookup"><span data-stu-id="a7782-2875">The number of spaces to insert before displaying or printing the next expression in a list.</span></span></param>
        <summary><span data-ttu-id="a7782-2876">Utilisé avec la fonction <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</span><span class="sxs-lookup"><span data-stu-id="a7782-2876">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span></span></summary>
        <returns><span data-ttu-id="a7782-2877">Utilisé avec la fonction <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</span><span class="sxs-lookup"><span data-stu-id="a7782-2877">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2878">Si `Count` est inférieure à la largeur de ligne de sortie, la position suivante d’impression immédiatement suit le nombre d’espaces imprimés.</span><span class="sxs-lookup"><span data-stu-id="a7782-2878">If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed.</span></span> <span data-ttu-id="a7782-2879">Si`Count` est supérieure à la largeur de ligne de sortie, `SPC` calcule la prochaine position d’impression à l’aide de la formule :</span><span class="sxs-lookup"><span data-stu-id="a7782-2879">If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="a7782-2880">`currentprintposition`(+(`Count``Mod``width`))</span><span class="sxs-lookup"><span data-stu-id="a7782-2880">`currentprintposition`(+(`Count``Mod``width`))</span></span>  
  
 <span data-ttu-id="a7782-2881">Par exemple, si la position d’impression actuelle est 24, la largeur de ligne de sortie est 80, et que vous spécifiez `SPC(90)`, l’impression suivante commence à la position 34 (position courante + le reste de 90/80).</span><span class="sxs-lookup"><span data-stu-id="a7782-2881">For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80).</span></span> <span data-ttu-id="a7782-2882">Si la différence entre la position d’impression actuelle et la largeur de ligne de sortie est inférieure à `Count` (ou `Count` `Mod` *largeur*), le `SPC` fonction passe au début de la ligne suivante et génère espaces égal à `Count` -(*largeur* - *currentprintposition*).</span><span class="sxs-lookup"><span data-stu-id="a7782-2882">If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` - (*width* - *currentprintposition*).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2883">Assurez-vous que les colonnes sont suffisamment larges pour lettres larges.</span><span class="sxs-lookup"><span data-stu-id="a7782-2883">Make sure your tabular columns are wide enough to allow for wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2884">Cet exemple utilise le `SPC` (fonction) pour positionner la sortie dans un fichier et dans le **sortie** fenêtre.</span><span class="sxs-lookup"><span data-stu-id="a7782-2884">This example uses the `SPC` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md"><span data-ttu-id="a7782-2885">Mod, opérateur (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2885">Mod Operator (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7782-2886">S'utilise avec les fonctions <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</span><span class="sxs-lookup"><span data-stu-id="a7782-2886">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a7782-2887">S'utilise avec les fonctions <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</span><span class="sxs-lookup"><span data-stu-id="a7782-2887">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
        <returns><span data-ttu-id="a7782-2888">S'utilise avec les fonctions <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</span><span class="sxs-lookup"><span data-stu-id="a7782-2888">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2889">Si la position d’impression en cours sur la ligne actuelle est supérieure à `Column`, `TAB` passe à la valeur de colonne égale à `Column` sur la ligne de sortie suivante.</span><span class="sxs-lookup"><span data-stu-id="a7782-2889">If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="a7782-2890">Si `Column` est inférieur à 1, `TAB` déplace la position d’impression à la colonne 1.</span><span class="sxs-lookup"><span data-stu-id="a7782-2890">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="a7782-2891">Si `Column` est supérieure à la largeur de ligne de sortie `TAB` calcule la prochaine position d’impression à l’aide de la formule :</span><span class="sxs-lookup"><span data-stu-id="a7782-2891">If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="a7782-2892">Largeur de colonne Mod</span><span class="sxs-lookup"><span data-stu-id="a7782-2892">Column Mod width</span></span>  
  
 <span data-ttu-id="a7782-2893">Par exemple, si *largeur* est 80 et que vous spécifiez `TAB(90)`, l’impression suivante commence à la colonne 10 (le reste de 90/80).</span><span class="sxs-lookup"><span data-stu-id="a7782-2893">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="a7782-2894">Si `Column` est inférieure à la position actuelle, l’impression commence à la ligne suivante à la position d’impression calculée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2894">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="a7782-2895">Si la position calculée est supérieure à la position actuelle, l’impression commence à l’impression calculée position sur la même ligne.</span><span class="sxs-lookup"><span data-stu-id="a7782-2895">If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="a7782-2896">La position d’impression à l’extrême gauche sur une ligne de sortie est toujours 1.</span><span class="sxs-lookup"><span data-stu-id="a7782-2896">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="a7782-2897">Lorsque vous utilisez le `Print` ou `PrintLine` fonctions pour imprimer les fichiers, le plus à droite est la largeur actuelle du fichier de sortie, que vous pouvez définir à l’aide de la `FileWidth` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-2897">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="a7782-2898">Le `TAB` fonction peut également être utilisée avec le `WriteLine` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-2898">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="a7782-2899">Il ne peut pas être utilisé avec <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2899">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2900">Assurez-vous que les colonnes sont assez large pour contenir des lettres larges.</span><span class="sxs-lookup"><span data-stu-id="a7782-2900">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2901">Cet exemple utilise le `TAB` (fonction) pour positionner la sortie dans un fichier et dans le **sortie** fenêtre.</span><span class="sxs-lookup"><span data-stu-id="a7782-2901">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md"><span data-ttu-id="a7782-2902">Mod, opérateur (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2902">Mod Operator (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column"><span data-ttu-id="a7782-2903">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2903">Optional.</span></span> <span data-ttu-id="a7782-2904">Le numéro de colonne atteint avant d'afficher ou d'imprimer l'expression suivante dans une liste.</span><span class="sxs-lookup"><span data-stu-id="a7782-2904">The column number moved to before displaying or printing the next expression in a list.</span></span> <span data-ttu-id="a7782-2905">En cas d'omission, <see langword="TAB" /> déplace le point d'insertion au début de la zone d'impression suivante.</span><span class="sxs-lookup"><span data-stu-id="a7782-2905">If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</span></span></param>
        <summary><span data-ttu-id="a7782-2906">S'utilise avec les fonctions <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</span><span class="sxs-lookup"><span data-stu-id="a7782-2906">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
        <returns><span data-ttu-id="a7782-2907">S'utilise avec les fonctions <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</span><span class="sxs-lookup"><span data-stu-id="a7782-2907">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2908">Si la position d’impression actuelle sur la ligne actuelle est supérieure à `Column`, `TAB` passe à la valeur de colonne égale à `Column` sur la ligne de sortie suivante.</span><span class="sxs-lookup"><span data-stu-id="a7782-2908">If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="a7782-2909">Si `Column` est inférieur à 1, `TAB` déplace la position d’impression à la colonne 1.</span><span class="sxs-lookup"><span data-stu-id="a7782-2909">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="a7782-2910">Si `Column` est supérieure à la largeur de ligne de sortie, `TAB` calcule la prochaine position d’impression à l’aide de la formule :</span><span class="sxs-lookup"><span data-stu-id="a7782-2910">If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="a7782-2911">Largeur de colonne Mod</span><span class="sxs-lookup"><span data-stu-id="a7782-2911">Column Mod width</span></span>  
  
 <span data-ttu-id="a7782-2912">Par exemple, si *largeur* est 80 et que vous spécifiez `TAB(90)`, l’impression suivante commence à la colonne 10 (le reste de 90/80).</span><span class="sxs-lookup"><span data-stu-id="a7782-2912">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="a7782-2913">Si `Column` est inférieure à la position actuelle, l’impression commence à la ligne suivante à la position d’impression calculée.</span><span class="sxs-lookup"><span data-stu-id="a7782-2913">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="a7782-2914">Si la position calculée est supérieure à la position actuelle, l’impression commence à l’impression calculée position sur la même ligne.</span><span class="sxs-lookup"><span data-stu-id="a7782-2914">If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="a7782-2915">La position d’impression à l’extrême gauche sur une ligne de sortie est toujours 1.</span><span class="sxs-lookup"><span data-stu-id="a7782-2915">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="a7782-2916">Lorsque vous utilisez le `Print` ou `PrintLine` fonctions pour imprimer les fichiers, le plus à droite est la largeur actuelle du fichier de sortie, que vous pouvez définir à l’aide de la `FileWidth` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-2916">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="a7782-2917">Le `TAB` fonction peut également être utilisée avec le `WriteLine` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a7782-2917">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="a7782-2918">Il ne peut pas être utilisé avec <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a7782-2918">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a7782-2919">Assurez-vous que les colonnes sont assez large pour contenir des lettres larges.</span><span class="sxs-lookup"><span data-stu-id="a7782-2919">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2920">Cet exemple utilise le `TAB` (fonction) pour positionner la sortie dans un fichier et dans le **sortie** fenêtre.</span><span class="sxs-lookup"><span data-stu-id="a7782-2920">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md"><span data-ttu-id="a7782-2921">Mod, opérateur (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-2921">Mod Operator (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a7782-2922">Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2922">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a7782-2923">La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2923">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a7782-2924">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2924">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2925">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2925">Required.</span></span> <span data-ttu-id="a7782-2926">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2926">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="a7782-2927">Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2927">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a7782-2928">La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2928">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a7782-2929">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2929">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2930">Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2930">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="a7782-2931">`Lock` et `Unlock` fonctions sont toujours utilisées par paires.</span><span class="sxs-lookup"><span data-stu-id="a7782-2931">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="a7782-2932">Les arguments de `Lock` et `Unlock` doivent être identiques.</span><span class="sxs-lookup"><span data-stu-id="a7782-2932">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="a7782-2933">Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2933">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="a7782-2934">Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2934">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="a7782-2935">Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2935">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2936">Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions.</span><span class="sxs-lookup"><span data-stu-id="a7782-2936">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="a7782-2937">Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2937">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2938">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2938">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2939">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2939">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2940">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2940">Required.</span></span> <span data-ttu-id="a7782-2941">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2941">Any valid file number.</span></span></param>
        <param name="Record"><span data-ttu-id="a7782-2942">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2942">Optional.</span></span> <span data-ttu-id="a7782-2943">Numéro du seul enregistrement ou octet à verrouiller ou déverrouiller</span><span class="sxs-lookup"><span data-stu-id="a7782-2943">Number of the only record or byte to lock or unlock</span></span></param>
        <summary><span data-ttu-id="a7782-2944">Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2944">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a7782-2945">La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2945">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a7782-2946">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2946">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2947">Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2947">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="a7782-2948">`Lock` et `Unlock` fonctions sont toujours utilisées par paires.</span><span class="sxs-lookup"><span data-stu-id="a7782-2948">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="a7782-2949">Les arguments de `Lock` et `Unlock` doivent être identiques.</span><span class="sxs-lookup"><span data-stu-id="a7782-2949">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="a7782-2950">Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2950">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="a7782-2951">Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2951">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="a7782-2952">Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2952">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2953">Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions.</span><span class="sxs-lookup"><span data-stu-id="a7782-2953">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="a7782-2954">Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2954">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2955">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2955">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2956">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2956">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2957">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2957">Required.</span></span> <span data-ttu-id="a7782-2958">N’importe quel numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2958">Any valid file number.</span></span></param>
        <param name="FromRecord"><span data-ttu-id="a7782-2959">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2959">Optional.</span></span> <span data-ttu-id="a7782-2960">Numéro du premier enregistrement ou octet à verrouiller ou déverrouiller</span><span class="sxs-lookup"><span data-stu-id="a7782-2960">Number of the first record or byte to lock or unlock.</span></span></param>
        <param name="ToRecord"><span data-ttu-id="a7782-2961">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2961">Optional.</span></span> <span data-ttu-id="a7782-2962">Numéro du dernier enregistrement ou octet à verrouiller ou déverrouiller</span><span class="sxs-lookup"><span data-stu-id="a7782-2962">Number of the last record or byte to lock or unlock.</span></span></param>
        <summary><span data-ttu-id="a7782-2963">Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2963">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a7782-2964">La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2964">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a7782-2965">Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2965">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2966">Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2966">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="a7782-2967">`Lock` et `Unlock` fonctions sont toujours utilisées par paires.</span><span class="sxs-lookup"><span data-stu-id="a7782-2967">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="a7782-2968">Les arguments de `Lock` et `Unlock` doivent être identiques.</span><span class="sxs-lookup"><span data-stu-id="a7782-2968">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="a7782-2969">Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2969">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="a7782-2970">Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2970">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="a7782-2971">Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2971">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-2972">Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions.</span><span class="sxs-lookup"><span data-stu-id="a7782-2972">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="a7782-2973">Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2973">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-2974">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2974">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-2975">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-2975">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-2976">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-2976">Required.</span></span> <span data-ttu-id="a7782-2977">Une expression <see langword="Integer" /> qui contient un numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-2977">An <see langword="Integer" /> expression that contains any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="a7782-2978">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2978">Optional.</span></span> <span data-ttu-id="a7782-2979">Une ou plusieurs expressions délimitées par des virgules à écrire dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2979">One or more comma-delimited expressions to write to a file.</span></span></param>
        <summary><span data-ttu-id="a7782-2980">Écrit des données dans un fichier séquentiel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2980">Writes data to a sequential file.</span></span> <span data-ttu-id="a7782-2981">Les données écrites avec <see langword="Write" /> sont généralement lues à partir d’un fichier à l’aide de <see langword="Input" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-2981">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-2982">Le `Write` et `WriteLine` fonctions sont fournies pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2982">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-2983">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-2983">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-2984">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-2984">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-2985">Si vous omettez `Output`, une ligne vide est imprimée dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2985">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="a7782-2986">Plusieurs expressions peuvent être séparées par une virgule.</span><span class="sxs-lookup"><span data-stu-id="a7782-2986">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="a7782-2987">Contrairement à la `Print` (fonction), le `Write` fonction insère des virgules entre les éléments et les chaînes entre guillemets car ils sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2987">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="a7782-2988">Il est inutile de placer de délimiteurs explicites dans la liste.</span><span class="sxs-lookup"><span data-stu-id="a7782-2988">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="a7782-2989">Lorsque `Write` est utilisé pour écrire des données dans un fichier, numérique uniquement, `Boolean`, date, la valeur null, et `Error` formats de données sont pris en charge.</span><span class="sxs-lookup"><span data-stu-id="a7782-2989">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="a7782-2990">Les hypothèses universelles suivantes sont suivies afin que les données peuvent toujours être lues et correctement interprétées à l’aide de `Input`, indépendamment des paramètres régionaux :</span><span class="sxs-lookup"><span data-stu-id="a7782-2990">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="a7782-2991">Données numériques sont toujours écrit avec un point comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-2991">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="a7782-2992">Pour `Boolean` données, soit `#TRUE#` ou `#FALSE#` est imprimé.</span><span class="sxs-lookup"><span data-stu-id="a7782-2992">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="a7782-2993">Le `True` et `False` mots clés ne sont pas traduits, indépendamment des paramètres régionaux.</span><span class="sxs-lookup"><span data-stu-id="a7782-2993">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="a7782-2994">Données de date sont écrites dans le fichier en utilisant le format de date universel.</span><span class="sxs-lookup"><span data-stu-id="a7782-2994">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="a7782-2995">Lorsque la date ou le composant heure manque ou est nul, seule la partie fournie est écrite dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-2995">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="a7782-2996">Si rien n’est écrit dans le fichier `Output` données sont vides.</span><span class="sxs-lookup"><span data-stu-id="a7782-2996">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="a7782-2997">Toutefois, pour les données de type null, `#NULL#` est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-2997">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="a7782-2998">Pour `Error` données, la sortie s’affiche en tant que `#ERROR errorcode#`.</span><span class="sxs-lookup"><span data-stu-id="a7782-2998">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="a7782-2999">Le `Error` mot clé n’est pas traduit, indépendamment des paramètres régionaux.</span><span class="sxs-lookup"><span data-stu-id="a7782-2999">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="a7782-3000">`WriteLine` Insère un caractère de saut de ligne (autrement dit, un retour chariot/ligne de flux, ou `Chr(13) + Chr(10)`), une fois qu’il a écrit le dernier caractère `Output` au fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-3000">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="a7782-3001">Vous pouvez incorporer des guillemets dans une chaîne à l’aide de guillemets doubles, ou « ».</span><span class="sxs-lookup"><span data-stu-id="a7782-3001">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="a7782-3002">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="a7782-3002">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="a7782-3003">Retourne une chaîne avec la valeur de `Double quotation marks aren't "difficult" to handle`.</span><span class="sxs-lookup"><span data-stu-id="a7782-3003">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="a7782-3004">Écriture dans un fichier à l’aide de la `Write` ou `WriteLine` functions exige `Append` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-3004">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-3005">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-3005">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-3006">Cet exemple utilise le `Write` fonction pour écrire des données brutes dans un fichier séquentiel.</span><span class="sxs-lookup"><span data-stu-id="a7782-3006">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a7782-3007">Le mode de fichier n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-3007">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-3008">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-3008">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-3009">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-3009">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-3010">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-3010">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a7782-3011">Obligatoire.</span><span class="sxs-lookup"><span data-stu-id="a7782-3011">Required.</span></span> <span data-ttu-id="a7782-3012">Une expression <see langword="Integer" /> qui contient un numéro de fichier valide.</span><span class="sxs-lookup"><span data-stu-id="a7782-3012">An <see langword="Integer" /> expression that contains any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="a7782-3013">Optionnel.</span><span class="sxs-lookup"><span data-stu-id="a7782-3013">Optional.</span></span> <span data-ttu-id="a7782-3014">Une ou plusieurs expressions délimitées par des virgules à écrire dans un fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-3014">One or more comma-delimited expressions to write to a file.</span></span></param>
        <summary><span data-ttu-id="a7782-3015">Écrit des données dans un fichier séquentiel.</span><span class="sxs-lookup"><span data-stu-id="a7782-3015">Writes data to a sequential file.</span></span> <span data-ttu-id="a7782-3016">Les données écrites avec <see langword="Write" /> sont généralement lues à partir d’un fichier à l’aide de <see langword="Input" />.</span><span class="sxs-lookup"><span data-stu-id="a7782-3016">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a7782-3017">Le `Write` et `WriteLine` fonctions sont fournies pour la compatibilité descendante et peut affecter les performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-3017">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a7782-3018">Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="a7782-3018">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a7782-3019">Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a7782-3019">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a7782-3020">Si vous omettez `Output`, une ligne vide est imprimée dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-3020">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="a7782-3021">Plusieurs expressions peuvent être séparées par une virgule.</span><span class="sxs-lookup"><span data-stu-id="a7782-3021">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="a7782-3022">Contrairement à la `Print` (fonction), le `Write` fonction insère des virgules entre les éléments et les chaînes entre guillemets car ils sont écrits dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-3022">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="a7782-3023">Il est inutile de placer de délimiteurs explicites dans la liste.</span><span class="sxs-lookup"><span data-stu-id="a7782-3023">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="a7782-3024">Lorsque `Write` est utilisé pour écrire des données dans un fichier, numérique uniquement, `Boolean`, date, la valeur null, et `Error` formats de données sont pris en charge.</span><span class="sxs-lookup"><span data-stu-id="a7782-3024">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="a7782-3025">Les hypothèses universelles suivantes sont suivies afin que les données peuvent toujours être lues et correctement interprétées à l’aide de `Input`, indépendamment des paramètres régionaux :</span><span class="sxs-lookup"><span data-stu-id="a7782-3025">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="a7782-3026">Données numériques sont toujours écrit avec un point comme séparateur décimal.</span><span class="sxs-lookup"><span data-stu-id="a7782-3026">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="a7782-3027">Pour `Boolean` données, soit `#TRUE#` ou `#FALSE#` est imprimé.</span><span class="sxs-lookup"><span data-stu-id="a7782-3027">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="a7782-3028">Le `True` et `False` mots clés ne sont pas traduits, indépendamment des paramètres régionaux.</span><span class="sxs-lookup"><span data-stu-id="a7782-3028">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="a7782-3029">Données de date sont écrites dans le fichier en utilisant le format de date universel.</span><span class="sxs-lookup"><span data-stu-id="a7782-3029">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="a7782-3030">Lorsque la date ou le composant heure manque ou est nul, seule la partie fournie est écrite dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-3030">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="a7782-3031">Si rien n’est écrit dans le fichier `Output` données sont vides.</span><span class="sxs-lookup"><span data-stu-id="a7782-3031">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="a7782-3032">Toutefois, pour les données de type null, `#NULL#` est écrit.</span><span class="sxs-lookup"><span data-stu-id="a7782-3032">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="a7782-3033">Pour `Error` données, la sortie s’affiche en tant que `#ERROR errorcode#`.</span><span class="sxs-lookup"><span data-stu-id="a7782-3033">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="a7782-3034">Le `Error` mot clé n’est pas traduit, indépendamment des paramètres régionaux.</span><span class="sxs-lookup"><span data-stu-id="a7782-3034">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="a7782-3035">`WriteLine` Insère un caractère de saut de ligne (autrement dit, un retour chariot/ligne de flux, ou `Chr(13) + Chr(10)`), une fois qu’il a écrit le dernier caractère `Output` au fichier.</span><span class="sxs-lookup"><span data-stu-id="a7782-3035">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="a7782-3036">Vous pouvez incorporer des guillemets dans une chaîne à l’aide de guillemets doubles, ou « ».</span><span class="sxs-lookup"><span data-stu-id="a7782-3036">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="a7782-3037">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="a7782-3037">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="a7782-3038">Retourne une chaîne avec la valeur de `Double quotation marks aren't "difficult" to handle`.</span><span class="sxs-lookup"><span data-stu-id="a7782-3038">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="a7782-3039">Écriture dans un fichier à l’aide de la `Write` ou `WriteLine` functions exige `Append` accéder à partir de la `FileIOPermissionAccess` énumération.</span><span class="sxs-lookup"><span data-stu-id="a7782-3039">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a7782-3040">Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a7782-3040">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a7782-3041">Cet exemple utilise le `Write` fonction pour écrire des données brutes dans un fichier séquentiel.</span><span class="sxs-lookup"><span data-stu-id="a7782-3041">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a7782-3042">Accès au fichier avec Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-3042">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a7782-3043">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a7782-3043">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a7782-3044">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a7782-3044">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>