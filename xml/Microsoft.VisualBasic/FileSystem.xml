<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="86f064f440ae5767e7b891c416e8e3b3adac224b" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57937406" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Le module <see langword="FileSystem" /> contient les procédures utilisées pour exécuter des opérations sur des fichiers, des répertoires ou des dossiers et les opérations système. La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que le module <see langword="FileSystem" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce module prend en charge les mots clés du langage Visual Basic et les membres de bibliothèque Runtime qui accèdent aux fichiers et dossiers.  
  
   
  
## Examples  
 Cet exemple utilise le `GetAttr` fonction permettant de déterminer les attributs d’un fichier et un répertoire ou un dossier.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">Liste des répertoires et des fichiers</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">Liste des entrées et sorties</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Mots clés (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membres de la bibliothèque d’exécution Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Obligatoire. Expression de chaîne qui identifie le répertoire ou dossier qui devient le nouveau répertoire ou dossier par défaut. <paramref name="Path" /> peut inclure le lecteur. Si aucun lecteur n'est spécifié, <see langword="ChDir" /> modifie le répertoire ou le dossier par défaut du lecteur actif.</param>
        <summary>Modifie le répertoire ou dossier actif. La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d’E/S de fichier que la fonction <see langword="ChDir" />. Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ChDir` fonction modifie le répertoire par défaut, mais pas le lecteur par défaut. Par exemple, si le lecteur par défaut est C, l’instruction suivante change le répertoire par défaut sur le lecteur D, mais C reste le lecteur par défaut :  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Vous pouvez rendre relatif des changements de répertoire est en tapant les deux points, comme suit :  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  Le `ChDir` fonction nécessite une autorisation de code non managé, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et.  
  
   
  
## Examples  
 Cet exemple utilise le `ChDir` (fonction) pour modifier le répertoire ou dossier actif.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> est vide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Un lecteur non valide est spécifié ou le lecteur est indisponible.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Comment : analyser des chemins d'accès dans Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Création, suppression et déplacement de fichiers et de répertoires dans Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Modifie le lecteur actif.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Obligatoire. Expression String qui spécifie un lecteur existant. Si vous fournissez une chaîne de longueur nulle (""), le lecteur actif n'est pas modifié. Si l'argument <paramref name="Drive" /> est une chaîne de plusieurs caractères, <see langword="ChDrive" /> n'utilise que la première lettre.</param>
        <summary>Modifie le lecteur actif.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ChDrive` fonction nécessite une autorisation de code non managé, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Cet exemple utilise le `ChDrive` (fonction) pour modifier le lecteur actif. La fonction lève une exception si le lecteur n’existe pas.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Un lecteur non valide est spécifié ou le lecteur est indisponible.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Obligatoire. Expression String qui spécifie un lecteur existant. Si vous fournissez une chaîne de longueur nulle (""), le lecteur actif n'est pas modifié. Si l'argument <paramref name="Drive" /> est une chaîne de plusieurs caractères, <see langword="ChDrive" /> n'utilise que la première lettre.</param>
        <summary>Modifie le lecteur actif.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ChDrive` fonction nécessite une autorisation de code non managé, ce qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.SecurityPermission> et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Cet exemple utilise le `ChDrive` (fonction) pour modifier le lecteur actif. La fonction lève une exception si le lecteur n’existe pas.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Un lecteur non valide est spécifié ou le lecteur est indisponible.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une chaîne représentant le chemin d'accès en cours. Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="CurDir" />. Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une chaîne représentant le chemin d'accès en cours. Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="CurDir" />. Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Chaîne représentant le chemin d'accès actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple utilise le `CurDir` fonction pour retourner le chemin d’accès actuel.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Optionnel. Expression <see langword="Char" /> qui spécifie un lecteur existant. Si aucun lecteur n'est spécifié ou si <paramref name="Drive" /> est une chaîne de longueur nulle (""), <see langword="CurDir" /> retourne le chemin d'accès du lecteur actif.</param>
        <summary>Retourne une chaîne représentant le chemin d'accès en cours. Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="CurDir" />. Pour plus d'informations, consultez <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Chaîne représentant le chemin d'accès actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple utilise le `CurDir` fonction pour retourner le chemin d’accès actuel.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une chaîne représentant le nom d'un fichier, d'un répertoire ou d'un dossier qui correspond à un modèle ou un attribut de fichier spécifié ou au nom de volume d'un lecteur. Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que la fonction <see langword="Dir" />. Pour plus d'informations, voir <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une chaîne représentant le nom d'un fichier, d'un répertoire ou d'un dossier qui correspond à un modèle ou un attribut de fichier spécifié ou au nom de volume d'un lecteur. Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que la fonction <see langword="Dir" />. Pour plus d'informations, voir <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Chaîne représentant le nom d'un fichier, d'un répertoire ou d'un dossier qui correspond à un attribut de fichier ou de modèle spécifié ou au nom de volume d'un lecteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Dir` fonction prend en charge l’utilisation de plusieurs caractères (`*`) et le caractère unique (`?`) des caractères génériques pour spécifier plusieurs fichiers.  
  
 `VbVolume` Retourne le nom de volume pour le lecteur au lieu d’un nom de fichier spécifique.  
  
 Vous devez fournir un `PathName` la première fois que vous appelez le `Dir` (fonction). Pour récupérer l’élément suivant, vous pouvez effectuer les appels suivants à la `Dir` fonction sans paramètres.  
  
> [!IMPORTANT]
>  Pour s’exécuter correctement, le `Dir` fonction requiert le <xref:System.Security.Permissions.FileIOPermissionAccess.Read> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> indicateurs de <xref:System.Security.Permissions.FileIOPermission> à accorder à l’exécution de code. Pour plus d’informations, consultez <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Le `Attributes` des valeurs d’énumération arguments sont les suivantes :  
  
|Value|Constante|Description |  
|-|-|-|  
|`Normal`|`vbnormal`|Par défaut. Spécifie les fichiers sans attributs.|  
|`ReadOnly`|`vbReadOnly`|Spécifie les fichiers en lecture seule et également des fichiers sans attributs.|  
|`Hidden`|`vbHidden`|Spécifie les fichiers masqués, ainsi que les fichiers sans attributs.|  
|`System`|`vbSystem`|Spécifie les fichiers système et également des fichiers sans attributs.|  
|`Volume`|`vbVolume`|Spécifie le nom de volume. Si aucun autre attribut est spécifié, `vbVolume` est ignoré.|  
|`Directory`|`vbDirectory`|Spécifie les répertoires ou des dossiers et également des fichiers sans attributs.|  
|`Archive`|`vbArchive`|Le fichier a été modifié depuis sa dernière sauvegarde.|  
|`Alias`|`vbAlias`|Le fichier porte un nom différent.|  
  
> [!NOTE]
>  Ces énumérations sont spécifiées par le langage Visual Basic et peuvent être utilisées partout dans votre code au lieu des valeurs réelles.  
  
   
  
## Examples  
 Cet exemple utilise le `Dir` (fonction) pour vérifier si certains fichiers et répertoires existent.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">Optionnel. Une expression de chaîne qui spécifie un nom de fichier, de répertoire ou de dossier, ou l’étiquette du volume d’un lecteur. Une chaîne de longueur nulle (<see langword="&quot;&quot;" />) est retournée si <paramref name="PathName" /> n'est pas trouvé.</param>
        <param name="Pathname">Optionnel. Une expression de chaîne qui spécifie un nom de fichier, de répertoire ou de dossier, ou l’étiquette du volume d’un lecteur. Une chaîne de longueur nulle (<see langword="&quot;&quot;" />) est retournée si <paramref name="Pathname" /> n'est pas trouvé.</param>
        <param name="Attributes">Optionnel. Énumération ou expression numérique dont la valeur spécifie des attributs de fichier. En cas d'omission, <see langword="Dir" /> retourne des fichiers qui correspondent à <paramref name="Pathname" />, mais n'ont pas d'attributs.</param>
        <summary>Retourne une chaîne représentant le nom d'un fichier, d'un répertoire ou d'un dossier qui correspond à un modèle ou un attribut de fichier spécifié ou au nom de volume d'un lecteur. Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que la fonction <see langword="Dir" />. Pour plus d'informations, voir <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Chaîne représentant le nom d'un fichier, d'un répertoire ou d'un dossier qui correspond à un attribut de fichier ou de modèle spécifié ou au nom de volume d'un lecteur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Dir` fonction prend en charge l’utilisation de plusieurs caractères (`*`) et le caractère unique (`?`) des caractères génériques pour spécifier plusieurs fichiers.  
  
 `VbVolume` Retourne le nom de volume pour le lecteur au lieu d’un nom de fichier spécifique.  
  
 Vous devez fournir un `PathName` la première fois que vous appelez le `Dir` (fonction). Pour récupérer l’élément suivant, vous pouvez effectuer les appels suivants à la `Dir` fonction sans paramètres.  
  
> [!IMPORTANT]
>  Pour s’exécuter correctement, le `Dir` fonction requiert le <xref:System.Security.Permissions.FileIOPermissionAccess.Read> et <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> indicateurs de <xref:System.Security.Permissions.FileIOPermission> à accorder à l’exécution de code. Pour plus d’informations, consultez <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, et [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Le `Attributes` des valeurs d’énumération arguments sont les suivantes :  
  
|Value|Constante|Description |  
|-|-|-|  
|`Normal`|`vbnormal`|Par défaut. Spécifie les fichiers sans attributs.|  
|`ReadOnly`|`vbReadOnly`|Spécifie les fichiers en lecture seule, en plus des fichiers sans attributs.|  
|`Hidden`|`vbHidden`|Spécifie les fichiers cachés, en plus des fichiers sans attributs.|  
|`System`|`vbSystem`|Spécifie les fichiers système, en plus des fichiers sans attributs.|  
|`Volume`|`vbVolume`|Spécifie le nom de volume. Si aucun autre attribut est spécifié, `vbVolume` est ignoré.|  
|`Directory`|`vbDirectory`|Spécifie les dossiers, en plus des fichiers sans attributs.|  
|`Archive`|`vbArchive`|Le fichier a été modifié depuis sa dernière sauvegarde.|  
|`Alias`|`vbAlias`|Le fichier porte un nom différent.|  
  
> [!NOTE]
>  Ces énumérations sont spécifiées par le langage Visual Basic et peuvent être utilisées partout dans votre code à la place les valeurs réelles.  
  
   
  
## Examples  
 Cet exemple utilise le `Dir` (fonction) pour vérifier si certains fichiers et répertoires existent.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. <see langword="Integer" /> qui contient un numéro de fichier valide.</param>
        <summary>Retourne une valeur booléenne <see langword="True" /> lorsque la fin d'un fichier ouvert pour <see langword="Random" /> ou <see langword="Input" /> séquentiel a été atteinte.</summary>
        <returns>Une valeur booléenne <see langword="True" /> lorsque la fin d’un fichier ouvert pour <see langword="Random" /> ou <see langword="Input" /> séquentiel a été atteinte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez `EOF` afin d’éviter l’erreur générée en tentant d’obtenir des données au-delà de la fin d’un fichier.  
  
 Le `EOF` fonction renvoie `False` jusqu'à ce que la fin du fichier a été atteinte. Avec les fichiers ouverts pour `Random` ou `Binary` accès, `EOF` retourne `False` jusqu'à l’exécution de la dernière `FileGet` fonction ne peut pas lire un enregistrement entier.  
  
 Avec les fichiers ouverts pour `Binary` accéder, une tentative de lecture par le biais du fichier en utilisant le `Input` fonctionner jusqu'à ce que `EOF` retourne `True` génère une erreur. Utiliser le `LOF` et `Loc` fonctions au lieu de `EOF` lors de la lecture des fichiers binaires avec `Input`, ou utilisez `Get` lorsque vous utilisez le `EOF` (fonction). Avec les fichiers ouverts pour `Output`, `EOF` retourne toujours `True`.  
  
   
  
## Examples  
 Cet exemple utilise le `EOF` fonction pour détecter la fin d’un fichier. Cet exemple suppose que `Testfile` est un fichier texte qui contient plusieurs lignes de texte.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. <see langword="Integer" />. N’importe quel numéro de fichier valide.</param>
        <summary>Retourne une énumération qui représente le mode de fichier pour les fichiers ouverts à l'aide de la fonction <see langword="FileOpen" />. Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que la fonction <see langword="FileAttr" />. Pour plus d'informations, voir <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Les valeurs d'énumération suivantes indiquent le mode d'accès au fichier : 
 <list type="table"><item><term> Value 
 </term><description> Mode 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette fonction retourne une énumération qui représente le mode de fichier pour les fichiers ouverts à l’aide de la `FileOpen` (fonction).  
  
   
  
## Examples  
 Cet exemple utilise le `FileAttr` fonction pour retourner le mode d’un fichier ouvert.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Optionnel. Tableau de paramètres de 0 ou plus de canaux à fermer.</param>
        <summary>Termine les opérations d'entrée/sortie (E/S) dans un fichier ouvert à l'aide de la fonction <see langword="FileOpen" />. <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier. Pour plus d'informations, voir <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `FileClose` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d'informations, voir [Procédure : Lire le texte à partir de fichiers avec un StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [Comment : Écrire du texte dans des fichiers à l’aide de StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), et [procédure pas à pas : Manipulation de fichiers et répertoires en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 Si vous omettez `FileNumbers`, tous les fichiers actifs ouvrent par le `FileOpen` (fonction) sont fermés.  
  
 Lorsque vous fermez les fichiers qui ont été ouverts pour `Output` ou `Append`, la mémoire tampon finale de sortie est écrite dans la mémoire tampon de système d’exploitation pour ce fichier. Tout espace associé fermé de mémoires tampons est publié le fichier.  
  
 Lorsque le `FileClose` fonction est exécutée, l’association d’un fichier avec son fichier numéro se termine.  
  
   
  
## Examples  
 Cet exemple utilise le `FileClose` (fonction) pour fermer un fichier ouvert pour `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> n’existe pas.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End, instruction</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Stop, instruction (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Obligatoire. Une expression de chaîne qui spécifie le nom du fichier à copier. <paramref name="Source" /> peut inclure le répertoire ou le dossier du fichier source, ainsi que son lecteur.</param>
        <param name="Destination">Obligatoire. Une expression de chaîne qui spécifie le nom du fichier de destination. <paramref name="Destination" /> peut inclure le répertoire ou le dossier, ainsi que le lecteur, du fichier de destination.</param>
        <summary>Copie un fichier. Le <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="FileCopy" />. Pour plus d'informations, voir <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous essayez d’utiliser le `FileCopy` fonctionnent sur un fichier ouvert, une erreur se produit.  
  
 `FileCopy` requiert une confiance totale pour travailler sur le lecteur local.  
  
   
  
## Examples  
 Cet exemple utilise le `FileCopy` (fonction) pour copier un fichier vers un autre. Pour cet exemple, supposons que `SrcFile` est un fichier qui contient des données.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Source" /> ou <paramref name="Destination" /> n'est pas valide ou n'est pas spécifié.</exception>
        <exception cref="T:System.IO.IOException">Le fichier est déjà ouvert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">Guide pratique pour créer une copie d'un fichier dans un autre répertoire en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Guide pratique pour créer une copie d'un fichier dans le même répertoire en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Guide pratique pour copier un répertoire vers un autre répertoire en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obligatoire. Une expression de chaîne qui spécifie un nom de fichier. <paramref name="PathName" /> peut inclure le répertoire ou le dossier, et le lecteur.</param>
        <summary>Retourne une valeur <see langword="Date" /> qui indique la date et l'heure à laquelle un fichier a été écrit. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileDateTime" />. Pour plus d'informations, consultez <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></summary>
        <returns>Valeur <see langword="Date" /> qui indique la date et l'heure à laquelle un fichier a été créé ou modifié pour la dernière fois.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple utilise le `FileDateTime` fonction pour déterminer la date et l’heure d’un fichier a été créée ou modifiée. Le format de la date et l’heure affichée est basé sur les paramètres régionaux du système.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="PathName" /> n'est pas valide ou contient des caractères génériques.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier cible n'existe pas.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier avec `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la`FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier avec `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé. La taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier avec `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier avec `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction),`FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la`FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <param name="StringIsFixedLength">Optionnel. S'applique uniquement lors de l'écriture d'une chaîne. Spécifie s'il est nécessaire d'écrire un descripteur à deux octets pour la chaîne décrivant la longueur. La valeur par défaut est <see langword="False" />.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <param name="ArrayIsDynamic">Optionnel. S'applique uniquement lors de l'écriture d'un tableau. Spécifie si le tableau sera traité comme dynamique et si un descripteur de tableau décrivant la taille et les limites du tableau est nécessaire.</param>
        <param name="StringIsFixedLength">Optionnel. S'applique uniquement lors de l'écriture d'une chaîne. Spécifie s'il est nécessaire d'écrire un descripteur à deux octets pour la chaîne décrivant la longueur. La valeur par défaut est <see langword="False" />.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGet" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGet` sont généralement écrites dans un fichier à l’aide de `FilePut`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet suivant le dernier `FileGet` ou `FilePut` (fonction) (ou vers lequel pointe le dernier `Seek` (fonction)) est en lecture.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGet` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le démarrage de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Par défaut, si la variable lue est une chaîne, `FileGet` lit un descripteur à deux octets qui contient la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe ; Lorsque vous placez dans un fichier, le descripteur de longueur n’est pas écrite. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, vous pouvez choisir s’il faut un descripteur pour la taille et la dimension du tableau. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lors de la lecture du tableau, vous devez correspond à la façon dont le tableau a été écrit. S’il a été écrit avec le descripteur, vous devez lire le descripteur. Si le descripteur n’est pas utilisé, la taille et les limites du tableau passé dans `FileGet` déterminer les éléments à lire.  
  
     Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Les octets 218 sont distribués comme suit :  
  
    -   18 octets pour le descripteur : (2 + 8 * 2)  
  
    -   200 octets pour les données : (5 * 10 * 4).  
  
-   Si la variable lue est un autre type de variable (pas une chaîne de longueur variable ou un objet), `FileGet` lit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours de lecture.  
  
-   `FileGet` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePut`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire les éléments individuels. Cela inclut les tableaux et leurs descripteurs. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille d’une chaîne lors de l’écriture sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGet` lit toutes les variables à partir du disque de façon contiguë ; Autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGet` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
-   `FileGet` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
    > [!IMPORTANT]
    >  Lecture d’un fichier à l’aide de la `FileGet` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de la variable valide dans laquelle les données sont lues.</param>
        <param name="RecordNumber">Optionnel. Numéro d'enregistrement (fichiers en mode <see langword="Random" />) ou numéro d’octet (fichiers en mode <see langword="Binary" />) auquel la lecture débute.</param>
        <summary>Lit les données d’un fichier disque ouvert dans une variable.  La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileGetObject" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `FileGetObject` fonction est utilisée au lieu de `FileGet` pour éviter toute ambiguïté au moment de la compilation si type `Object` est retourné au lieu d’un autre type, tel que `Integer`, `Long`, `Short`, et ainsi de suite.  
  
 Si vous avez l’intention d’écrire le `Variant` type, `FileGetObject` est requis. En cas de doute, si vous utilisez un objet pour le deuxième paramètre, il est toujours conseillé d’utiliser `FilePutObject` et `FileGetObject`.  
  
 `FileGetObject` est valide uniquement dans `Random` et `Binary` mode.  
  
 Données lues avec `FileGetObject` sont généralement écrites avec `FilePutObject`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, `FileGetObject` lit l’enregistrement ou octet après le dernier `FileGetObject` ou `FilePutObject` (fonction) (ou vers lequel pointe le dernier `Seek` fonction).  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours de lecture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FileGetObject` lit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Car il est impossible de déterminer précisément la quantité de données de la marge intérieure, il est judicieux d’avoir la longueur d’enregistrement correspond à la longueur des données en cours de lecture.  
  
-   Si la variable lue est une chaîne, par défaut `FileGetObject` lit un descripteur à deux octets contenant la longueur de chaîne, puis lit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause de le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets. Visual Basic 6.0 et les versions antérieures prennent en charge les chaînes de longueur fixe et lors de la lecture dans un fichier, le descripteur de longueur n’est pas écrit. Si vous souhaitez lire une chaîne sans descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable lue est un tableau, la longueur d’enregistrement spécifié par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : 2 + 8 * NumberOfDimensions.  
  
     Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque :  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     Les octets 218 sont distribués comme suit : 18 octets pour le descripteur (2 + 8 * 2) et 100 octets pour les données (5 * 10 * 4).  
  
-   `FileGetObject` lit les éléments de structures comme si chacun d’eux ont été lu individuellement, sauf qu’il n’existe aucun remplissage entre les éléments. Sur le disque, un tableau dynamique d’un type défini par l’utilisateur (écrit avec `FilePutObject`) est préfixé par un descripteur dont la longueur est égale à 2 plus 8 fois le nombre de dimensions : 2 + 8 * NumberOfDimensions. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour lire des éléments individuels, y compris les tableaux et leurs descripteurs. Le <xref:Microsoft.VisualBasic.VBFixedStringAttribute> classe peut être appliquée aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lorsqu’elle est écrite sur le disque.  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, tous les `Random` règles s’appliquent à ces exceptions près :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FileGetObject` lit toutes les variables à partir du disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FileGetObject` lit uniquement les données. Aucun descripteur n’est en lecture.  
  
 `FileGetObject` lit les chaînes de longueur variable qui ne sont pas des éléments de structures, sans rechercher le descripteur de deux octets. Le nombre d’octets lus est égal au nombre de caractères de la chaîne.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
   
  
## Examples  
 L’exemple suivant lit un enregistrement dans un fichier de test et il récupère ensuite.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obligatoire. Une expression de chaîne qui spécifie un fichier. <paramref name="PathName" /> peut inclure le répertoire ou le dossier, et le lecteur.</param>
        <summary>Retourne une valeur qui spécifie la longueur d’un fichier en octets. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileLen" />. Pour plus d'informations, consultez <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Longueur du fichier en octets.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le fichier spécifié est ouvert lorsque la `FileLen` fonction est appelée, la valeur retournée représente la taille du fichier au moment il a été ouvert.  
  
> [!NOTE]
>  Pour obtenir la longueur actuelle d’un fichier ouvert, utilisez la `LOF` (fonction).  
  
   
  
## Examples  
 Cet exemple utilise le `FileLen` fonction pour retourner la longueur d’un fichier en octets. Pour cet exemple, supposons que `TestFile` est un fichier qui contient des données.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier n'existe pas.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide. Utilisez la fonction <see langword="FreeFile" /> pour obtenir le numéro du prochain fichier disponible.</param>
        <param name="FileName">Obligatoire. Une expression de chaîne qui spécifie un nom de fichier. Peut inclure le répertoire ou le dossier, ainsi que le lecteur.</param>
        <param name="Mode">Obligatoire. Énumération spécifiant le mode de fichier : <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> ou <see langword="Random" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.OpenMode" />.</param>
        <param name="Access">Optionnel. Énumération spécifiant quelles sont les opérations autorisées sur le fichier ouvert : <see langword="Read" />, <see langword="Write" /> ou <see langword="ReadWrite" />. La valeur par défaut est <see langword="ReadWrite" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</param>
        <param name="Share">Optionnel. Énumération spécifiant les opérations non autorisées sur le fichier ouvert par d'autres processus : <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> et <see langword="Lock Read Write" />. La valeur par défaut est <see langword="Lock Read Write" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.OpenShare" />.</param>
        <param name="RecordLength">Optionnel. Nombre inférieur ou égal à 32 767 (octets). Pour les fichiers ouverts pour accès aléatoire, cette valeur est la longueur de l'enregistrement. Pour les fichiers à accès séquentiel, cette valeur est le nombre de caractères mis en mémoire tampon.</param>
        <summary>Ouvre un fichier pour entrée ou sortie. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileOpen" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `FileOpen` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Vous devez ouvrir un fichier avant toute opération d’e/s peut être effectuée sur celui-ci. `FileOpen` alloue une mémoire tampon d’e/s au fichier et détermine le mode d’accès à utiliser avec la mémoire tampon.  
  
> [!IMPORTANT]
>  Lors de l’écriture dans un fichier, une application peut avoir créer un fichier, si le fichier auquel il tente d’écrire n’existe pas. Pour ce faire, il a besoin d’autorisation pour le répertoire dans lequel le fichier doit être créé. Toutefois, si le fichier spécifié par `FileName` n’existe pas, l’application doit `Write` autorisation uniquement au fichier lui-même. Où que possible, afin d’améliorer la sécurité, créer le fichier pendant le déploiement et d’accorder `Write` autorisation à ce fichier uniquement, et non pour l’ensemble du répertoire. Pour aider à améliorer la sécurité, d’écrire des données dans les annuaires d’utilisateurs au lieu du répertoire racine ou le répertoire Program Files.  
  
 Vous trouverez le canal à ouvrir à l’aide de la `FreeFile()` (fonction).  
  
> [!IMPORTANT]
>  Le `FileOpen` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération, qui peut affecter son exécution dans les situations de confiance partielle. Pour plus d’informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple illustre différentes utilisations de la `FileOpen` fonction pour activer l’entrée et sortie vers un fichier.  
  
 Le code suivant ouvre le fichier `TestFile` dans `Input` mode.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 Cet exemple ouvre le fichier dans `Binary` mode pour les opérations d’écriture uniquement.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 L’exemple suivant ouvre le fichier dans `Random` mode. Le fichier contient des enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 Cet exemple de code ouvre le fichier dans `Output` mode ; toute opération qui peut lire ou écrire dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 Cet exemple de code ouvre le fichier dans `Binary` mode pour la lecture ; les autres processus ne peut pas lire le fichier.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur d'enregistrement est négative (et différente de -1).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileName" /> est déjà ouvert ou <paramref name="FileName" /> n'est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le`VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le`RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <param name="StringIsFixedLength">Optionnel. S'applique uniquement lors de l'écriture d'une chaîne. Spécifie s'il faut écrire, sur le fichier, un descripteur de longueur de chaîne à deux octets pour la chaîne. La valeur par défaut est <see langword="False" />.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <param name="ArrayIsDynamic">Optionnel. S'applique uniquement lors de l'écriture d'un tableau. Spécifie si le tableau est traité comme dynamique, et s'il faut écrire un descripteur de tableau pour la chaîne décrivant la longueur.</param>
        <param name="StringIsFixedLength">Optionnel. S'applique uniquement lors de l'écriture d'une chaîne. Spécifie s'il faut écrire, sur le fichier, un descripteur de longueur de chaîne à deux octets pour la chaîne. La valeur par défaut est <see langword="False" />.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePut" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePut` sont généralement lues à partir d’un fichier à l’aide de `FileGet`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, l’enregistrement ou octet après le dernier `FileGet` ou `FilePut` fonctionne ou vers lequel pointe le dernier `Seek` fonction est écrite.  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePut` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePut`, vous devez faire de même avec `FileGet`, et vous devez vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePut` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Étant donné que la quantité de données de remplissage ne peut pas être déterminée avec certitude, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception sera levée.  
  
-   Si la variable écrite est une chaîne, `FilePut` écrit un descripteur à deux octets qui contient la longueur de chaîne et écrit les données de la variable. Par conséquent, la longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePut` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePut` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePut` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, vous avez la possibilité d’écrire un descripteur pour la taille et les dimensions du tableau ou non. Visual Basic 6.0 et les versions antérieures écrivent le descripteur de fichier pour un tableau dynamique, mais pas pour un tableau de taille fixe. Visual Basic 2005 par défaut n’écrit ne pas le descripteur. Pour écrire le descripteur, définissez le `ArrayIsDynamic` paramètre `True`. Lorsque vous écrivez le tableau, vous devez faire correspondre la façon que le tableau sera lue ; s’il doit être lu avec le descripteur, vous devez écrire le descripteur. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions). La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Par exemple, la déclaration de tableau suivante nécessite 218 octets lorsque le tableau est écrit sur le disque.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable en cours d’écriture est n’importe quel autre type de variable (pas une chaîne de longueur variable ou un objet), `FilePut` écrit uniquement les données de variable. La longueur d’enregistrement spécifiée par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la longueur des données en cours d’écriture.  
  
-   `FilePut` écrit des éléments de structures comme si chacun était écrite individuellement, mais il n’existe aucun remplissage entre les éléments. Le `VBFixedString` attribut peut être appliqué aux champs de chaîne dans les structures pour indiquer la taille de la chaîne lors de l’écriture sur le disque.  
  
    > [!NOTE]
    >  Champs de chaîne dont le nombre d’ont que ceux spécifiés par le `VBFixedString` attribut sont tronqués lors de l’écriture sur le disque,  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, la plupart de la `Random` règles de mode s’appliquent, à quelques exceptions près. Les règles suivantes pour les fichiers ouverts dans `Binary` mode diffèrent des règles pour `Random` mode :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePut` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
-   Pour tout tableau autre qu’un tableau dans une structure, `FilePut` écrit uniquement les données. Aucun descripteur n’est écrit.  
  
-   `FilePut` écrit des chaînes de longueur variable qui ne sont pas des éléments de structure, sans le descripteur de deux octets. Le nombre d’octets écrits est égal au nombre de caractères dans la chaîne. Par exemple, les instructions suivantes écrivent 11 octets dans le fichier numéro 1 :  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Écriture dans un fichier à l’aide de la `FilePut` fonction requiert `Write` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePut` fonction pour écrire des données dans un fichier. Cinq enregistrements de la structure `Person` sont écrits dans le fichier.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 et différent de -1.</exception>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Nom de variable valide contenant les données écrites sur le disque.</param>
        <param name="RecordNumber">Optionnel. Numéro de l'enregistrement (fichiers ouverts en mode <see langword="Random" />) ou de l'octet (fichiers ouverts en mode <see langword="Binary" />) par lequel l'écriture débute.</param>
        <summary>Écrit les données d'une variable dans un fichier sur disque.  La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FilePutObject" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `FilePutObject` fonction est utilisée au lieu de `FilePut` pour éviter toute ambiguïté au moment de la compilation si type `Object` est passée au lieu d’un autre type, tel que `Integer`, `Long`, `Short`, et ainsi de suite.  
  
 `FilePutObject` écrit et lit des descripteurs qui décrivent l’objet. Si vous avez l’intention d’écrire le `Variant` type, `FilePutObject` est requis. En cas de doute, si vous utilisez un objet pour le deuxième paramètre, nous vous recommandons de toujours utiliser `FilePutObject` et `FileGetObject`.  
  
 `FilePutObject` est valide uniquement dans `Random` et `Binary` mode.  
  
 Les données écrites avec `FilePutObject` sont généralement lues à partir d’un fichier à l’aide de `FileGetObject`.  
  
 Le premier enregistrement ou octet d’un fichier est à la position 1, le deuxième enregistrement ou octet la position 2 et ainsi de suite. Si vous omettez `RecordNumber`, `FilePutObject` écrit l’enregistrement ou octet après le dernier `FileGetObject` ou `FilePutObject` (fonction) (ou l’enregistrement ou octet vers lequel pointe le dernier `Seek` fonction).  
  
 Le `StringIsFixedLength` argument contrôle si la fonction interprète les chaînes de longueur fixe ou variable. `FilePutObject` n’écrit pas le descripteur de longueur lorsque l’argument est `True`. Si vous utilisez `StringIsFixedLength`  =  `True` avec `FilePutObject`, vous devez faire de même avec `FileGetObject`, et vous devez également vous assurer que la chaîne est initialisée à la longueur attendue.  
  
## <a name="random-mode"></a>Mode aléatoire  
 Pour les fichiers ouverts dans `Random` mode, les règles suivantes s’appliquent :  
  
-   Si la longueur des données en cours d’écriture est inférieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), `FilePutObject` écrit les enregistrements suivants sur les limites de longueur d’enregistrement. L’espace entre la fin d’un enregistrement et le début de l’enregistrement suivant est rempli avec le contenu existant de la mémoire tampon de fichier. Car il est impossible de déterminer précisément la quantité de données de la marge intérieure, il est généralement une bonne idée d’avoir à la longueur d’enregistrement correspond à la longueur des données en cours d’écriture. Si la longueur des données en cours d’écriture est supérieure à la longueur spécifiée dans le `RecordLength` clause de le `FileOpen` (fonction), une exception est levée.  
  
-   Si la variable écrite est un objet qui contient un type numérique, `FilePutObject` écrit deux octets identifiant le `VarType` de l’objet, puis écrit la variable. Par exemple, lors de l’écriture d’un objet qui contient un entier, `FilePutObject` écrit six octets : deux octets qui identifient l’objet en tant que `VarType(3)` (`Integer`) et quatre octets qui contiennent les données. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieur au nombre réel d’octets requis pour stocker la variable d’au moins deux octets.  
  
-   Si la variable écrite est un objet qui contient une chaîne, `FilePutObject` écrit un descripteur à deux octets identifiant le `VarType(8)` de l’objet, un descripteur à deux octets indiquant la longueur de la chaîne, puis écrit les données de chaîne. La longueur d’enregistrement spécifiée par le `RecordLength` paramètre dans le `FileOpen` fonction doit être supérieure à la longueur réelle de la chaîne de moins de quatre octets. Si vous souhaitez placer une chaîne sans le descripteur, vous devez passer `True` à la `StringIsFixedLength` paramètre et la chaîne lue doit être la longueur correcte.  
  
-   Si la variable écrite est un tableau, la longueur d’enregistrement spécifié par le `RecordLength` clause dans la `FileOpen` fonction doit être supérieure ou égale à la somme de tous les octets nécessaires pour écrire les données de tableau et le descripteur de tableau. Le descripteur spécifie le rang du tableau, la taille et les limites inférieures de chaque rang. Sa longueur est égale à 2 plus 8 fois le nombre de dimensions : (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Mode binaire  
 Pour les fichiers ouverts dans `Binary` mode, tous les le `Random` mode règles s’appliquent, à l’exception :  
  
-   Le `RecordLength` clause dans la `FileOpen` fonction n’a aucun effet. `FilePutObject` écrit toutes les variables sur le disque de manière contiguë, autrement dit, sans remplissage entre les enregistrements.  
  
   
  
## Examples  
 Cet exemple utilise le `FilePutObject` fonction pour écrire une chaîne dans un fichier.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="RecordWidth">Obligatoire. Expression numérique comprise dans la plage 0-255, limites incluses, qui indique combien de caractères apparaissent sur une ligne avant de commencer une nouvelle ligne. Si <paramref name="RecordWidth" /> égale 0, il n'y a aucune limite à la longueur d'une ligne. La valeur par défaut <paramref name="RecordWidth" /> est 0.</param>
        <summary>Assigne une largeur de ligne de sortie à un fichier ouvert à l'aide de la fonction <see langword="FileOpen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple utilise le `FileWidth` fonction permettant de définir la largeur de ligne de sortie pour un fichier.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur <see langword="Integer" /> qui représente le prochain numéro de fichier utilisable par la fonction <see langword="FileOpen" />.</summary>
        <returns>Une valeur entière qui représente le prochain numéro de fichier utilisable par la fonction <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez `FreeFile` pour fournir un numéro de fichier qui n’est pas déjà utilisé.  
  
   
  
## Examples  
 Cet exemple utilise le `FreeFile` fonction pour retourner le nombre de fichiers disponible suivant. Cinq fichiers sont ouverts à l’intérieur de la boucle, et des exemples de données sont écrites dans chacun.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Plus de 255 fichiers sont en cours d'utilisation.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obligatoire. Une expression de chaîne qui spécifie un nom de fichier, de répertoire ou de dossier. <paramref name="PathName" /> peut inclure le répertoire ou le dossier, ainsi que le lecteur.</param>
        <summary>Retourne une valeur <see langword="FileAttribute" /> qui représente les attributs d'un fichier, répertoire ou dossier. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="FileAttribute" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>La valeur retournée par <see langword="GetAttr" /> est la somme des valeurs d'énumération suivantes : 
 <list type="table"><item><term> Value 
 </term><description> Constante 
 </description><description> Description  
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Lecture seule.  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Masqué.  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> Fichier système.  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Répertoire ou dossier.  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> Le fichier a été modifié depuis sa dernière sauvegarde.  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> Le fichier porte un nom différent.  
  
 </description></item></list><block subset="none" type="note"><para>  
 Ces énumérations sont spécifiées par le langage Visual Basic. Les noms peuvent remplacer les valeurs réelles partout dans votre code.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer les attributs définis, utilisez la `And` opérateur pour effectuer une comparaison au niveau du bit de la valeur retournée par la `GetAttr` (fonction) et la valeur de l’attribut de fichier individuel. Si le résultat n’est pas égal à zéro, cet attribut est défini pour le fichier nommé. Par exemple, la valeur de retour de la commande suivante `And` expression est zéro si le `Archive` attribut n’est pas défini :  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Une valeur différente de zéro est retournée si le `Archive` attribut est défini.  
  
   
  
## Examples  
 Cet exemple utilise le `GetAttr` fonction permettant de déterminer les attributs d’un fichier et un répertoire ou un dossier.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="Pathname" /> n'est pas valide ou contient des caractères génériques.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier cible n'existe pas.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">And, opérateur (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</param>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte quelques lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</param>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte quelques lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</param>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</param>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</param>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</param>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</param>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</param>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, étant donné que la virgule est considérée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</param>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</param>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</param>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Value">Obligatoire. Variable à laquelle ont été assignées les valeurs lues dans le fichier. Ne peut pas être une variable tableau ou objet.</param>
        <summary>Lit des données dans un fichier séquentiel ouvert et les assigne à des variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Input` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `Input` sont généralement écrites dans un fichier à l’aide de `Write`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic 2005.  
  
 Lors de la lecture, chaîne standard ou données numériques sont affectées à des variables sans modification. Le tableau suivant illustre comment les autres données d’entrée sont traitées.  
  
|Données|Valeur assignée à la variable|  
|-|-|  
|Virgule de séparation ou ligne vierge|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # ou #FALSE #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La date et/ou heure représentées par l’expression|  
|#ERROR `errornumber`#|`errornumber` (la variable est un objet marqué comme une erreur)|  
  
 Si vous atteignez la fin du fichier pendant que vous entrent un élément de données, l’entrée est arrêtée et une erreur se produit.  
  
> [!NOTE]
>  Le `Input` fonction n’est pas localisée. Par exemple, dans la version allemande, si vous entrez 3,14159, elle retourne uniquement 3, car la virgule est traitée comme un séparateur au lieu de variable comme séparateur décimal.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `Input` fonction requiert `Read` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Input` fonction permettant de lire des données à partir d’un fichier dans deux variables. Cet exemple suppose que `TestFile` est un fichier qui comporte plusieurs lignes de données écrites à l’aide de la `Write` fonctionner, chaque ligne contenant une chaîne entre guillemets et un nombre, séparés par une virgule, par exemple : (« Hello », 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="CharCount">Obligatoire. Toute expression numérique valide qui spécifie le nombre de caractères à lire.</param>
        <summary>Retourne une valeur <see langword="String" /> qui contient des caractères provenant d'un fichier ouvert en mode <see langword="Input" /> ou <see langword="Binary" />. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="InputString" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Une chaîne qui contient des caractères provenant d’un fichier ouvert en mode <see langword="Input" /> ou <see langword="Binary" />. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `InputString` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec le `InputString` (fonction) est généralement écrites dans un fichier à l’aide de `Print` ou `FilePut`. Utilisez cette fonction uniquement avec les fichiers ouverts dans `Input` ou `Binary` mode.  
  
 Contrairement à la `Input` (fonction), le `InputString` fonction retourne tous les caractères lus. Cela inclut des virgules, retours-chariot imbriqués, sauts de ligne, entre guillemets et les espaces de début.  
  
 Avec les fichiers ouverts pour `Binary` accéder, une tentative de lecture du fichier à l’aide de la `InputString` jusqu'à `EOF` retourne `True` génère une erreur. Utiliser le `LOF` et `Loc` fonctions au lieu de `EOF` lorsque vous lisez des fichiers binaires à l’aide de `InputString`, ou utilisez `FileGet` lorsque vous utilisez le `EOF` (fonction).  
  
> [!NOTE]
>  Lors de la lecture à partir de fichiers, ne faites pas de prendre des décisions de sécurité sur le contenu du fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
   
  
## Examples  
 Cet exemple utilise le `InputString` fonction permettant de lire un caractère à la fois à partir d’un fichier et l’imprimer à la `Output` fenêtre. Cet exemple suppose que `MyFile` est un fichier texte qui comporte plusieurs lignes d’exemples de données.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> n’existe pas.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="CharCount" /> &lt; 0 ou &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obligatoire. Une expression de chaîne qui spécifie un ou plusieurs noms de fichiers à supprimer. <paramref name="PathName" /> peut inclure le répertoire ou le dossier, ainsi que le lecteur.</param>
        <summary>Supprime des fichiers d'un disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="Kill" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` prend en charge l’utilisation de plusieurs caractères (`*`) et le caractère unique (`?`) des caractères génériques pour spécifier plusieurs fichiers.  
  
 **Note de sécurité** afin d’exécuter, le `Kill` fonction requiert `Read` et `PathDiscovery` indicateurs de <xref:System.Security.Permissions.FileIOPermission> à accorder à l’exécution de code. Pour plus d’informations, consultez <xref:System.Security.SecurityException> [autorisations d’accès de Code](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 Cet exemple utilise le `Kill` (fonction) pour supprimer un fichier à partir d’un disque.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le ou les fichiers cibles sont ouverts.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le ou les fichiers cibles sont introuvables.</exception>
        <exception cref="T:System.Security.SecurityException">Autorisation refusée.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <summary>Lit une ligne seule dans un fichier à accès séquentiel ouvert et l'assigne à une variable <see langword="String" />.</summary>
        <returns>Lit une ligne seule dans un fichier à accès séquentiel ouvert et l'assigne à une variable <see langword="String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `LineInput` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Données lues avec `LineInput` sont généralement écrites dans un fichier à l’aide de `Print`.  
  
> [!IMPORTANT]
>  Lors de la lecture à partir de fichiers, ne vous basez pas sur le contenu d’un fichier basé sur l’extension de nom de fichier. Par exemple, un fichier nommé Form1.vb ne peut pas être un fichier source Visual Basic.  
  
 Le `LineInput` fonction lit à partir d’un fichier d’un caractère à la fois jusqu'à ce qu’il rencontre un retour chariot (`Chr(13)`) ou saut de ligne-retour chariot (`Chr(13) + Chr(10)`) séquence. Séquences retour chariot/ligne flux sont ignorées au lieu d’ajouté à la chaîne de caractères.  
  
> [!IMPORTANT]
>  Lecture d’un fichier à l’aide de la `LineInput` fonction requiert `Read` accéder à partir de la <xref:System.Security.Permissions.FileIOPermissionAccess> énumération.  
  
   
  
## Examples  
 Cet exemple utilise le `LineInput` (fonction) pour lire une ligne dans un fichier séquentiel et l’affecter à une variable. Cet exemple suppose que `TestFile` est un fichier texte qui comporte plusieurs lignes d’exemples de données.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">La fin du fichier est atteinte.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> n’existe pas.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. Tout numéro de fichier <see langword="Integer" /> valide.</param>
        <summary>Retourne une valeur qui spécifie la position lecture/écriture actuelle d’un fichier ouvert.</summary>
        <returns>La position de lecture/écriture actuelle dans un fichier ouvert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Loc` fonction est de base zéro ; son utilisation pour récupérer le premier octet dans un fichier retournera 0.  
  
 Le `Loc` fonction est fournie pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Ce qui suit décrit la valeur de retour pour chaque mode d’accès au fichier :  
  
|Mode|Valeur de retour|  
|-|-|  
|`Random`|Numéro du dernier enregistrement lu ou écrit dans le fichier.|  
|`Sequential`|Position d’octet actuelle dans le fichier divisé par 128. Toutefois, les informations retournées par `Loc` pour les fichiers à accès séquentiel n’est ni utilisé ni nécessaire.|  
|`Binary`|Position du dernier octet lu ou écrit.|  
  
   
  
## Examples  
 Cet exemple utilise le `Loc` fonction pour retourner la position de lecture/écriture actuelle dans un fichier ouvert. Cet exemple suppose que `MyFile` est un fichier texte qui comporte plusieurs lignes d’exemples de données.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />. La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <summary>Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />. La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.  
  
 `Lock` et `Unlock` fonctions sont toujours utilisées par paires. Les arguments de `Lock` et `Unlock` doivent être identiques.  
  
 Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier. Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.  
  
 Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions. Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Record">Optionnel. Numéro du seul enregistrement ou octet à verrouiller ou déverrouiller.</param>
        <summary>Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />. La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.  
  
 `Lock` et `Unlock` fonctions sont toujours utilisées par paires. Les arguments de `Lock` et `Unlock` doivent être identiques.  
  
 Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier. Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.  
  
 Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions. Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="FromRecord">Optionnel. Numéro du premier enregistrement ou octet à verrouiller ou déverrouiller</param>
        <param name="ToRecord">Optionnel. Numéro du dernier enregistrement ou octet à verrouiller ou déverrouiller</param>
        <summary>Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />. La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.  
  
 `Lock` et `Unlock` fonctions sont toujours utilisées par paires. Les arguments de `Lock` et `Unlock` doivent être identiques.  
  
 Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier. Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.  
  
 Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions. Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. Une entier qui contient un numéro de fichier valide.</param>
        <summary>Retourne la taille, en octets, d’un fichier ouvert à l’aide de la fonction <see langword="FileOpen" />. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="LOF" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>La taille, en octets, d’un fichier ouvert à l’aide de la fonction <see langword="FileOpen" />. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `FileLen` fonction pour obtenir la longueur d’un fichier qui n’est pas ouvert.  
  
   
  
## Examples  
 Cet exemple utilise le `LOF` fonction permettant de déterminer la taille d’un fichier ouvert. Cet exemple suppose que `TestFile` est un fichier texte qui contient des exemples de données.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Obligatoire. Une expression de chaîne qui identifie le répertoire à créer. Le <paramref name="Path" /> peut inclure le lecteur. Si aucun lecteur n'est spécifié, <see langword="MkDir" /> crée le nouveau répertoire sur le lecteur actif.</param>
        <summary>Crée un répertoire. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="MkDir" />. Pour plus d'informations, consultez <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette fonction crée un nouveau répertoire.  
  
   
  
## Examples  
 Cet exemple utilise le `MkDir` fonction permettant de créer un répertoire. Si le lecteur n’est pas spécifié, le nouveau répertoire est créé sur le lecteur actif.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> n'est pas spécifié ou il est vide.</exception>
        <exception cref="T:System.Security.SecurityException">Autorisation refusée.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire existe déjà.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">Guide pratique pour créer un répertoire en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Output">Optionnel. Zéro, une ou plusieurs expressions délimitées par des virgules à écrire dans un fichier.  
  
Les paramètres de l’argument <paramref name="Output" /> sont : 
 <see langword="T:System.IO.IOException" />: Le mode de fichier n’est pas valide.  
  
 <see langword="T:System.IO.IOException" /> : <paramref name="FileNumber" /> n'existe pas.</param>
        <summary>Écrit des données formatées dans un fichier séquentiel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Print` et `PrintLine` fonctions sont fournies pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` n’inclut pas de saut de ligne à la fin d’une ligne ; Toutefois, `PrintLine` inclut une saut de ligne.  
  
 Données écrites avec `Print` sont généralement lues à partir d’un fichier à l’aide de `LineInput` ou `Input`.  
  
 Si vous omettez `Output` pour `PrintLine`, une ligne vide est imprimée dans le fichier ; pour `Print`, rien n’est sortie. Plusieurs expressions séparées par une virgule seront alignées sur les limites des onglets, mais mélange de virgules et `TAB` peut entraîner des résultats incohérents.  
  
 Pour `Boolean` données, soit `True` ou `False` est imprimé. Le `True` et `False` mots clés ne sont pas traduits, quel que soit les paramètres régionaux.  
  
 Données de date sont écrites dans le fichier à l’aide du format de date courte standard reconnu par votre système. Lorsque la date ou le composant heure manque ou est nul, seule la partie fournie est écrite dans le fichier.  
  
 Si rien n’est écrit dans le fichier `Output` données sont vides. Toutefois, si `Output` les données de liste sont `DBNull`, `Null` est écrit dans le fichier.  
  
 Pour `Error` données, la sortie s’affiche en tant que `Error errorcode`. Le `Error` mot clé n’est pas traduit, quel que soit les paramètres régionaux.  
  
 Toutes les données écrites dans le fichier à l’aide de `Print` respectent les conventions ; autrement dit, les données sont correctement mis en forme en utilisant le séparateur décimal approprié. Si l’utilisateur souhaite sortir des données pour une utilisation par plusieurs paramètres régionaux, `Write` doit être utilisé.  
  
 Écriture dans un fichier à l’aide de la `Print` ou `PrintLine` functions exige `Write` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Print` et `PrintLine` fonctions pour écrire des données dans un fichier.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Output">Optionnel. Zéro, une ou plusieurs expressions délimitées par des virgules à écrire dans un fichier.  
  
Les paramètres de l’argument <paramref name="Output" /> sont : 
 <see langword="T:System.IO.IOException" />: Le mode de fichier n’est pas valide.  
  
 <see langword="T:System.IO.IOException" /> : <paramref name="FileNumber" /> n'existe pas.</param>
        <summary>Écrit des données formatées dans un fichier séquentiel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Print` et `PrintLine` fonctions sont fournies pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` n’inclut pas de saut de ligne à la fin d’une ligne ; Toutefois,`PrintLine` inclut une saut de ligne.  
  
 Données écrites avec `Print` sont généralement lues à partir d’un fichier à l’aide de `LineInput` ou `Input`.  
  
 Si vous omettez `Output` pour `PrintLine`, une ligne vide est imprimée dans le fichier ; pour `Print`, rien n’est sortie. Plusieurs expressions séparées par une virgule seront alignées sur les limites des onglets, mais mélange de virgules et `TAB` peut entraîner des résultats incohérents.  
  
 Pour `Boolean` données, soit `True` ou `False` est imprimé. Le `True` et `False` mots clés ne sont pas traduits, quel que soit les paramètres régionaux.  
  
 Données de date sont écrites dans le fichier en utilisant le format de date courte standard reconnu par le système. Lorsque la date ou le composant heure manque ou est nul, seule la partie fournie est écrite dans le fichier.  
  
 Si rien n’est écrit dans le fichier `Output` données sont vides. Toutefois, si `Output` les données de liste sont `DBNull`, `Null` est écrit dans le fichier.  
  
 Pour `Error` données, la sortie s’affiche en tant que `Error errorcode`. Le `Error` mot clé n’est pas traduit, quel que soit les paramètres régionaux.  
  
 Toutes les données écrites dans le fichier à l’aide de `Print` respectent les conventions ; autrement dit, les données sont correctement mis en forme en utilisant le séparateur décimal approprié. Si l’utilisateur souhaite sortir des données pour une utilisation par plusieurs paramètres régionaux, `Write` doit être utilisé.  
  
 Écriture dans un fichier à l’aide de la `Print` ou `PrintLine` functions exige `Write` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Print` et `PrintLine` fonctions pour écrire des données dans un fichier.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Obligatoire. Une expression de chaîne qui spécifie le nom et l’emplacement du fichier existant. <paramref name="OldPath" /> peut inclure le répertoire et le lecteur du fichier.</param>
        <param name="NewPath">Obligatoire. Une expression de chaîne qui spécifie le nom et l’emplacement du nouveau fichier. <paramref name="NewPath" /> peut inclure le répertoire et le lecteur de l'emplacement de destination. Le nom de fichier spécifié par <paramref name="NewPath" /> ne peut pas déjà exister.</param>
        <summary>Renomme un fichier ou un répertoire sur un disque. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="Rename" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le`Rename` fonction renomme un fichier et les déplace vers un autre répertoire, si nécessaire. Le `Rename` fonction peut déplacer un fichier sur les disques, mais elle ne peut renommer un répertoire existant lorsque les deux `NewPath` et `OldPath` se trouvent sur le même lecteur. `Rename` Impossible de créer un nouveau fichier ou un répertoire.  
  
 À l’aide de la `Rename` fonction sur un fichier ouvert génère une erreur. Vous devez fermer un fichier ouvert avant de le renommer. `Rename` arguments ne peut pas inclure plusieurs caractères (*) et des caractères génériques ( ?) à caractère unique.  
  
> [!IMPORTANT]
>  Lorsque vous utilisez `Rename` pour copier un fichier à partir d’un emplacement non protégé vers un emplacement protégé, le fichier conserve les droits moins restreints. Vérifiez que vous n’introduisez pas un risque de sécurité possible.  
  
   
  
## Examples  
 Cet exemple utilise le `Rename` (fonction) pour renommer un fichier. Pour cet exemple, supposons que les répertoires qui sont déjà spécifiés existent.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin n’est pas valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier <paramref name="OldPath" /> n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Impossible de renommer vers un autre périphérique.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Guide pratique pour renommer un fichier en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme tous les fichiers disque ouverts à l'aide de la fonction <see langword="FileOpen" />. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="Reset" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Reset` fonction ferme tous les fichiers actifs ouverts par le `FileOpen` de fonction et a la même fonction que `FileClose()` sans aucun paramètre.  
  
   
  
## Examples  
 Cet exemple utilise le `Reset` (fonction) pour fermer tous les fichiers ouverts et écrire le contenu de toutes les mémoires tampons de fichiers sur le disque. Notez l’utilisation de la `Object` variable `FileNumber` comme une chaîne et un nombre.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End, instruction</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Obligatoire. Une expression de chaîne qui identifie le répertoire ou le dossier à supprimer. <paramref name="Path" /> peut inclure le lecteur. Si aucun lecteur n'est spécifié, <see langword="RmDir" /> supprime le répertoire du lecteur actif.</param>
        <summary>Supprime un répertoire existant. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="RmDir" />. Pour plus d'informations, consultez <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une erreur se produit si vous essayez d’utiliser `RmDir` sur un répertoire qui contient les fichiers. Utilisez le `Kill` (fonction) pour supprimer tous les fichiers avant d’essayer de supprimer un répertoire.  
  
   
  
## Examples  
 Cet exemple utilise le `RmDir` (fonction) pour supprimer un répertoire existant.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> n'est pas spécifié ou il est vide.</exception>
        <exception cref="T:System.IO.IOException">Le répertoire cible contient des fichiers.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le répertoire n'existe pas.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un <see langword="Long" /> qui spécifie la position de lecture/écriture actuelle dans un fichier ouvert à l'aide de la fonction <see langword="FileOpen" /> ou définit la position de la prochaine opération de lecture/écriture dans un fichier ouvert via la fonction <see langword="FileOpen" />. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="Seek" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. <see langword="Integer" /> qui contient un numéro de fichier valide.</param>
        <summary>Retourne un <see langword="Long" /> qui spécifie la position de lecture/écriture actuelle dans un fichier ouvert à l'aide de la fonction <see langword="FileOpen" /> ou définit la position de la prochaine opération de lecture/écriture dans un fichier ouvert via la fonction <see langword="FileOpen" />. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="Seek" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Un <see langword="Long" /> qui spécifie la position de lecture/écriture actuelle dans un fichier ouvert à l’aide de la fonction <see langword="FileOpen" /> ou définit la position de la prochaine opération de lecture/écriture dans un fichier ouvert via la fonction <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Retourne une valeur comprise entre 1 et 2 147 483 647 (équivalent à 2 ^ 31 - 1), inclus.  
  
 Ce qui suit décrit les valeurs de retour pour chaque mode d’accès au fichier :  
  
|Mode|Valeur de retour|  
|-|-|  
|`Random`|Numéro de l’enregistrement suivant lues ou écrites|  
|`Binary`, `Input`, `Output`, `Append`|Position d’octet à partir duquel l’opération suivante se produit. Le premier octet dans un fichier est à la position 1, le deuxième octet est à la position 2 et ainsi de suite.|  
  
   
  
## Examples  
 Cet exemple utilise le `Seek` fonction pour retourner la position actuelle du fichier. L’exemple part du principe `TestFile` est un fichier qui contient les enregistrements de la structure `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Pour les fichiers ouverts dans `Random` mode, `Seek` renvoie le numéro de l’enregistrement suivant.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Pour les fichiers ouverts dans les modes autres que `Random` mode, `Seek` retourne la position d’octet à partir duquel l’opération suivante se produit. Supposons que `TestFile` est un fichier qui contient plusieurs lignes de texte.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Cet exemple utilise le `Seek` fonction pour définir la position de la prochaine opération de lecture ou d’écrire dans un fichier.  
  
 Pour les fichiers ouverts dans les modes autres que `Random` mode, `Seek` définit la position d’octet à partir duquel l’opération suivante se produit. Supposons que `TestFile` est un fichier qui contient plusieurs lignes de texte.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. <see langword="Integer" /> qui contient un numéro de fichier valide.</param>
        <param name="Position">Obligatoire. Nombre compris dans la plage 1-2 147 483 647 inclus, qui indique où l’opération de lecture/écriture suivante doit avoir lieu.</param>
        <summary>Retourne un <see langword="Long" /> qui spécifie la position de lecture/écriture actuelle dans un fichier ouvert à l'aide de la fonction <see langword="FileOpen" /> ou définit la position de la prochaine opération de lecture/écriture dans un fichier ouvert via la fonction <see langword="FileOpen" />. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="Seek" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Retourne une valeur comprise entre 1 et 2 147 483 647 (équivalent à 2 ^ 31 - 1), inclus.  
  
 Ce qui suit décrit les valeurs de retour pour chaque mode d’accès au fichier :  
  
|Mode|Valeur de retour|  
|-|-|  
|`Random`|Numéro de l’enregistrement suivant lues ou écrites|  
|`Binary`, `Input`, `Output`, `Append`|Position d’octet à partir duquel l’opération suivante se produit. Le premier octet dans un fichier est à la position 1, le deuxième octet est à la position 2 et ainsi de suite.|  
  
   
  
## Examples  
 Cet exemple utilise le `Seek` fonction pour retourner la position actuelle du fichier. L’exemple part du principe `TestFile` est un fichier qui contient les enregistrements de la structure `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Pour les fichiers ouverts dans `Random` mode, `Seek` renvoie le numéro de l’enregistrement suivant.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Pour les fichiers ouverts dans les modes autres que `Random` mode, `Seek` retourne la position d’octet à partir duquel l’opération suivante se produit. Supposons que `TestFile` est un fichier qui contient plusieurs lignes de texte.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Cet exemple utilise le `Seek` fonction pour définir la position de la prochaine opération de lecture ou d’écrire dans un fichier.  
  
 Pour les fichiers ouverts dans les modes autres que `Random` mode, `Seek` définit la position d’octet à partir duquel l’opération suivante se produit. Supposons que `TestFile` est un fichier qui contient plusieurs lignes de texte.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lecture à partir de fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Écriture dans des fichiers en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Obligatoire. Une expression de chaîne qui spécifie un nom de fichier. <paramref name="PathName" /> peut inclure le répertoire ou le dossier, ainsi que le lecteur.</param>
        <param name="Attributes">Obligatoire. Constante ou expression numérique dont la somme spécifie des attributs de fichier.</param>
        <summary>Définit les informations d'attribut d'un fichier. La fonctionnalité <see langword="My" /> améliore la productivité et les performances des opérations d’E/S de fichier par rapport à <see langword="SetAttr" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une erreur d’exécution se produit si vous essayez de définir les attributs d’un fichier ouvert.  
  
 Le `Attributes` des valeurs d’énumération arguments sont les suivantes :  
  
|Value|Constante|Description |  
|-|-|-|  
|`Normal`|`vbNormal`|Normal (valeur par défaut).|  
|`ReadOnly`|`vbReadOnly`|Lecture seule.|  
|`Hidden`|`vbHidden`|Masqué.|  
|`System`|`vbSystem`|Fichier système.|  
|`Volume`|`vbVolume`|Nom de volume|  
|`Directory`|`vbDirectory`|Répertoire ou dossier.|  
|`Archive`|`vbArchive`|Le fichier a été modifié depuis sa dernière sauvegarde.|  
|`Alias`|`vbAlias`|Le fichier porte un nom différent.|  
  
> [!NOTE]
>  Ces énumérations sont spécifiées par le langage Visual Basic. Les noms peuvent être utilisés n’importe où dans votre code au lieu des valeurs réelles.  
  
   
  
## Examples  
 Cet exemple utilise le `SetAttr` fonction permettant de définir les attributs d’un fichier.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le type <paramref name="Attribute" />' n'est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Obligatoire. Nombre d'espaces à insérer avant d'afficher ou d'écrire l'expression suivante dans une liste.</param>
        <summary>Utilisé avec la fonction <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</summary>
        <returns>Utilisé avec la fonction <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `Count` est inférieure à la largeur de ligne de sortie, la position suivante d’impression immédiatement suit le nombre d’espaces imprimés. Si`Count` est supérieure à la largeur de ligne de sortie, `SPC` calcule la prochaine position d’impression à l’aide de la formule :  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Par exemple, si la position d’impression actuelle est 24, la largeur de ligne de sortie est 80, et que vous spécifiez `SPC(90)`, l’impression suivante commence à la position 34 (position courante + le reste de 90/80). Si la différence entre la position d’impression actuelle et la largeur de ligne de sortie est inférieure à `Count` (ou `Count` `Mod` *largeur*), le `SPC` fonction passe au début de la ligne suivante et génère espaces égal à `Count` -(*largeur* - *currentprintposition*).  
  
> [!NOTE]
>  Assurez-vous que les colonnes sont suffisamment larges pour lettres larges.  
  
   
  
## Examples  
 Cet exemple utilise le `SPC` (fonction) pour positionner la sortie dans un fichier et dans le **sortie** fenêtre.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod, opérateur (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>S'utilise avec les fonctions <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>S'utilise avec les fonctions <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</summary>
        <returns>S'utilise avec les fonctions <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la position d’impression en cours sur la ligne actuelle est supérieure à `Column`, `TAB` passe à la valeur de colonne égale à `Column` sur la ligne de sortie suivante. Si `Column` est inférieur à 1, `TAB` déplace la position d’impression à la colonne 1. Si `Column` est supérieure à la largeur de ligne de sortie `TAB` calcule la prochaine position d’impression à l’aide de la formule :  
  
 Largeur de colonne Mod  
  
 Par exemple, si *largeur* est 80 et que vous spécifiez `TAB(90)`, l’impression suivante commence à la colonne 10 (le reste de 90/80). Si `Column` est inférieure à la position actuelle, l’impression commence à la ligne suivante à la position d’impression calculée. Si la position calculée est supérieure à la position actuelle, l’impression commence à l’impression calculée position sur la même ligne.  
  
 La position d’impression à l’extrême gauche sur une ligne de sortie est toujours 1. Lorsque vous utilisez le `Print` ou `PrintLine` fonctions pour imprimer les fichiers, le plus à droite est la largeur actuelle du fichier de sortie, que vous pouvez définir à l’aide de la `FileWidth` (fonction).  
  
 Le `TAB` fonction peut également être utilisée avec le `WriteLine` (fonction). Il ne peut pas être utilisé avec <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Assurez-vous que les colonnes sont assez large pour contenir des lettres larges.  
  
   
  
## Examples  
 Cet exemple utilise le `TAB` (fonction) pour positionner la sortie dans un fichier et dans le **sortie** fenêtre.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod, opérateur (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Optionnel. Le numéro de colonne atteint avant d'afficher ou d'imprimer l'expression suivante dans une liste. En cas d'omission, <see langword="TAB" /> déplace le point d'insertion au début de la zone d'impression suivante.</param>
        <summary>S'utilise avec les fonctions <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</summary>
        <returns>S'utilise avec les fonctions <see langword="Print" /> ou <see langword="PrintLine" /> pour positionner la sortie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la position d’impression actuelle sur la ligne actuelle est supérieure à `Column`, `TAB` passe à la valeur de colonne égale à `Column` sur la ligne de sortie suivante. Si `Column` est inférieur à 1, `TAB` déplace la position d’impression à la colonne 1. Si `Column` est supérieure à la largeur de ligne de sortie, `TAB` calcule la prochaine position d’impression à l’aide de la formule :  
  
 Largeur de colonne Mod  
  
 Par exemple, si *largeur* est 80 et que vous spécifiez `TAB(90)`, l’impression suivante commence à la colonne 10 (le reste de 90/80). Si `Column` est inférieure à la position actuelle, l’impression commence à la ligne suivante à la position d’impression calculée. Si la position calculée est supérieure à la position actuelle, l’impression commence à l’impression calculée position sur la même ligne.  
  
 La position d’impression à l’extrême gauche sur une ligne de sortie est toujours 1. Lorsque vous utilisez le `Print` ou `PrintLine` fonctions pour imprimer les fichiers, le plus à droite est la largeur actuelle du fichier de sortie, que vous pouvez définir à l’aide de la `FileWidth` (fonction).  
  
 Le `TAB` fonction peut également être utilisée avec le `WriteLine` (fonction). Il ne peut pas être utilisé avec <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Assurez-vous que les colonnes sont assez large pour contenir des lettres larges.  
  
   
  
## Examples  
 Cet exemple utilise le `TAB` (fonction) pour positionner la sortie dans un fichier et dans le **sortie** fenêtre.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod, opérateur (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />. La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <summary>Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />. La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.  
  
 `Lock` et `Unlock` fonctions sont toujours utilisées par paires. Les arguments de `Lock` et `Unlock` doivent être identiques.  
  
 Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier. Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.  
  
 Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions. Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="Record">Optionnel. Numéro du seul enregistrement ou octet à verrouiller ou déverrouiller</param>
        <summary>Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />. La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.  
  
 `Lock` et `Unlock` fonctions sont toujours utilisées par paires. Les arguments de `Lock` et `Unlock` doivent être identiques.  
  
 Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier. Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.  
  
 Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions. Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. N’importe quel numéro de fichier valide.</param>
        <param name="FromRecord">Optionnel. Numéro du premier enregistrement ou octet à verrouiller ou déverrouiller</param>
        <param name="ToRecord">Optionnel. Numéro du dernier enregistrement ou octet à verrouiller ou déverrouiller</param>
        <summary>Contrôle l'accès par d'autres processus à tout ou partie d'un fichier ouvert à l'aide de la fonction <see langword="Open" />. La fonctionnalité <see langword="My" /> permet une meilleure productivité et de meilleures performances dans les opérations d'E/S de fichier que <see langword="Lock" /> et <see langword="Unlock" />. Pour plus d'informations, consultez <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Lock` et `Unlock` fonctions sont utilisées dans les environnements où plusieurs processus peuvent avoir besoin d’accès dans le même fichier.  
  
 `Lock` et `Unlock` fonctions sont toujours utilisées par paires. Les arguments de `Lock` et `Unlock` doivent être identiques.  
  
 Si `Record`, ou `FromRecord` et `ToRecord` sont ne pas fournis, le verrou sera pour la totalité du fichier. Si `Record` seul est spécifié, l’enregistrement unique sera verrouillé/déverrouillé.  
  
 Si le fichier a été ouvert pour l’entrée séquentielle ou de sortie, `Lock` et `Unlock` affectent la totalité du fichier, quelle que soit la plage spécifiée par `FromRecord` et`ToRecord`.  
  
   
  
## Examples  
 Cet exemple illustre l’utilisation de la `Lock` et `Unlock` fonctions. Cet exemple suppose que `People.txt` est un fichier qui contient les enregistrements de la structure `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. Une expression <see langword="Integer" /> qui contient un numéro de fichier valide.</param>
        <param name="Output">Optionnel. Une ou plusieurs expressions délimitées par des virgules à écrire dans un fichier.</param>
        <summary>Écrit des données dans un fichier séquentiel. Les données écrites avec <see langword="Write" /> sont généralement lues à partir d’un fichier à l’aide de <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Write` et `WriteLine` fonctions sont fournies pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Si vous omettez `Output`, une ligne vide est imprimée dans le fichier. Plusieurs expressions peuvent être séparées par une virgule.  
  
 Contrairement à la `Print` (fonction), le `Write` fonction insère des virgules entre les éléments et les chaînes entre guillemets car ils sont écrits dans le fichier. Il est inutile de placer de délimiteurs explicites dans la liste. Lorsque `Write` est utilisé pour écrire des données dans un fichier, numérique uniquement, `Boolean`, date, la valeur null, et `Error` formats de données sont pris en charge. Les hypothèses universelles suivantes sont suivies afin que les données peuvent toujours être lues et correctement interprétées à l’aide de `Input`, indépendamment des paramètres régionaux :  
  
-   Données numériques sont toujours écrit avec un point comme séparateur décimal.  
  
-   Pour `Boolean` données, soit `#TRUE#` ou `#FALSE#` est imprimé. Le `True` et `False` mots clés ne sont pas traduits, indépendamment des paramètres régionaux.  
  
-   Données de date sont écrites dans le fichier en utilisant le format de date universel. Lorsque la date ou le composant heure manque ou est nul, seule la partie fournie est écrite dans le fichier.  
  
-   Si rien n’est écrit dans le fichier `Output` données sont vides. Toutefois, pour les données de type null, `#NULL#` est écrit.  
  
-   Pour `Error` données, la sortie s’affiche en tant que `#ERROR errorcode#`. Le `Error` mot clé n’est pas traduit, indépendamment des paramètres régionaux.  
  
 `WriteLine` Insère un caractère de saut de ligne (autrement dit, un retour chariot/ligne de flux, ou `Chr(13) + Chr(10)`), une fois qu’il a écrit le dernier caractère `Output` au fichier.  
  
 Vous pouvez incorporer des guillemets dans une chaîne à l’aide de guillemets doubles, ou « ». Par exemple :  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Retourne une chaîne avec la valeur de `Double quotation marks aren't "difficult" to handle`.  
  
 Écriture dans un fichier à l’aide de la `Write` ou `WriteLine` functions exige `Append` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Write` fonction pour écrire des données brutes dans un fichier séquentiel.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le mode de fichier n’est pas valide.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatoire. Une expression <see langword="Integer" /> qui contient un numéro de fichier valide.</param>
        <param name="Output">Optionnel. Une ou plusieurs expressions délimitées par des virgules à écrire dans un fichier.</param>
        <summary>Écrit des données dans un fichier séquentiel. Les données écrites avec <see langword="Write" /> sont généralement lues à partir d’un fichier à l’aide de <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Write` et `WriteLine` fonctions sont fournies pour la compatibilité descendante et peut affecter les performances. Pour les applications non héritées, le `My.Computer.FileSystem` objet offre de meilleures performances. Pour plus d’informations, consultez [accès au fichier avec Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Si vous omettez `Output`, une ligne vide est imprimée dans le fichier. Plusieurs expressions peuvent être séparées par une virgule.  
  
 Contrairement à la `Print` (fonction), le `Write` fonction insère des virgules entre les éléments et les chaînes entre guillemets car ils sont écrits dans le fichier. Il est inutile de placer de délimiteurs explicites dans la liste. Lorsque `Write` est utilisé pour écrire des données dans un fichier, numérique uniquement, `Boolean`, date, la valeur null, et `Error` formats de données sont pris en charge. Les hypothèses universelles suivantes sont suivies afin que les données peuvent toujours être lues et correctement interprétées à l’aide de `Input`, indépendamment des paramètres régionaux :  
  
-   Données numériques sont toujours écrit avec un point comme séparateur décimal.  
  
-   Pour `Boolean` données, soit `#TRUE#` ou `#FALSE#` est imprimé. Le `True` et `False` mots clés ne sont pas traduits, indépendamment des paramètres régionaux.  
  
-   Données de date sont écrites dans le fichier en utilisant le format de date universel. Lorsque la date ou le composant heure manque ou est nul, seule la partie fournie est écrite dans le fichier.  
  
-   Si rien n’est écrit dans le fichier `Output` données sont vides. Toutefois, pour les données de type null, `#NULL#` est écrit.  
  
-   Pour `Error` données, la sortie s’affiche en tant que `#ERROR errorcode#`. Le `Error` mot clé n’est pas traduit, indépendamment des paramètres régionaux.  
  
 `WriteLine` Insère un caractère de saut de ligne (autrement dit, un retour chariot/ligne de flux, ou `Chr(13) + Chr(10)`), une fois qu’il a écrit le dernier caractère `Output` au fichier.  
  
 Vous pouvez incorporer des guillemets dans une chaîne à l’aide de guillemets doubles, ou « ». Par exemple :  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Retourne une chaîne avec la valeur de `Double quotation marks aren't "difficult" to handle`.  
  
 Écriture dans un fichier à l’aide de la `Write` ou `WriteLine` functions exige `Append` accéder à partir de la `FileIOPermissionAccess` énumération. Pour plus d'informations, consultez <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Cet exemple utilise le `Write` fonction pour écrire des données brutes dans un fichier séquentiel.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Accès au fichier avec Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Guide pratique pour écrire du texte dans des fichiers en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procédure : Écrire du texte dans un fichier avec un Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
  </Members>
</Type>