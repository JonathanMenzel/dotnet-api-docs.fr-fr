<Type Name="AsyncResult" FullName="System.Runtime.Remoting.Messaging.AsyncResult">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dc0d37c6403e708442c5d9a420583a08ac46d972" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48711416" /></Metadata><TypeSignature Language="C#" Value="public class AsyncResult : IAsyncResult, System.Runtime.Remoting.Messaging.IMessageSink" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit AsyncResult extends System.Object implements class System.IAsyncResult, class System.Runtime.Remoting.Messaging.IMessageSink" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.Messaging.AsyncResult" />
  <TypeSignature Language="VB.NET" Value="Public Class AsyncResult&#xA;Implements IAsyncResult, IMessageSink" />
  <TypeSignature Language="C++ CLI" Value="public ref class AsyncResult : IAsyncResult, System::Runtime::Remoting::Messaging::IMessageSink" />
  <TypeSignature Language="F#" Value="type AsyncResult = class&#xA;    interface IAsyncResult&#xA;    interface IMessageSink" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Remoting.Messaging.IMessageSink</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsule les résultats d'une opération asynchrone sur un délégué.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Remoting.Messaging.AsyncResult> classe est utilisée conjointement avec les appels de méthode asynchrone effectuées à l’aide de délégués. Le <xref:System.IAsyncResult> retourné à partir du délégué `BeginInvoke` méthode pouvant être castée en un <xref:System.Runtime.Remoting.Messaging.AsyncResult>. Le <xref:System.Runtime.Remoting.Messaging.AsyncResult> a le <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A> propriété qui contient le délégué de l’objet sur lequel l’appel asynchrone a été appelé.  
  
 Pour plus d’informations sur `BeginInvoke` et les appels asynchrones à l’aide de délégués, consultez [délégués asynchrones à l’aide de programmation](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-using-delegates.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> propriété à obtenir un <xref:System.Threading.WaitHandle>et l’attente d’un appel asynchrone sur un délégué. Le <xref:System.Threading.WaitHandle> est signalé quand l’appel asynchrone se termine et vous pouvez l’attendre en appelant la méthode <xref:System.Threading.WaitHandle.WaitOne%2A> .  
  
 L’exemple se compose de deux classes, la classe qui contient la méthode appelée de façon asynchrone, et la classe qui contient le `Main` méthode qui effectue l’appel.  
  
 Pour plus d’informations et d’autres exemples d’appel des méthodes de façon asynchrone à l’aide de délégués, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#3](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/waithandle.cpp#3)]
[!code-csharp[AsyncDelegateExamples#3](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/waithandle.cs#3)]
[!code-vb[AsyncDelegateExamples#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/WaitHandle.vb#3)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-using-delegates.md">Programmation asynchrone à l'aide de délégués</related>
  </Docs>
  <Members>
    <Member MemberName="AsyncDelegate">
      <MemberSignature Language="C#" Value="public virtual object AsyncDelegate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AsyncDelegate As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ AsyncDelegate { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncDelegate : obj" Usage="System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet de délégué sur lequel l'appel asynchrone a été effectué.</summary>
        <value>Objet de délégué sur lequel l'appel asynchrone a été effectué.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A> propriété peut être castée en la classe réelle du délégué défini par l’utilisateur.  
  
 Par exemple, si le délégué a été utilisé pour effectuer l’appel asynchrone est de type `MyDelegate`, le délégué retourné par cette propriété doit être casté en `MyDelegate`. La méthode de rappel pouvez ensuite appeler le délégué `EndInvoke` méthode avec la signature appropriée, afin d’obtenir les résultats de l’appel de méthode asynchrone.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A> propriété pour obtenir le délégué utilisé pour passer l’appel asynchrone, afin d’appeler `EndInvoke`. L’exemple caste le <xref:System.IAsyncResult>, qui est le seul paramètre de la méthode de rappel à une <xref:System.Runtime.Remoting.Messaging.AsyncResult> objet.  
  
 L’exemple se compose de deux classes, la classe qui contient la méthode appelée de façon asynchrone, et la classe qui contient le `Main` méthode qui effectue l’appel.  
  
 Pour plus d’informations sur la façon dont cet exemple de rappel fonctionne et plus d’exemples d’appel de méthodes asynchrone à l’aide de délégués, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#5](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/callback.cpp#5)]
[!code-csharp[AsyncDelegateExamples#5](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/callback.cs#5)]
[!code-vb[AsyncDelegateExamples#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/callback.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncProcessMessage">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(class System.Runtime.Remoting.Messaging.IMessage msg, class System.Runtime.Remoting.Messaging.IMessageSink replySink) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AsyncProcessMessage (msg As IMessage, replySink As IMessageSink) As IMessageCtrl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessageCtrl ^ AsyncProcessMessage(System::Runtime::Remoting::Messaging::IMessage ^ msg, System::Runtime::Remoting::Messaging::IMessageSink ^ replySink);" />
      <MemberSignature Language="F#" Value="abstract member AsyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage * System.Runtime.Remoting.Messaging.IMessageSink -&gt; System.Runtime.Remoting.Messaging.IMessageCtrl&#xA;override this.AsyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage * System.Runtime.Remoting.Messaging.IMessageSink -&gt; System.Runtime.Remoting.Messaging.IMessageCtrl" Usage="asyncResult.AsyncProcessMessage (msg, replySink)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Messaging.IMessageSink.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageCtrl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMessage" />
        <Parameter Name="replySink" Type="System.Runtime.Remoting.Messaging.IMessageSink" />
      </Parameters>
      <Docs>
        <param name="msg">Interface <see cref="T:System.Runtime.Remoting.Messaging.IMessage" /> de demande.</param>
        <param name="replySink">Interface <see cref="T:System.Runtime.Remoting.Messaging.IMessageSink" /> de réponse.</param>
        <summary>Implémente l'interface <see cref="T:System.Runtime.Remoting.Messaging.IMessageSink" />.</summary>
        <returns>Aucune valeur n'est retournée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage%2A> méthode de la <xref:System.Runtime.Remoting.Messaging.IMessageSink> interface n’est pas pertinente pour la <xref:System.Runtime.Remoting.Messaging.AsyncResult> classe. Implémentation par <xref:System.Runtime.Remoting.Messaging.AsyncResult> lève un <xref:System.NotSupportedException>. Au lieu de cela, obtenir un <xref:System.Runtime.Remoting.Messaging.AsyncResult> en castant le <xref:System.IAsyncResult> interface retournée par un appel asynchrone effectué à l’aide d’un délégué.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public virtual object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Runtime.Remoting.Messaging.AsyncResult.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet fourni comme dernier paramètre d'un appel de méthode <see langword="BeginInvoke" />.</summary>
        <value>Objet fourni comme dernier paramètre d'un appel de méthode <see langword="BeginInvoke" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la `BeginInvoke` (méthode), consultez [délégués asynchrones à l’aide de programmation](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-using-delegates.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment la <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncState%2A> propriété est utilisée pour transmettre des informations à une méthode de rappel. Le dernier paramètre de la `BeginInvoke` appel de méthode est une chaîne de format, la méthode de rappel utilise pour mettre en forme un message de sortie.  
  
 L’exemple se compose de deux classes, la classe qui contient la méthode appelée de façon asynchrone, et la classe qui contient le `Main` méthode qui effectue l’appel.  
  
 Pour plus d’informations sur la façon dont cet exemple de rappel fonctionne et plus d’exemples d’appel de méthodes asynchrone à l’aide de délégués, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#5](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/callback.cpp#5)]
[!code-csharp[AsyncDelegateExamples#5](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/callback.cs#5)]
[!code-vb[AsyncDelegateExamples#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/callback.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncWaitHandle">
      <MemberSignature Language="C#" Value="public virtual System.Threading.WaitHandle AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AsyncWaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Threading::WaitHandle ^ AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncWaitHandle : System.Threading.WaitHandle" Usage="System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Threading.WaitHandle" /> qui encapsule des handles de synchronisation Win32 et permet l'implémentation de divers schémas de synchronisation.</summary>
        <value><see cref="T:System.Threading.WaitHandle" /> qui encapsule des handles de synchronisation Win32 et permet l'implémentation de divers schémas de synchronisation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.WaitHandle> retourné par cette méthode est automatiquement signalée lorsque l’opération asynchrone est terminée.  
  
 Le handle d’attente n’est pas fermé automatiquement lorsque vous appelez `EndInvoke` sur le délégué a été utilisé pour appeler la méthode asynchrone. Si vous libérez toutes les références au handle d’attente, les ressources système sont libérées quand le garbage collection récupère le handle d’attente. Pour libérer les ressources système dès que vous avez terminé d’utiliser le handle d’attente, appelez le <xref:System.Threading.WaitHandle.Close%2A?displayProperty=nameWithType> (méthode). Le garbage collection fonctionne plus efficacement lorsque les objets jetables sont explicitement fermées ou supprimées.  
  
> [!CAUTION]
>  Le <xref:System.Threading.WaitHandle> contenus dans le <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> propriété peut être utilisée pour bloquer le thread actuel jusqu'à ce que l’appel asynchrone est terminée. Toutefois, le <xref:System.Threading.WaitHandle> ignorera la <xref:System.AsyncCallback>, si elle a été spécifiée pendant la `BeginInvoke` appeler. Par conséquent, une situation peut se produire dans lequel l’application s’arrête avant la <xref:System.AsyncCallback> a terminé l’exécution, même si un <xref:System.Threading.WaitHandle> sert à blocage jusqu'à la fin de l’appel asynchrone. Pour obtenir un exemple d’une telle situation, consultez l’exemple de la <xref:System.Runtime.Remoting.Messaging.AsyncResult> classe et de supprimer le <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> instruction.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> propriété à obtenir un <xref:System.Threading.WaitHandle>et l’attente d’un appel asynchrone sur un délégué. Le <xref:System.Threading.WaitHandle> est signalé quand l’appel asynchrone se termine et vous pouvez l’attendre en appelant la méthode <xref:System.Threading.WaitHandle.WaitOne%2A> .  
  
 L’exemple se compose de deux classes, la classe qui contient la méthode appelée de façon asynchrone, et la classe qui contient le `Main` méthode qui effectue l’appel.  
  
 Pour plus d’informations et d’autres exemples d’appel des méthodes de façon asynchrone à l’aide de délégués, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#3](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/waithandle.cpp#3)]
[!code-csharp[AsyncDelegateExamples#3](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/waithandle.cs#3)]
[!code-vb[AsyncDelegateExamples#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/WaitHandle.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.WaitHandle" />
      </Docs>
    </Member>
    <Member MemberName="CompletedSynchronously">
      <MemberSignature Language="C#" Value="public virtual bool CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CompletedSynchronously As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedSynchronously : bool" Usage="System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'appel <see langword="BeginInvoke" /> s'est terminé de façon synchrone.</summary>
        <value><see langword="true" /> si l'appel <see langword="BeginInvoke" /> s'est terminé de façon synchrone ; sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il est détecté que le `BeginInvoke` appel s’est terminé de façon synchrone dans le <xref:System.AsyncCallback> délégué, il est probable que le thread qui a appelé BeginInvoke est le thread actuel. La plupart des fournisseurs de la <xref:System.IAsyncResult> interface n’utilisera pas la fonctionnalité et renverra une valeur par défaut `false`.  
  
 L’implémentation actuelle de <xref:System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously%2A> retourne toujours `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvokeCalled">
      <MemberSignature Language="C#" Value="public bool EndInvokeCalled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndInvokeCalled" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled" />
      <MemberSignature Language="VB.NET" Value="Public Property EndInvokeCalled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndInvokeCalled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EndInvokeCalled : bool with get, set" Usage="System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si <see langword="EndInvoke" /> a été appelé sur <see cref="T:System.Runtime.Remoting.Messaging.AsyncResult" /> en cours.</summary>
        <value><see langword="true" /> si <see langword="EndInvoke" /> a été appelé sur <see cref="T:System.Runtime.Remoting.Messaging.AsyncResult" /> en cours ; sinon <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReplyMessage">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.Messaging.IMessage GetReplyMessage ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessage GetReplyMessage() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReplyMessage () As IMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessage ^ GetReplyMessage();" />
      <MemberSignature Language="F#" Value="abstract member GetReplyMessage : unit -&gt; System.Runtime.Remoting.Messaging.IMessage&#xA;override this.GetReplyMessage : unit -&gt; System.Runtime.Remoting.Messaging.IMessage" Usage="asyncResult.GetReplyMessage " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le message de réponse pour l'appel asynchrone.</summary>
        <returns>Message de communication à distance qui doit représenter une réponse à un appel de méthode sur un objet distant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A> méthode peut retourner un objet après la <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> méthode est appelée. Le <xref:System.Runtime.Remoting.Messaging.IMessage> valeur de retour peut être castée en un <xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage>.  
  
 Toutefois, vous n’avez pas besoin d’appeler une de ces méthodes directement. Ils sont destinés à une utilisation par l’infrastructure de communication à distance du .NET Framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public virtual bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le serveur a terminé l'appel.</summary>
        <value><see langword="true" /> après que le serveur a terminé l'appel ; sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le serveur ne doit pas utiliser toutes les ressources fournies par un client en dehors de convenues sémantiques de partage une fois qu’il a le <xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A> propriété `true`. Par conséquent, il est possible sans le client peut détruire les ressources après la <xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A> retourne de la propriété `true`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.IAsyncResult.IsCompleted%2A> propriété de la <xref:System.Runtime.Remoting.Messaging.AsyncResult> retourné par `BeginInvoke` pour savoir quand un appel asynchrone se termine. Cela est possible quand vous effectuez l’appel asynchrone à partir d’un thread qui gère l’interface utilisateur. L’interrogation pour connaître l’état d’avancement permet au thread appelant de continuer à s’exécuter pendant que l’appel asynchrone s’exécute sur un thread <xref:System.Threading.ThreadPool> .  
  
 L’exemple se compose de deux classes, la classe qui contient la méthode appelée de façon asynchrone, et la classe qui contient le `Main` méthode qui effectue l’appel.  
  
 Pour plus d’informations et d’autres exemples d’appel des méthodes de façon asynchrone à l’aide de délégués, consultez [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 [!code-cpp[AsyncDelegateExamples#1](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/TestMethod.cpp#1)]
 [!code-csharp[AsyncDelegateExamples#1](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/TestMethod.cs#1)]
 [!code-vb[AsyncDelegateExamples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/TestMethod.vb#1)]  
[!code-cpp[AsyncDelegateExamples#4](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncDelegateExamples/cpp/polling.cpp#4)]
[!code-csharp[AsyncDelegateExamples#4](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncDelegateExamples/CS/polling.cs#4)]
[!code-vb[AsyncDelegateExamples#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncDelegateExamples/VB/polling.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextSink">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.Messaging.IMessageSink NextSink { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Remoting.Messaging.IMessageSink NextSink" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Messaging.AsyncResult.NextSink" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSink As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Remoting::Messaging::IMessageSink ^ NextSink { System::Runtime::Remoting::Messaging::IMessageSink ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSink : System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.Messaging.AsyncResult.NextSink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.Remoting.Messaging.IMessageSink.NextSink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le récepteur de messages suivant dans la chaîne de récepteurs.</summary>
        <value>Interface <see cref="T:System.Runtime.Remoting.Messaging.IMessageSink" /> qui représente le récepteur de messages suivant dans la chaîne de récepteurs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation actuelle de <xref:System.Runtime.Remoting.Messaging.AsyncResult.NextSink%2A> retourne `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMessageCtrl">
      <MemberSignature Language="C#" Value="public virtual void SetMessageCtrl (System.Runtime.Remoting.Messaging.IMessageCtrl mc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetMessageCtrl(class System.Runtime.Remoting.Messaging.IMessageCtrl mc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl(System.Runtime.Remoting.Messaging.IMessageCtrl)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetMessageCtrl (mc As IMessageCtrl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetMessageCtrl(System::Runtime::Remoting::Messaging::IMessageCtrl ^ mc);" />
      <MemberSignature Language="F#" Value="abstract member SetMessageCtrl : System.Runtime.Remoting.Messaging.IMessageCtrl -&gt; unit&#xA;override this.SetMessageCtrl : System.Runtime.Remoting.Messaging.IMessageCtrl -&gt; unit" Usage="asyncResult.SetMessageCtrl mc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mc" Type="System.Runtime.Remoting.Messaging.IMessageCtrl" />
      </Parameters>
      <Docs>
        <param name="mc"><see cref="T:System.Runtime.Remoting.Messaging.IMessageCtrl" /> pour l'appel de méthode distant en cours.</param>
        <summary>Définit <see cref="T:System.Runtime.Remoting.Messaging.IMessageCtrl" /> pour l'appel de méthode distant en cours qui offre un moyen de contrôler les messages asynchrones après leur distribution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous n’avez pas besoin d’appeler le <xref:System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncProcessMessage">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(class System.Runtime.Remoting.Messaging.IMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SyncProcessMessage (msg As IMessage) As IMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::Messaging::IMessage ^ SyncProcessMessage(System::Runtime::Remoting::Messaging::IMessage ^ msg);" />
      <MemberSignature Language="F#" Value="abstract member SyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage -&gt; System.Runtime.Remoting.Messaging.IMessage&#xA;override this.SyncProcessMessage : System.Runtime.Remoting.Messaging.IMessage -&gt; System.Runtime.Remoting.Messaging.IMessage" Usage="asyncResult.SyncProcessMessage msg" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMessage" />
      </Parameters>
      <Docs>
        <param name="msg">Message de réponse à un appel de méthode sur un objet distant.</param>
        <summary>Traite de manière synchrone un message de réponse retourné par un appel de méthode sur un objet distant.</summary>
        <returns>Retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> méthode implémente la <xref:System.Runtime.Remoting.Messaging.IMessageSink> interface. Vous n’avez pas besoin d’appeler cette méthode directement. Il est prévu pour une utilisation par l’infrastructure de communication à distance du .NET Framework.  
  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> appelle le code de consommateur <xref:System.AsyncCallback> déléguer. Il définit également la <xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage> instance retournée par la <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A> (méthode). Si le `msg` paramètre est de type <xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage>, le même objet est retourné par <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A>. Sinon, un message de réponse qui contient une exception de communication à distance est retourné.  
  
 <xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> modifie également la valeur retournée par la <xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>