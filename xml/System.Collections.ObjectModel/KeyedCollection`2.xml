<Type Name="KeyedCollection&lt;TKey,TItem&gt;" FullName="System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3534cea367a9d48a548c1c49b2b7d0292ba22003" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39840640" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.KeyedCollection`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class KeyedCollection(Of TKey, TItem)&#xA;Inherits Collection(Of TItem)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TItem&gt;&#xA;public ref class KeyedCollection abstract : System::Collections::ObjectModel::Collection&lt;TItem&gt;" />
  <TypeSignature Language="F#" Value="type KeyedCollection&lt;'Key, 'Item&gt; = class&#xA;    inherit Collection&lt;'Item&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TItem" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;TItem&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">TItem</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Type de clés de la collection.</typeparam>
    <typeparam name="TItem">Type d’éléments de la collection.</typeparam>
    <summary>Fournit la classe de base abstraite pour une collection dont les clés sont incorporées dans les valeurs.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Collections.ObjectModel.KeyedCollection%602> classe fournit les deux o (1) une récupération indexée et une récupération proche d’o (1) à clé. Il est un type abstrait, ou plus précisément un ensemble infini de types abstraits, car chacun de ses types génériques construits est une classe de base abstraite. Pour utiliser <xref:System.Collections.ObjectModel.KeyedCollection%602>, dérivez votre type de collection du type construit approprié.  
  
 Le <xref:System.Collections.ObjectModel.KeyedCollection%602> classe est un hybride entre une collection basée sur le <xref:System.Collections.Generic.IList%601> interface générique et une collection basée sur le <xref:System.Collections.Generic.IDictionary%602> interface générique. Comme les collections basées sur le <xref:System.Collections.Generic.IList%601> interface générique, <xref:System.Collections.ObjectModel.KeyedCollection%602> est une liste indexée d’éléments. Comme les collections basées sur le <xref:System.Collections.Generic.IDictionary%602> interface générique, <xref:System.Collections.ObjectModel.KeyedCollection%602> a une clé associée à chaque élément.  
  
 Contrairement aux dictionnaires, un élément de <xref:System.Collections.ObjectModel.KeyedCollection%602> n’est pas une paire clé/valeur ; au lieu de cela, l’élément tout entier est la valeur et la clé est incorporée au sein de la valeur.  Par exemple, un élément d’une collection dérivée de `KeyedCollection\<String,String>` (`KeyedCollection(Of String, String)` en Visual Basic) peut être « John Doe Jr. » où la valeur est « John Doe Jr. » et la clé est « Doe » ; ou une collection d’enregistrements d’employés contenant des clés de type entier peut être dérivée de `KeyedCollection\<int,Employee>`. Le résumé <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> méthode extrait la clé de l’élément.  
  
 Par défaut, le <xref:System.Collections.ObjectModel.KeyedCollection%602> contient un dictionnaire de recherche que vous pouvez obtenir avec le <xref:System.Collections.ObjectModel.KeyedCollection%602.Dictionary%2A> propriété.  Lorsqu’un élément est ajouté à la <xref:System.Collections.ObjectModel.KeyedCollection%602>, clé de l’élément est extrait qu’une seule fois et enregistrée dans le dictionnaire de recherche pour accélérer les recherches. Ce comportement est substitué en spécifiant un seuil de création de dictionnaire lorsque vous créez le <xref:System.Collections.ObjectModel.KeyedCollection%602>. Le dictionnaire de recherche est créé la première fois que le nombre d’éléments dépasse ce seuil.  Si vous spécifiez -1 comme seuil, le dictionnaire de recherche n’est jamais créé.  
  
> [!NOTE]
>  Lorsque le dictionnaire de recherche interne est utilisé, il contient des références à tous les éléments dans la collection si `TItem` est un type référence, ou copie de tous les éléments dans la collection si `TItem` est un type valeur. Par conséquent, à l’aide du dictionnaire de recherche peut ne pas convenir si `TItem` est un type valeur.  
  
 Vous pouvez accéder à un élément par son index ou clé à l’aide de la <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> propriété. Vous pouvez ajouter des éléments sans une clé, mais ces éléments sont accessibles par la suite uniquement par index.  
  
   
  
## Examples  
 Cette section contient deux exemples de code. Le premier exemple montre le code minimal requis pour dériver de <xref:System.Collections.ObjectModel.KeyedCollection%602>et illustre de nombreuses méthodes héritées. Le deuxième exemple montre comment substituer les méthodes protégées de <xref:System.Collections.ObjectModel.KeyedCollection%602> pour fournir un comportement personnalisé.  
  
 **Exemple 1**  
  
 Cet exemple de code montre le code minimal nécessaire de dériver une classe de collection à partir de <xref:System.Collections.ObjectModel.KeyedCollection%602>: substitution de la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> (méthode) et en fournissant un constructeur public qui délègue à un constructeur de classe de base. L’exemple de code montre également la plupart des propriétés et méthodes héritées de <xref:System.Collections.ObjectModel.KeyedCollection%602> et <xref:System.Collections.ObjectModel.Collection%601> classes.  
  
 Le `SimpleOrder` classe est une liste très simple qui contient `OrderItem` objets, chacun d’eux représente un élément de ligne dans l’ordre. La clé de `OrderItem` est immuable, un facteur important pour les classes qui dérivent de <xref:System.Collections.ObjectModel.KeyedCollection%602>. Pour obtenir un exemple de code qui utilise des clés mutables, consultez <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 **Exemple 2**  
  
 L’exemple de code suivant montre comment substituer la méthode protégée <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, et <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthodes, pour fournir un comportement personnalisé pour le <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, et <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> méthodes et pour définition de la valeur par défaut <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propriété (l’indexeur en c#). Le comportement personnalisé fourni dans cet exemple est un événement de notification nommé `Changed`, qui est déclenché à la fin de chacune des méthodes substituées.  
  
 L’exemple de code crée la `SimpleOrder` classe qui dérive de <xref:System.Collections.ObjectModel.KeyedCollection%602> et représente un bon de commande simple. Le formulaire de commande contient `OrderItem` objets représentant les éléments triés. L’exemple de code crée également un `SimpleOrderChangedEventArgs` classe permettant de contenir les informations d’événement et une énumération pour identifier le type de modification.  
  
 L’exemple de code illustre le comportement personnalisé en appelant les propriétés et méthodes de la classe dérivée, dans le `Main` méthode de la `Demo` classe.  
  
 Cet exemple de code utilise des objets avec des clés immuables. Pour obtenir un exemple de code qui utilise des clés mutables, consultez <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Specialized.StringDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> qui utilise le comparateur d'égalité par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Collections.ObjectModel.KeyedCollection%602> créées avec ce constructeur utilise le comparateur d’égalité générique par défaut pour le type de la clé, obtenu à partir de <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Pour spécifier un comparateur d’égalité générique différents, utilisez le <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> constructeur ou la <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> constructeur.  
  
 Par défaut, le <xref:System.Collections.ObjectModel.KeyedCollection%602> contient un dictionnaire de recherche qui est créé lorsque le premier élément est ajouté. Lorsqu’un élément est ajouté à la <xref:System.Collections.ObjectModel.KeyedCollection%602>, clé de l’élément est extrait qu’une seule fois et enregistrée dans le dictionnaire de recherche pour accélérer les recherches. Ce comportement peut être remplacé en utilisant le <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> constructeur et en spécifiant un seuil de création de dictionnaire.  
  
> [!NOTE]
>  Étant donné que le <xref:System.Collections.ObjectModel.KeyedCollection%602> classe est abstraite (`MustInherit` en Visual Basic), vous devez dériver à partir de celui-ci pour pouvoir le pour utiliser. Dans le constructeur pour votre type dérivé, appelez la <xref:System.Collections.ObjectModel.KeyedCollection%602> constructeur. Il n’est pas nécessaire d’exposer des fonctionnalités telles que le comparateur d’égalité ou le seuil de création de dictionnaire dans vos constructeurs.  
  
 Ce constructeur est une opération o (1).  
  
   
  
## Examples  
 Cet exemple de code montre le code minimal nécessaire de dériver une classe de collection à partir de <xref:System.Collections.ObjectModel.KeyedCollection%602>: substitution de la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> (méthode) et en fournissant un constructeur public qui délègue à un constructeur de classe de base. L’exemple de code montre également la plupart des propriétés et méthodes héritées de <xref:System.Collections.ObjectModel.KeyedCollection%602> et <xref:System.Collections.ObjectModel.Collection%601> classes.  
  
 Le `SimpleOrder` classe est une liste très simple qui contient `OrderItem` objets, chacun d’eux représente un élément de ligne dans l’ordre. La clé de `OrderItem` est immuable, un facteur important pour les classes qui dérivent de <xref:System.Collections.ObjectModel.KeyedCollection%602>. Pour obtenir un exemple de code qui utilise des clés mutables, consultez <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implémentation de l'interface générique <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser lors de la comparaison des clés, ou <see langword="null" /> pour utiliser le comparateur d'égalité par défaut pour le type de la clé provenant de <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> qui utilise le comparateur d'égalité spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le <xref:System.Collections.ObjectModel.KeyedCollection%602> contient un dictionnaire de recherche qui est créé lorsque le premier élément est ajouté. Lorsqu’un élément est ajouté à la <xref:System.Collections.ObjectModel.KeyedCollection%602>, clé de l’élément est extrait qu’une seule fois et enregistrée dans le dictionnaire de recherche pour accélérer les recherches. Ce comportement peut être remplacé en utilisant le <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> constructeur et en spécifiant un seuil de création de dictionnaire.  
  
> [!NOTE]
>  Étant donné que le <xref:System.Collections.ObjectModel.KeyedCollection%602> classe est abstraite (`MustInherit` en Visual Basic), vous devez dériver à partir de celui-ci pour pouvoir le pour utiliser. Dans le constructeur pour votre type dérivé, appelez la <xref:System.Collections.ObjectModel.KeyedCollection%602> constructeur. Il n’est pas nécessaire d’exposer des fonctionnalités telles que le comparateur d’égalité ou le seuil de création de dictionnaire dans vos constructeurs.  
  
 Ce constructeur est une opération o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer, int32 dictionaryCreationThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey), dictionaryCreationThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; * int -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; (comparer, dictionaryCreationThreshold)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
        <Parameter Name="dictionaryCreationThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Implémentation de l'interface générique <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser lors de la comparaison des clés, ou <see langword="null" /> pour utiliser le comparateur d'égalité par défaut pour le type de la clé provenant de <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <param name="dictionaryCreationThreshold">Nombre d’éléments que la collection peut contenir sans créer de dictionnaire de recherche (0 crée le dictionnaire de recherche lorsque le premier élément est ajouté) ou -1 pour spécifier qu’aucun dictionnaire de recherche ne doit être créé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> qui utilise le comparateur d'égalité spécifié et crée un dictionnaire de recherche lorsque le seuil spécifié est dépassé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le <xref:System.Collections.ObjectModel.KeyedCollection%602> contient un dictionnaire de recherche qui est créé lorsque le premier élément est ajouté. Lorsqu’un élément est ajouté à la <xref:System.Collections.ObjectModel.KeyedCollection%602>, clé de l’élément est extrait qu’une seule fois et enregistrée dans le dictionnaire de recherche pour accélérer les recherches. Ce constructeur vous permet de substituer ce comportement. Spécifiez 0 pour créer le dictionnaire lorsque le premier élément est ajouté, 1 pour créer le dictionnaire lorsque le deuxième élément est ajouté et ainsi de suite. Si vous spécifiez -1 comme seuil, le dictionnaire de recherche n’est jamais créé.  
  
 Pour les très petites collections améliorer la vitesse de récupération fournie par le dictionnaire de recherche ne peut pas être intéressant de la mémoire supplémentaire requise par le dictionnaire. Définir un seuil vous permet de décider quand bon compromis.  
  
> [!NOTE]
>  Étant donné que le <xref:System.Collections.ObjectModel.KeyedCollection%602> classe est abstraite (`MustInherit` en Visual Basic), vous devez dériver à partir de celui-ci pour pouvoir le pour utiliser. Dans le constructeur pour votre type dérivé, appelez la <xref:System.Collections.ObjectModel.KeyedCollection%602> constructeur. Il n’est pas nécessaire d’exposer des fonctionnalités telles que le comparateur d’égalité ou le seuil de création de dictionnaire dans vos constructeurs.  
  
 Ce constructeur est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment substituer la méthode protégée <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, et <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthodes, pour fournir un comportement personnalisé pour le <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, et <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> méthodes et pour définition de la valeur par défaut <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propriété (l’indexeur en c#). Le comportement personnalisé fourni dans cet exemple est un événement de notification nommé `Changed`, qui est déclenché à la fin de chacune des méthodes substituées.  
  
 L’exemple de code utilise le <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> constructeur avec un seuil de 0, afin que le dictionnaire interne est créé la première fois un objet est ajouté à la collection.  
  
 L’exemple de code crée la `SimpleOrder` classe qui dérive de <xref:System.Collections.ObjectModel.KeyedCollection%602> et représente un bon de commande simple. Le formulaire de commande contient `OrderItem` objets représentant les éléments triés. L’exemple de code crée également un `SimpleOrderChangedEventArgs` classe permettant de contenir les informations d’événement et une énumération pour identifier le type de modification.  
  
 L’exemple de code illustre le comportement personnalisé en appelant les propriétés et méthodes de la classe dérivée, dans le `Main` méthode de la `Demo` classe.  
  
 Cet exemple de code utilise des objets avec des clés immuables. Pour obtenir un exemple de code qui utilise des clés mutables, consultez <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="dictionaryCreationThreshold" /> est inférieur à -1.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName="ChangeItemKey">
      <MemberSignature Language="C#" Value="protected void ChangeItemKey (TItem item, TKey newKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ChangeItemKey(!TItem item, !TKey newKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ChangeItemKey (item As TItem, newKey As TKey)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ChangeItemKey(TItem item, TKey newKey);" />
      <MemberSignature Language="F#" Value="member this.ChangeItemKey : 'Item * 'Key -&gt; unit" Usage="keyedCollection.ChangeItemKey (item, newKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
        <Parameter Name="newKey" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="item">Clé de l'élément à modifier.</param>
        <param name="newKey">Nouvelle clé pour <c>item</c>.</param>
        <summary>Modifie la clé associée à l'élément spécifié dans le dictionnaire de recherche.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne modifie pas la clé incorporée dans `item`; il remplace simplement la clé enregistrée dans le dictionnaire de recherche.  Par conséquent, si `newKey` est différent de la clé qui est incorporée dans `item`, vous ne pouvez pas accéder à `item` à l’aide de la clé retournée par <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Cette méthode ne fait rien si le <xref:System.Collections.ObjectModel.KeyedCollection%602> n’a pas un dictionnaire de recherche.  
  
 Chaque clé dans un <xref:System.Collections.ObjectModel.KeyedCollection%602> doit être unique. Une clé ne peut pas être `null`.  
  
 Cette méthode est une opération o (1).  
  
## <a name="notes-for-implementers"></a>Notes de publication pour les implémenteurs  
 Avant de modifier la clé incorporée dans un élément, vous devez appeler cette méthode pour mettre à jour la clé dans le dictionnaire de recherche. Si le seuil de création de dictionnaire est – 1, l’appel de cette méthode n’est pas nécessaire.  
  
 N’exposez pas le <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> méthode comme une méthode publique d’une classe dérivée. Utilisation incorrecte de cette méthode place le dictionnaire de recherche désynchronisés avec des clés de l’élément. Par exemple, si la clé à `null` et l’affectation à une autre valeur ajoute plusieurs clés d’un élément au dictionnaire de recherche. Exposer cette méthode en interne pour autoriser des clés d’élément mutables : lorsque la clé d’un élément change, cette méthode est utilisée pour modifier la clé dans le dictionnaire de recherche.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment substituer la méthode protégée <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> méthode pour prendre en charge des clés mutables et comment remplacer l’élément protégé <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, et <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthodes pour maintenir l’intégrité des clés et la collection.  
  
 L’exemple de code crée la `MutableKeys` collection qui dérive de <xref:System.Collections.ObjectModel.KeyedCollection%602>et le `MutableKey` classe. Le `MutableKey` classe a un définissable `Key` propriété. Lorsqu’une nouvelle clé est assignée à la propriété, l’accesseur Set de propriété appelle le `internal` (`Friend` en Visual Basic) `ChangeKey` méthode de la collection pour tester si la nouvelle clé serait en conflit avec une clé existante. Dans ce cas, une exception est levée et la valeur de propriété n’est pas modifiée.  
  
 Afin de maintenir la connexion entre un `MutableKey` objet et le `MutableKeys` collection et pour empêcher un objet à partir de laquelle elle est insérée deux collections, la `MutableKey` classe a un `internal` (`Friend` en Visual Basic) `Collection`champ. Ce champ est géré par les méthodes protégées qui fournissent un comportement personnalisé pour ajouter et supprimer des éléments de la collection, telles que le <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> (méthode). Le champ est défini lorsque l’élément est ajouté à une collection et effacé lorsque l’élément est supprimé.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> est introuvable.  
  
- ou - 
 <paramref name="key" /> existe déjà dans le <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="keyedCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les éléments de <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il existe un dictionnaire de recherche, cette méthode efface mais ne le supprime pas.  
  
 Si le nombre d’éléments a dépassé le seuil de création de dictionnaire et le <xref:System.Collections.ObjectModel.KeyedCollection%602> est à l’aide d’un dictionnaire de recherche, il continuera à utiliser un dictionnaire de recherche, même si le nombre d’éléments est à nouveau sous le seuil.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Notes de publication pour les implémenteurs  
 Substituez cette méthode pour fournir le comportement personnalisé pour le <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> méthode, héritée de la <xref:System.Collections.ObjectModel.Collection%601> classe générique.  
  
 Appeler l’implémentation de classe de base de cette méthode pour effacer la collection sous-jacente et effacer le dictionnaire de recherche.  
  
   
  
## Examples  
 Cette section contient deux exemples de code qui montrent la substitution de la <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> méthode pour fournir un comportement personnalisé pour effacer tous les objets de la collection. Le premier exemple ajoute un événement de notification personnalisé et le second prend en charge une collection d’objets avec des clés mutables.  
  
 Exemple 1  
  
 L’exemple de code suivant montre comment substituer la méthode protégée <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, et <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthodes, pour fournir un comportement personnalisé pour le <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, et <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> méthodes et pour définition de la valeur par défaut <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propriété (l’indexeur en c#). Le comportement personnalisé fourni dans cet exemple est un événement de notification nommé `Changed`, qui est déclenché à la fin de chacune des méthodes substituées.  
  
 L’exemple de code crée la `SimpleOrder` classe qui dérive de <xref:System.Collections.ObjectModel.KeyedCollection%602> et représente un bon de commande simple. Le formulaire de commande contient `OrderItem` objets représentant les éléments triés. L’exemple de code crée également un `SimpleOrderChangedEventArgs` classe permettant de contenir les informations d’événement et une énumération pour identifier le type de modification.  
  
 L’exemple de code illustre le comportement personnalisé en appelant les propriétés et méthodes de la classe dérivée, dans le `Main` méthode de la `Demo` classe.  
  
 Cet exemple de code utilise des objets avec des clés immuables. Pour obtenir un exemple de code qui utilise des clés mutables, consultez <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Exemple 2  
  
 L’exemple de code suivant montre comment substituer la méthode protégée <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> méthode pour prendre en charge des clés mutables et comment remplacer l’élément protégé <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, et <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthodes pour maintenir l’intégrité des clés et la collection.  
  
 L’exemple de code crée la `MutableKeys` collection qui dérive de <xref:System.Collections.ObjectModel.KeyedCollection%602>et le `MutableKey` classe. Le `MutableKey` classe a un définissable `Key` propriété. Lorsqu’une nouvelle clé est assignée à la propriété, l’accesseur Set de propriété appelle le `internal` (`Friend` en Visual Basic) `ChangeKey` méthode de la collection pour tester si la nouvelle clé serait en conflit avec une clé existante. Dans ce cas, une exception est levée et la valeur de propriété n’est pas modifiée.  
  
 Afin de maintenir la connexion entre un `MutableKey` objet et le `MutableKeys` collection et pour empêcher un objet à partir de laquelle elle est insérée deux collections, la `MutableKey` classe a un `internal` (`Friend` en Visual Basic) `Collection`champ. Ce champ est géré par les méthodes protégées qui fournissent un comportement personnalisé pour ajouter et supprimer des éléments de la collection, telles que le <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> (méthode). Le champ est défini lorsque l’élément est ajouté à une collection et effacé lorsque l’élément est supprimé.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le comparateur d’égalité générique utilisé pour déterminer l’égalité des clés dans la collection.</summary>
        <value>Implémentation de l'interface générique <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> utilisée pour déterminer l'égalité des clés dans la collection.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Contains : 'Key -&gt; bool" Usage="keyedCollection.Contains key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé à rechercher dans <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</param>
        <summary>Détermine si la collection contient un élément avec la clé spécifiée.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> contient un élément correspondant à la clé spécifiée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Collections.ObjectModel.KeyedCollection%602> a un dictionnaire de recherche, `key` est utilisé pour rechercher le dictionnaire. S’il n’existe aucun dictionnaire de recherche, la clé de chaque élément est extraite à l’aide de la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> (méthode) et comparée à la clé spécifiée.  
  
 Cette méthode est une opération o (1) si le <xref:System.Collections.ObjectModel.KeyedCollection%602> a un dictionnaire de recherche ; sinon c’est un O (`n`) opération, où `n` est <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Cet exemple de code montre le code minimal nécessaire de dériver une classe de collection à partir de <xref:System.Collections.ObjectModel.KeyedCollection%602>: substitution de la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> (méthode) et en fournissant un constructeur public qui délègue à un constructeur de classe de base. L’exemple de code montre également la plupart des propriétés et méthodes héritées de <xref:System.Collections.ObjectModel.KeyedCollection%602> et <xref:System.Collections.ObjectModel.Collection%601> classes.  
  
 Le `SimpleOrder` classe est une liste très simple qui contient `OrderItem` objets, chacun d’eux représente un élément de ligne dans l’ordre. La clé de `OrderItem` est immuable, un facteur important pour les classes qui dérivent de <xref:System.Collections.ObjectModel.KeyedCollection%602>. Pour obtenir un exemple de code qui utilise des clés mutables, consultez <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;!TKey, !TItem&gt; Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary(Of TKey, TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ Dictionary { System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Dictionary : System.Collections.Generic.IDictionary&lt;'Key, 'Item&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Dictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;TKey,TItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le dictionnaire de recherche du <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <value>Dictionnaire de recherche du <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, s'il existe ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le <xref:System.Collections.ObjectModel.KeyedCollection%602> contient un dictionnaire de recherche qui est créé lorsque le premier élément est ajouté. Lorsqu’un élément est ajouté à la <xref:System.Collections.ObjectModel.KeyedCollection%602>, clé de l’élément est extrait qu’une seule fois et enregistrée dans le dictionnaire de recherche pour accélérer les recherches. Ce comportement peut être remplacé en utilisant le <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> constructeur et en spécifiant un seuil de création de dictionnaire.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment substituer la méthode protégée <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> méthode pour prendre en charge des clés mutables et comment remplacer l’élément protégé <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, et <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthodes pour maintenir l’intégrité des clés et la collection.  
  
 L’exemple de code crée la `MutableKeys` collection qui dérive de <xref:System.Collections.ObjectModel.KeyedCollection%602>et le `MutableKey` classe. Le `MutableKey` classe a un définissable `Key` propriété. Lorsqu’une nouvelle clé est assignée à la propriété, l’accesseur Set de propriété appelle le `internal` (`Friend` en Visual Basic) `ChangeKey` méthode de la collection pour tester si la nouvelle clé serait en conflit avec une clé existante. Dans ce cas, une exception est levée et la valeur de propriété n’est pas modifiée.  
  
 Afin de maintenir la connexion entre un `MutableKey` objet et le `MutableKeys` collection et pour empêcher un objet à partir de laquelle elle est insérée deux collections, la `MutableKey` classe a un `internal` (`Friend` en Visual Basic) `Collection`champ. Ce champ est géré par les méthodes protégées qui fournissent un comportement personnalisé pour ajouter et supprimer des éléments de la collection, telles que le <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> (méthode). Le champ est défini lorsque l’élément est ajouté à une collection et effacé lorsque l’élément est supprimé.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="GetKeyForItem">
      <MemberSignature Language="C#" Value="protected abstract TKey GetKeyForItem (TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance !TKey GetKeyForItem(!TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetKeyForItem (item As TItem) As TKey" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract TKey GetKeyForItem(TItem item);" />
      <MemberSignature Language="F#" Value="abstract member GetKeyForItem : 'Item -&gt; 'Key" Usage="keyedCollection.GetKeyForItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="item">Élément à partir duquel extraire la clé.</param>
        <summary>Lorsqu'il est implémenté dans une classe dérivée, il extrait la clé de l'élément spécifié.</summary>
        <returns>Clé pour l'élément spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clé dans le dictionnaire de recherche est différente de la clé qui est incorporée dans `item`, vous ne pouvez pas accéder à `item` à l’aide de la clé retournée par <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Vous pouvez implémenter cette méthode pour retourner `null` pour une collection qui contient des éléments sans clés, auquel cas les éléments sont accessibles uniquement par leur index. Cette méthode est une opération o (1).  
  
## <a name="notes-for-implementers"></a>Notes de publication pour les implémenteurs  
 Vous devez substituer cette méthode pour fournir un moyen pour extraire des éléments dans le dictionnaire des clés du dictionnaire.  
  
 Cette méthode est appelée en interne. Il n’est pas nécessaire pour qu’elle soit publique.  
  
   
  
## Examples  
 Cet exemple de code montre le code minimal nécessaire de dériver une classe de collection à partir de <xref:System.Collections.ObjectModel.KeyedCollection%602>: substitution de la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> (méthode) et en fournissant un constructeur public qui délègue à un constructeur de classe de base. L’exemple de code montre également la plupart des propriétés et méthodes héritées de <xref:System.Collections.ObjectModel.KeyedCollection%602> et <xref:System.Collections.ObjectModel.Collection%601> classes.  
  
 Le `SimpleOrder` classe est une liste très simple qui contient `OrderItem` objets, chacun d’eux représente un élément de ligne dans l’ordre. La clé de `OrderItem` est immuable, un facteur important pour les classes qui dérivent de <xref:System.Collections.ObjectModel.KeyedCollection%602>. Pour obtenir un exemple de code qui utilise des clés mutables, consultez <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * 'Item -&gt; unit" Usage="keyedCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro auquel <c>l’élément</c> doit être inséré.</param>
        <param name="item">Objet à insérer.</param>
        <summary>Insère un élément dans la classe <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> au niveau de l'index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `index` est égal à <xref:System.Collections.ObjectModel.Collection%601.Count%2A>, `item` est ajouté à la fin de la <xref:System.Collections.ObjectModel.KeyedCollection%602>.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> est appelée par le <xref:System.Collections.ObjectModel.Collection%601.Add%2A> et <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> méthodes.  
  
## <a name="notes-for-implementers"></a>Notes de publication pour les implémenteurs  
 Substituez cette méthode pour fournir le comportement personnalisé pour le <xref:System.Collections.ObjectModel.Collection%601.Add%2A> et <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> méthodes, héritées de la <xref:System.Collections.ObjectModel.Collection%601> classe générique.  
  
 Appeler l’implémentation de classe de base de cette méthode pour insérer l’élément dans la collection sous-jacente et mettre à jour le dictionnaire de recherche.  
  
   
  
## Examples  
 Cette section contient deux exemples de code qui montrent la substitution de la <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> méthode pour fournir un comportement personnalisé pour ajouter ou insérer des objets dans la collection. Le premier exemple ajoute un événement de notification personnalisé et le second prend en charge une collection d’objets avec des clés mutables.  
  
 Exemple 1  
  
 L’exemple de code suivant montre comment substituer la méthode protégée <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, et <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthodes, pour fournir un comportement personnalisé pour le <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, et <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> méthodes et pour définition de la valeur par défaut <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propriété (l’indexeur en c#). Le comportement personnalisé fourni dans cet exemple est un événement de notification nommé `Changed`, qui est déclenché à la fin de chacune des méthodes substituées.  
  
 L’exemple de code crée la `SimpleOrder` classe qui dérive de <xref:System.Collections.ObjectModel.KeyedCollection%602> et représente un bon de commande simple. Le formulaire de commande contient `OrderItem` objets représentant les éléments triés. L’exemple de code crée également un `SimpleOrderChangedEventArgs` classe permettant de contenir les informations d’événement et une énumération pour identifier le type de modification.  
  
 L’exemple de code illustre le comportement personnalisé en appelant les propriétés et méthodes de la classe dérivée, dans le `Main` méthode de la `Demo` classe.  
  
 Cet exemple de code utilise des objets avec des clés immuables. Pour obtenir un exemple de code qui utilise des clés mutables, consultez <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Exemple 2  
  
 L’exemple de code suivant montre comment substituer la méthode protégée <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> méthode pour prendre en charge des clés mutables et comment remplacer l’élément protégé <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, et <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthodes pour maintenir l’intégrité des clés et la collection.  
  
 L’exemple de code crée la `MutableKeys` collection qui dérive de <xref:System.Collections.ObjectModel.KeyedCollection%602>et le `MutableKey` classe. Le `MutableKey` classe a un définissable `Key` propriété. Lorsqu’une nouvelle clé est assignée à la propriété, l’accesseur Set de propriété appelle le `internal` (`Friend` en Visual Basic) `ChangeKey` méthode de la collection pour tester si la nouvelle clé serait en conflit avec une clé existante. Dans ce cas, une exception est levée et la valeur de propriété n’est pas modifiée.  
  
 Afin de maintenir la connexion entre un `MutableKey` objet et le `MutableKeys` collection et pour empêcher un objet à partir de laquelle elle est insérée deux collections, la `MutableKey` classe a un `internal` (`Friend` en Visual Basic) `Collection`champ. Ce champ est géré par les méthodes protégées qui fournissent un comportement personnalisé pour ajouter et supprimer des éléments de la collection, telles que le <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> (méthode). Le champ est défini lorsque l’élément est ajouté à une collection et effacé lorsque l’élément est supprimé.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> est inférieur à 0.  
  
- ou - 
 <paramref name="index" /> est supérieur à <see cref="P:System.Collections.ObjectModel.Collection`1.Count" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TItem this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TItem Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TItem default[TKey] { TItem get(TKey key); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Item" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'élément à obtenir.</param>
        <summary>Obtient l'élément avec la clé spécifiée.</summary>
        <value>Élément correspondant à la clé spécifiée. Si un élément avec la clé spécifiée n'est pas trouvé, une exception est levée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété permet d’accéder à un élément spécifique dans la collection à l’aide de la syntaxe suivante : `myCollection[key]` (`myCollection(key)` en Visual Basic).  
  
> [!NOTE]
>  Cette propriété est différente de héritées <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> propriété qui obtient et définit des éléments par index numérique. Toutefois, si `TKey` est de type <xref:System.Int32>, cette propriété masque la propriété héritée. Dans ce cas, vous pouvez accéder à la propriété héritée en effectuant un cast du <xref:System.Collections.ObjectModel.KeyedCollection%602> à son type de base. Par exemple, `KeyedCollection<int, MyType>` (`KeyedCollection(Of Integer, MyType)` en Visual Basic, `KeyedCollection<int, MyType^>` en C++) peut être casté en `Collection<MyType>` (`Collection(Of MyType)` en Visual Basic, `Collection<MyType^>` dans C++).  
  
 Si le <xref:System.Collections.ObjectModel.KeyedCollection%602> a un dictionnaire de recherche, `key` est utilisée pour récupérer l’élément à partir du dictionnaire.  S’il n’existe aucun dictionnaire de recherche, la clé de chaque élément est extraite à l’aide de la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> (méthode) et comparée à la clé spécifiée.  
  
 Le langage c# utilise le mot clé pour définir les indexeurs au lieu d’implémenter le <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> propriété. Visual Basic implémente <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> comme propriété par défaut, ce qui fournit les mêmes fonctionnalités d'indexation.  
  
 Récupération de la valeur de cette propriété est une opération o (1) si le <xref:System.Collections.ObjectModel.KeyedCollection%602> a un dictionnaire de recherche ; sinon c’est un O (`n`) opération, où `n` est <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Cet exemple de code montre le code minimal nécessaire de dériver une classe de collection à partir de <xref:System.Collections.ObjectModel.KeyedCollection%602>: substitution de la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> (méthode) et en fournissant un constructeur public qui délègue à un constructeur de classe de base. L’exemple de code montre également la plupart des propriétés et méthodes héritées de <xref:System.Collections.ObjectModel.KeyedCollection%602> et <xref:System.Collections.ObjectModel.Collection%601> classes.  
  
 L’exemple de code appelle à la fois le <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> propriété, qui est en lecture seule et la récupération par clé, et le <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> propriété, qui peut être définie et effectue une récupération par index. Il montre comment accéder à la propriété de ce dernier lorsque les objets dans la collection dérivée ont des clés de type entier, se distinguent pas des entiers utilisés pour la récupération indexée.  
  
 Le `SimpleOrder` classe est une liste très simple qui contient `OrderItem` objets, chacun d’eux représente un élément de ligne dans l’ordre. La clé de `OrderItem` est immuable, un facteur important pour les classes qui dérivent de <xref:System.Collections.ObjectModel.KeyedCollection%602>. Pour obtenir un exemple de code qui utilise des clés mutables, consultez <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Il n'existe aucun élément portant la clé spécifiée dans la collection.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Key -&gt; bool" Usage="keyedCollection.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clé de l'élément à supprimer.</param>
        <summary>Supprime de <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> l'élément ayant la clé spécifiée.</summary>
        <returns>
          <see langword="true" /> si la suppression de l'élément réussit ; sinon, <see langword="false" />.  Cette méthode retourne également <see langword="false" /> si <paramref name="key" /> est introuvable dans <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clé de l’élément est également supprimée du dictionnaire de recherche.  
  
 Si le nombre d’éléments a dépassé le seuil de création de dictionnaire et le <xref:System.Collections.ObjectModel.KeyedCollection%602> est à l’aide d’un dictionnaire de recherche, il continuera à utiliser un dictionnaire de recherche, même si le nombre d’éléments est à nouveau sous le seuil.  
  
> [!NOTE]
>  Pour personnaliser le comportement de cette méthode, substituez le <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> (méthode).  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Cet exemple de code montre le code minimal nécessaire de dériver une classe de collection à partir de <xref:System.Collections.ObjectModel.KeyedCollection%602>: substitution de la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> (méthode) et en fournissant un constructeur public qui délègue à un constructeur de classe de base. L’exemple de code montre également la plupart des propriétés et méthodes héritées de <xref:System.Collections.ObjectModel.KeyedCollection%602> et <xref:System.Collections.ObjectModel.Collection%601> classes.  
  
 L’exemple montre <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A> héritée de la méthode <xref:System.Collections.ObjectModel.KeyedCollection%602>, qui supprime l’élément ayant la clé spécifiée et également le <xref:System.Collections.ObjectModel.Collection%601.Remove%2A> et <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%2A> méthodes héritées de <xref:System.Collections.ObjectModel.Collection%601>, lequel supprimer respectivement par objet et par index.  
  
 Le `SimpleOrder` classe est une liste très simple qui contient `OrderItem` objets, chacun d’eux représente un élément de ligne dans l’ordre. La clé de `OrderItem` est immuable, un facteur important pour les classes qui dérivent de <xref:System.Collections.ObjectModel.KeyedCollection%602>. Pour obtenir un exemple de code qui utilise des clés mutables, consultez <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="keyedCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de l'élément à supprimer.</param>
        <summary>Supprime l'élément au niveau de l'index spécifié de <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clé de l’élément est également supprimée du dictionnaire de recherche.  
  
 Si le nombre d’éléments a dépassé le seuil de création de dictionnaire et le <xref:System.Collections.ObjectModel.KeyedCollection%602> est à l’aide d’un dictionnaire de recherche, il continuera à utiliser un dictionnaire de recherche, même si le nombre d’éléments est à nouveau sous le seuil.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Notes de publication pour les implémenteurs  
 Substituez cette méthode pour fournir le comportement personnalisé pour le <xref:System.Collections.ObjectModel.Collection%601.Remove%28%600%29> et <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%28System.Int32%29> méthodes, héritées de la <xref:System.Collections.ObjectModel.Collection%601> classe générique et le <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%28%600%29> (méthode).  
  
 Appelez l’implémentation de classe de base de cette méthode pour supprimer l’élément de la collection sous-jacente et mettre à jour le dictionnaire de recherche.  
  
   
  
## Examples  
 Cette section contient deux exemples de code qui montrent la substitution de la <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> méthode pour fournir un comportement personnalisé pour la suppression d’objets dans la collection. Le premier exemple ajoute un événement de notification personnalisé et le second prend en charge une collection d’objets avec des clés mutables.  
  
 Exemple 1  
  
 L’exemple de code suivant montre comment substituer la méthode protégée <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, et <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthodes, pour fournir un comportement personnalisé pour le <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, et <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> méthodes et pour définition de la valeur par défaut <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propriété (l’indexeur en c#). Le comportement personnalisé fourni dans cet exemple est un événement de notification nommé `Changed`, qui est déclenché à la fin de chacune des méthodes substituées.  
  
 L’exemple de code crée la `SimpleOrder` classe qui dérive de <xref:System.Collections.ObjectModel.KeyedCollection%602> et représente un bon de commande simple. Le formulaire de commande contient `OrderItem` objets représentant les éléments triés. L’exemple de code crée également un `SimpleOrderChangedEventArgs` classe permettant de contenir les informations d’événement et une énumération pour identifier le type de modification.  
  
 L’exemple de code illustre le comportement personnalisé en appelant les propriétés et méthodes de la classe dérivée, dans le `Main` méthode de la `Demo` classe.  
  
 Cet exemple de code utilise des objets avec des clés immuables. Pour obtenir un exemple de code qui utilise des clés mutables, consultez <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Exemple 2  
  
 L’exemple de code suivant montre comment substituer la méthode protégée <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> méthode pour prendre en charge des clés mutables et comment remplacer l’élément protégé <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, et <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthodes pour maintenir l’intégrité des clés et la collection.  
  
 L’exemple de code crée la `MutableKeys` collection qui dérive de <xref:System.Collections.ObjectModel.KeyedCollection%602>et le `MutableKey` classe. Le `MutableKey` classe a un définissable `Key` propriété. Lorsqu’une nouvelle clé est assignée à la propriété, l’accesseur Set de propriété appelle le `internal` (`Friend` en Visual Basic) `ChangeKey` méthode de la collection pour tester si la nouvelle clé serait en conflit avec une clé existante. Dans ce cas, une exception est levée et la valeur de propriété n’est pas modifiée.  
  
 Afin de maintenir la connexion entre un `MutableKey` objet et le `MutableKeys` collection et pour empêcher un objet à partir de laquelle elle est insérée deux collections, la `MutableKey` classe a un `internal` (`Friend` en Visual Basic) `Collection`champ. Ce champ est géré par les méthodes protégées qui fournissent un comportement personnalisé pour ajouter et supprimer des éléments de la collection, telles que le <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> (méthode). Le champ est défini lorsque l’élément est ajouté à une collection et effacé lorsque l’élément est supprimé.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * 'Item -&gt; unit" Usage="keyedCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de l'élément à remplacer.</param>
        <param name="item">Nouvel élément.</param>
        <summary>Remplace l'élément à l'index spécifié par l'élément spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le dictionnaire de recherche est mis à jour en conséquence. Autrement dit, la clé de l’élément qui est remplacé est supprimée du dictionnaire de recherche, et la clé du nouvel élément est ajoutée.  
  
 Cette méthode est une opération o (1).  
  
## <a name="notes-for-implementers"></a>Notes de publication pour les implémenteurs  
 Substituez cette méthode pour fournir le comportement personnalisé pour le paramètre le <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propriété héritée de la <xref:System.Collections.ObjectModel.Collection%601> classe générique.  
  
> [!NOTE]
>  Cette méthode n’affecte pas le comportement de la <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> propriété, qui est en lecture seule.  
  
 Appelez l’implémentation de classe de base de cette méthode pour définir l’élément dans la collection sous-jacente et mettre à jour le dictionnaire de recherche.  
  
   
  
## Examples  
 Cette section contient deux exemples de code qui montrent la substitution de la <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthode pour fournir le comportement personnalisé pour définir le <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> propriété. Le premier exemple ajoute un événement de notification personnalisé et le second prend en charge une collection d’objets avec des clés mutables.  
  
 Exemple 1  
  
 L’exemple de code suivant montre comment substituer la méthode protégée <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, et <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthodes, pour fournir un comportement personnalisé pour le <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, et <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> méthodes et pour définition de la valeur par défaut <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propriété (l’indexeur en c#). Le comportement personnalisé fourni dans cet exemple est un événement de notification nommé `Changed`, qui est déclenché à la fin de chacune des méthodes substituées.  
  
 L’exemple de code crée la `SimpleOrder` classe qui dérive de <xref:System.Collections.ObjectModel.KeyedCollection%602> et représente un bon de commande simple. Le formulaire de commande contient `OrderItem` objets représentant les éléments triés. L’exemple de code crée également un `SimpleOrderChangedEventArgs` classe permettant de contenir les informations d’événement et une énumération pour identifier le type de modification.  
  
 L’exemple de code illustre le comportement personnalisé en appelant les propriétés et méthodes de la classe dérivée, dans le `Main` méthode de la `Demo` classe.  
  
 Cet exemple de code utilise des objets avec des clés immuables. Pour obtenir un exemple de code qui utilise des clés mutables, consultez <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Exemple 2  
  
 L’exemple de code suivant montre comment substituer la méthode protégée <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> méthode pour prendre en charge des clés mutables et comment remplacer l’élément protégé <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, et <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> méthodes pour maintenir l’intégrité des clés et la collection.  
  
 L’exemple de code crée la `MutableKeys` collection qui dérive de <xref:System.Collections.ObjectModel.KeyedCollection%602>et le `MutableKey` classe. Le `MutableKey` classe a un définissable `Key` propriété. Lorsqu’une nouvelle clé est assignée à la propriété, l’accesseur Set de propriété appelle le `internal` (`Friend` en Visual Basic) `ChangeKey` méthode de la collection pour tester si la nouvelle clé serait en conflit avec une clé existante. Dans ce cas, une exception est levée et la valeur de propriété n’est pas modifiée.  
  
 Afin de maintenir la connexion entre un `MutableKey` objet et le `MutableKeys` collection et pour empêcher un objet à partir de laquelle elle est insérée deux collections, la `MutableKey` classe a un `internal` (`Friend` en Visual Basic) `Collection`champ. Ce champ est géré par les méthodes protégées qui fournissent un comportement personnalisé pour ajouter et supprimer des éléments de la collection, telles que le <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> (méthode). Le champ est défini lorsque l’élément est ajouté à une collection et effacé lorsque l’élément est supprimé.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TItem&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef item As TItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TItem % item);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="keyedCollection.TryGetValue (key, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="item" Type="TItem" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>