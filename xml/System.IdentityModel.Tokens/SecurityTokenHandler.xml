<Type Name="SecurityTokenHandler" FullName="System.IdentityModel.Tokens.SecurityTokenHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0c79f213d3f161955116c54a6c327ec3259dc61c" />
    <Meta Name="ms.sourcegitcommit" Value="1afcc8f9041ff3093fd13fb0afda92ac188878a9" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="09/06/2018" />
    <Meta Name="ms.locfileid" Value="43850448" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenHandler : System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenHandler extends System.Object implements class System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenHandler&#xA;Implements ICustomIdentityConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenHandler abstract : System::IdentityModel::Configuration::ICustomIdentityConfiguration" />
  <TypeSignature Language="F#" Value="type SecurityTokenHandler = class&#xA;    interface ICustomIdentityConfiguration" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IdentityModel.Configuration.ICustomIdentityConfiguration</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Classe de base abstraite pour les gestionnaires de jetons de sécurité.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler> est la classe de base à partir de la sécurité tous les gestionnaires de jetons dérivent. Un gestionnaire de jetons de sécurité est responsable de :  
  
-   Validation des jetons de sécurité (<xref:System.IdentityModel.Tokens.SecurityToken>) du type, il est conçu pour les processus et l’empaquetage les revendications contenues dans le jeton dans un <xref:System.Security.Claims.ClaimsIdentity> objet.  
  
-   Sérialiser et désérialiser des jetons de sécurité du type, il est conçu pour traiter.  
  
-   Sérialiser et désérialiser des clauses d’identificateur de clé (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>) qui renvoient aux jetons du type, il est conçu pour traiter les vers et depuis `<wsse:SecurityTokenReference>` éléments.  
  
-   Création de jetons de sécurité à partir d’un <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor> objet passé par les implémentations de la <xref:System.IdentityModel.SecurityTokenService> classe.  
  
-   Création des clauses d’identificateur de clé à partir d’un jeton de sécurité pour les implémentations de la <xref:System.IdentityModel.SecurityTokenService> classe.  
  
 Windows Identity Foundation (WIF) est fourni les gestionnaires de jetons de sécurité suivants prêts à l’emploi :  
  
-   <xref:System.IdentityModel.Tokens.EncryptedSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.KerberosSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MembershipUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.RsaSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.Saml2SecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SamlSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.UserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.WindowsUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.X509SecurityTokenHandler>  
  
 La plupart de ces classes expose des membres supplémentaires qui implémentent des fonctionnalités spécifiques pour le traitement des jetons pour lequel la classe est conçue. Dans de nombreux cas, il peut être préférable de dériver de l’une de ces classes, plutôt que directement à partir de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler> classe.  
  
 Un gestionnaire de jetons de sécurité peut être ajouté ou supprimé d’une collection de gestionnaires de jetons en spécifiant le [ &lt;ajouter&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md), [ &lt;supprimer&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md), ou [ &lt;effacer&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/clear.md) éléments sous le [ &lt;securityTokenHandlers&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) élément dans un fichier de configuration. Le <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration> objet qui contient les paramètres de configuration pour la collection de gestionnaires sont accessibles via le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> propriété et la collection de gestionnaires dont le Gestionnaire de jetons est un membre est accessible à partir de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection%2A> propriété. Vous pouvez remplacer le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> méthode pour traiter tous les éléments de configuration personnalisée qui accepte votre gestionnaire.  
  
 Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler> classe expose plusieurs autres propriétés et méthodes. Selon les fonctionnalités que vous choisissez d’implémenter, vous pouvez remplacer tout ou partie de ces membres.  
  
 Vous devez substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> propriété et la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> méthode pour fournir l’infrastructure WIF avec des informations sur le type de jeton de sécurité que votre classe est conçue pour traiter.  
  
 Validation, la sérialisation et désérialisation fonctionnalités sont exposées via les propriétés ou méthodes qui indiquent si le gestionnaire peut effectuer une fonction spécifique associée à l’ou les méthodes qui implémentent la fonctionnalité. La liste suivante associe les propriétés ou méthodes qui indiquent les fonctionnalités avec les méthodes qui implémentent cette fonctionnalité :  
  
-   Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> propriété et la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> méthode : valide un jeton et les revendications contenues dans le jeton dans les packages un <xref:System.Security.Claims.ClaimsIdentity>.  
  
-   Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> propriété et le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> méthodes : sérialisation de jeton.  
  
-   Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> méthodes et les <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> méthodes : la désérialisation du jeton.  
  
-   Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A> (méthode) et le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> méthode : la désérialisation des clauses d’identificateur de clé.  
  
-   Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> (méthode) et le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> méthode : sérialisation des clauses d’identificateur de clé.  
  
 Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> et <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> méthodes sont appelées à partir du pipeline dans les implémentations de la <xref:System.IdentityModel.SecurityTokenService> classe.  
  
 Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> méthode est appelée par l’infrastructure WIF pour déterminer si le jeton spécifié a déjà été reçu. Par défaut, cette méthode retourne `false`, ce qui indique que le jeton n’a pas déjà été reçu. Vous pouvez substituer la méthode et fournir une logique pour détecter les jetons relus.  
  
   
  
## Examples  
 Les exemples de code dans tous les <xref:System.IdentityModel.Tokens.SecurityTokenHandler> rubriques sont extraites de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens). Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md). Le code XML suivant montre comment ajouter le Gestionnaire de jetons SWT à la collection de gestionnaires de jetons.  
  
```xml  
<system.identityModel>  
  <identityConfiguration saveBootstrapContext="true">  
    <issuerTokenResolver type="SimpleWebToken.CustomIssuerTokenResolver, SimpleWebToken">  
      <AddAudienceKeyPair  symmetricKey="wAVkldQiFypTQ+kdNdGWCYCHRcee8XmXxOvgmak8vSY=" audience="http://localhost:19851/" />  
    </issuerTokenResolver>  
    <issuerNameRegistry type="RelyingParty.TrustedIssuerNameRegistry, RelyingParty"/>  
    <audienceUris>  
      <add value="http://localhost:19851/"/>  
    </audienceUris>  
    <securityTokenHandlers>  
      <add type="SimpleWebToken.SimpleWebTokenHandler, SimpleWebToken" />  
    </securityTokenHandlers>  
  </identityConfiguration>  
</system.identityModel>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SecurityToken" />
    <altmember cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" />
    <altmember cref="T:System.IdentityModel.SecurityTokenService" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Appelée à partir des constructeurs des classes dérivées pour initialiser la classe <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadKeyIdentifierClause (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Lecteur XML positionné au niveau de l'élément de début. Le lecteur ne doit pas être avancé par cette méthode.</param>
        <summary>Retourne une valeur qui indique si l'élément XML dont il est fait référence par le lecteur XML spécifié est une clause de l'identificateur de clé qui peut être désérialisée par cette instance.</summary>
        <returns>
          <see langword="true" /> si la méthode <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" /> peut lire l'élément ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne `false` pour indiquer que la clause d’identificateur de clé ne peut pas être lu.  
  
 Une classe dérivée vérifie l’élément auquel le lecteur fait référence afin de déterminer si l’instance peut désérialiser une clause d’identificateur de clé. Cela est généralement effectuée via un appel à la <xref:System.Xml.XmlReader.IsStartElement%2A?displayProperty=nameWithType> méthode avec les chaînes appropriées d’élément et l’espace de noms spécifié. Si vous substituez <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>, vous devez également substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> méthode pour fournir la logique pour désérialiser la clause d’identificateur de clé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une valeur qui indique si le jeton spécifié peut être désérialisé en tant que jeton du type traité par cette instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (tokenString As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : string -&gt; bool&#xA;override this.CanReadToken : string -&gt; bool" Usage="securityTokenHandler.CanReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Chaîne de jeton à lire.</param>
        <summary>Retourne une valeur qui indique si la chaîne spécifiée peut être désérialisée comme un jeton du type traité par cette instance.</summary>
        <returns>
          <see langword="true" /> si la méthode <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" /> peut lire l'élément ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implémentation par défaut retourne toujours `false`.  
  
 Si vous substituez cette méthode, vous devez également substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> méthode pour fournir la logique pour désérialiser le jeton.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Lecteur XML positionné au niveau d'un élément de début. Le lecteur ne doit pas être avancé par cette méthode.</param>
        <summary>Retourne une valeur qui indique si l'élément XML référencé par le lecteur XML spécifié peut être lu comme un jeton du type traité par cette instance.</summary>
        <returns>
          <see langword="true" /> si la méthode <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" /> peut lire l'élément ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implémentation par défaut retourne toujours `false`.  
  
 Une classe dérivée vérifie l’élément auquel le lecteur fait référence afin de déterminer si l’instance peut désérialiser un jeton de sécurité. Cela est généralement effectuée via un appel à la <xref:System.Xml.XmlReader.IsStartElement%2A> méthode avec les chaînes appropriées d’élément et l’espace de noms spécifié. Si vous substituez <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>, vous devez également substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> méthode ou le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> méthode pour fournir la logique pour désérialiser la clause d’identificateur de clé.  
  
   
  
## Examples  
 Le code suivant montre comment substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> méthode pour déterminer si un jeton peut être lu par un gestionnaire. Le code provient de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens). Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public virtual bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le gestionnaire prend en charge la validation des jetons de sécurité.</summary>
        <value>
          <see langword="true" /> si la classe est capable de valider des jetons de sécurité ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour implémenter la validation dans une classe dérivée, substituez cette propriété pour retourner `true` et remplacer le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> méthode pour implémenter la logique de validation.  
  
   
  
## Examples  
 Le code suivant montre comment substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> propriété pour indiquer qu’un gestionnaire personnalisé peut valider des jetons. Le code provient de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens). Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanWriteKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanWriteKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool&#xA;override this.CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool" Usage="securityTokenHandler.CanWriteKeyIdentifierClause securityKeyIdentifierClause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="securityKeyIdentifierClause">Clause de l'identificateur de clé à vérifier.</param>
        <summary>Retourne une valeur qui indique si la clause d'identificateur de clé spécifiée peut être sérialisée par cette instance.</summary>
        <returns>
          <see langword="true" /> si la clause d'identificateur de clé spécifiée peut être sérialisée ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implémentation par défaut retourne toujours `false`.  
  
 Si vous substituez <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A>, vous devez également substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> méthode pour fournir la logique permettant de sérialiser la clause d’identificateur de clé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le gestionnaire peut sérialiser les jetons de sécurité.</summary>
        <value>
          <see langword="true" /> si la classe est capable de sérialiser des jetons ; sinon <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour implémenter la sérialisation dans une classe dérivée, substituez cette propriété pour retourner `true` et remplacer le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> méthodes à implémenter la logique de sérialisation.  
  
   
  
## Examples  
 Le code suivant montre comment substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> propriété pour indiquer qu’un gestionnaire personnalisé peut sérialiser les jetons. Le code provient de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens). Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Configuration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberSignature Language="VB.NET" Value="Public Property Configuration As SecurityTokenHandlerConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ Configuration { System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Configuration : System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration with get, set" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration" /> qui fournit la configuration pour l'instance actuelle.</summary>
        <value>Objet de configuration pour l'instance actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> propriété est généralement définie par l’infrastructure de configuration à partir de la [ &lt;securityTokenHandlerConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlerconfiguration.md) Démarrer élément dans le fichier de configuration au cours de l’application.  
  
 Dans les classes dérivées, vous utilisez le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> propriété pour accéder aux paramètres de configuration, par exemple, le Registre des noms d’émetteur à utiliser dans le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> méthode est accessible à partir de la <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.IssuerNameRegistry%2A?displayProperty=nameWithType> propriété de l’objet de configuration.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainingCollection">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainingCollection As SecurityTokenHandlerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ ContainingCollection { System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainingCollection : System.IdentityModel.Tokens.SecurityTokenHandlerCollection" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de gestionnaires de jetons qui contient l'instance actuelle.</summary>
        <value>Collection de gestionnaires de jetons qui contient l'instance actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le Gestionnaire de jetons est ajouté à un <xref:System.IdentityModel.Tokens.SecurityTokenHandlerCollection> instance, cette propriété est définie automatiquement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenReference">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference (System.IdentityModel.Tokens.SecurityToken token, bool attached);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference(class System.IdentityModel.Tokens.SecurityToken token, bool attached) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference(System.IdentityModel.Tokens.SecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSecurityTokenReference (token As SecurityToken, attached As Boolean) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ CreateSecurityTokenReference(System::IdentityModel::Tokens::SecurityToken ^ token, bool attached);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.CreateSecurityTokenReference (token, attached)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="attached" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="token">Jeton pour lequel la référence doit être créée.</param>
        <param name="attached">
          <see langword="true" /> si une référence jointe doit être créée ; <see langword="false" /> si une référence non jointe doit être créée.</param>
        <summary>En cas de substitution dans une classe dérivée, crée la référence de jeton de sécurité pour les jetons traités par cette classe. Cette méthode est généralement appelée par un service d'émission de jeton de sécurité (STS).</summary>
        <returns>Clause d'identificateur de clé qui référence le jeton spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, cette méthode lève un <xref:System.NotImplementedException> exception.  
  
 Les classes dérivées remplacent cette méthode pour retourner une clause d’identificateur de clé (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>) qui peut être utilisé pour créer un `<wsse:SecurityTokenReference>` élément pour le jeton spécifié.  
  
 Appelée à partir des implémentations de la <xref:System.IdentityModel.SecurityTokenService> classe.  
  
 En règle générale, un <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause> n’a pas besoin à utiliser, autre que lors de la création d’un service de jeton de sécurité personnalisé. Lorsqu'un service d'émission du jeton de sécurité retourne un jeton de sécurité, le jeton de sécurité émis contient des références à des jetons de sécurité attachés et détachés. Les références attachées renvoient aux jetons de sécurité qui sont contenus dans l'en-tête de sécurité d'un message SOAP et les références détachées renvoient à des jetons de sécurité qui ne sont pas inclus dans l'en-tête de sécurité d'un message SOAP. En général, ces références déclarent l'authenticité du jeton de sécurité émis.  
  
   
  
## Examples  
 Le code suivant montre comment substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> méthode pour créer une clause d’identificateur de clé à partir du jeton spécifié. Le code provient de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens). Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">Descripteur de jeton de sécurité à partir duquel le jeton doit être créé. Les propriétés du descripteur de jeton sont définies avant l'appel de cette méthode.</param>
        <summary>En cas de substitution dans une classe dérivée, crée un jeton de sécurité à l'aide descripteur de jetons spécifié. Cette méthode est appelée par un service d'émission de jeton de sécurité (STS).</summary>
        <returns>Jeton de sécurité qui correspond aux propriétés du descripteur de jetons.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, cette méthode lève un <xref:System.NotImplementedException> exception.  
  
 Appelée à partir des implémentations de la <xref:System.IdentityModel.SecurityTokenService> classe.  
  
   
  
## Examples  
 Le code suivant montre comment substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> méthode pour créer et renvoyer un jeton à partir d’un descripteur de jetons. Le code provient de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens). Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetectReplayedToken">
      <MemberSignature Language="C#" Value="protected virtual void DetectReplayedToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DetectReplayedToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DetectReplayedToken (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DetectReplayedToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.DetectReplayedToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Jeton à vérifier pour la relecture.</param>
        <summary>En cas de substitution dans une classe dérivée, lève une exception si le jeton spécifié est identifié comme étant relu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implémentation par défaut n'exécute aucune opération.  
  
 Les classes dérivées doivent lever un <xref:System.IdentityModel.Tokens.SecurityTokenReplayDetectedException> si le jeton a déjà été utilisé.  
  
 Windows Identity Foundation (WIF) fournit la <xref:System.IdentityModel.Tokens.TokenReplayCache> à partir de quels relecture caches peuvent être dérivés de classe et le [ &lt;tokenReplayCache&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/tokenreplaycache.md) élément de configuration, ce qui peut être utilisé pour configurer le cache de relecture utilisé par les gestionnaires de jetons dans une application ; Toutefois, l’implémentation exacte de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> méthode revient au Concepteur de la classe dérivée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public abstract string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="securityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, retourne l'ensemble des URI utilisés dans les demandes pour identifier un jeton du type traité par cette classe dérivée.</summary>
        <returns>Ensemble d'URI qui identifient le type de jeton que ce gestionnaire prend en charge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type> du jeton traité par l’instance actuelle est accessible via la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> propriété. Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> méthode retourne le jeu d’identificateurs acceptables qui peut être utilisé dans les messages pour faire référence au type de jeton. Par exemple, la valeur de l’URI utilisé dans le `<wst:TokenType>` élément sous le `<wst:RequestSecurityToken>` élément pour demander un type spécifique de jeton (représenté par le <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType%2A?displayProperty=nameWithType> propriété dans le modèle objet).  
  
   
  
## Examples  
 Le code suivant montre comment substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> méthode pour retourner les identificateurs de type de jeton pour un jeton personnalisé. Le code provient de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens). Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#17](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#17)]  
[!code-csharp[WifRcCustomToken#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public virtual void LoadCustomConfiguration (System.Xml.XmlNodeList nodelist);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList nodelist) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadCustomConfiguration (nodelist As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadCustomConfiguration(System::Xml::XmlNodeList ^ nodelist);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit&#xA;override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="securityTokenHandler.LoadCustomConfiguration nodelist" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IdentityModel.Configuration.ICustomIdentityConfiguration.LoadCustomConfiguration(System.Xml.XmlNodeList)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodelist" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="nodelist">Éléments XML de configuration. Chaque nœud de la liste est de type <see cref="T:System.Xml.XmlElement" />.</param>
        <summary>Après substitution dans une classe dérivée, charge la configuration personnalisée à partir de XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> méthode est appelée par l’infrastructure de configuration. Lorsque cette méthode est appelée, le `nodelist` contiendra les éléments enfants de niveau supérieur du Gestionnaire de jetons [ &lt;ajouter&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) élément à partir du fichier de configuration. Chacun d'entre eux peut, à son tour, contient des attributs ou éléments enfants en fonction du schéma de configuration que vous définissez pour votre classe dérivée.  
  
 L’implémentation par défaut lève un <xref:System.NotImplementedException>. Substituez cette méthode dans votre classe dérivée pour activer l’initialisation de votre gestionnaire de jetons de sécurité à partir d’un fichier de configuration.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadKeyIdentifierClause (reader As XmlReader) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ ReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.ReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Un lecteur XML positionné sur l'élément de début du XML à désérialiser dans la clause d'identificateur de clé.</param>
        <summary>En cas de substitution dans une classe dérivée, désérialise le XML référencé par le lecteur XML spécifié en clause d'identificateur de clé qui référence un jeton traité par la classe dérivée.</summary>
        <returns>Clause de l'identificateur de clé qui a été désérialisée à partir du XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, cette méthode lève un <xref:System.NotImplementedException> exception.  
  
 Substituez cette méthode pour fournir la logique pour désérialiser une clause d’identificateur de clé à partir de XML. Si vous substituez cette méthode, vous devez également substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, désérialise le XML spécifié en un jeton du type traité par cette classe dérivée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (tokenString As String) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Chaîne à désérialiser.</param>
        <summary>En cas de substitution dans une classe dérivée, désérialise la chaîne spécifiée en un jeton du type traité par cette classe dérivée.</summary>
        <returns>Jeton de sécurité qui a été désérialisé de la chaîne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Par défaut, cette méthode lève un <xref:System.NotImplementedException> exception.  
  
 Substituez cette méthode pour fournir une fonctionnalité qui peut désérialiser un jeton de sécurité à partir d’une chaîne. Si vous substituez cette méthode, vous devez également substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Lecteur XML positionné au niveau de l'élément de début du jeton.</param>
        <summary>En cas de substitution dans une classe dérivée, désérialise le XML référencé par le lecteur XML spécifié en un jeton du type traité par cette classe dérivée.</summary>
        <returns>Jeton de sécurité qui a été désérialisé du XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Par défaut, cette méthode lève un <xref:System.NotImplementedException> exception.  
  
 Substituez cette méthode pour fournir la logique pour désérialiser un jeton de sécurité à partir de XML. Si vous substituez cette méthode, vous devez également substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> (méthode). En règle générale, dans les classes dérivées, si la méthode ne peut pas désérialiser le jeton à partir du XML référencé, d’elle lève un <xref:System.Xml.XmlException>.  
  
   
  
## Examples  
 Le code suivant montre comment substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> méthode pour lire un jeton personnalisé à partir du lecteur XML spécifié. Le code provient de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens). Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#7)]  
[!code-csharp[WifRcCustomToken#8](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#8)]  
[!code-csharp[WifRcCustomToken#14](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">Lecteur XML positionné au niveau de l'élément de début du jeton.</param>
        <param name="tokenResolver">Programme de résolution de jetons qui contient des jetons hors bande et mis en cache.</param>
        <summary>En cas de substitution dans une classe dérivée, désérialise le XML référencé par un lecteur XML spécifié en un jeton du type traité par cette classe dérivée à l'aide du lecteur XML et du programme de résolution de jetons spécifiés.</summary>
        <returns>Jeton de sécurité qui a été désérialisé du XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 L’implémentation par défaut ignore le `tokenResolver` paramètre et délègue l’appel à la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> (méthode).  
  
 Substituez cette méthode pour fournir la logique pour désérialiser un jeton de sécurité à partir de XML. Si vous substituez cette méthode, vous devez également substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> (méthode). En règle générale, dans les classes dérivées, si la méthode ne peut pas désérialiser le jeton à partir du XML référencé, d’elle lève un <xref:System.Xml.XmlException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public abstract Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le type de jeton de sécurité traité par cette instance.</summary>
        <value>Type du jeton de sécurité qui est traité par cette instance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez substituer cette propriété dans les classes dérivées et retourner le <xref:System.Type> du jeton de sécurité (<xref:System.IdentityModel.Tokens.SecurityToken>) qui est traitée par la classe dérivée.  
  
   
  
## Examples  
 Le code suivant montre comment substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> propriété pour retourner le <xref:System.Type> de jetons de sécurité qui sont traités par un gestionnaire personnalisé. Le code provient de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens). Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#18](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationFailure">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationFailure (System.IdentityModel.Tokens.SecurityToken token, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationFailure(class System.IdentityModel.Tokens.SecurityToken token, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationFailure(System.IdentityModel.Tokens.SecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationFailure (token As SecurityToken, errorMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationFailure(System::IdentityModel::Tokens::SecurityToken ^ token, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationFailure : System.IdentityModel.Tokens.SecurityToken * string -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationFailure (token, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">Le jeton de sécurité qui est validé.</param>
        <param name="errorMessage">Message à écrire dans la trace.</param>
        <summary>Effectue le traçage de l'événement d'échec lors de la validation des jetons de sécurité lorsque le traçage est activé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit être appelée à partir de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> méthode lorsque la validation du jeton échoue.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationSuccess">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationSuccess (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationSuccess(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationSuccess(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationSuccess (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationSuccess(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationSuccess : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationSuccess token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Jeton qui a été validé.</param>
        <summary>Effectue le traçage de la validation réussie de l'événement de jetons de sécurité lorsque le traçage est activé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit être appelée à partir de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> méthode une fois que le jeton a été validé avec succès.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;&#xA;override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="securityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Jeton à valider.</param>
        <summary>En cas de substitution dans une classe dérivée,valide le jeton de sécurité spécifié. Le jeton doit être du type traité par la classe dérivée.</summary>
        <returns>Identités contenues dans le jeton.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, cette méthode lève un <xref:System.NotImplementedException> exception.  
  
 Le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> méthode est appelée par l’infrastructure pour valider et extraire les revendications du jeton de sécurité désérialisé. Ces revendications sont retournées dans la collection de <xref:System.Security.Claims.ClaimsIdentity> objets retournés par la méthode. En règle générale, cette collection contiendra une identité unique.  
  
 Dans les classes dérivées, la validation inclut généralement valider le public concerné est spécifié dans le jeton par rapport à l’audience URI spécifiés dans le <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.AudienceRestriction%2A?displayProperty=nameWithType> propriété de l’objet de configuration de gestionnaire de jetons spécifié sur le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> propriété. Ces URI sont généralement définies dans le fichier de configuration sous la [ &lt;audienceUris&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/audienceuris.md) élément. Si l’audience ne peut pas être validée, une <xref:System.IdentityModel.Tokens.AudienceUriValidationFailedException> exception doit être levée.  
  
 Lors du traitement du jeton, l’émetteur est généralement validé en transmettant le jeton de l’émetteur à un de la <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> méthodes sur le <xref:System.IdentityModel.Tokens.IssuerNameRegistry> objet qui est configuré pour le gestionnaire par le biais du <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> propriété. Le Registre des noms d’émetteur est généralement configuré via le [ &lt;issuerNameRegistry&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/issuernameregistry.md) élément dans le fichier de configuration. Le <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> retourne le nom de l’émetteur. Ce nom doit être utilisé pour définir le <xref:System.Security.Claims.Claim.Issuer%2A?displayProperty=nameWithType> propriété dans les revendications contenues dans le jeton. Si le Registre des noms d’émetteur ne contient pas une entrée pour le jeton d’émetteur, <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> retourne `null`. Dans ce cas un <xref:System.IdentityModel.Tokens.SecurityTokenException> est généralement levée dans les classes dérivées, mais ce comportement revient le Concepteur de la classe.  
  
   
  
## Examples  
 Le code suivant illustre une substitution de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> méthode pour un gestionnaire de jetons de sécurité qui traite les jetons web simples (SWT). Le code provient de la `CustomToken` exemple. Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#9](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#9)]  
  
 Le code suivant montre `CreateClaims` méthode est appelée à partir de la substitution de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> méthode dans l’exemple précédent. Cette méthode retourne un <xref:System.Security.Claims.ClaimsIdentity> objet qui est créé à partir des revendications dans le jeton. Le code provient de la `CustomToken` exemple. Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#15](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#15)]  
  
 Le code suivant montre `ValidateSignature` méthode est appelée à partir de la substitution de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> méthode dans le Gestionnaire de jetons web simples. Cette méthode valide la signature du jeton à l’aide de la configuration <xref:System.IdentityModel.Tokens.IssuerTokenResolver>. Le code provient de la `CustomToken` exemple. Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#12](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#12)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 Le code suivant montre `ValidateAudience` méthode est appelée à partir de la substitution de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> méthode dans le Gestionnaire de jetons web simples. Cette méthode valide l’audience contenue dans le jeton par rapport à l’audience URI qui ont été spécifiés dans la configuration. Le code provient de la `CustomToken` exemple. Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#13](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual void WriteKeyIdentifierClause (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteKeyIdentifierClause(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteKeyIdentifierClause(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit&#xA;override this.WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit" Usage="securityTokenHandler.WriteKeyIdentifierClause (writer, securityKeyIdentifierClause)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="writer">Enregistreur XML.</param>
        <param name="securityKeyIdentifierClause">Clause d'identificateur de clé à sérialiser.</param>
        <summary>En cas de substitution dans une classe dérivée, sérialise la clause d'identificateur de clé spécifiée au format XML. La clause de l'identificateur de clé doit être du type pris en charge par la classe dérivée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, cette méthode lève un <xref:System.NotImplementedException> exception.  
  
 Substituez cette méthode pour fournir la logique permettant de sérialiser une clause d’identificateur de clé au format XML. Si vous substituez cette méthode, vous devez également substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, sérialise le jeton de sécurité spécifié. Le jeton doit être du type traité par la classe dérivée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual string WriteToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string WriteToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (token As SecurityToken) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ WriteToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string&#xA;override this.WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string" Usage="securityTokenHandler.WriteToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Jeton à sérialiser.</param>
        <summary>En cas de substitution dans une classe dérivée, sérialise le jeton de sécurité spécifié en chaîne. Le jeton doit être du type traité par la classe dérivée.</summary>
        <returns>Jeton sérialisé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, cette méthode lève un <xref:System.NotImplementedException> exception.  
  
 Substituez cette méthode pour fournir la logique permettant de sérialiser un jeton de sécurité au format XML. Si vous substituez cette méthode, vous devez également substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">Enregistreur XML.</param>
        <param name="token">Jeton à sérialiser.</param>
        <summary>En cas de substitution dans une classe dérivée, sérialise le jeton de sécurité spécifié au format XML. Le jeton doit être du type traité par la classe dérivée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, cette méthode lève un <xref:System.NotImplementedException> exception.  
  
 Substituez cette méthode pour fournir la logique permettant de sérialiser un jeton de sécurité au format XML. Si vous substituez cette méthode, vous devez également substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> propriété.  
  
   
  
## Examples  
 Le code suivant montre comment substituer la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> méthode pour sérialiser un jeton personnalisé. Le code provient de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui autorisent le traitement des jetons SWT (Simple Web Tokens). Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [Index exemple de Code WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#10](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#10)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>