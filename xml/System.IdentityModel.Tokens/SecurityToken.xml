<Type Name="SecurityToken" FullName="System.IdentityModel.Tokens.SecurityToken">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5d83a3c0ff5a463334c8da2634f37f2551e13307" />
    <Meta Name="ms.sourcegitcommit" Value="3507e865a3613c00760f25ad1045aaa11bae4dd8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/23/2018" />
    <Meta Name="ms.locfileid" Value="31779231" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityToken" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityToken extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SecurityToken" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityToken" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityToken abstract" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente une classe de base utilisée pour implémenter tous les jetons de sécurité.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez un jeton de sécurité pour fournir les informations d'identification de l'authentification ou pour protéger un message.  
  
 Un jeton de sécurité permettre permettent de fournir des informations d’identification d’authentification, chiffrement matériel de clé, ou, dans le cas d’un jeton de sécurité émis par un service jeton de sécurité (STS), une collection de revendications sur un sujet. Tous les jetons de sécurité dérivent la <xref:System.IdentityModel.Tokens.SecurityToken> classe.  
  
 À compter de .NET 4.5, Windows Identity Foundation (WIF) a été entièrement intégré dans le .NET Framework et les classes exposées par WIF sont la méthode recommandée pour la gestion des jetons de sécurité dans votre code. Dans WIF, les jetons de sécurité sont sérialisées et désérialisées vers et à partir de leur XML représentation et sont validés à l’aide des classes dérivées de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler> classe de base. Validation d’un jeton implique non seulement vous être assuré que le jeton est valid, mais également retourner un <xref:System.Security.Claims.ClaimsIdentity> instance à partir du jeton qui peut être utilisé dans les décisions d’authentification et autorisation. Le <xref:System.Security.Claims.ClaimsIdentity> est construit par l’implémentation du Gestionnaire de jetons de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> méthode à partir des revendications contenues dans le jeton comme ainsi que les revendications qui font partie intégrante du jeton de type lui-même.  
  
 WIF est livré avec prise en charge pour les types de jetons de sécurité suivants :  
  
-   <xref:System.IdentityModel.Tokens.Saml2SecurityToken>Représente un jeton de sécurité qui est basé sur une Assertion de 2.0 SAML. Ce type de jeton est généralement émis par un service de jeton de sécurité en réponse à une WS-Trust ou WS-Federation sécurité demande de jeton (RST).  
  
-   <xref:System.IdentityModel.Tokens.SamlSecurityToken>Représente un jeton de sécurité qui est basé sur une Assertion de 1.1 SAML. Ce type de jeton est généralement émis par un service de jeton de sécurité en réponse à une WS-Trust ou WS-Federation sécurité demande de jeton (RST).  
  
-   <xref:System.IdentityModel.Tokens.KerberosRequestorSecurityToken> et <xref:System.IdentityModel.Tokens.KerberosReceiverSecurityToken>: représente un jeton de sécurité qui est basé sur un ticket Kerberos qui est reçu ou envoyé dans un message SOAP  
  
-   <xref:System.IdentityModel.Tokens.RsaSecurityToken>Représente un jeton de sécurité qui est basé sur la clé créée à l’aide de l’algorithme RSA.  
  
-   <xref:System.IdentityModel.Tokens.SessionSecurityToken>Représente un jeton de sécurité qui contient des informations sur une session.  
  
-   <xref:System.IdentityModel.Tokens.UserNameSecurityToken>Représente un jeton de sécurité qui est basé sur un nom d’utilisateur et un mot de passe.  
  
-   <xref:System.IdentityModel.Tokens.WindowsSecurityToken>Représente un jeton de sécurité qui est basé sur l’identité d’un compte de domaine ou d’utilisateur Windows.  
  
-   <xref:System.IdentityModel.Tokens.X509SecurityToken>Représente un jeton de sécurité qui est basé sur un certificat X.509.  
  
-   <xref:System.IdentityModel.Tokens.X509WindowsSecurityToken>Représente un jeton de sécurité qui est basé sur un certificat X.509 qui est mappé à un utilisateur de domaine Windows ou un compte d’utilisateur ordinateur local.  
  
 Deux autres classes de jeton de sécurité, <xref:System.IdentityModel.Tokens.GenericXmlSecurityToken> et <xref:System.IdentityModel.Tokens.EncryptedSecurityToken>, peut être utilisé pour aider à gérer les cas générales.  
  
 D’une manière générale sécurité jetons se répartissent en trois catégories principales :  
  
-   Les jetons qui référencent les services de chiffrement ou clé matériau. Par exemple le <xref:System.IdentityModel.Tokens.RsaSecurityToken> et <xref:System.IdentityModel.Tokens.X509SecurityToken> types sont souvent utilisés dans ce but.  
  
-   Jetons qui représentent des informations d’identification pour les utilisateurs qui ont déjà été authentifiées. Par exemple, le <xref:System.IdentityModel.Tokens.UserNameSecurityToken>, <xref:System.IdentityModel.Tokens.WindowsSecurityToken>et, dans le cas d’un utilisateur authentifié à l’aide d’un certificat, le <xref:System.IdentityModel.Tokens.X509SecurityToken> types.  
  
-   Jetons émis par un service de jeton de sécurité (STS) en réponse à une demande de jeton de sécurité à l’aide du protocole WS-Federation ou WS-Trust. Ceux-ci sont généralement retournés dans un `wst:RequestSecurityTokenResponse` fragment XML. Le <xref:System.IdentityModel.Tokens.Saml2SecurityToken> et <xref:System.IdentityModel.Tokens.SamlSecurityToken> types sont souvent utilisés pour représenter ces jetons.  
  
 Un type spécial de jeton, le <xref:System.IdentityModel.Tokens.SessionSecurityToken>, contient les informations nécessaires pour recréer une entité de sécurité lors de l’utilisation des sessions dans les scénarios actives ou passives.  
  
 Pour ajouter des fonctionnalités aux types de jetons existants, que vous pouvez dériver le type spécifique et son gestionnaire de jetons associé pour prendre en charge tous les nouveaux éléments que vous ajoutez au jeton. Pour ajouter la prise en charge de nouveaux types de jetons, vous pouvez dériver directement à partir de la <xref:System.IdentityModel.Tokens.SecurityToken> classe. Lorsque vous faites cela, vous devez également créer une classe de gestionnaire de jetons en dérivant de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler> classe. Selon la façon dont votre jeton doit être utilisé, vous devez également créer un programme de résolution de jeton personnalisé en dérivant de la <xref:System.IdentityModel.Tokens.IssuerTokenResolver> de classe, ainsi qu’une ou plusieurs types de clause d’identificateur de clé personnalisée en dérivant de la <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause> classe.  
  
   
  
## Examples  
 Les exemples de code qui sont utilisés dans les <xref:System.IdentityModel.Tokens.SecurityToken> rubriques sont tirées de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui permettent le traitement des jetons SWT (Simple Web Tokens). Il inclut une implémentation d’un `SimpleWebToken` classe et un `SimpleWebTokenHandler` classe, ainsi que d’autres classes qui prennent en charge des jetons SWT. Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [exemple d’Index de Code WIF](~/docs/framework/security/wif-code-sample-index.md). Le code suivant illustre l’implémentation de la `SimpleWebToken` classe. Cette classe étend <xref:System.IdentityModel.Tokens.SecurityToken>.  
  
 [!code-csharp[WifCustomTokenST#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtokenconstants.cs#1)]  
[!code-csharp[WifCustomTokenST#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtoken.cs#2)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Vous devez substituer la <see cref="P:System.IdentityModel.Tokens.SecurityToken.Id" />, <see cref="P:System.IdentityModel.Tokens.SecurityToken.SecurityKeys" />, <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" />, et <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> propriétés. Le <see cref="M:System.IdentityModel.Tokens.SecurityToken.CanCreateKeyIdentifierClause``1" />, <see cref="M:System.IdentityModel.Tokens.SecurityToken.CreateKeyIdentifierClause``1" />, <see cref="M:System.IdentityModel.Tokens.SecurityToken.MatchesKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />, et <see cref="M:System.IdentityModel.Tokens.SecurityToken.ResolveKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" /> prend en charge les méthodes tous les identificateurs de clé de type <see cref="T:System.IdentityModel.Tokens.LocalIdKeyIdentifierClause" />. Vous devez substituer ces méthodes pour prendre en charge d’autres types d’identificateur de clé dans votre classe dérivée.</para>
    </block>
    <altmember cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" />
    <altmember cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
    <altmember cref="T:System.IdentityModel.Tokens.IssuerTokenResolver" />
    <altmember cref="T:System.IdentityModel.Tokens.LocalIdKeyIdentifierClause" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityToken ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityToken.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityToken();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Appelé par les constructeurs dans les classes dérivées pour initialiser la classe <see cref="T:System.IdentityModel.Tokens.SecurityToken" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanCreateKeyIdentifierClause&lt;T&gt;">
      <MemberSignature Language="C#" Value="public virtual bool CanCreateKeyIdentifierClause&lt;T&gt; () where T : System.IdentityModel.Tokens.SecurityKeyIdentifierClause;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanCreateKeyIdentifierClause&lt;(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause) T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityToken.CanCreateKeyIdentifierClause``1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanCreateKeyIdentifierClause(Of T As SecurityKeyIdentifierClause) () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::IdentityModel::Tokens::SecurityKeyIdentifierClause virtual bool CanCreateKeyIdentifierClause();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">
          <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> qui spécifie l'identificateur de clé à créer.</typeparam>
        <summary>Obtient une valeur qui indique si ce jeton de sécurité est capable de créer l'identificateur de clé spécifié.</summary>
        <returns>
          <see langword="true" /> lorsque <paramref name="T" /> est de type <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.IdentityModel.Tokens.SecurityToken.CanCreateKeyIdentifierClause%2A> permet de déterminer si un jeton de sécurité peut créer un identificateur de clé spécifique. Pour créer l'identificateur de clé, appelez la méthode <xref:System.IdentityModel.Tokens.SecurityToken.CreateKeyIdentifierClause%2A>.  
  
 L’implémentation par défaut prend en charge les clauses d’identificateur de clé de type <xref:System.IdentityModel.Tokens.LocalIdKeyIdentifierClause>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.Tokens.SecurityToken.CreateKeyIdentifierClause``1" />
        <altmember cref="T:System.IdentityModel.Tokens.LocalIdKeyIdentifierClause" />
      </Docs>
    </Member>
    <Member MemberName="CreateKeyIdentifierClause&lt;T&gt;">
      <MemberSignature Language="C#" Value="public virtual T CreateKeyIdentifierClause&lt;T&gt; () where T : System.IdentityModel.Tokens.SecurityKeyIdentifierClause;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !!T CreateKeyIdentifierClause&lt;(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause) T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityToken.CreateKeyIdentifierClause``1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateKeyIdentifierClause(Of T As SecurityKeyIdentifierClause) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::IdentityModel::Tokens::SecurityKeyIdentifierClause virtual T CreateKeyIdentifierClause();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">
          <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> qui spécifie l'identificateur de clé à créer.</typeparam>
        <summary>Crée la clause d'identificateur de clé spécifiée.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> qui est une clause d'identificateur de clé pour le jeton de sécurité.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.IdentityModel.Tokens.SecurityToken.CanCreateKeyIdentifierClause%2A> permet de déterminer si un jeton de sécurité peut créer un identificateur de clé spécifique. Pour créer l'identificateur de clé, appelez la méthode <xref:System.IdentityModel.Tokens.SecurityToken.CreateKeyIdentifierClause%2A>.  
  
 L’implémentation par défaut prend en charge les clauses d’identificateur de clé de type <xref:System.IdentityModel.Tokens.LocalIdKeyIdentifierClause>. Si une clause d’identificateur de clé de type <xref:System.IdentityModel.Tokens.LocalIdKeyIdentifierClause> ne peut pas être créé, un <xref:System.NotSupportedException> est levée.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.Tokens.SecurityToken.CanCreateKeyIdentifierClause``1" />
        <altmember cref="T:System.IdentityModel.Tokens.LocalIdKeyIdentifierClause" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public abstract string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityToken.Id" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Id { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un identificateur unique du jeton de sécurité.</summary>
        <value>Identificateur unique du jeton de sécurité.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En général, lorsqu'un jeton de sécurité est sérialisé en XML, l'attribut `Id` pour le jeton de sécurité a la valeur de la propriété <xref:System.IdentityModel.Tokens.SecurityToken.Id%2A>.  
  
   
  
## Examples  
 Les exemples de code qui sont utilisés dans les <xref:System.IdentityModel.Tokens.SecurityToken> rubriques sont tirées de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui permettent le traitement des jetons SWT (Simple Web Tokens). Il inclut une implémentation d’un `SimpleWebToken` classe et un `SimpleWebTokenHandler` classe, ainsi que d’autres classes qui prennent en charge des jetons SWT. Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [exemple d’Index de Code WIF](~/docs/framework/security/wif-code-sample-index.md). Le code suivant illustre la substitution de la <xref:System.IdentityModel.Tokens.SecurityToken.Id%2A> propriété.  
  
 [!code-csharp[WifCustomTokenST#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtokenconstants.cs#1)]  
[!code-csharp[WifCustomTokenST#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtoken.cs#3)]  
[!code-csharp[WifCustomTokenST#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtoken.cs#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous devez substituer la <see cref="P:System.IdentityModel.Tokens.SecurityToken.Id" /> propriété.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MatchesKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool MatchesKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MatchesKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MatchesKeyIdentifierClause (keyIdentifierClause As SecurityKeyIdentifierClause) As Boolean" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MatchesKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ keyIdentifierClause);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public virtual bool MatchesKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause skiClause);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MatchesKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause skiClause) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityToken.MatchesKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MatchesKeyIdentifierClause (skiClause As SecurityKeyIdentifierClause) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MatchesKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ skiClause);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="skiClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyIdentifierClause">To be added.</param>
        <param name="skiClause">To be added.</param>
        <summary>Retourne une valeur qui indique si l'identificateur de clé pour cette instance peut être résolu à la clause d'identificateur de clé spécifiée.</summary>
        <returns>
          <see langword="true" /> si <paramref name="keyIdentifierClause" /> est un <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> et qu'il a le même identificateur unique que la propriété <see cref="P:System.IdentityModel.Tokens.SecurityToken.Id" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut prend en charge les clauses d’identificateur de clé de type <xref:System.IdentityModel.Tokens.LocalIdKeyIdentifierClause>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IdentityModel.Tokens.LocalIdKeyIdentifierClause" />
      </Docs>
    </Member>
    <Member MemberName="ResolveKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKey ResolveKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKey ResolveKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveKeyIdentifierClause (keyIdentifierClause As SecurityKeyIdentifierClause) As SecurityKey" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKey ^ ResolveKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ keyIdentifierClause);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKey ResolveKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause skiClause);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKey ResolveKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause skiClause) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityToken.ResolveKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveKeyIdentifierClause (skiClause As SecurityKeyIdentifierClause) As SecurityKey" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKey ^ ResolveKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ skiClause);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="skiClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyIdentifierClause">To be added.</param>
        <param name="skiClause">To be added.</param>
        <summary>Obtient la clé pour la clause d'identificateur de clé spécifiée.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Tokens.SecurityKey" /> qui représente la clé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.IdentityModel.Tokens.SecurityToken.ResolveKeyIdentifierClause%2A> appelle le <xref:System.IdentityModel.Tokens.SecurityToken.MatchesKeyIdentifierClause%2A> pour déterminer en premier lieu si la clause d'identificateur de clé spécifiée est la même que cette instance.  
  
 L’implémentation par défaut retourne le premier élément de la <xref:System.IdentityModel.Tokens.SecurityToken.SecurityKeys%2A> collection si la collection n’est pas vide et si <xref:System.IdentityModel.Tokens.SecurityToken.MatchesKeyIdentifierClause%2A> retourne `true`; sinon, elle retourne `null`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lorsque vous héritez de <see cref="T:System.IdentityModel.Tokens.SecurityToken" />,  que vous implémentez la méthode <see cref="M:System.IdentityModel.Tokens.SecurityToken.ResolveKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" /> et que <paramref name="keyIdentifierClause" /> ne peut être résolu, retournez <see langword="null" />. Aucune exception ne doit être levée à partir de la méthode <see cref="M:System.IdentityModel.Tokens.SecurityToken.ResolveKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />.</para>
        </block>
        <altmember cref="M:System.IdentityModel.Tokens.SecurityToken.MatchesKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
        <altmember cref="T:System.IdentityModel.Tokens.LocalIdKeyIdentifierClause" />
      </Docs>
    </Member>
    <Member MemberName="SecurityKeys">
      <MemberSignature Language="C#" Value="public abstract System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.Tokens.SecurityKey&gt; SecurityKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.Tokens.SecurityKey&gt; SecurityKeys" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityToken.SecurityKeys" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property SecurityKeys As ReadOnlyCollection(Of SecurityKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::Tokens::SecurityKey ^&gt; ^ SecurityKeys { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::Tokens::SecurityKey ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.Tokens.SecurityKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les clés de chiffrement associées au jeton de sécurité.</summary>
        <value>
          <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de type <see cref="T:System.IdentityModel.Tokens.SecurityKey" /> qui contient l'ensemble de clés associé au jeton de sécurité.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IdentityModel.Tokens.SamlSecurityToken.SecurityKeys%2A> propriété à définir les clés de chiffrement pour ce jeton de sécurité protéger les jetons ou un message SOAP. Les clés peuvent être utilisées, entre autres choses, pour signer numériquement ou chiffrer des jetons ou des messages SOAP.  
  
   
  
## Examples  
 Les exemples de code qui sont utilisés dans les <xref:System.IdentityModel.Tokens.SecurityToken> rubriques sont tirées de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui permettent le traitement des jetons SWT (Simple Web Tokens). Il inclut une implémentation d’un `SimpleWebToken` classe et un `SimpleWebTokenHandler` classe, ainsi que d’autres classes qui prennent en charge des jetons SWT. Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [exemple d’Index de Code WIF](~/docs/framework/security/wif-code-sample-index.md). Le code suivant illustre la substitution de la <xref:System.IdentityModel.Tokens.SecurityToken.SecurityKeys%2A> propriété.  
  
 [!code-csharp[WifCustomTokenST#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtokenconstants.cs#1)]  
[!code-csharp[WifCustomTokenST#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtoken.cs#3)]  
[!code-csharp[WifCustomTokenST#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtoken.cs#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous devez substituer la <see cref="P:System.IdentityModel.Tokens.SecurityToken.SecurityKeys" /> propriété.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ValidFrom">
      <MemberSignature Language="C#" Value="public abstract DateTime ValidFrom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ValidFrom" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ValidFrom As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property DateTime ValidFrom { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le premier instant auquel ce jeton de sécurité est valide.</summary>
        <value>
          <see cref="T:System.DateTime" /> qui représente le premier instant auquel ce jeton de sécurité est valide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les propriétés <xref:System.IdentityModel.Tokens.SecurityToken.ValidFrom%2A> et <xref:System.IdentityModel.Tokens.SecurityToken.ValidTo%2A> permettent de déterminer la période pendant laquelle un jeton <xref:System.IdentityModel.Tokens.SecurityToken> est valide. Les propriétés <xref:System.IdentityModel.Tokens.SecurityToken.ValidFrom%2A> et <xref:System.IdentityModel.Tokens.SecurityToken.ValidTo%2A> représentent respectivement le premier et le dernier instant auxquels le jeton de sécurité est valide.  
  
   
  
## Examples  
 Les exemples de code qui sont utilisés dans les <xref:System.IdentityModel.Tokens.SecurityToken> rubriques sont tirées de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui permettent le traitement des jetons SWT (Simple Web Tokens). Il inclut une implémentation d’un `SimpleWebToken` classe et un `SimpleWebTokenHandler` classe, ainsi que d’autres classes qui prennent en charge des jetons SWT. Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [exemple d’Index de Code WIF](~/docs/framework/security/wif-code-sample-index.md). Le code suivant illustre la substitution de la <xref:System.IdentityModel.Tokens.SecurityToken.ValidFrom%2A> propriété.  
  
 [!code-csharp[WifCustomTokenST#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtokenconstants.cs#1)]  
[!code-csharp[WifCustomTokenST#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtoken.cs#3)]  
[!code-csharp[WifCustomTokenST#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtoken.cs#6)]  
[!code-csharp[WifCustomTokenST#8](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtoken.cs#8)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous devez substituer la <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" /> propriété.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ValidTo">
      <MemberSignature Language="C#" Value="public abstract DateTime ValidTo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ValidTo" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ValidTo As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property DateTime ValidTo { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le dernier instant auquel ce jeton de sécurité est valide.</summary>
        <value>
          <see cref="T:System.DateTime" /> qui représente le dernier instant auquel ce jeton de sécurité est valide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les propriétés <xref:System.IdentityModel.Tokens.SecurityToken.ValidFrom%2A> et <xref:System.IdentityModel.Tokens.SecurityToken.ValidTo%2A> permettent de déterminer la période pendant laquelle un jeton <xref:System.IdentityModel.Tokens.SecurityToken> est valide. Les propriétés <xref:System.IdentityModel.Tokens.SecurityToken.ValidFrom%2A> et <xref:System.IdentityModel.Tokens.SecurityToken.ValidTo%2A> représentent respectivement le premier et le dernier instant auxquels le jeton de sécurité est valide.  
  
   
  
## Examples  
 Les exemples de code qui sont utilisés dans les <xref:System.IdentityModel.Tokens.SecurityToken> rubriques sont tirées de la `Custom Token` exemple. Cet exemple fournit des classes personnalisées qui permettent le traitement des jetons SWT (Simple Web Tokens). Il inclut une implémentation d’un `SimpleWebToken` classe et un `SimpleWebTokenHandler` classe, ainsi que d’autres classes qui prennent en charge des jetons SWT. Pour plus d’informations sur cet exemple et d’autres exemples disponibles pour WIF et où les télécharger, consultez [exemple d’Index de Code WIF](~/docs/framework/security/wif-code-sample-index.md). Le code suivant illustre la substitution de la <xref:System.IdentityModel.Tokens.SecurityToken.ValidTo%2A> propriété.  
  
 [!code-csharp[WifCustomTokenST#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtokenconstants.cs#1)]  
[!code-csharp[WifCustomTokenST#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtoken.cs#3)]  
[!code-csharp[WifCustomTokenST#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtoken.cs#7)]  
[!code-csharp[WifCustomTokenST#8](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokenst/cs/simplewebtoken/simplewebtoken.cs#8)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Vous devez substituer la <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> propriété.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>