<Type Name="SessionSecurityTokenHandler" FullName="System.IdentityModel.Tokens.SessionSecurityTokenHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="90a1fcded2108cbac55b6246d2cf8f9a7ea209d5" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51897676" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SessionSecurityTokenHandler : System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SessionSecurityTokenHandler extends System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class SessionSecurityTokenHandler&#xA;Inherits SecurityTokenHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class SessionSecurityTokenHandler : System::IdentityModel::Tokens::SecurityTokenHandler" />
  <TypeSignature Language="F#" Value="type SessionSecurityTokenHandler = class&#xA;    inherit SecurityTokenHandler" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Tokens.SecurityTokenHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> qui traite des jetons de sécurité de type <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> classe sérialise, désérialise et valide les jetons de session. Les jetons de session sont des jetons de type <xref:System.IdentityModel.Tokens.SessionSecurityToken>. Le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> classe sérialise les jetons vers et depuis le format du cookie. Par défaut, la classe sérialise les jetons en Feb2005 de Conversation WS-Secure ou WS-Secure Conversation 1.3 `<wsc:SecurityContextToken>` éléments. Les jetons de session sont utilisées par le <xref:System.IdentityModel.Services.WSFederationAuthenticationModule> (WSFAM) et le <xref:System.IdentityModel.Services.SessionAuthenticationModule> (SAM) pour stocker les informations relatives à une session, il s’agit principalement le <xref:System.Security.Claims.ClaimsPrincipal> associé à l’utilisateur authentifié et les heures de début et d’expiration de session.  
  
 Dans les scénarios passifs, le <xref:System.IdentityModel.Services.WSFederationAuthenticationModule> appelle le <xref:System.IdentityModel.Services.SessionAuthenticationModule> (SAM) dans le pipeline d’authentification pour créer un jeton de session à partir de la <xref:System.Security.Claims.ClaimsPrincipal> qui représente l’utilisateur authentifié. Le module SAM utilise son configuré <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> pour créer le jeton et de le sérialiser dans un cookie (et pour désérialiser le jeton à partir d’un cookie pour les requêtes ultérieures). Le module SAM utilise une instance de son configuré <xref:System.IdentityModel.Services.CookieHandler> classe à écrire le cookie dans la réponse HTTP. Ce cookie est ensuite renvoyé au client et sur les demandes suivantes, le client peut présenter le cookie, plutôt que d’effectuer un aller-retour au fournisseur d’identité pour obtenir un jeton de sécurité à nouveau. Pour plus d’informations sur le fonctionnement des sessions avec WIF, consultez [gestion de Session WIF](~/docs/framework/security/wif-session-management.md).  
  
> [!NOTE]
>  Le \<securityTokenHandlers > élément de configuration peut être utilisé pour spécifier un <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> qui a la responsabilité pour la sécurisation des sessions de l’application. Les développeurs doivent utiliser attention lorsque vous modifiez ce paramètre de configuration, comme un système mal configuré peut entraîner de compromission de l’application. Par exemple, en spécifiant un lien hypertexte dérivé «http://msdn.microsoft.com/library/hh193426%28v=vs.110%29.aspx"\t « _blank » <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> et en passant une collection de transformations (CookieTransform) vide à la base, correspond à l’identité des utilisateurs en cours de sérialisation dans un cookie qui n’était pas protégé. Cela pourrait permettre un attaquant de modifier l’identité et par conséquent les privilèges d’accès.  
  
 Si le jeton de session est en mode de référence, autrement dit, son <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> propriété est `true`, la session de gestionnaire de jetons sérialise uniquement les propriétés de jeton de session qui sont nécessaires pour régénérer la clé dans le <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>. Dans le cas par défaut, le <xref:System.IdentityModel.Tokens.SessionSecurityTokenCacheKey> classe est utilisée pour représenter les clés de cache, et le Gestionnaire de jetons écrit le <xref:System.IdentityModel.Tokens.SessionSecurityToken.ContextId%2A?displayProperty=nameWithType> et <xref:System.IdentityModel.Tokens.SessionSecurityToken.KeyGeneration%2A?displayProperty=nameWithType> propriétés du jeton. Si le jeton de session n’est pas en mode de référence, autrement dit, le <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> propriété est `false`, outre les propriétés mentionnées précédemment, le gestionnaire appelle ensuite la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> méthode sur un tableau d’octets à partir duquel le jeton et les magasins sérialisé le valeur résultante dans le cookie ainsi. Pour plus d’informations sur la façon dont le jeton est sérialisé, consultez le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> (méthode).  
  
 Le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> propriété obtient la liste des transformations qui sont appliqués à la session de jeton dans le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> (méthode). Toutes les transformations dérivent la <xref:System.IdentityModel.CookieTransform> classe. Dans le cas par défaut le <xref:System.IdentityModel.DeflateCookieTransform> et <xref:System.IdentityModel.ProtectedDataCookieTransform> sont appliquées. Le <xref:System.IdentityModel.ProtectedDataCookieTransform> utilise l’API de Protection des données (DPAPI) pour protéger le matériel de cookie. DPAPI utilise une clé qui est spécifique à l’ordinateur sur lequel il est en cours d’exécution dans ses algorithmes de protection. Pour cette raison, le Gestionnaire de jetons de session par défaut n’est pas utilisable dans les scénarios de batterie de serveurs Web car, dans de tels scénarios, les jetons écrites sur un ordinateur peuvent devant être lus sur un autre ordinateur. Vous pouvez utiliser plusieurs stratégies pour contourner ce problème. Par exemple, vous pouvez :  
  
-   Remplacez la valeur par défaut <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> avec le <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>. Le <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler> vous permet de spécifier des clés de signature et le chiffrement sous ASP.NET `<machineKey>` élément dans le fichier de configuration.  
  
-   Fournir un gestionnaire pour le <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfigurationCreated?displayProperty=nameWithType> événement dans le fichier global.asax.cs et remplacez la session par défaut du gestionnaire avec une instance de jeton <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> qui a une liste des transformations qui inclut le <xref:System.IdentityModel.RsaSignatureCookieTransform> et <xref:System.IdentityModel.RsaEncryptionCookieTransform>. Vous pouvez créer la nouvelle instance en appelant un des constructeurs qui prend une liste des transformations.  
  
-   Dériver une transformation personnalisée à partir de la <xref:System.IdentityModel.CookieTransform> classe de base et utiliser la méthode ci-dessus pour l’inclure dans la liste des transformations à appliquer.  
  
-   Dériver à partir d’un gestionnaire de jetons personnalisé <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> et implémenter votre propre mécanisme.  
  
 Pour plus d’informations sur l’utilisation de sessions dans les scénarios de batterie de serveurs Web, consultez [WIF et batteries de serveurs Web](~/docs/framework/security/wif-and-web-farms.md).  
  
 Le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> est inclus dans la collection de gestionnaires de jetons par défaut ; Toutefois, remplacez par un gestionnaire de jetons de session personnalisée en spécifiant au préalable un [ &lt;supprimer&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md) élément sous le [ &lt;securityTokenHandlers&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) élément à supprimer le gestionnaire par défaut à partir de la collection, puis en ajoutant votre gestionnaire de jetons personnalisé à l’aide de la [ &lt;ajouter&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) élément. Par défaut, vous pouvez spécifier la durée de vie de jeton par défaut en incluant le [ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) élément sous le `<add>` élément. Vous pouvez concevoir un gestionnaire de jetons personnalisé à des éléments de configuration personnalisée sous la `<add>` élément en substituant le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration%2A> méthode pour fournir la logique pour les traiter.  
  
   
  
## Examples  
 Le code XML suivant montre comment remplacer le Gestionnaire de jetons de sécurité session de valeur par défaut dans une collection de gestionnaires de jetons avec une instance de la <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler> classe dans la configuration.  
  
```xml  
<securityTokenHandlers>  
  <remove type="System.IdentityModel.Tokens.SessionSecurityTokenHandler, System.IdentityModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  <add type="System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
</securityTokenHandlers>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SessionSecurityTokenCache" />
    <altmember cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />
    <altmember cref="T:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler" />
    <altmember cref="T:System.IdentityModel.CookieTransform" />
    <related type="Article" href="https://msdn.microsoft.com/library/496a1735-cbb7-49d5-a6aa-dd5550462073">&lt;sessionTokenRequirement&gt;</related>
    <related type="Article" href="https://msdn.microsoft.com/library/fc3cd7fa-2b45-4614-a44f-8fa9b9d15284">WIF et batteries de serveurs web</related>
    <related type="Article" href="https://msdn.microsoft.com/library/98bce126-18a9-401b-b20d-67ee462a5f8a">Gestion de session WIF</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> qui utilise les transformations de cookies et la durée de vie de jeton par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> et <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> propriétés sont initialisées à <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime> et <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; transforms);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; transforms) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.CookieTransform})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transforms As ReadOnlyCollection(Of CookieTransform))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Tokens.SessionSecurityTokenHandler : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; -&gt; System.IdentityModel.Tokens.SessionSecurityTokenHandler" Usage="new System.IdentityModel.Tokens.SessionSecurityTokenHandler transforms" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" />
      </Parameters>
      <Docs>
        <param name="transforms">Transformations à appliquer lors de l'encodage ou du décodage du cookie. Définit la propriété <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> qui utilise les transformations de cookies spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propriété <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> est initialisée à <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transforms" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; transforms, TimeSpan tokenLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; transforms, valuetype System.TimeSpan tokenLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.CookieTransform},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transforms As ReadOnlyCollection(Of CookieTransform), tokenLifetime As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms, TimeSpan tokenLifetime);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.Tokens.SessionSecurityTokenHandler : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; * TimeSpan -&gt; System.IdentityModel.Tokens.SessionSecurityTokenHandler" Usage="new System.IdentityModel.Tokens.SessionSecurityTokenHandler (transforms, tokenLifetime)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" />
        <Parameter Name="tokenLifetime" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="transforms">Transformations à appliquer lors de l'encodage ou du décodage du cookie. Définit la propriété <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />.</param>
        <param name="tokenLifetime">Durée de vie par défaut d'un jeton. Définit la propriété <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> qui utilise les transformations de cookies et la durée de vie de jeton spécifiées.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transforms" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="tokenLifetime" /> est inférieur ou égal à <see cref="F:System.TimeSpan.Zero" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyTransforms">
      <MemberSignature Language="C#" Value="protected virtual byte[] ApplyTransforms (byte[] cookie, bool outbound);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] ApplyTransforms(unsigned int8[] cookie, bool outbound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ApplyTransforms (cookie As Byte(), outbound As Boolean) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ApplyTransforms(cli::array &lt;System::Byte&gt; ^ cookie, bool outbound);" />
      <MemberSignature Language="F#" Value="abstract member ApplyTransforms : byte[] * bool -&gt; byte[]&#xA;override this.ApplyTransforms : byte[] * bool -&gt; byte[]" Usage="sessionSecurityTokenHandler.ApplyTransforms (cookie, outbound)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Byte[]" />
        <Parameter Name="outbound" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cookie">Cookie qui sera transformé.</param>
        <param name="outbound">
          <see langword="true" /> si le cookie doit être encodé ; <see langword="false" /> si le cookie doit être décodé.</param>
        <summary>Applique les transformations spécifiées par la propriété <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> pour encoder ou décoder le cookie spécifié.</summary>
        <returns>Cookie encodé ou décodé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand un cookie d’encodage transforme sont appliquées dans l’ordre dans lequel ils apparaissent dans le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> propriété. Lors du décodage d’un cookie, elles sont appliquées dans l’ordre inverse.  
  
 Appelée à partir de la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A> et <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A> méthodes pour encoder et décoder le matériel de cookie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public override bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="sessionSecurityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> sur le <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> entrant. Le lecteur doit être placé au niveau d'un élément <see langword="&lt;wsc:SecurityContextToken&gt;" />.</param>
        <summary>Retourne une valeur qui indique si le lecteur est positionné sur un élément <see langword="&lt;wsc:SecurityContextToken&gt;" /> .</summary>
        <returns>
          <see langword="true" /> si le lecteur pointe sur un élément <see langword="&lt;wsc:SecurityContextToken&gt;" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public override bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce gestionnaire prend en charge la validation des jetons du type <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <value>
          <see langword="true" /> si le gestionnaire prend en charge la validation des jetons du type <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> ; sinon <see langword="false" />. Toujours <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public override bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce gestionnaire peut écrire les jetons de type <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <value>
          <see langword="true" /> si le gestionnaire peut écrire des jetons de type <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> ; sinon, <see langword="false" />. Toujours <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieElementName">
      <MemberSignature Language="C#" Value="public virtual string CookieElementName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CookieElementName" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CookieElementName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CookieElementName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieElementName : string" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de l'élément de cookie.</summary>
        <value>Nom de l'élément de cookie. Le nom d’élément par défaut est « Cookie ».</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est utilisée dans le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A> et <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A> méthodes pour déterminer l’élément sous lequel le matériel de jeton encodé doit être écrit ou lu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      </Docs>
    </Member>
    <Member MemberName="CookieNamespace">
      <MemberSignature Language="C#" Value="public virtual string CookieNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CookieNamespace" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CookieNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CookieNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieNamespace : string" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'espace de noms pour l'élément de cookie.</summary>
        <value>Espace de noms pour l'élément de cookie. L’espace de noms par défaut est «http://schemas.microsoft.com/ws/2006/05/security».</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est utilisée dans le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A> et <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A> méthodes pour déterminer l’espace de noms de l’élément sous lequel le matériel de jeton encodé doit être écrit ou lu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken (System.Security.Claims.ClaimsPrincipal principal, string context, string endpointId, DateTime validFrom, DateTime validTo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken(class System.Security.Claims.ClaimsPrincipal principal, string context, string endpointId, valuetype System.DateTime validFrom, valuetype System.DateTime validTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CreateSessionSecurityToken(System.Security.Claims.ClaimsPrincipal,System.String,System.String,System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSessionSecurityToken (principal As ClaimsPrincipal, context As String, endpointId As String, validFrom As DateTime, validTo As DateTime) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SessionSecurityToken ^ CreateSessionSecurityToken(System::Security::Claims::ClaimsPrincipal ^ principal, System::String ^ context, System::String ^ endpointId, DateTime validFrom, DateTime validTo);" />
      <MemberSignature Language="F#" Value="abstract member CreateSessionSecurityToken : System.Security.Claims.ClaimsPrincipal * string * string * DateTime * DateTime -&gt; System.IdentityModel.Tokens.SessionSecurityToken&#xA;override this.CreateSessionSecurityToken : System.Security.Claims.ClaimsPrincipal * string * string * DateTime * DateTime -&gt; System.IdentityModel.Tokens.SessionSecurityToken" Usage="sessionSecurityTokenHandler.CreateSessionSecurityToken (principal, context, endpointId, validFrom, validTo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="endpointId" Type="System.String" />
        <Parameter Name="validFrom" Type="System.DateTime" />
        <Parameter Name="validTo" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="principal">Principal des revendications.</param>
        <param name="context">Chaîne de contexte définie par l'appelant.</param>
        <param name="endpointId">Identificateur du point de terminaison auquel le jeton est étendu.</param>
        <param name="validFrom">Instant auquel le jeton devient non valide.</param>
        <param name="validTo">Instant après lequel le jeton n'est plus valide.</param>
        <summary>Crée un <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> en fonction du principal des revendications spécifié et de la plage horaire pendant laquelle le jeton est valide.</summary>
        <returns>Jeton de sécurité de session qui a été créé. Les propriétés du nouveau jeton de session sont définies en fonction des paramètres spécifiés.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">Descripteur de jeton à partir duquel créer le jeton.</param>
        <summary>Crée un jeton de sécurité en fonction du descripteur de jetons spécifié.</summary>
        <returns>Jeton de sécurité de session qui a été créé. Il s'agira d'une instance de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée et retourne un jeton de sécurité de session en utilisant les propriétés suivantes dans le descripteur de jeton : <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A?displayProperty=nameWithType>, et <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A?displayProperty=nameWithType>. Si le <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.SaveBootstrapContext%2A?displayProperty=nameWithType> propriété a la valeur `true` sur la configuration du Gestionnaire de jeton spécifiée par le <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> propriété, le contexte de démarrage est créé à partir de la <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Token%2A?displayProperty=nameWithType> propriété et est enregistré dans le jeton de session.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tokenDescriptor" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultCookieTransforms">
      <MemberSignature Language="C#" Value="public static readonly System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; DefaultCookieTransforms;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; DefaultCookieTransforms" />
      <MemberSignature Language="DocId" Value="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultCookieTransforms As ReadOnlyCollection(Of CookieTransform) " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ DefaultCookieTransforms;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultCookieTransforms : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Collection en lecture seule qui contient la liste des transformations par défaut à appliquer aux cookies, à <see cref="T:System.IdentityModel.DeflateCookieTransform" /> et à <see cref="T:System.IdentityModel.ProtectedDataCookieTransform" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultLifetime">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan DefaultLifetime;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan DefaultLifetime" />
      <MemberSignature Language="DocId" Value="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultLifetime As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan DefaultLifetime;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultLifetime : TimeSpan" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Constante qui spécifie la durée de vie par défaut des cookies, soit dix heures.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultTokenLifetime">
      <MemberSignature Language="C#" Value="public static TimeSpan DefaultTokenLifetime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.TimeSpan DefaultTokenLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultTokenLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultTokenLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeSpan DefaultTokenLifetime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultTokenLifetime : TimeSpan" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultTokenLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la durée de vie du jeton par défaut.</summary>
        <value>Durée de vie du jeton par défaut. Toujours <see cref="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public override string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="override this.GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="sessionSecurityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient les URI d'identificateur de type de jeton pour les types de jetons qui peuvent être gérés par ce gestionnaire.</summary>
        <returns>URI d'identificateur de type de jeton pour les types de jetons qui peuvent être gérés par ce gestionnaire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI des types suivants sont pris en charge : «http://schemas.microsoft.com/ws/2006/05/servicemodel/tokens/SecureConversation«, »http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/sct», et «http://schemas.xmlsoap.org/ws/2005/02/sc/sct».  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public override void LoadCustomConfiguration (System.Xml.XmlNodeList customConfigElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList customConfigElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub LoadCustomConfiguration (customConfigElements As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void LoadCustomConfiguration(System::Xml::XmlNodeList ^ customConfigElements);" />
      <MemberSignature Language="F#" Value="override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="sessionSecurityTokenHandler.LoadCustomConfiguration customConfigElements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customConfigElements" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="customConfigElements">Éléments de configuration personnalisée.</param>
        <summary>Charge la configuration personnalisée à partir du XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelée par l’infrastructure de configuration pour initialiser le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> instance. Initialise le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> propriété à partir de la `lifetime` attribut de la [ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) élément dans le fichier de configuration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customConfigElements" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La configuration spécifiée par <paramref name="customConfigElements" /> n'est pas valide. Par exemple, il ne contient pas d'élément <see langword="&lt;sessionTokenRequirement&gt;" />, il contient plusieurs éléments <see langword="&lt;sessionTokenRequirement&gt;" />, une valeur <see cref="T:System.TimeSpan" /> valide ne peut pas être lue à partir de l'attribut <see langword="lifetime" />, ou l'attribut <see langword="lifetime" /> spécifie une valeur inférieure à <see cref="F:System.TimeSpan.Zero" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/496a1735-cbb7-49d5-a6aa-dd5550462073">&lt;sessionTokenRequirement&gt;</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit un <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]

 L’implémentation par défaut désérialise le jeton à partir d’un Feb2005 de Conversation WS-Secure ou WS-Secure Conversation 1.3 `<wsc:SecurityContextToken>` élément.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> sur le <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> entrant.</param>
        <summary>Lit le <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> à l'aide du lecteur XML spécifié.</summary>
        <returns>Jeton de sécurité de session qui a été lu, instance <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]

 Le lecteur doit être positionné sur un Feb2005 WS-Secure de Conversation ou un WS-Secure Conversation 1.3 `<wsc:SecurityContextToken>` élément.  
  
 L’implémentation par défaut appelle la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%28System.Xml.XmlReader%2CSystem.IdentityModel.Selectors.SecurityTokenResolver%29?displayProperty=nameWithType> méthode à l’aide d’un programme de résolution de jeton par défaut.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">Le lecteur n'est pas positionné sur un <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> ou <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> ne peut pas être lu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (byte[] token, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(unsigned int8[] token, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (token As Byte(), tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(cli::array &lt;System::Byte&gt; ^ token, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="override this.ReadToken : byte[] * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.ReadToken (token, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.Byte[]" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="token">Flux d'octets qui contient le jeton.</param>
        <param name="tokenResolver">Programme de résolution du jeton à employer.</param>
        <summary>Lit le <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> d'un flux d'octets à l'aide du programme de résolution de jetons spécifié.</summary>
        <returns>Le <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> qui a été lu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]

 L’implémentation par défaut crée un <xref:System.Xml.XmlDictionaryReader> sur le jeton et appelle le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%28System.Xml.XmlReader%2CSystem.IdentityModel.Selectors.SecurityTokenResolver%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="sessionSecurityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> sur le <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> entrant.</param>
        <param name="tokenResolver">
          <see cref="T:System.IdentityModel.Selectors.SecurityTokenResolver" /> qui peut être utilisé pour corriger <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Lit le <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> à l'aide du lecteur XML et du programme de résolution de jeton spécifiés.</summary>
        <returns>Jeton de sécurité de session qui a été lu, instance <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]

 Le lecteur doit être positionné sur un Feb2005 WS-Secure de Conversation ou un WS-Secure Conversation 1.3 `<wsc:SecurityContextToken>` élément.  
  
 Si le matériel de jeton est mis en cache, il est lu à partir du cache de jeton, qui est une instance de la <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache> classe. Sinon, le matériel de jeton est lu à partir de l’élément enfant de le `<wsc:SecurityContextToken>` élément qui est spécifié par le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName%2A> et <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace%2A> propriétés et le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> méthode est appelée pour décoder le cookie.  
  
 Pour plus d’informations sur la façon dont les jetons de session sont sérialisés dans un `<SecurityContextToken` élément, consultez le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="tokenResolver" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">Le lecteur n'est pas positionné sur un <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> ou <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> ne peut pas être lu.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetTransforms">
      <MemberSignature Language="C#" Value="protected void SetTransforms (System.Collections.Generic.IEnumerable&lt;System.IdentityModel.CookieTransform&gt; transforms);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTransforms(class System.Collections.Generic.IEnumerable`1&lt;class System.IdentityModel.CookieTransform&gt; transforms) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.SetTransforms(System.Collections.Generic.IEnumerable{System.IdentityModel.CookieTransform})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTransforms (transforms As IEnumerable(Of CookieTransform))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTransforms(System::Collections::Generic::IEnumerable&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms);" />
      <MemberSignature Language="F#" Value="member this.SetTransforms : seq&lt;System.IdentityModel.CookieTransform&gt; -&gt; unit" Usage="sessionSecurityTokenHandler.SetTransforms transforms" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.Generic.IEnumerable&lt;System.IdentityModel.CookieTransform&gt;" />
      </Parameters>
      <Docs>
        <param name="transforms">Transformations à utiliser.</param>
        <summary>Définit les transformations qui seront appliquées aux cookies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définit la liste des transformations que retourné par la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> propriété. Transformations sont appliquées dans l’ordre dans lequel ils apparaissent dans la liste lors de l’encodage d’un cookie et dans l’ordre inverse lors du décodage d’un cookie.  
  
> [!WARNING]
>  Si le `transforms` paramètre est `null`, une exception est levée à partir de la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> méthode lorsqu’elle est appelée pour coder ou décoder le cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenLifetime">
      <MemberSignature Language="C#" Value="public virtual TimeSpan TokenLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TokenLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property TokenLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property TimeSpan TokenLifetime { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TokenLifetime : TimeSpan with get, set" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la durée de vie du jeton.</summary>
        <value>Durée de vie du jeton. La valeur par défaut est <see cref="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, si le [ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) élément est spécifié dans le fichier de configuration, le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> propriété est initialisée à la valeur de la `lifetime` l’attribut par le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une tentative d'affectation d'un intervalle de temps inférieur ou égal à zéro se produit.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/496a1735-cbb7-49d5-a6aa-dd5550462073">&lt;sessionTokenRequirement&gt;</related>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public override Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de jetons traités par ce gestionnaire.</summary>
        <value>
          <see cref="T:System.Type" /> de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transforms">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; Transforms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; Transforms" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transforms As ReadOnlyCollection(Of CookieTransform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ Transforms { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Transforms : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" Usage="System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les transformations qui seront appliquées au cookie.</summary>
        <value>Liste des transformations qui seront appliquées au cookie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les transformations sont appliquées dans le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateSession">
      <MemberSignature Language="C#" Value="protected virtual void ValidateSession (System.IdentityModel.Tokens.SessionSecurityToken securityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateSession(class System.IdentityModel.Tokens.SessionSecurityToken securityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateSession(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateSession (securityToken As SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateSession(System::IdentityModel::Tokens::SessionSecurityToken ^ securityToken);" />
      <MemberSignature Language="F#" Value="abstract member ValidateSession : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit&#xA;override this.ValidateSession : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit" Usage="sessionSecurityTokenHandler.ValidateSession securityToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="securityToken">Jeton à vérifier.</param>
        <summary>Détermine si la session associée au jeton spécifié est toujours valide. La validité est déterminée en vérifiant les propriétés <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" /> et <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> du jeton spécifié. Exception levée si la session n'est plus valide.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeton n’est pas valide si sa <xref:System.IdentityModel.Tokens.SecurityToken.ValidFrom%2A> propriété est définie sur une valeur qui se produit ultérieurement à <xref:System.DateTime.UtcNow%2A>, ou si son <xref:System.IdentityModel.Tokens.SecurityToken.ValidTo%2A> propriété est définie sur une valeur qui se produit antérieure à <xref:System.DateTime.UtcNow%2A>.  
  
 Appelée à partir de la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%2A> méthodes pour valider la session.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityToken" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenNotYetValidException">La propriété <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" /> du jeton est postérieure à <see cref="P:System.DateTime.UtcNow" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenExpiredException">La propriété <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> du jeton est antérieure à <see cref="P:System.DateTime.UtcNow" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Valide un jeton et retourne ses revendications.</summary>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public override System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="sessionSecurityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Jeton à valider. Doit être attribuable à partir de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Valide le jeton spécifié et retourne ses revendications.</summary>
        <returns>Identités contenues dans le jeton.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelle le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateSession%2A> méthode pour valider le jeton.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="token" />
          <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> n’est pas attribuable à partir de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SessionSecurityToken token, string endpointId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SessionSecurityToken token, string endpointId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SessionSecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SessionSecurityToken, endpointId As String) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SessionSecurityToken ^ token, System::String ^ endpointId);" />
      <MemberSignature Language="F#" Value="override this.ValidateToken : System.IdentityModel.Tokens.SessionSecurityToken * string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="sessionSecurityTokenHandler.ValidateToken (token, endpointId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
        <Parameter Name="endpointId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">Jeton à valider. Doit être attribuable à partir de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <param name="endpointId">Identificateur du point de terminaison auquel le jeton est étendu.</param>
        <summary>Valide le jeton de session spécifié et retourne ses revendications.</summary>
        <returns>Identités contenues dans le jeton.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Effectue une vérification pour vous assurer que le jeton spécifié est étendu pour l’ID de point de terminaison spécifié et, si tel est le cas, appelle le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%28System.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> méthode ; sinon, lève un <xref:System.IdentityModel.Tokens.SecurityTokenException>.  
  
> [!IMPORTANT]
>  Les jetons de session qui ont un <xref:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId%2A> propriété `null` ou vides sont considérées comme à être une étendue globale. Cela pose un risque de sécurité potentiel. C’est pourquoi vous devez vous assurer que le <xref:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId%2A> propriété est définie dans les jetons de session.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="token" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="endpointId" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> n’est pas attribuable à partir de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">La propriété <see cref="P:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId" /> du jeton spécifié n'a pas la valeur <see langword="null" /> ou n'est pas vide et sa valeur est différente de celle spécifiée par le paramètre <paramref name="endpointId" />.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sérialise un jeton.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut sérialise le jeton dans un Feb2005 de Conversation WS-Secure ou WS-Secure Conversation 1.3 `<wsc:SecurityContextToken>` élément.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual byte[] WriteToken (System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] WriteToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (sessionToken As SessionSecurityToken) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ WriteToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken);" />
      <MemberSignature Language="F#" Value="override this.WriteToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; byte[]" Usage="sessionSecurityTokenHandler.WriteToken sessionToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Jeton à écrire.</param>
        <summary>Sérialise le jeton spécifié dans un tableau d'octets.</summary>
        <returns>Tableau d'octets encodé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sérialise le jeton spécifié par la création et le writer XML sur un <xref:System.IO.MemoryStream> et en appelant le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> (méthode). Cette surcharge pour plus d’informations, consultez.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sessiontoken" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public override void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="sessionSecurityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">Writer XML avec lequel sérialiser le jeton.</param>
        <param name="token">Jeton à sérialiser. Instance de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Sérialise le jeton spécifié à l'aide du writer XML spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut sérialise le jeton spécifié soit en tant que WS-Secure de Feb2005 de Conversation ou WS-Secure Conversation 1.3 `<wsc:SecurityContextToken>` élément, selon la valeur de la <xref:System.IdentityModel.Tokens.SessionSecurityToken.SecureConversationVersion%2A?displayProperty=nameWithType> propriété. Le <xref:System.IdentityModel.Tokens.SessionSecurityToken.Id%2A?displayProperty=nameWithType> propriété est sérialisée comme le `Id` attribut. Le <xref:System.IdentityModel.Tokens.SessionSecurityToken.ContextId%2A?displayProperty=nameWithType> propriété est sérialisée comme le `<Identifier>` élément enfant. Si ce n’est pas `null` le <xref:System.IdentityModel.Tokens.SessionSecurityToken.KeyGeneration%2A?displayProperty=nameWithType> propriété est sérialisée comme un `<Instance>` élément. Enfin, si le <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> propriété est `false`, le jeton entier est sérialisé dans un tableau binaire qui est transmis à la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> méthode à encoder. Le jeton encodé est ensuite écrites comme une valeur codée en base64 pour l’élément et l’espace de noms spécifié par le <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName%2A> et <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace%2A> propriétés. Si le <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> propriété est `true`, le jeton n’est pas sérialisé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="writer" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="token" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> n’est pas attribuable à partir de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.  
  
- ou - 
La propriété <see cref="P:System.IdentityModel.Tokens.SessionSecurityToken.SecureConversationVersion" /> du jeton spécifie une version de WS-Secure Conversation qui n'est pas prise en charge par le gestionnaire.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </Member>
  </Members>
</Type>