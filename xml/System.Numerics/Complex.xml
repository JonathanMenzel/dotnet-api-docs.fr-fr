<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="91e3f8eb255ecea49f114ef22b5e0be3116e0a0f" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52737033" /></Metadata><TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="60bda-101">Représente un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-101">Represents a complex number.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-102">Un nombre complexe est un nombre qui comprend une partie réelle et une partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="60bda-103">Un nombre complexe de z est généralement écrites sous la forme z = x + yi, où *x* et *y* sont des nombres réels, et *je* est l’unité imaginaire qui possède la propriété *i* <sup>2</sup> = -1.</span><span class="sxs-lookup"><span data-stu-id="60bda-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="60bda-104">La partie réelle du nombre complexe est représentée par *x*, et la partie imaginaire du nombre complexe est représentée par *y*.</span><span class="sxs-lookup"><span data-stu-id="60bda-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="60bda-105">Le <xref:System.Numerics.Complex> type utilise le système de coordonnées cartésiennes (réel, imaginaire) lors de l’instanciation et la manipulation des nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="60bda-106">Un nombre complexe peut être représenté comme un point dans un système de coordonnées à deux dimensions, ce qui est appelé le plan complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="60bda-107">La partie réelle du nombre complexe est positionnée sur l’axe des abscisses (l’axe horizontal), et la partie imaginaire est positionnée sur l’axe des ordonnées (axe vertical).</span><span class="sxs-lookup"><span data-stu-id="60bda-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="60bda-108">N’importe quel point dans le plan complexe peut également être exprimée en fonction de sa valeur absolue, en utilisant le système de coordonnées polaires.</span><span class="sxs-lookup"><span data-stu-id="60bda-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system.</span></span> <span data-ttu-id="60bda-109">Dans les coordonnées polaires, un point se caractérise par deux nombres :</span><span class="sxs-lookup"><span data-stu-id="60bda-109">In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="60bda-110">Sa grandeur, qui est la distance entre le point à partir de l’origine (autrement dit, 0,0, ou au point auquel l’axe des abscisses et l’axe des y).</span><span class="sxs-lookup"><span data-stu-id="60bda-110">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="60bda-111">Sa phase, qui est l’angle entre l’axe des réels et le trait dessiné depuis l’origine au point.</span><span class="sxs-lookup"><span data-stu-id="60bda-111">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="60bda-112">Instanciation d’un nombre complexe</span><span class="sxs-lookup"><span data-stu-id="60bda-112">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="60bda-113">Vous pouvez affecter une valeur à un nombre complexe dans une des manières suivantes :</span><span class="sxs-lookup"><span data-stu-id="60bda-113">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="60bda-114">En passant deux <xref:System.Double> valeurs à son constructeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-114">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="60bda-115">La première valeur représente la partie réelle du nombre complexe, et la deuxième valeur représente la partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-115">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="60bda-116">Ces valeurs représentent la position du nombre complexe dans le système de coordonnées cartésiennes à deux dimensions.</span><span class="sxs-lookup"><span data-stu-id="60bda-116">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="60bda-117">En appelant la méthode statique (`Shared` en Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> méthode pour créer un nombre complexe à partir de ses coordonnées polaires.</span><span class="sxs-lookup"><span data-stu-id="60bda-117">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="60bda-118">En attribuant un <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, ou <xref:System.Double> valeur un <xref:System.Numerics.Complex> objet.</span><span class="sxs-lookup"><span data-stu-id="60bda-118">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="60bda-119">La valeur devient la partie réelle du nombre complexe, et sa partie imaginaire est égal à 0.</span><span class="sxs-lookup"><span data-stu-id="60bda-119">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="60bda-120">En castant (en c#) ou en convertissant (en Visual Basic) un <xref:System.Decimal> ou <xref:System.Numerics.BigInteger> valeur un <xref:System.Numerics.Complex> objet.</span><span class="sxs-lookup"><span data-stu-id="60bda-120">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="60bda-121">La valeur devient la partie réelle du nombre complexe, et sa partie imaginaire est égal à 0.</span><span class="sxs-lookup"><span data-stu-id="60bda-121">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="60bda-122">En assignant le nombre complexe qui est retourné par une méthode ou un opérateur à un <xref:System.Numerics.Complex> objet.</span><span class="sxs-lookup"><span data-stu-id="60bda-122">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="60bda-123">Par exemple, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> est une méthode statique qui retourne un nombre complexe qui est la somme des deux nombres complexes, et le <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> opérateur ajoute deux nombres complexes et retourne le résultat.</span><span class="sxs-lookup"><span data-stu-id="60bda-123">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="60bda-124">L’exemple suivant illustre chacune de ces cinq façons d’affecter une valeur à un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-124">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="60bda-125">Opérations avec des nombres complexes</span><span class="sxs-lookup"><span data-stu-id="60bda-125">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="60bda-126">Le <xref:System.Numerics.Complex> structure dans le .NET Framework inclut des membres qui fournissent les fonctionnalités suivantes :</span><span class="sxs-lookup"><span data-stu-id="60bda-126">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="60bda-127">Méthodes permettant de comparer deux nombres complexes pour déterminer s’ils sont égaux.</span><span class="sxs-lookup"><span data-stu-id="60bda-127">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="60bda-128">Opérateurs pour effectuer des opérations arithmétiques sur les nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-128">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="60bda-129"><xref:System.Numerics.Complex> opérateurs permettent d’effectuer une addition, soustraction, multiplication, division et la négation unaire avec des nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-129"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="60bda-130">Méthodes pour effectuer d’autres opérations numériques sur les nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-130">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="60bda-131">Outre les quatre opérations arithmétiques base, vous pouvez déclencher un nombre complexe à une puissance spécifiée, recherche la racine carrée d’un nombre complexe et obtenir la valeur absolue d’un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-131">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="60bda-132">Méthodes pour effectuer des opérations trigonométriques sur les nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-132">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="60bda-133">Par exemple, vous pouvez calculer la tangente d’un angle représentée par un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-133">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="60bda-134">Notez que, étant donné que le <xref:System.Numerics.Complex.Real%2A> et <xref:System.Numerics.Complex.Imaginary%2A> propriétés sont en lecture seule, vous ne pouvez pas modifier la valeur d’un existant <xref:System.Numerics.Complex> objet.</span><span class="sxs-lookup"><span data-stu-id="60bda-134">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="60bda-135">Toutes les méthodes qui effectuent une opération sur un <xref:System.Numerics.Complex> number, si leur valeur de retour est de type <xref:System.Numerics.Complex>, retournent un nouvel <xref:System.Numerics.Complex> nombre.</span><span class="sxs-lookup"><span data-stu-id="60bda-135">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="60bda-136">Précision et nombres complexes</span><span class="sxs-lookup"><span data-stu-id="60bda-136">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="60bda-137">Les parties imaginaires et réelles d’un nombre complexe sont représentées par deux valeurs à virgule flottante double précision.</span><span class="sxs-lookup"><span data-stu-id="60bda-137">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="60bda-138">Cela signifie que <xref:System.Numerics.Complex> valeurs, telles que des valeurs à virgule flottante double précision, peuvent perdre en précision à la suite d’opérations numériques.</span><span class="sxs-lookup"><span data-stu-id="60bda-138">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="60bda-139">Cela signifie que stricte les comparaisons d’égalité de deux <xref:System.Numerics.Complex> valeurs peuvent échouer, même si la différence entre les deux valeurs est en raison d’une perte de précision.</span><span class="sxs-lookup"><span data-stu-id="60bda-139">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="60bda-140">Pour plus d'informations, consultez <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="60bda-140">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="60bda-141">Par exemple, l’exécution de l’élévation sur le logarithme d’un nombre doit retourner le nombre d’origine.</span><span class="sxs-lookup"><span data-stu-id="60bda-141">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="60bda-142">Toutefois, dans certains cas, la perte de précision de valeurs à virgule flottante peut entraîner légères différences entre les deux valeurs, comme l’illustre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="60bda-142">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="60bda-143">De même, l’exemple suivant, qui calcule la racine carrée d’un <xref:System.Numerics.Complex> number, produit des résultats légèrement différents sur les 32 bits et IA64 des versions du .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="60bda-143">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="60bda-144">Nombres complexes, l’infini et NaN</span><span class="sxs-lookup"><span data-stu-id="60bda-144">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="60bda-145">Les parties imaginaires et réelles d’un nombre complexe sont représentées par <xref:System.Double> valeurs.</span><span class="sxs-lookup"><span data-stu-id="60bda-145">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="60bda-146">En plus d’allant <xref:System.Double.MinValue?displayProperty=nameWithType> à <xref:System.Double.MaxValue?displayProperty=nameWithType>, la partie réelle ou imaginaire d’un nombre complexe peut avoir une valeur de <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, ou <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-146">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60bda-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, et <xref:System.Double.NaN?displayProperty=nameWithType> tous les propagent dans toutes les opérations arithmétiques ou trigonométriques.</span><span class="sxs-lookup"><span data-stu-id="60bda-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="60bda-148">Dans l’exemple suivant, la division par <xref:System.Numerics.Complex.Zero> produit un nombre complexe dont les parties réelles et imaginaires sont tous deux <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-148">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60bda-149">Par conséquent, l’exécution de la multiplication avec cette valeur produit également un nombre complexe dont les parties réelles et imaginaires sont <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-149">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60bda-150">De même, exécution d’une multiplication qui dépasse la plage de la <xref:System.Double> type génère un nombre complexe dont la partie réelle est <xref:System.Double.NaN?displayProperty=nameWithType> et dont la partie imaginaire est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-150">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60bda-151">Par la suite effectuer une division avec ce nombre complexe retourne un nombre complexe dont la partie réelle est <xref:System.Double.NaN?displayProperty=nameWithType> et dont la partie imaginaire est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-151">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="60bda-152">Les opérations mathématiques avec des nombres complexes qui ne sont pas valides ou qui dépassent la plage de la <xref:System.Double> type de données ne lèvent pas d’exception.</span><span class="sxs-lookup"><span data-stu-id="60bda-152">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="60bda-153">Au lieu de cela, elles retournent un <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, ou <xref:System.Double.NaN?displayProperty=nameWithType> dans les conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="60bda-153">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="60bda-154">La division d’un nombre positif par zéro retourne <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-154">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="60bda-155">Toute opération qui dépasse la limite supérieure de la <xref:System.Double> retourne de type de données <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-155">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="60bda-156">La division d’un nombre négatif par zéro retourne <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-156">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="60bda-157">Toute opération qui dépasse la limite inférieure de la <xref:System.Double> retourne de type de données <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-157">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="60bda-158">La division d’un zéro par zéro retourne <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-158">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="60bda-159">Toute opération qui est exécutée sur les opérandes dont les valeurs sont <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, ou <xref:System.Double.NaN?displayProperty=nameWithType> retourne <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, ou <xref:System.Double.NaN?displayProperty=nameWithType>, en fonction de l’opération spécifique.</span><span class="sxs-lookup"><span data-stu-id="60bda-159">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="60bda-160">Notez que cela s’applique à tous les calculs intermédiaires effectuées par une méthode.</span><span class="sxs-lookup"><span data-stu-id="60bda-160">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="60bda-161">Par exemple, la multiplication de `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` utilise la formule (ac - bd) + (ad + bc) je.</span><span class="sxs-lookup"><span data-stu-id="60bda-161">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="60bda-162">Le calcul du vrai composant qui résulte de la multiplication évalue l’expression 9e308 \* 2.5 - 9e308 \* 3.5.</span><span class="sxs-lookup"><span data-stu-id="60bda-162">The calculation of the real component that results from the multiplication evaluates the expression 9e308 \* 2.5 - 9e308 \* 3.5.</span></span> <span data-ttu-id="60bda-163">Chaque multiplication intermédiaire dans cette expression retourne <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>et la tentative de soustraire <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> de <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> retourne <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-163">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="60bda-164">Mise en forme d’un nombre complexe</span><span class="sxs-lookup"><span data-stu-id="60bda-164">Formatting a Complex Number</span></span>  
 <span data-ttu-id="60bda-165">Par défaut, la représentation sous forme de chaîne d’un nombre complexe prend la forme `(` *réel* `,` *imaginaire*`)`, où *réel* et *imaginaire* sont les représentations sous forme de chaîne de la <xref:System.Double> valeurs qui forment les composants réelle et imaginaire du nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-165">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="60bda-166">Certaines surcharges de la <xref:System.Numerics.Complex.ToString%2A> méthode permettent de personnaliser les représentations sous forme de chaîne de ces <xref:System.Double> valeurs afin de refléter les conventions de mise en forme d’une culture particulière ou de s’afficher dans un format particulier défini par une valeur numérique standard ou personnalisée chaîne de format.</span><span class="sxs-lookup"><span data-stu-id="60bda-166">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="60bda-167">(Pour plus d’informations, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="60bda-167">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="60bda-168">Une des façons plus courantes d’exprimer la représentation sous forme de chaîne d’un nombre complexe prend la forme a + bi, où un est le composant réel du nombre complexe, et b est le composant imaginaire du nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-168">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="60bda-169">En génie électrique, un nombre complexe est plus souvent exprimé comme un + bj.</span><span class="sxs-lookup"><span data-stu-id="60bda-169">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="60bda-170">Vous pouvez retourner la représentation sous forme de chaîne d’un nombre complexe dans un de ces deux formes.</span><span class="sxs-lookup"><span data-stu-id="60bda-170">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="60bda-171">Pour ce faire, définissez un fournisseur de format personnalisé en implémentant le <xref:System.ICustomFormatter> et <xref:System.IFormatProvider> interfaces, puis appelez le <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="60bda-171">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="60bda-172">L’exemple suivant définit un `ComplexFormatter` classe qui représente un nombre complexe en tant que chaîne sous la forme d’un + bi ou un + bj.</span><span class="sxs-lookup"><span data-stu-id="60bda-172">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="60bda-173">L’exemple suivant utilise ensuite ce formateur personnalisé pour la représentation sous forme de chaîne d’un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-173">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real"><span data-ttu-id="60bda-174">Partie réelle du nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-174">The real part of the complex number.</span></span></param>
        <param name="imaginary"><span data-ttu-id="60bda-175">Partie imaginaire du nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-175">The imaginary part of the complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-176">Initialise une nouvelle instance de la structure <see cref="T:System.Numerics.Complex" /> à l'aide des valeurs réelles et imaginaires spécifiées.</span><span class="sxs-lookup"><span data-stu-id="60bda-176">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-177">Le `real` ou `imaginary` arguments peuvent manquer de précision si elles sont des types de données qui nécessitent une conversion explicite vers <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="60bda-177">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-178">L’exemple suivant instancie deux nombres complexes et les utilise dans les opérations d’addition, soustraction, multiplication et division.</span><span class="sxs-lookup"><span data-stu-id="60bda-178">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-179">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-179">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-180">Obtient la valeur absolue (ou ordre de grandeur) d'un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-180">Gets the absolute value (or magnitude) of a complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-181">Valeur absolue de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-181">The absolute value of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-182">La valeur absolue d’un nombre complexe est équivalente à son <xref:System.Numerics.Complex.Magnitude%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="60bda-182">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="60bda-183">La valeur absolue d’un nombre réel une + bi est calculé comme suit :</span><span class="sxs-lookup"><span data-stu-id="60bda-183">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="60bda-184">Si b = 0, le résultat est 0.</span><span class="sxs-lookup"><span data-stu-id="60bda-184">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="60bda-185">Si un > b, il en résulte un \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="60bda-185">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="60bda-186">Si b > un, le résultat est b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="60bda-186">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="60bda-187">Si le calcul de la valeur absolue provoque un dépassement de capacité, la méthode retourne <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-187">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60bda-188">Si le <xref:System.Numerics.Complex.Real%2A> ou <xref:System.Numerics.Complex.Imaginary%2A> propriété est <xref:System.Double.NaN?displayProperty=nameWithType> et l’autre propriété n’est ni <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ni <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, la méthode retourne <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-188">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-189">L’exemple suivant calcule la valeur absolue d’un nombre complexe et montre qu’il est équivalent à la valeur de la <xref:System.Numerics.Complex.Magnitude%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="60bda-189">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-190">Nombre complexe qui représente un cosinus.</span><span class="sxs-lookup"><span data-stu-id="60bda-190">A complex number that represents a cosine.</span></span></param>
        <summary><span data-ttu-id="60bda-191">Retourne l'angle qui correspond au cosinus d'arc du nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-191">Returns the angle that is the arc cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-192">L'angle, mesuré en radians, qui correspond au cosinus d'arc de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-192">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-193">Le <xref:System.Numerics.Complex.Acos%2A> méthode pour les nombres complexes correspond à la <xref:System.Math.Acos%2A?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-193">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="60bda-194">Le <xref:System.Numerics.Complex.Acos%2A> méthode utilise la formule suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-194">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="60bda-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="60bda-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="60bda-196">L’exemple suivant illustre la <xref:System.Numerics.Complex.Acos%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="60bda-196">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="60bda-197">Il montre que le passage de la valeur retournée par la <xref:System.Numerics.Complex.Acos%2A> méthode à la <xref:System.Numerics.Complex.Cos%2A> méthode retourne la version d’origine <xref:System.Numerics.Complex> valeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-197">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60bda-198">Premier nombre complexe à ajouter.</span><span class="sxs-lookup"><span data-stu-id="60bda-198">The first complex number to add.</span></span></param>
        <param name="right"><span data-ttu-id="60bda-199">Deuxième nombre complexe à ajouter.</span><span class="sxs-lookup"><span data-stu-id="60bda-199">The second complex number to add.</span></span></param>
        <summary><span data-ttu-id="60bda-200">Ajoute deux nombres complexes et retourne le résultat.</span><span class="sxs-lookup"><span data-stu-id="60bda-200">Adds two complex numbers and returns the result.</span></span></summary>
        <returns><span data-ttu-id="60bda-201">Somme de <paramref name="left" /> et <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-201">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-202">L’ajout d’un type complexe du nombre, a + bi, et un deuxième nombre complexe, le c + l’injection de dépendance, prend la forme suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-202">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="60bda-203">(a + c) + (b + d) i.</span><span class="sxs-lookup"><span data-stu-id="60bda-203">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="60bda-204">Si l’appel de méthode provoque un dépassement de capacité dans le composant réel ou imaginaire, la valeur du composant est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-204">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="60bda-205">Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent utiliser la <xref:System.Numerics.Complex.Add%2A> méthode pour effectuer une addition avec des nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-205">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-206">L’exemple suivant illustre l’addition avec des nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-206">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-207">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-207">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-208">Retourne l'angle qui correspond au sinus d'arc du nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-208">Returns the angle that is the arc sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-209">Angle qui correspond au sinus d'arc de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-209">The angle which is the arc sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-210">Le <xref:System.Numerics.Complex.Asin%2A> méthode pour les nombres complexes correspond à la <xref:System.Math.Asin%2A?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-210">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="60bda-211">Le <xref:System.Numerics.Complex.Asin%2A> méthode utilise la formule suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-211">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="60bda-212">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* valeur + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -valeur \* valeur))</span><span class="sxs-lookup"><span data-stu-id="60bda-212">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="60bda-213">L’exemple suivant illustre la <xref:System.Numerics.Complex.Asin%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="60bda-213">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="60bda-214">Il montre que le passage de la valeur retournée par la <xref:System.Numerics.Complex.Asin%2A> méthode à la <xref:System.Numerics.Complex.Sin%2A> méthode retourne la version d’origine <xref:System.Numerics.Complex> valeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-214">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-215">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-215">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-216">Retourne l'angle qui correspond à la tangente d'arc du nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-216">Returns the angle that is the arc tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-217">Angle qui correspond à la tangente d'arc de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-217">The angle that is the arc tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-218">Le <xref:System.Numerics.Complex.Atan%2A> méthode pour les nombres complexes correspond à la <xref:System.Math.Atan%2A?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-218">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="60bda-219">Le <xref:System.Numerics.Complex.Atan%2A> méthode utilise la formule suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-219">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="60bda-220"><xref:System.Numerics.Complex.ImaginaryOne> / nouveau complexe (2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* valeur)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* valeur)</span><span class="sxs-lookup"><span data-stu-id="60bda-220"><xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value)</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="60bda-221">L’exemple suivant illustre la <xref:System.Numerics.Complex.Atan%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="60bda-221">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="60bda-222">Il montre que le passage de la valeur retournée par la <xref:System.Numerics.Complex.Atan%2A> méthode à la <xref:System.Numerics.Complex.Tan%2A> méthode retourne la version d’origine <xref:System.Numerics.Complex> valeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-222">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-223">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-223">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-224">Calcule le conjugué d'un nombre complexe et retourne le résultat.</span><span class="sxs-lookup"><span data-stu-id="60bda-224">Computes the conjugate of a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="60bda-225">Conjugué de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-225">The conjugate of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-226">Le conjugué d’un nombre complexe inverse le signe du composant imaginaire ; Autrement dit, elle s’applique négation unaire la partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-226">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="60bda-227">Si un + bi est un nombre complexe, son conjugué est a - bi.</span><span class="sxs-lookup"><span data-stu-id="60bda-227">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-228">L’exemple suivant affiche le conjugué de deux nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-228">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-229">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-229">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-230">Retourne le cosinus du nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-230">Returns the cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-231">Cosinus de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-231">The cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-232">Le <xref:System.Numerics.Complex.Cos%2A> méthode pour les nombres complexes correspond à la <xref:System.Math.Cos%2A?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-232">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="60bda-233">Le <xref:System.Numerics.Complex.Cos%2A> méthode utilise la formule suivante pour calculer le cosinus du nombre complexe a + bi :</span><span class="sxs-lookup"><span data-stu-id="60bda-233">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="60bda-234">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="60bda-234">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-235">L’exemple suivant illustre la <xref:System.Numerics.Complex.Acos%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="60bda-235">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="60bda-236">Il montre que le passage de la valeur retournée par la <xref:System.Numerics.Complex.Acos%2A> méthode à la <xref:System.Numerics.Complex.Cos%2A> méthode retourne la version d’origine <xref:System.Numerics.Complex> valeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-236">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-237">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-237">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-238">Retourne le cosinus hyperbolique du nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-238">Returns the hyperbolic cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-239">Cosinus hyperbolique de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-239">The hyperbolic cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-240">Le <xref:System.Numerics.Complex.Cosh%2A> méthode pour les nombres complexes correspond à la <xref:System.Math.Cosh%2A?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-240">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="60bda-241">Le <xref:System.Numerics.Complex.Cosh%2A> méthode utilise la formule suivante pour calculer le cosinus hyperbolique du nombre complexe a + bi :</span><span class="sxs-lookup"><span data-stu-id="60bda-241">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="60bda-242">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="60bda-242">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="60bda-243">Nombre complexe à diviser.</span><span class="sxs-lookup"><span data-stu-id="60bda-243">The complex number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="60bda-244">Nombre complexe par lequel diviser.</span><span class="sxs-lookup"><span data-stu-id="60bda-244">The complex number to divide by.</span></span></param>
        <summary><span data-ttu-id="60bda-245">Divise un nombre complexe par un autre et retourne le résultat.</span><span class="sxs-lookup"><span data-stu-id="60bda-245">Divides one complex number by another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="60bda-246">Quotient de la division.</span><span class="sxs-lookup"><span data-stu-id="60bda-246">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-247">La division d’un nombre complexe, un + bi, par un deuxième nombre complexe, le nombre, le c + l’injection de dépendances, prend la forme suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-247">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="60bda-248">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) je</span><span class="sxs-lookup"><span data-stu-id="60bda-248">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="60bda-249">Si le calcul du quotient provoque un dépassement de capacité dans le composant réel ou imaginaire, la valeur de ce composant est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-249">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="60bda-250">Le <xref:System.Numerics.Complex.Divide%2A> méthode peut être utilisée par les langages qui ne prennent pas en charge les opérateurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="60bda-250">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="60bda-251">Son comportement est identique à la division à l’aide de l’opérateur de division.</span><span class="sxs-lookup"><span data-stu-id="60bda-251">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-252">L’exemple suivant divise un nombre complexe par chaque élément dans un tableau de nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-252">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60bda-253">Retourne une valeur qui indique si deux nombres complexes sont égaux.</span><span class="sxs-lookup"><span data-stu-id="60bda-253">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-254">Nombre complexe à comparer.</span><span class="sxs-lookup"><span data-stu-id="60bda-254">The complex number to compare.</span></span></param>
        <summary><span data-ttu-id="60bda-255">Retourne une valeur qui indique si l'instance actuelle et un nombre complexe spécifié ont la même valeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-255">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span></span></summary>
        <returns><span data-ttu-id="60bda-256"><see langword="true" /> si ce nombre complexe et <paramref name="value" /> ont la même valeur ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-256"><see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-257">Le <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> méthode fournit le <xref:System.IEquatable%601> implémentation pour le <xref:System.Numerics.Complex> structure.</span><span class="sxs-lookup"><span data-stu-id="60bda-257">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="60bda-258">Elle fonctionne légèrement mieux que <xref:System.Numerics.Complex.Equals%28System.Object%29> (méthode), car il n’a pas à convertir son paramètre en un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-258">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="60bda-259">Deux nombres complexes sont égaux si leurs parties réelles sont égales et leurs parties imaginaires sont égales.</span><span class="sxs-lookup"><span data-stu-id="60bda-259">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="60bda-260">Le <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> méthode est équivalente à l’expression suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-260">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="60bda-261">Utilisez le <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> méthode avec précaution, car deux valeurs qui sont apparemment équivalentes peuvent être considérés comme inégaux en raison de la précision différente de leurs composants réels et imaginaires.</span><span class="sxs-lookup"><span data-stu-id="60bda-261">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="60bda-262">L’exemple suivant signale que <c>(3.33333, 0.142857)</c> et <c>(10/3, 1/7)</c> ne sont pas égaux.</span><span class="sxs-lookup"><span data-stu-id="60bda-262">The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.</span></span>  
  
<span data-ttu-id="60bda-263">[ ! code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [ ! code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="60bda-263">[!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span></span> 
<span data-ttu-id="60bda-264">Une technique recommandée consiste à définir une marge acceptable de différence entre les deux valeurs (tel que. % 01 d’un des composants de réelles et imaginaires des valeurs) au lieu de comparer les valeurs pour l’égalité.</span><span class="sxs-lookup"><span data-stu-id="60bda-264">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="60bda-265">Si la valeur absolue de la différence entre les deux valeurs est inférieure ou égale à cette marge, la différence est probablement en raison d’une différence de précision, et, par conséquent, les valeurs sont susceptibles d’être égale.</span><span class="sxs-lookup"><span data-stu-id="60bda-265">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="60bda-266">L’exemple suivant utilise cette technique pour comparer deux valeurs complexes qui peuvent pour être inégaux l’exemple de code précédent.</span><span class="sxs-lookup"><span data-stu-id="60bda-266">The following example uses this technique to compare the two complex values that the previous code example found to be unequal.</span></span> <span data-ttu-id="60bda-267">Il recherche les deux nombres complexes sont égales.</span><span class="sxs-lookup"><span data-stu-id="60bda-267">It finds the two complex numbers to be equal.</span></span>  
  
<span data-ttu-id="60bda-268">[ ! code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [ ! code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span><span class="sxs-lookup"><span data-stu-id="60bda-268">[!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span></span></para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="60bda-269">Objet à comparer.</span><span class="sxs-lookup"><span data-stu-id="60bda-269">The object to compare.</span></span></param>
        <summary><span data-ttu-id="60bda-270">Retourne une valeur qui indique si l'instance actuelle et un objet spécifié ont la même valeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-270">Returns a value that indicates whether the current instance and a specified object have the same value.</span></span></summary>
        <returns><span data-ttu-id="60bda-271"><see langword="true" /> si le paramètre <paramref name="obj" /> est un objet <see cref="T:System.Numerics.Complex" /> ou un type capable d'effectuer une conversion implicite en objet <see cref="T:System.Numerics.Complex" /> et que sa valeur est égale à l'objet <see cref="T:System.Numerics.Complex" /> actuel ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-271"><see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-272">Deux nombres complexes sont égaux si leurs parties réelles sont égales et leurs parties imaginaires sont égales.</span><span class="sxs-lookup"><span data-stu-id="60bda-272">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="60bda-273">Le <xref:System.Numerics.Complex.Equals%28System.Object%29> méthode est équivalente à l’expression suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-273">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="60bda-274">Si le `obj` paramètre n’est pas un <xref:System.Numerics.Complex> objet, mais il est un type de données pour lequel une conversion implicite est définie, le <xref:System.Numerics.Complex.Equals%28System.Object%29> méthode convertit `obj` à un <xref:System.Numerics.Complex> objet dont la partie réelle est égale à la valeur de `obj`et dont la partie imaginaire est égale à zéro avant d’effectuer la comparaison.</span><span class="sxs-lookup"><span data-stu-id="60bda-274">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="60bda-275">L’exemple suivant illustre cela en détectant qu’un nombre complexe et une valeur à virgule flottante double précision sont égaux.</span><span class="sxs-lookup"><span data-stu-id="60bda-275">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="60bda-276">Utilisez le <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> méthode avec précaution, car deux valeurs qui sont apparemment équivalentes peuvent être considérés comme inégaux en raison de la précision différente de leurs composants réels et imaginaires.</span><span class="sxs-lookup"><span data-stu-id="60bda-276">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="60bda-277">Le problème peut être accentué si <paramref name="obj" /> doit être converti en un <see cref="T:System.Double" /> avant d’effectuer la comparaison.</span><span class="sxs-lookup"><span data-stu-id="60bda-277">The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison.</span></span> <span data-ttu-id="60bda-278">L’exemple suivant compare un nombre complexe dont le vrai composant semble être égal à un <see cref="T:System.Single" /> valeur <see cref="T:System.Single" /> valeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-278">The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value.</span></span> <span data-ttu-id="60bda-279">Comme le montre la sortie, la comparaison d’égalité retourne <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-279">As the output shows, the comparison for equality returns <see langword="False" />.</span></span>  
  
<span data-ttu-id="60bda-280">[ ! code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [ ! code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span><span class="sxs-lookup"><span data-stu-id="60bda-280">[!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span></span> 
<span data-ttu-id="60bda-281">Une technique recommandée consiste à définir une marge acceptable de différence entre les deux valeurs (tel que. % 01 d’un des composants de réelles et imaginaires des valeurs) au lieu de comparer les valeurs pour l’égalité.</span><span class="sxs-lookup"><span data-stu-id="60bda-281">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="60bda-282">Si la valeur absolue de la différence entre les deux valeurs est inférieure ou égale à cette marge, la différence est probablement en raison d’une différence de précision et, par conséquent, les valeurs sont susceptibles d’être égal.</span><span class="sxs-lookup"><span data-stu-id="60bda-282">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="60bda-283">L’exemple suivant utilise cette technique pour comparer les deux valeurs qui peuvent pour être inégaux l’exemple de code précédent.</span><span class="sxs-lookup"><span data-stu-id="60bda-283">The following example uses this technique to compare the two values that the previous code example found to be unequal.</span></span> <span data-ttu-id="60bda-284">Il désormais les trouve sont égales.</span><span class="sxs-lookup"><span data-stu-id="60bda-284">It now finds them to be equal.</span></span>  
  
<span data-ttu-id="60bda-285">[ ! code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [ ! code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span><span class="sxs-lookup"><span data-stu-id="60bda-285">[!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-286">Nombre complexe qui spécifie une puissance.</span><span class="sxs-lookup"><span data-stu-id="60bda-286">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="60bda-287">Retourne <see langword="e" /> élevé à la puissance spécifiée par un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-287">Returns <see langword="e" /> raised to the power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-288">Nombre <see langword="e" /> élevé à la puissance <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-288">The number <see langword="e" /> raised to the power <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-289">Utilisez le <xref:System.Numerics.Complex.Pow%2A> méthode pour calculer les puissances des autres bases.</span><span class="sxs-lookup"><span data-stu-id="60bda-289">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="60bda-290">Le <xref:System.Numerics.Complex.Exp%2A> méthode pour les nombres complexes correspond à la <xref:System.Math.Exp%2A?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-290">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="60bda-291"><xref:System.Numerics.Complex.Exp%2A> est l’inverse de <xref:System.Numerics.Complex.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="60bda-291"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-292">L’exemple suivant illustre la <xref:System.Numerics.Complex.Exp%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="60bda-292">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="60bda-293">Il montre que, avec une tolérance pour le manque de précision de la <xref:System.Double> type de données, en passant la valeur retournée par la <xref:System.Numerics.Complex.Log%2A> méthode à la <xref:System.Numerics.Complex.Exp%2A> méthode retourne la version d’origine <xref:System.Numerics.Complex> valeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-293">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude"><span data-ttu-id="60bda-294">Grandeur, à savoir la distance entre l'origine (intersection de l'axe des abscisses et de l'axe des ordonnées) et le nombre.</span><span class="sxs-lookup"><span data-stu-id="60bda-294">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span></span></param>
        <param name="phase"><span data-ttu-id="60bda-295">Phase, à savoir l'angle de la ligne par rapport à l'axe horizontal, mesurée en radians.</span><span class="sxs-lookup"><span data-stu-id="60bda-295">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span></span></param>
        <summary><span data-ttu-id="60bda-296">Crée un nombre complexe à partir des coordonnées polaires d'un point.</span><span class="sxs-lookup"><span data-stu-id="60bda-296">Creates a complex number from a point's polar coordinates.</span></span></summary>
        <returns><span data-ttu-id="60bda-297">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-297">A complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-298">Le <xref:System.Numerics.Complex.FromPolarCoordinates%2A> méthode instancie un nombre complexe selon ses coordonnées polaires.</span><span class="sxs-lookup"><span data-stu-id="60bda-298">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="60bda-299">Car il existe plusieurs représentations sous forme d’un point sur un plan complexe, la valeur de retour de la <xref:System.Numerics.Complex.FromPolarCoordinates%2A> méthode est normalisée.</span><span class="sxs-lookup"><span data-stu-id="60bda-299">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="60bda-300">La grandeur est normalisée en un nombre positif, et la phase est normalisée en une valeur dans la plage de -<xref:System.Math.PI> à <xref:System.Math.PI>.</span><span class="sxs-lookup"><span data-stu-id="60bda-300">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="60bda-301">Par conséquent, les valeurs de la <xref:System.Numerics.Complex.Phase%2A> et <xref:System.Numerics.Complex.Magnitude%2A> propriétés du nombre complexe qui en résulte ne peuvent pas égaler les valeurs d’origine de la `magnitude` et `phase` paramètres.</span><span class="sxs-lookup"><span data-stu-id="60bda-301">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="60bda-302">Pour convertir une valeur de degrés en radians pour le `phase` paramètre, multipliez-la par  <xref:System.Math.PI?displayProperty=nameWithType> /180.</span><span class="sxs-lookup"><span data-stu-id="60bda-302">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-303">L’exemple suivant utilise le <xref:System.Numerics.Complex.FromPolarCoordinates%2A> méthode pour instancier un nombre complexe selon ses coordonnées polaires, puis affiche la valeur de son <xref:System.Numerics.Complex.Magnitude%2A> et <xref:System.Numerics.Complex.Phase%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="60bda-303">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60bda-304">Retourne le code de hachage pour l'objet <see cref="T:System.Numerics.Complex" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="60bda-304">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <returns><span data-ttu-id="60bda-305">Code de hachage d'un entier signé 32 bits.</span><span class="sxs-lookup"><span data-stu-id="60bda-305">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60bda-306">Obtient le composant imaginaire de l'objet <see cref="T:System.Numerics.Complex" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="60bda-306">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="60bda-307">Composant imaginaire d'un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-307">The imaginary component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-308">Étant donné un nombre complexe a + bi, le <xref:System.Numerics.Complex.Imaginary%2A> propriété retourne la valeur de b.</span><span class="sxs-lookup"><span data-stu-id="60bda-308">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-309">L’exemple suivant instancie un tableau de <xref:System.Numerics.Complex> objets et affiche les composants réels et imaginaires de chacun sous la forme a + bi.</span><span class="sxs-lookup"><span data-stu-id="60bda-309">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60bda-310">Retourne une nouvelle instance <see cref="T:System.Numerics.Complex" /> avec un nombre réel égal à zéro et un nombre imaginaire égal à un.</span><span class="sxs-lookup"><span data-stu-id="60bda-310">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60bda-311">L’exemple suivant instancie un <xref:System.Numerics.Complex> valeur à l’aide de la <xref:System.Numerics.Complex.ImaginaryOne> propriété.</span><span class="sxs-lookup"><span data-stu-id="60bda-311">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="60bda-312">Il compare ensuite cette valeur à une autre valeur est instanciée en appelant le <xref:System.Numerics.Complex> constructeur avec une partie réelle égale à zéro et une partie imaginaire égale à un.</span><span class="sxs-lookup"><span data-stu-id="60bda-312">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="60bda-313">Comme le montre la sortie de l’exemple, les deux valeurs sont égales.</span><span class="sxs-lookup"><span data-stu-id="60bda-313">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60bda-314">Retourne le logarithme d'un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-314">Returns the logarithm of a complex number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-315">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-315">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-316">Retourne le logarithme naturel (base <see langword="e" />) d'un nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-316">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-317">Logarithme naturel (base <see langword="e" />) de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-317">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-318">Le <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> méthode pour les nombres complexes correspond à la <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-318">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-319">L’exemple suivant illustre la <xref:System.Numerics.Complex.Log%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="60bda-319">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="60bda-320">Il montre que, avec une tolérance pour le manque de précision de la <xref:System.Double> type de données, en passant la valeur retournée par la <xref:System.Numerics.Complex.Log%2A> méthode à la <xref:System.Numerics.Complex.Exp%2A> méthode retourne la version d’origine <xref:System.Numerics.Complex> valeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-320">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-321">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-321">A complex number.</span></span></param>
        <param name="baseValue"><span data-ttu-id="60bda-322">Base du logarithme.</span><span class="sxs-lookup"><span data-stu-id="60bda-322">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="60bda-323">Retourne le logarithme d'un nombre complexe spécifié dans une base spécifiée.</span><span class="sxs-lookup"><span data-stu-id="60bda-323">Returns the logarithm of a specified complex number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="60bda-324">Logarithme de <paramref name="value" /> en base <paramref name="baseValue" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-324">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-325">Le <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> méthode pour les nombres complexes correspond à la <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-325">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-326">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-326">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-327">Retourne le logarithme de base 10 d'un nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-327">Returns the base-10 logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-328">Logarithme de base 10 de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-328">The base-10 logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-329">Le <xref:System.Numerics.Complex.Log10%2A> méthode pour les nombres complexes correspond à la <xref:System.Math.Log10%2A?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-329">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60bda-330">Obtient l'ordre de grandeur (ou valeur absolue) d'un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-330">Gets the magnitude (or absolute value) of a complex number.</span></span></summary>
        <value><span data-ttu-id="60bda-331">Grandeur de l'instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="60bda-331">The magnitude of the current instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-332">Le <xref:System.Numerics.Complex.Magnitude%2A> propriété est équivalente à la valeur absolue d’un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-332">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="60bda-333">Il spécifie la distance à partir de l’origine (intersection de l’axe des x et y dans le système de coordonnées cartésiennes) et le point à deux dimensions représenté par un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-333">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="60bda-334">La valeur absolue est calculée comme suit :</span><span class="sxs-lookup"><span data-stu-id="60bda-334">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="60bda-335">&#124;a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(un \* un + b \* b)</span><span class="sxs-lookup"><span data-stu-id="60bda-335">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a \* a + b \* b)</span></span>  
  
 <span data-ttu-id="60bda-336">Si le calcul de la valeur absolue provoque un dépassement de capacité, cette propriété retourne <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-336">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="60bda-337">Le <xref:System.Numerics.Complex.Magnitude%2A> et <xref:System.Numerics.Complex.Phase%2A> propriétés définissent la position d’un point qui représente un nombre complexe dans le système de coordonnées polaires.</span><span class="sxs-lookup"><span data-stu-id="60bda-337">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="60bda-338">Vous pouvez instancier un nombre complexe selon ses coordonnées polaires au lieu de ses coordonnées cartésiennes en appelant le <xref:System.Numerics.Complex.FromPolarCoordinates%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="60bda-338">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-339">L’exemple suivant calcule la valeur absolue d’un nombre complexe et montre qu’il est équivalent à la valeur de la <xref:System.Numerics.Complex.Magnitude%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="60bda-339">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60bda-340">Premier nombre complexe à multiplier.</span><span class="sxs-lookup"><span data-stu-id="60bda-340">The first complex number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="60bda-341">Second nombre complexe à multiplier.</span><span class="sxs-lookup"><span data-stu-id="60bda-341">The second complex number to multiply.</span></span></param>
        <summary><span data-ttu-id="60bda-342">Retourne le produit de deux nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-342">Returns the product of two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="60bda-343">Produit des paramètres <paramref name="left" /> et <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-343">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-344">La multiplication d’un type complexe du nombre, a + bi, et un deuxième nombre complexe, le c + l’injection de dépendance, prend la forme suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-344">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="60bda-345">(ac - bd) + (ad + bc) je</span><span class="sxs-lookup"><span data-stu-id="60bda-345">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="60bda-346">Si la multiplication provoque un dépassement de capacité dans le composant réel ou imaginaire, la valeur de ce composant est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-346">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="60bda-347">Le <xref:System.Numerics.Complex.Multiply%2A> méthode est implémentée pour les langages qui ne prennent pas en charge les opérateurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="60bda-347">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="60bda-348">Son comportement est identique à la multiplication à l’aide de l’opérateur de multiplication.</span><span class="sxs-lookup"><span data-stu-id="60bda-348">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-349">L’exemple suivant multiplie un nombre complexe par chaque élément dans un tableau de nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-349">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-350">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-350">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-351">Retourne l'inverse additif d'un nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-351">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-352">Résultat des composants <see cref="P:System.Numerics.Complex.Real" /> et <see cref="P:System.Numerics.Complex.Imaginary" /> du paramètre <paramref name="value" /> multiplié par -1.</span><span class="sxs-lookup"><span data-stu-id="60bda-352">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-353">L’inverse additif d’un nombre complexe est un nombre complexe qui produit une valeur de <xref:System.Numerics.Complex> lorsqu’il est ajouté au nombre complexe d’origine.</span><span class="sxs-lookup"><span data-stu-id="60bda-353">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="60bda-354">Cette méthode retourne un nombre complexe dans lequel les composants réelles et imaginaires du nombre complexe d’origine sont multipliés par -1.</span><span class="sxs-lookup"><span data-stu-id="60bda-354">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="60bda-355">Le <xref:System.Numerics.Complex.Negate%2A> méthode est implémentée pour les langages qui ne prennent pas en charge les opérateurs personnalisés.</span><span class="sxs-lookup"><span data-stu-id="60bda-355">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="60bda-356">Son comportement est identique à la négation à l’aide de l’opérateur de négation unaire, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span><span class="sxs-lookup"><span data-stu-id="60bda-356">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-357">L’exemple suivant obtient l’inverse additif de chaque élément dans un tableau de nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-357">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60bda-358">Retourne une nouvelle instance <see cref="T:System.Numerics.Complex" /> avec un nombre réel égal à un et un nombre imaginaire égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-358">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60bda-359">L’exemple suivant instancie un <xref:System.Numerics.Complex> valeur à l’aide de la <xref:System.Numerics.Complex.One> propriété.</span><span class="sxs-lookup"><span data-stu-id="60bda-359">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="60bda-360">Il compare ensuite cette valeur à une autre valeur est instanciée en appelant le <xref:System.Numerics.Complex> constructeur avec une égale à la partie réelle et une partie imaginaire égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-360">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="60bda-361">Comme le montre la sortie de l’exemple, les deux valeurs sont égales.</span><span class="sxs-lookup"><span data-stu-id="60bda-361">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60bda-362">Première valeur à ajouter.</span><span class="sxs-lookup"><span data-stu-id="60bda-362">The first value to add.</span></span></param>
        <param name="right"><span data-ttu-id="60bda-363">Seconde valeur à ajouter.</span><span class="sxs-lookup"><span data-stu-id="60bda-363">The second value to add.</span></span></param>
        <summary><span data-ttu-id="60bda-364">Ajoute deux nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-364">Adds two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="60bda-365">Somme de <paramref name="left" /> et <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-365">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-366">Le <xref:System.Numerics.Complex.op_Addition%2A> méthode définit l’opération d’addition pour les nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-366">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="60bda-367">Il permet le code suivant :</span><span class="sxs-lookup"><span data-stu-id="60bda-367">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="60bda-368">L’ajout d’un type complexe du nombre, a + bi, et un deuxième nombre complexe, le c + l’injection de dépendance, prend la forme suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-368">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="60bda-369">(a + c) + (b + d) i</span><span class="sxs-lookup"><span data-stu-id="60bda-369">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="60bda-370">Si l’appel de méthode provoque un dépassement de capacité dans le composant réel ou imaginaire, la valeur de ce composant est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-370">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="60bda-371">Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.Complex.Add%2A> méthode à la place.</span><span class="sxs-lookup"><span data-stu-id="60bda-371">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="60bda-372">La méthode équivalente pour cet opérateur est <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="60bda-372">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="60bda-373">L’exemple suivant illustre l’addition avec des nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-373">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60bda-374">Valeur à diviser.</span><span class="sxs-lookup"><span data-stu-id="60bda-374">The value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="60bda-375">Valeur par laquelle diviser.</span><span class="sxs-lookup"><span data-stu-id="60bda-375">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="60bda-376">Divise un nombre complexe spécifié par un autre nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-376">Divides a specified complex number by another specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-377">Résultat de la division de <paramref name="left" /> par <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-377">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-378">Le <xref:System.Numerics.Complex.op_Division%2A> méthode définit l’opération de division pour les nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-378">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="60bda-379">Il permet le code suivant :</span><span class="sxs-lookup"><span data-stu-id="60bda-379">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="60bda-380">La division d’un type complexe du nombre, a + bi, et un deuxième nombre complexe, le c + l’injection de dépendance, prend la forme suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-380">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="60bda-381">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) je</span><span class="sxs-lookup"><span data-stu-id="60bda-381">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="60bda-382">Si la division provoque un dépassement de capacité dans le composant réel ou imaginaire, la valeur de ce composant est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-382">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="60bda-383">Les langages qui ne prennent pas en charge les opérateurs personnalisés et la surcharge d’opérateur peuvent appeler la <xref:System.Numerics.Complex.Divide%2A> méthode à la place.</span><span class="sxs-lookup"><span data-stu-id="60bda-383">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="60bda-384">La méthode équivalente pour cet opérateur est <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="60bda-384">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60bda-385">Premier nombre complexe à comparer.</span><span class="sxs-lookup"><span data-stu-id="60bda-385">The first complex number to compare.</span></span></param>
        <param name="right"><span data-ttu-id="60bda-386">Deuxième nombre complexe à comparer.</span><span class="sxs-lookup"><span data-stu-id="60bda-386">The second complex number to compare.</span></span></param>
        <summary><span data-ttu-id="60bda-387">Retourne une valeur qui indique si deux nombres complexes sont égaux.</span><span class="sxs-lookup"><span data-stu-id="60bda-387">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
        <returns><span data-ttu-id="60bda-388"><see langword="true" /> si les paramètres <paramref name="left" /> et <paramref name="right" /> ont la même valeur ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-388"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-389">Le <xref:System.Numerics.Complex.op_Equality%2A> méthode définit l’opération de l’opérateur d’égalité pour <xref:System.Numerics.Complex> valeurs.</span><span class="sxs-lookup"><span data-stu-id="60bda-389">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="60bda-390">Il permet le code suivant :</span><span class="sxs-lookup"><span data-stu-id="60bda-390">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="60bda-391">Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> méthode à la place.</span><span class="sxs-lookup"><span data-stu-id="60bda-391">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="60bda-392">Deux nombres complexes sont égaux si leurs parties réelles sont égales et leurs parties imaginaires sont égales.</span><span class="sxs-lookup"><span data-stu-id="60bda-392">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="60bda-393">Le <xref:System.Numerics.Complex.op_Equality%2A> méthode est équivalente à l’expression suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-393">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="60bda-394">Notez que, en raison de différences de précision, deux nombres complexes qui sont apparemment équivalentes peuvent être considérés comme inégaux.</span><span class="sxs-lookup"><span data-stu-id="60bda-394">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="60bda-395">Pour plus d’informations et une solution de contournement possible, consultez le <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="60bda-395">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="60bda-396">La méthode équivalente pour cet opérateur est <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="60bda-396">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60bda-397">Définit une conversion explicite entre un objet <see cref="T:System.Numerics.Complex" /> et un autre type.</span><span class="sxs-lookup"><span data-stu-id="60bda-397">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-398">Valeur à convertir en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-398">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-399">Définit une conversion explicite d'une valeur <see cref="T:System.Decimal" /> en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-399">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-400">Nombre complexe ayant un composant réel égal à <paramref name="value" /> et un composant imaginaire égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-400">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-401">Opérateurs de conversion explicite définissent des types qui peuvent être convertis en un <xref:System.Numerics.Complex> objet.</span><span class="sxs-lookup"><span data-stu-id="60bda-401">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="60bda-402">Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données.</span><span class="sxs-lookup"><span data-stu-id="60bda-402">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="60bda-403">Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` en Visual Basic) est utilisé.</span><span class="sxs-lookup"><span data-stu-id="60bda-403">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="60bda-404">Sinon, ils affichent une erreur du compilateur.</span><span class="sxs-lookup"><span data-stu-id="60bda-404">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="60bda-405">La conversion d’un <xref:System.Decimal> valeur à la partie réelle d’un nombre complexe peut entraîner une perte de précision, car un <xref:System.Double>, qui est le type de ce nombre complexe <xref:System.Numerics.Complex.Real%2A> propriété, a moins de chiffres significatifs qu’un <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="60bda-405">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="60bda-406">L’exemple suivant illustre la conversion explicite de <xref:System.Decimal> valeurs <xref:System.Numerics.Complex> valeurs.</span><span class="sxs-lookup"><span data-stu-id="60bda-406">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-407">Valeur à convertir en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-407">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-408">Définit une conversion explicite d'une valeur <see cref="T:System.Numerics.BigInteger" /> en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-408">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-409">Nombre complexe ayant un composant réel égal à <paramref name="value" /> et un composant imaginaire égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-409">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-410">Opérateurs de conversion explicite définissent des types qui peuvent être convertis en un <xref:System.Numerics.Complex> objet.</span><span class="sxs-lookup"><span data-stu-id="60bda-410">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="60bda-411">Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données.</span><span class="sxs-lookup"><span data-stu-id="60bda-411">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="60bda-412">Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` en Visual Basic) est utilisé.</span><span class="sxs-lookup"><span data-stu-id="60bda-412">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="60bda-413">Sinon, ils affichent une erreur du compilateur.</span><span class="sxs-lookup"><span data-stu-id="60bda-413">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="60bda-414">La conversion d’un <xref:System.Numerics.BigInteger> valeur à la partie réelle d’un nombre complexe peut entraîner une perte de précision, car un <xref:System.Double>, qui est le type de ce nombre complexe <xref:System.Numerics.Complex.Real%2A> propriété, a moins de chiffres significatifs qu’un <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="60bda-414">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="60bda-415">Si la conversion échoue, car le <xref:System.Numerics.BigInteger> valeur est en dehors des limites de la <xref:System.Double> type, l’opération ne lève pas une <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-415">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="60bda-416">Au lieu de cela, si `value` est inférieure à <xref:System.Double.MinValue>, le résultat est un nombre complexe ayant un <xref:System.Numerics.Complex.Real%2A> valeur de propriété égale à <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="60bda-416">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="60bda-417">Si `value` est supérieur à <xref:System.Double.MaxValue>, le résultat est un nombre complexe ayant un <xref:System.Numerics.Complex.Real%2A> valeur de propriété égale à <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="60bda-417">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="60bda-418">L’exemple suivant illustre la conversion explicite de <xref:System.Numerics.BigInteger> valeurs <xref:System.Numerics.Complex> valeurs.</span><span class="sxs-lookup"><span data-stu-id="60bda-418">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60bda-419">Définit une conversion implicite entre un objet <see cref="T:System.Numerics.Complex" /> et un autre type.</span><span class="sxs-lookup"><span data-stu-id="60bda-419">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-420">Valeur à convertir en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-420">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-421">Définit une conversion implicite d'un octet non signé en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-421">Defines an implicit conversion of an unsigned byte to a complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-422">Objet qui contient la valeur du paramètre <paramref name="value" /> comme partie réelle et zéro comme partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-422">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-423">Les surcharges de la <xref:System.Numerics.Complex.op_Implicit%2A> opérateur définissent les types à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.Complex> objet sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60bda-423">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="60bda-424">Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-424">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="60bda-425">Cette surcharge permet au compilateur de gérer les conversions d’un <xref:System.Byte> valeur à un nombre complexe, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="60bda-425">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="60bda-426">Notez que le résultat de la conversion est un nombre complexe dont la partie réelle est égale à la <xref:System.Byte> valeur et dont la partie imaginaire est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-426">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-427">Valeur à convertir en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-427">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-428">Définit une conversion implicite d'un nombre à virgule flottante double précision en un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-428">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-429">Objet qui contient la valeur du paramètre <paramref name="value" /> comme partie réelle et zéro comme partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-429">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-430">Les surcharges de la <xref:System.Numerics.Complex.op_Implicit%2A> opérateur définissent les types à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.Complex> objet sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60bda-430">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="60bda-431">Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-431">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="60bda-432">Cette surcharge permet au compilateur de gérer les conversions d’un <xref:System.Double> valeur à un nombre complexe, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="60bda-432">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="60bda-433">Notez que le résultat de la conversion est un nombre complexe dont la partie réelle est égale à la <xref:System.Double> valeur et dont la partie imaginaire est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-433">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-434">Valeur à convertir en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-434">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-435">Définit une conversion implicite d'un entier 16 bits signé en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-435">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-436">Objet qui contient la valeur du paramètre <paramref name="value" /> comme partie réelle et zéro comme partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-436">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-437">Les surcharges de la <xref:System.Numerics.Complex.op_Implicit%2A> opérateur définissent les types à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.Complex> objet sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60bda-437">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="60bda-438">Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-438">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="60bda-439">Cette surcharge permet au compilateur de gérer les conversions d’un entier 16 bits signé à un nombre complexe, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="60bda-439">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="60bda-440">Notez que le résultat de la conversion est un nombre complexe dont la partie réelle est égale à l’entier 16 bits signé et dont la partie imaginaire est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-440">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-441">Valeur à convertir en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-441">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-442">Définit une conversion implicite d'un entier 32 bits signé en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-442">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-443">Objet qui contient la valeur du paramètre <paramref name="value" /> comme partie réelle et zéro comme partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-443">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-444">Les surcharges de la <xref:System.Numerics.Complex.op_Implicit%2A> opérateur définissent les types à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.Complex> objet sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60bda-444">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="60bda-445">Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-445">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="60bda-446">Cette surcharge permet au compilateur de gérer les conversions d’un entier 32 bits signé à un nombre complexe, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="60bda-446">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="60bda-447">Notez que le résultat de la conversion est un nombre complexe dont la partie réelle est égale à l’entier signé de 32 bits et dont la partie imaginaire est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-447">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-448">Valeur à convertir en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-448">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-449">Définit une conversion implicite d'un entier 64 bits signé en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-449">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-450">Objet qui contient la valeur du paramètre <paramref name="value" /> comme partie réelle et zéro comme partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-450">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-451">Les surcharges de la <xref:System.Numerics.Complex.op_Implicit%2A> opérateur définissent les types à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.Complex> objet sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60bda-451">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="60bda-452">Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-452">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="60bda-453">Cette surcharge permet au compilateur de gérer les conversions d’un entier 64 bits signé à un nombre complexe, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="60bda-453">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="60bda-454">Notez que le résultat de la conversion est un nombre complexe dont la partie réelle est égale à l’entier 64 bits signé et dont la partie imaginaire est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-454">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-455">Valeur à convertir en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-455">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-456">Définit une conversion implicite d'un octet signé en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-456">Defines an implicit conversion of a signed byte to a complex number.</span></span>   
           
<span data-ttu-id="60bda-457">Cette API n'est pas conforme CLS.</span><span class="sxs-lookup"><span data-stu-id="60bda-457">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="60bda-458">Objet qui contient la valeur du paramètre <paramref name="value" /> comme partie réelle et zéro comme partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-458">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-459">Les surcharges de la <xref:System.Numerics.Complex.op_Implicit%2A> opérateur définissent les types à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.Complex> objet sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60bda-459">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="60bda-460">Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-460">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="60bda-461">Cette surcharge permet au compilateur de gérer les conversions d’un octet signé à un nombre complexe, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="60bda-461">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="60bda-462">Notez que le résultat de la conversion est un nombre complexe dont la partie réelle est égale à l’octet signé et dont la partie imaginaire est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-462">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-463">Valeur à convertir en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-463">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-464">Définit une conversion implicite d'un nombre à virgule flottante simple précision en un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-464">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-465">Objet qui contient la valeur du paramètre <paramref name="value" /> comme partie réelle et zéro comme partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-465">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-466">Les surcharges de la <xref:System.Numerics.Complex.op_Implicit%2A> opérateur définissent les types à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.Complex> objet sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60bda-466">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="60bda-467">Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-467">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="60bda-468">Cette surcharge permet au compilateur de gérer les conversions d’un <xref:System.Single> valeur à un nombre complexe, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="60bda-468">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="60bda-469">Notez que le résultat de la conversion est un nombre complexe dont la partie réelle est égale à la <xref:System.Single> valeur et dont la partie imaginaire est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-469">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-470">Valeur à convertir en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-470">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-471">Définit une conversion implicite d'un entier 16 bits non signé en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-471">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="60bda-472">Cette API n'est pas conforme CLS.</span><span class="sxs-lookup"><span data-stu-id="60bda-472">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="60bda-473">Objet qui contient la valeur du paramètre <paramref name="value" /> comme partie réelle et zéro comme partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-473">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-474">Les surcharges de la <xref:System.Numerics.Complex.op_Implicit%2A> opérateur définissent les types à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.Complex> objet sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60bda-474">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="60bda-475">Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-475">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="60bda-476">Cette surcharge permet au compilateur de gérer les conversions d’un entier 16 bits non signé à un nombre complexe, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="60bda-476">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="60bda-477">Notez que le résultat de la conversion est un nombre complexe dont la partie réelle est égale à l’entier 16 bits non signé et dont la partie imaginaire est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-477">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-478">Valeur à convertir en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-478">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-479">Définit une conversion implicite d'un entier 32 bits non signé en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-479">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="60bda-480">Cette API n'est pas conforme CLS.</span><span class="sxs-lookup"><span data-stu-id="60bda-480">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="60bda-481">Objet qui contient la valeur du paramètre <paramref name="value" /> comme partie réelle et zéro comme partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-481">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-482">Les surcharges de la <xref:System.Numerics.Complex.op_Implicit%2A> opérateur définissent les types à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.Complex> objet sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60bda-482">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="60bda-483">Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-483">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="60bda-484">Cette surcharge permet au compilateur de gérer les conversions d’un entier 32 bits non signé à un nombre complexe, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="60bda-484">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="60bda-485">Notez que le résultat de la conversion est un nombre complexe dont la partie réelle est égale à l’entier non signé de 32 bits et dont la partie imaginaire est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-485">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-486">Valeur à convertir en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-486">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-487">Définit une conversion implicite d'un entier 64 bits non signé en nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-487">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="60bda-488">Cette API n'est pas conforme CLS.</span><span class="sxs-lookup"><span data-stu-id="60bda-488">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="60bda-489">Objet qui contient la valeur du paramètre <paramref name="value" /> comme partie réelle et zéro comme partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-489">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-490">Les surcharges de la <xref:System.Numerics.Complex.op_Implicit%2A> opérateur définissent les types à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.Complex> objet sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60bda-490">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="60bda-491">Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-491">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="60bda-492">Cette surcharge permet au compilateur de gérer les conversions d’un entier 64 bits non signé à un nombre complexe, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="60bda-492">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="60bda-493">Notez que le résultat de la conversion est un nombre complexe dont la partie réelle est égale à l’entier non signé de 64 bits et dont la partie imaginaire est égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-493">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60bda-494">Première valeur à comparer.</span><span class="sxs-lookup"><span data-stu-id="60bda-494">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="60bda-495">Deuxième valeur à comparer.</span><span class="sxs-lookup"><span data-stu-id="60bda-495">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="60bda-496">Retourne une valeur qui indique si deux nombres complexes sont différents.</span><span class="sxs-lookup"><span data-stu-id="60bda-496">Returns a value that indicates whether two complex numbers are not equal.</span></span></summary>
        <returns><span data-ttu-id="60bda-497"><see langword="true" /> si <paramref name="left" /> et <paramref name="right" /> ne sont pas égales ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-497"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-498">Le <xref:System.Numerics.Complex.op_Equality%2A> méthode définit l’opération de l’opérateur d’inégalité pour les nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-498">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="60bda-499">Il permet le code suivant :</span><span class="sxs-lookup"><span data-stu-id="60bda-499">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="60bda-500">Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent tester l’inégalité en appelant le <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> (méthode) et en inversant sa valeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-500">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="60bda-501">Notez que, en raison de différences de précision, deux nombres complexes qui sont apparemment équivalentes peuvent être considérés comme inégaux.</span><span class="sxs-lookup"><span data-stu-id="60bda-501">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="60bda-502">Une solution de contournement possible consiste à implémenter une méthode de comparaison qui retourne `true` uniquement si la différence entre les deux parties réelles et imaginaires des nombres complexes dépasse un certain seuil (tel que. 01 % de la valeur du composant réel ou imaginaire de un des nombres complexes).</span><span class="sxs-lookup"><span data-stu-id="60bda-502">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="60bda-503">Pour plus d'informations, voir la méthode <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>.</span><span class="sxs-lookup"><span data-stu-id="60bda-503">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60bda-504">Première valeur à multiplier.</span><span class="sxs-lookup"><span data-stu-id="60bda-504">The first value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="60bda-505">Seconde valeur à multiplier.</span><span class="sxs-lookup"><span data-stu-id="60bda-505">The second value to multiply.</span></span></param>
        <summary><span data-ttu-id="60bda-506">Multiplie deux nombres complexes spécifiés.</span><span class="sxs-lookup"><span data-stu-id="60bda-506">Multiplies two specified complex numbers.</span></span></summary>
        <returns><span data-ttu-id="60bda-507">Produit de <paramref name="left" /> et <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-507">The product of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-508">Le <xref:System.Numerics.Complex.op_Multiply%2A> méthode définit l’opération de l’opérateur de multiplication pour les nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-508">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="60bda-509">Il permet le code suivant :</span><span class="sxs-lookup"><span data-stu-id="60bda-509">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="60bda-510">La multiplication d’un type complexe du nombre, a + bi, et un deuxième nombre complexe, le c + l’injection de dépendance, prend la forme suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-510">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="60bda-511">(ac - bd) + (ad + bc) je</span><span class="sxs-lookup"><span data-stu-id="60bda-511">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="60bda-512">Si la multiplication provoque un dépassement de capacité dans le composant réel ou imaginaire, la valeur de ce composant est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-512">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="60bda-513">Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.Complex.Multiply%2A> méthode à la place.</span><span class="sxs-lookup"><span data-stu-id="60bda-513">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="60bda-514">La méthode équivalente pour cet opérateur est <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="60bda-514">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60bda-515">Valeur à laquelle appliquer la soustraction (diminuende).</span><span class="sxs-lookup"><span data-stu-id="60bda-515">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="60bda-516">Valeur à soustraire (diminuteur).</span><span class="sxs-lookup"><span data-stu-id="60bda-516">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="60bda-517">Soustrait un nombre complexe d'un autre nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-517">Subtracts a complex number from another complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-518">Résultat de la soustraction de <paramref name="right" /> de <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-518">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-519">Le <xref:System.Numerics.Complex.op_Subtraction%2A> méthode définit l’opération de l’opérateur de soustraction pour les nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-519">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="60bda-520">Il permet le code suivant :</span><span class="sxs-lookup"><span data-stu-id="60bda-520">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="60bda-521">Si l’appel de méthode provoque un dépassement de capacité dans le composant réel ou imaginaire, la valeur de ce composant est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-521">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="60bda-522">La soustraction d’un nombre complexe, le c + l’injection de dépendance, à partir d’un autre nombre complexe, un + bi, prend la forme suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-522">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="60bda-523">(a - c) + (b - d) i</span><span class="sxs-lookup"><span data-stu-id="60bda-523">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="60bda-524">Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.Complex.Subtract%2A> méthode à la place.</span><span class="sxs-lookup"><span data-stu-id="60bda-524">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="60bda-525">La méthode équivalente pour cet opérateur est <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="60bda-525">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-526">Valeur à rendre négative.</span><span class="sxs-lookup"><span data-stu-id="60bda-526">The value to negate.</span></span></param>
        <summary><span data-ttu-id="60bda-527">Retourne l'inverse additif d'un nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-527">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-528">Résultat des composants <see cref="P:System.Numerics.Complex.Real" /> et <see cref="P:System.Numerics.Complex.Imaginary" /> du paramètre <paramref name="value" /> multiplié par -1.</span><span class="sxs-lookup"><span data-stu-id="60bda-528">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-529">Le <xref:System.Numerics.Complex.op_UnaryNegation%2A> méthode définit l’opération de l’opérateur de négation (inverse additif) unaire pour les nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-529">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="60bda-530">Il permet le code suivant :</span><span class="sxs-lookup"><span data-stu-id="60bda-530">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="60bda-531">Nombre complexe résultant produit une valeur de <xref:System.Numerics.Complex> 0 (zéro) lorsqu’il est ajouté au nombre complexe d’origine.</span><span class="sxs-lookup"><span data-stu-id="60bda-531">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="60bda-532">Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.Complex.Negate%2A> méthode à la place.</span><span class="sxs-lookup"><span data-stu-id="60bda-532">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="60bda-533">La méthode équivalente pour cet opérateur est <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="60bda-533">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60bda-534">Obtient la phase d'un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-534">Gets the phase of a complex number.</span></span></summary>
        <value><span data-ttu-id="60bda-535">Phase d'un nombre complexe, en radians.</span><span class="sxs-lookup"><span data-stu-id="60bda-535">The phase of a complex number, in radians.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-536">Pour un nombre complexe un + bi, la phase est calculée comme <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, un).</span><span class="sxs-lookup"><span data-stu-id="60bda-536">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="60bda-537">Vous pouvez identifier un nombre complexe par ses coordonnées cartésiennes sur le plan complexe ou par ses coordonnées polaires.</span><span class="sxs-lookup"><span data-stu-id="60bda-537">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="60bda-538">La phase (argument) d’un nombre complexe est l’angle de l’axe réel d’une ligne dessinée à partir du point d’origine (intersection de l’axe des abscisses et l’axe des ordonnées) et le point représenté par le nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-538">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="60bda-539">La grandeur (représentée par la <xref:System.Numerics.Complex.Magnitude%2A> propriété) est la distance entre le point d’origine et le point représenté par le nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-539">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="60bda-540">Vous pouvez instancier un nombre complexe selon ses coordonnées polaires au lieu de ses coordonnées cartésiennes en appelant le <xref:System.Numerics.Complex.FromPolarCoordinates%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="60bda-540">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="60bda-541">Pour convertir la phase de radians en degrés, multipliez-le par 180 /<xref:System.Math.PI?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-541">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-542">L’exemple suivant utilise le <xref:System.Numerics.Complex.FromPolarCoordinates%2A> méthode pour instancier un nombre complexe selon ses coordonnées polaires, puis affiche la valeur de son <xref:System.Numerics.Complex.Magnitude%2A> et <xref:System.Numerics.Complex.Phase%2A> propriétés.</span><span class="sxs-lookup"><span data-stu-id="60bda-542">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60bda-543">Retourne un nombre complexe spécifié élevé à une puissance spécifiée.</span><span class="sxs-lookup"><span data-stu-id="60bda-543">Returns a specified complex number raised to a specified power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-544">Nombre complexe à élever à une puissance.</span><span class="sxs-lookup"><span data-stu-id="60bda-544">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="60bda-545">Nombre à virgule flottante double précision. qui spécifie une puissance.</span><span class="sxs-lookup"><span data-stu-id="60bda-545">A double-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="60bda-546">Retourne un nombre complexe spécifié élevé à une puissance spécifiée par un nombre à virgule flottante double précision.</span><span class="sxs-lookup"><span data-stu-id="60bda-546">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="60bda-547">Nombre complexe <paramref name="value" /> élevé à la puissance <paramref name="power" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-547">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-548">Si `value` est <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, la méthode retourne <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-548">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60bda-549">Pour les autres valeurs, si `power` est 0, la méthode retourne <xref:System.Numerics.Complex.One?displayProperty=nameWithType>et si `power` est 1, elle retourne `value`.</span><span class="sxs-lookup"><span data-stu-id="60bda-549">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="60bda-550">Cette méthode correspond à la <xref:System.Math.Pow%2A?displayProperty=nameWithType> méthode pour les types numériques primitifs.</span><span class="sxs-lookup"><span data-stu-id="60bda-550">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-551">L’exemple suivant illustre une puissance à l’aide d’un nombre complexe et un exposant dont la valeur est comprise entre -1 à 10.</span><span class="sxs-lookup"><span data-stu-id="60bda-551">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-552">Nombre complexe à élever à une puissance.</span><span class="sxs-lookup"><span data-stu-id="60bda-552">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="60bda-553">Nombre complexe qui spécifie une puissance.</span><span class="sxs-lookup"><span data-stu-id="60bda-553">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="60bda-554">Retourne un nombre complexe spécifié élevé à une puissance spécifiée par un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-554">Returns a specified complex number raised to a power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-555">Nombre complexe <paramref name="value" /> élevé à la puissance <paramref name="power" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-555">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60bda-556">Obtient le composant réel de l'objet <see cref="T:System.Numerics.Complex" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="60bda-556">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="60bda-557">Composant réel d'un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-557">The real component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-558">Étant donné un nombre complexe a + bi, le <xref:System.Numerics.Complex.Real%2A> propriété retourne la valeur d’un.</span><span class="sxs-lookup"><span data-stu-id="60bda-558">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-559">L’exemple suivant instancie un tableau de <xref:System.Numerics.Complex> objets et affiche les composants réels et imaginaires de chacun sous la forme a + bi.</span><span class="sxs-lookup"><span data-stu-id="60bda-559">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-560">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-560">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-561">Retourne l'inverse multiplicatif d'un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-561">Returns the multiplicative inverse of a complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-562">Réciproque de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-562">The reciprocal of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-563">Le réciproque, ou inverse multiplicatif, d’un nombre *x* est un nombre *y* où *x* multipliée par *y* donne 1.</span><span class="sxs-lookup"><span data-stu-id="60bda-563">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="60bda-564">L’inverse d’un nombre complexe est le nombre complexe qui produit <xref:System.Numerics.Complex.One?displayProperty=nameWithType> lorsque les deux nombres sont multipliés.</span><span class="sxs-lookup"><span data-stu-id="60bda-564">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="60bda-565">Si un nombre complexe est représenté par a + bi, son réciproque est représenté par l’expression un / (un<sup>2</sup>+ b<sup>2</sup>) + b-/ (un<sup>2</sup> + b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="60bda-565">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="60bda-566">Si la valeur est <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, la méthode retourne <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-566">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60bda-567">Sinon, elle retourne le résultat de l’expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`.</span><span class="sxs-lookup"><span data-stu-id="60bda-567">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-568">L’exemple suivant utilise la <xref:System.Numerics.Complex.Reciprocal%2A> méthode pour calculer les valeurs réciproques de plusieurs nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-568">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="60bda-569">Il montre également que le résultat de la multiplication d’un nombre complexe par son réciproque est <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-569">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-570">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-570">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-571">Retourne le sinus du nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-571">Returns the sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-572">Sinus de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-572">The sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-573">Le <xref:System.Numerics.Complex.Sin%2A> méthode pour les nombres complexes correspond à la <xref:System.Math.Sin%2A?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-573">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="60bda-574">Le <xref:System.Numerics.Complex.Sin%2A> méthode utilise la formule suivante pour calculer le sinus du nombre complexe a + bi :</span><span class="sxs-lookup"><span data-stu-id="60bda-574">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="60bda-575">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="60bda-575">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-576">L’exemple suivant illustre la <xref:System.Numerics.Complex.Sin%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="60bda-576">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="60bda-577">Il montre que le passage de la valeur retournée par la <xref:System.Numerics.Complex.Asin%2A> méthode à la <xref:System.Numerics.Complex.Sin%2A> méthode retourne la version d’origine <xref:System.Numerics.Complex> valeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-577">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-578">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-578">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-579">Retourne le sinus hyperbolique du nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-579">Returns the hyperbolic sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-580">Sinus hyperbolique de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-580">The hyperbolic sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-581">Le <xref:System.Numerics.Complex.Sinh%2A> méthode pour les nombres complexes correspond à la <xref:System.Math.Sinh%2A?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-581">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="60bda-582">Le <xref:System.Numerics.Complex.Sinh%2A> méthode utilise la formule suivante pour calculer le sinus hyperbolique du nombre complexe a + bi :</span><span class="sxs-lookup"><span data-stu-id="60bda-582">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="60bda-583">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="60bda-583">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-584">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-584">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-585">Retourne la racine carrée d'un nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-585">Returns the square root of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-586">Racine carrée de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-586">The square root of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-587">La racine carrée du nombre complexe `value` est calculée à l’aide de la formule suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-587">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="60bda-588"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A> / 2.0)</span><span class="sxs-lookup"><span data-stu-id="60bda-588"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="60bda-589">Le <xref:System.Numerics.Complex.Sqrt%2A> méthode pour les nombres complexes correspond à la <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-589">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60bda-590">Valeur à laquelle appliquer la soustraction (diminuende).</span><span class="sxs-lookup"><span data-stu-id="60bda-590">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="60bda-591">Valeur à soustraire (diminuteur).</span><span class="sxs-lookup"><span data-stu-id="60bda-591">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="60bda-592">Soustrait un nombre complexe d'un autre et retourne le résultat.</span><span class="sxs-lookup"><span data-stu-id="60bda-592">Subtracts one complex number from another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="60bda-593">Résultat de la soustraction de <paramref name="right" /> de <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-593">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-594">La soustraction d’un nombre complexe, le c + l’injection de dépendance, à partir d’un autre nombre complexe, un + bi, prend la forme suivante :</span><span class="sxs-lookup"><span data-stu-id="60bda-594">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="60bda-595">(a - c) + (b - d) i</span><span class="sxs-lookup"><span data-stu-id="60bda-595">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="60bda-596">Si l’appel de méthode provoque un dépassement de capacité dans le composant réel ou imaginaire, la valeur de ce composant est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60bda-596">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="60bda-597">Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent utiliser la <xref:System.Numerics.Complex.Subtract%2A> méthode pour effectuer une soustraction à l’aide de nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-597">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-598">L’exemple suivant soustrait chaque nombre complexe dans un tableau à partir d’un nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-598">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-599">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-599">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-600">Retourne la tangente du nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-600">Returns the tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-601">Tangente de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-601">The tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-602">Le <xref:System.Numerics.Complex.Tan%2A> méthode pour les nombres complexes correspond à la <xref:System.Math.Tan%2A?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-602">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="60bda-603">Le <xref:System.Numerics.Complex.Tan%2A> méthode utilise la formule suivante pour calculer la tangente du nombre complexe `value`:</span><span class="sxs-lookup"><span data-stu-id="60bda-603">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="60bda-604"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="60bda-604"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-605">L’exemple suivant illustre la <xref:System.Numerics.Complex.Tan%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="60bda-605">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="60bda-606">Il montre que le passage de la valeur retournée par la <xref:System.Numerics.Complex.Atan%2A> méthode à la <xref:System.Numerics.Complex.Tan%2A> méthode retourne la version d’origine <xref:System.Numerics.Complex> valeur.</span><span class="sxs-lookup"><span data-stu-id="60bda-606">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60bda-607">Nombre complexe.</span><span class="sxs-lookup"><span data-stu-id="60bda-607">A complex number.</span></span></param>
        <summary><span data-ttu-id="60bda-608">Retourne la tangente hyperbolique du nombre complexe spécifié.</span><span class="sxs-lookup"><span data-stu-id="60bda-608">Returns the hyperbolic tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="60bda-609">Tangente hyperbolique de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-609">The hyperbolic tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-610">Le <xref:System.Numerics.Complex.Tanh%2A> méthode pour les nombres complexes correspond à la <xref:System.Math.Tanh%2A?displayProperty=nameWithType> méthode pour les nombres réels.</span><span class="sxs-lookup"><span data-stu-id="60bda-610">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="60bda-611">Le <xref:System.Numerics.Complex.Tanh%2A> méthode utilise la formule suivante pour calculer la tangente hyperbolique du nombre complexe `value`:</span><span class="sxs-lookup"><span data-stu-id="60bda-611">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="60bda-612"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="60bda-612"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60bda-613">Convertit la valeur d'un nombre complexe en sa représentation sous forme de chaîne équivalente.</span><span class="sxs-lookup"><span data-stu-id="60bda-613">Converts the value of a complex number to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60bda-614">Convertit la valeur du nombre complexe actuel en sa représentation sous forme de chaîne équivalente au format cartésien.</span><span class="sxs-lookup"><span data-stu-id="60bda-614">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span></span></summary>
        <returns><span data-ttu-id="60bda-615">Représentation sous forme de chaîne de l'instance actuelle au format cartésien.</span><span class="sxs-lookup"><span data-stu-id="60bda-615">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-616">La représentation sous forme de chaîne par défaut d’un nombre complexe affiche le nombre à l’aide de ses coordonnées cartésiennes sous la forme `(` *un* `,` *b*`)`, où *un* est la partie réelle du nombre complexe, et *b* est la partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-616">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="60bda-617">Les deux *un* et *b* sont mis en forme à l’aide du spécificateur de format général (« G ») et les conventions de la culture système actuelle.</span><span class="sxs-lookup"><span data-stu-id="60bda-617">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-618">L’exemple suivant affiche la représentation sous forme de chaîne de plusieurs nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-618">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="60bda-619">La sortie utilise les conventions de mise en forme de l’anglais - culture United States (« en-US »), c'est-à-dire, dans ce cas, la culture système actuelle.</span><span class="sxs-lookup"><span data-stu-id="60bda-619">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="60bda-620">Objet qui fournit des informations de mise en forme propres à la culture.</span><span class="sxs-lookup"><span data-stu-id="60bda-620">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="60bda-621">Convertit la valeur du nombre complexe actuel en sa représentation sous forme de chaîne équivalente au format cartésien à l'aide des informations de mise en forme propres à la culture spécifiées.</span><span class="sxs-lookup"><span data-stu-id="60bda-621">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="60bda-622">Représentation sous forme de chaîne de l'instance actuelle au format cartésien, telle que spécifiée par <paramref name="provider" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-622">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-623">La représentation sous forme de chaîne du nombre complexe retourné par cette méthode affiche le nombre à l’aide de ses coordonnées cartésiennes sous la forme `(` *un* `,` *b*`)`, où *un* est la partie réelle du nombre complexe, et *b* est la partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-623">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="60bda-624">Les deux *un* et *b* sont mis en forme à l’aide du spécificateur de format général (« G ») et les conventions de la culture définie par `provider`.</span><span class="sxs-lookup"><span data-stu-id="60bda-624">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="60bda-625">Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation.</span><span class="sxs-lookup"><span data-stu-id="60bda-625">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="60bda-626">Son <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations spécifiques à la culture sur le format des nombres imaginaires et dans la chaîne retournée.</span><span class="sxs-lookup"><span data-stu-id="60bda-626">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="60bda-627">Si `provider` est `null`, la chaîne retournée est mise en forme le <xref:System.Globalization.NumberFormatInfo> objet de la culture actuelle.</span><span class="sxs-lookup"><span data-stu-id="60bda-627">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="60bda-628">Le `provider` paramètre peut prendre l’une des opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="60bda-628">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="60bda-629">Un <xref:System.Globalization.CultureInfo> objet qui représente la culture qui fournit des informations de mise en forme</span><span class="sxs-lookup"><span data-stu-id="60bda-629">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="60bda-630">Le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.</span><span class="sxs-lookup"><span data-stu-id="60bda-630">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="60bda-631">Un objet personnalisé qui implémente le <xref:System.IFormatProvider> interface.</span><span class="sxs-lookup"><span data-stu-id="60bda-631">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="60bda-632">Son <xref:System.IFormatProvider.GetFormat%2A> méthode retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.</span><span class="sxs-lookup"><span data-stu-id="60bda-632">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-633">L’exemple suivant affiche la représentation sous forme de chaîne de plusieurs nombres complexes.</span><span class="sxs-lookup"><span data-stu-id="60bda-633">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="60bda-634">Le résultat utilise les conventions de mise en forme de l’anglais - États-Unis (« en-US ») et Français - cultures de France (« fr-FR »).</span><span class="sxs-lookup"><span data-stu-id="60bda-634">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="60bda-635">Chaîne de format numérique standard ou personnalisée.</span><span class="sxs-lookup"><span data-stu-id="60bda-635">A standard or custom numeric format string.</span></span></param>
        <summary><span data-ttu-id="60bda-636">Convertit la valeur du nombre complexe actuel en sa représentation sous forme de chaîne équivalente au format cartésien en utilisant le format spécifié pour ses parties imaginaire et réelle.</span><span class="sxs-lookup"><span data-stu-id="60bda-636">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="60bda-637">Représentation sous forme de chaîne de l'instance actuelle au format cartésien.</span><span class="sxs-lookup"><span data-stu-id="60bda-637">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-638">La représentation sous forme de chaîne du nombre complexe retourné par cette méthode affiche le nombre à l’aide de ses coordonnées cartésiennes sous la forme `(` *un* `,` *b*`)`, où *un* est la partie réelle du nombre complexe, et *b* est la partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-638">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="60bda-639">Les deux *un* et *b* sont mis en forme à l’aide de la chaîne de format spécifiée par `format`.</span><span class="sxs-lookup"><span data-stu-id="60bda-639">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="60bda-640">Le `format` paramètre peut être n’importe quel spécificateur de format numérique standard valide, ou toute combinaison de spécificateurs de format numériques personnalisées.</span><span class="sxs-lookup"><span data-stu-id="60bda-640">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="60bda-641">Si `format` est égal à <xref:System.String.Empty?displayProperty=nameWithType> ou est `null`, les parties réelles et imaginaires du nombre complexe sont mis en forme avec le spécificateur de format général (« G »).</span><span class="sxs-lookup"><span data-stu-id="60bda-641">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="60bda-642">Si `format` est une autre valeur, la méthode lève une exception une <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-642">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="60bda-643">Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques suivantes :</span><span class="sxs-lookup"><span data-stu-id="60bda-643">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="60bda-644">Pour plus d’informations sur les chaînes de format numérique, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="60bda-644">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="60bda-645">Pour plus d’informations sur la mise en forme dans le .NET Framework, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="60bda-645">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="60bda-646">Le format de la chaîne retournée est déterminé par le <xref:System.Globalization.NumberFormatInfo> objet pour la culture actuelle.</span><span class="sxs-lookup"><span data-stu-id="60bda-646">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="60bda-647">Selon le `format` paramètre, cet objet contrôle les symboles tels que le signe négatif, le séparateur de groupes et le symbole de virgule décimale dans la chaîne de sortie.</span><span class="sxs-lookup"><span data-stu-id="60bda-647">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="60bda-648">Pour fournir des informations de mise en forme pour les cultures autres que la culture actuelle, appelez le <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> de surcharge.</span><span class="sxs-lookup"><span data-stu-id="60bda-648">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-649">L’exemple suivant initialise un nombre complexe et l’affiche à l’aide de plusieurs chaînes de format standard.</span><span class="sxs-lookup"><span data-stu-id="60bda-649">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="60bda-650"><paramref name="format" /> n’est pas une chaîne de format valide.</span><span class="sxs-lookup"><span data-stu-id="60bda-650"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="60bda-651">Chaînes de format numériques standard</span><span class="sxs-lookup"><span data-stu-id="60bda-651">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="60bda-652">Chaînes de format numériques personnalisées</span><span class="sxs-lookup"><span data-stu-id="60bda-652">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="60bda-653">Chaîne de format numérique standard ou personnalisée.</span><span class="sxs-lookup"><span data-stu-id="60bda-653">A standard or custom numeric format string.</span></span></param>
        <param name="provider"><span data-ttu-id="60bda-654">Objet qui fournit des informations de mise en forme propres à la culture.</span><span class="sxs-lookup"><span data-stu-id="60bda-654">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="60bda-655">Convertit la valeur du nombre complexe actuel en sa représentation sous forme de chaîne équivalente au format cartésien en utilisant le format et les informations de mise en forme spécifiques à la culture spécifiés pour ses parties imaginaire et réelle.</span><span class="sxs-lookup"><span data-stu-id="60bda-655">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="60bda-656">Représentation sous forme de chaîne de l'instance actuelle au format cartésien, telle que spécifiée par <paramref name="format" /> et <paramref name="provider" />.</span><span class="sxs-lookup"><span data-stu-id="60bda-656">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-657">La représentation sous forme de chaîne du nombre complexe retourné par cette méthode affiche le nombre à l’aide de ses coordonnées cartésiennes sous la forme `(` *un* `,` *b*`)`, où *un* est la partie réelle du nombre complexe, et *b* est la partie imaginaire.</span><span class="sxs-lookup"><span data-stu-id="60bda-657">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="60bda-658">Les deux *un* et *b* sont mis en forme à l’aide de la chaîne de format spécifiée par `format`.</span><span class="sxs-lookup"><span data-stu-id="60bda-658">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="60bda-659">Le `format` paramètre peut être n’importe quel spécificateur de format numérique standard valide, ou toute combinaison de spécificateurs de format numériques personnalisées.</span><span class="sxs-lookup"><span data-stu-id="60bda-659">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="60bda-660">Si `format` est égal à <xref:System.String.Empty?displayProperty=nameWithType> ou est `null`, les parties réelles et imaginaires du nombre complexe sont mis en forme avec le spécificateur de format général (« G »).</span><span class="sxs-lookup"><span data-stu-id="60bda-660">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="60bda-661">Si `format` est une autre valeur, la méthode lève une exception une <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="60bda-661">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="60bda-662">Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques suivantes :</span><span class="sxs-lookup"><span data-stu-id="60bda-662">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="60bda-663">Pour plus d’informations sur les chaînes de format numérique, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="60bda-663">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="60bda-664">Pour plus d’informations sur la mise en forme dans le .NET Framework, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="60bda-664">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="60bda-665">Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation.</span><span class="sxs-lookup"><span data-stu-id="60bda-665">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="60bda-666">Son <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations spécifiques à la culture sur le format des nombres imaginaires et dans la chaîne retournée.</span><span class="sxs-lookup"><span data-stu-id="60bda-666">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="60bda-667">Selon le `format` paramètre, cet objet contrôle les symboles tels que le signe négatif, le séparateur de groupes et le symbole de virgule décimale dans la chaîne de sortie.</span><span class="sxs-lookup"><span data-stu-id="60bda-667">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="60bda-668">Si `provider` est `null`, la chaîne retournée est mise en forme le <xref:System.Globalization.NumberFormatInfo> objet de la culture actuelle.</span><span class="sxs-lookup"><span data-stu-id="60bda-668">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="60bda-669">Le `provider` paramètre peut prendre l’une des opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="60bda-669">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="60bda-670">Un <xref:System.Globalization.CultureInfo> objet qui représente la culture qui fournit des informations de mise en forme</span><span class="sxs-lookup"><span data-stu-id="60bda-670">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="60bda-671">Le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.</span><span class="sxs-lookup"><span data-stu-id="60bda-671">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="60bda-672">Un objet personnalisé qui implémente le <xref:System.IFormatProvider> interface.</span><span class="sxs-lookup"><span data-stu-id="60bda-672">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="60bda-673">Son <xref:System.IFormatProvider.GetFormat%2A> méthode retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.</span><span class="sxs-lookup"><span data-stu-id="60bda-673">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-674">L’exemple suivant crée un tableau de nombres complexes et affiche chacun à l’aide de plusieurs chaînes de format standard ainsi que <xref:System.Globalization.CultureInfo> objets qui représentent les cultures Anglais - États-Unis (« en-US ») et Français - France (« fr-FR »).</span><span class="sxs-lookup"><span data-stu-id="60bda-674">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="60bda-675"><paramref name="format" /> n’est pas une chaîne de format valide.</span><span class="sxs-lookup"><span data-stu-id="60bda-675"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="60bda-676">Chaînes de format numériques standard</span><span class="sxs-lookup"><span data-stu-id="60bda-676">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="60bda-677">Chaînes de format numériques personnalisées</span><span class="sxs-lookup"><span data-stu-id="60bda-677">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60bda-678">Retourne une nouvelle instance <see cref="T:System.Numerics.Complex" /> avec un nombre réel égal à zéro et un nombre imaginaire égal à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-678">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60bda-679">Le <xref:System.Numerics.Complex.Zero> propriété est fréquemment utilisée pour comparer un <xref:System.Numerics.Complex> valeur à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-679">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60bda-680">L’exemple suivant instancie un <xref:System.Numerics.Complex> valeur à l’aide de la <xref:System.Numerics.Complex.Zero> propriété.</span><span class="sxs-lookup"><span data-stu-id="60bda-680">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="60bda-681">Il compare ensuite cette valeur à une autre valeur est instanciée en appelant le <xref:System.Numerics.Complex> constructeur avec une partie réelle égale à zéro et une partie imaginaire égale à zéro.</span><span class="sxs-lookup"><span data-stu-id="60bda-681">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="60bda-682">Comme le montre la sortie de l’exemple, les deux valeurs sont égales.</span><span class="sxs-lookup"><span data-stu-id="60bda-682">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>