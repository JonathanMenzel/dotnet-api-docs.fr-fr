<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e1cc88ecbcca23616e88b5a9a8dc83caae6a32e3" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39913976" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un entier signé arbitrairement grand.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger> type est un type immuable qui représente un entier arbitrairement grand dont la valeur en théorie n’a aucune limite supérieure ou inférieure. Les membres de la <xref:System.Numerics.BigInteger> type proches de celles des autres types intégraux (le <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, et <xref:System.UInt64> types). Ce type diffère des autres types intégraux dans la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], qui ont une plage indiquée par leurs `MinValue` et `MaxValue` propriétés.  
  
> [!NOTE]
>  Étant donné que le <xref:System.Numerics.BigInteger> type est immuable (consultez [la mutabilité et BigInteger Structure](#mutability)) et car il n’a aucune limite supérieure ou inférieure, une <xref:System.OutOfMemoryException> peut être levée pour toute opération qui entraîne un <xref:System.Numerics.BigInteger> valeur à croissance trop grand.  
  
## <a name="instantiating-a-biginteger-object"></a>Instanciation d’un objet BigInteger  
 Vous pouvez instancier un <xref:System.Numerics.BigInteger> objet de plusieurs façons :  
  
-   Vous pouvez utiliser la `new` mot clé et de fournir n’importe quelle valeur intégrale ou à virgule flottante en tant que paramètre à la <xref:System.Numerics.BigInteger> constructeur. (Les valeurs à virgule flottante sont tronquées avant qu’ils sont affectés à la <xref:System.Numerics.BigInteger>.) L’exemple suivant montre comment utiliser le `new` mot clé pour instancier <xref:System.Numerics.BigInteger> valeurs.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   Vous pouvez déclarer un <xref:System.Numerics.BigInteger> variable et assigner une valeur tout comme vous serait le tout type numérique, à condition que cette valeur est un type intégral. L’exemple suivant utilise l’attribution pour créer un <xref:System.Numerics.BigInteger> valeur à partir d’un <xref:System.Int64>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   Vous pouvez affecter une valeur décimale ou à virgule flottante à un <xref:System.Numerics.BigInteger> vous effectuez un cast de la valeur ou tout d’abord le convertir l’objet. L’exemple suivant effectue un cast (en c#) ou convertit (en Visual Basic) explicitement un <xref:System.Double> et un <xref:System.Decimal> valeur à un <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Ces méthodes permettent d’instancier un <xref:System.Numerics.BigInteger> types uniquement de l’objet dont la valeur est dans la plage d’un des numériques existants. Vous pouvez instancier un <xref:System.Numerics.BigInteger> objet dont la valeur peut dépasser la plage des types numériques existants dans un des trois façons :  
  
-   Vous pouvez utiliser la `new` mot clé et fournir un tableau d’octets de toute taille pour le <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> constructeur. Exemple :  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   Vous pouvez appeler la <xref:System.Numerics.BigInteger.Parse%2A> ou <xref:System.Numerics.BigInteger.TryParse%2A> méthodes pour convertir la représentation sous forme de chaîne d’un nombre en une <xref:System.Numerics.BigInteger>. Exemple :  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   Vous pouvez appeler un `static` (`Shared` en Visual Basic) <xref:System.Numerics.BigInteger> méthode qui effectue une opération sur une expression numérique et retourne un calculé <xref:System.Numerics.BigInteger> résultat. L’exemple suivant fait cela par la création de cubes <xref:System.UInt64.MaxValue?displayProperty=nameWithType> et assigne le résultat à un <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 La valeur non initialisée d’un <xref:System.Numerics.BigInteger> est <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Exécution d’opérations sur des valeurs BigInteger  
 Vous pouvez utiliser un <xref:System.Numerics.BigInteger> instance comme vous utiliseriez tout autre type intégral. <xref:System.Numerics.BigInteger> surcharge les opérateurs numériques standards pour que vous puissiez effectuer des opérations mathématiques de base telles que l’addition, soustraction, division, multiplication, soustraction, négation et négation unaire. Vous pouvez également utiliser les opérateurs numériques standard pour comparer deux <xref:System.Numerics.BigInteger> valeurs entre eux. Comme les autres types intégraux, <xref:System.Numerics.BigInteger> prend également en charge l’opérateur de bits `And`, `Or`, `XOr`, gauche MAJ et les opérateurs de décalage vers la droite. Pour les langages qui ne prennent pas en charge les opérateurs personnalisés, la <xref:System.Numerics.BigInteger> structure fournit également des méthodes équivalentes pour effectuer des opérations mathématiques. Ceux-ci incluent <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>et plusieurs autres.  
  
 De nombreux membres de la <xref:System.Numerics.BigInteger> structure correspondent directement aux membres des autres types intégraux. En outre, <xref:System.Numerics.BigInteger> ajoute des membres tels que les éléments suivants :  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, qui retourne une valeur qui indique le signe d’un <xref:System.Numerics.BigInteger> valeur.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, qui retourne la valeur absolue d’un <xref:System.Numerics.BigInteger> valeur.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, qui retourne le quotient et le reste d’une opération de division.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, qui retourne le plus grand commun diviseur de deux <xref:System.Numerics.BigInteger> valeurs.  
  
 La plupart de ces membres supplémentaires correspondent aux membres de la <xref:System.Math> (classe), qui fournit la fonctionnalité pour travailler avec les types numériques primitifs.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>La mutabilité et Structure BigInteger  
 L’exemple suivant instancie un <xref:System.Numerics.BigInteger> de l’objet, puis incrémente sa valeur d’une unité.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Bien que cet exemple s’affiche pour modifier la valeur de l’objet existant, cela n’est pas le cas. <xref:System.Numerics.BigInteger> les objets sont immuables, ce qui signifie qu’en interne, le common language runtime crée en fait un <xref:System.Numerics.BigInteger> de l’objet et lui assigne une valeur supérieure à sa valeur précédente. Ce nouvel objet est ensuite retourné à l’appelant.  
  
> [!NOTE]
>  Les autres types numériques dans le .NET Framework sont également immuables. Toutefois, étant donné que le <xref:System.Numerics.BigInteger> type n’a aucune limite supérieure ou inférieure, ses valeurs peuvent considérablement augmenter et avoir un impact mesurable sur les performances.  
  
 Bien que ce processus est transparent pour l’appelant, il entraîne une baisse des performances. Dans certains cas, particulièrement lorsque des opérations répétées sont exécutées dans une boucle sur très volumineux <xref:System.Numerics.BigInteger> valeurs, cette altération des performances peut être significative. Par exemple, dans l’exemple suivant, une opération répétitivement jusqu'à un million de fois et un <xref:System.Numerics.BigInteger> valeur est incrémentée d’un chaque fois que l’opération réussit.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 Dans ce cas, vous pouvez améliorer les performances en exécutant toutes les assignations intermédiaires à un <xref:System.Int32> variable. La valeur finale de la variable peut ensuite être assignée à la <xref:System.Numerics.BigInteger> objet lors de la boucle s’arrête. L'exemple suivant illustre cette situation.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Utilisation des chaînes hexadécimales et des tableaux d’octets  
 Si vous convertissez <xref:System.Numerics.BigInteger> valeurs aux tableaux d’octets, ou si vous convertissez des tableaux d’octets à <xref:System.Numerics.BigInteger> valeurs, vous devez prendre en compte l’ordre des octets. Le <xref:System.Numerics.BigInteger> structure attend les octets individuels dans un tableau d’octets apparaissent dans l’ordre de primauté (autrement dit, les octets de poids faible de la valeur précèdent les octets d’ordre supérieur). Vous pouvez effectuer un aller-retour d’une <xref:System.Numerics.BigInteger> valeur en appelant le <xref:System.Numerics.BigInteger.ToByteArray%2A> (méthode), puis en passant l’octet qui en résulte de tableau à la <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructeur, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Pour instancier un <xref:System.Numerics.BigInteger> valeur à partir d’un tableau d’octets qui représente une valeur d’un autre type intégral, vous pouvez passer la valeur intégrale la <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> (méthode) et transmettez l’octet qui en résulte de tableau à la <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructeur. L’exemple suivant instancie un <xref:System.Numerics.BigInteger> valeur à partir d’un tableau d’octets qui représente un <xref:System.Int16> valeur.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 Le <xref:System.Numerics.BigInteger> structure suppose que les valeurs négatives sont stockées en utilisant la représentation de complément à deux. Étant donné que le <xref:System.Numerics.BigInteger> structure représente une valeur numérique sans longueur fixe, le <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructeur interprète toujours le bit le plus significatif du dernier octet dans le tableau comme un bit de signe. Pour empêcher le <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructeur à partir de la confusion entre des deux complément représentation d’une valeur négative avec la représentation sous forme de signe et la grandeur d’une valeur positive, positive valeurs dans lequel le meilleur bit significatif du dernier octet dans le tableau d’octets serait normalement jeu doit inclure un octet supplémentaire dont la valeur est 0. Par exemple, 0xC0 0xBD 0xF0 0xFF est la représentation hexadécimale little endian de -1,000,000 ou 4,293,967,296. Étant donné que le bit le plus significatif du dernier octet dans ce tableau est sur, la valeur du tableau d’octets serait interprétée par le <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructeur comme -1,000,000. Pour instancier un <xref:System.Numerics.BigInteger> dont la valeur est positive, un tableau d’octets dont les éléments sont des 0xC0 0xBD 0xF0 0xFF 0x00 doit être passé au constructeur. L'exemple suivant illustre ce comportement.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Les tableaux d’octets créés par la <xref:System.Numerics.BigInteger.ToByteArray%2A> méthode à partir des valeurs positives incluent cet octet de valeur zéro supplémentaire. Par conséquent, le <xref:System.Numerics.BigInteger> structure peut effectuer un aller-retour avec valeurs en les assignant puis de les restaurer à partir de tableaux d’octets, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 Toutefois, vous devrez peut-être ajouter cet octet de valeur zéro supplémentaire aux tableaux d’octets qui sont créés dynamiquement par le développeur ou qui sont retournés par les méthodes qui convertissent des entiers non signés en tableaux d’octets (tel que <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, et <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 Lors de l’analyse d’une chaîne hexadécimale, les <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> et <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> méthodes supposent que si le bit le plus significatif du premier octet dans la chaîne est défini, ou si le premier chiffre hexadécimal de la chaîne représente les quatre bits de poids faible d’une valeur d’octet, la valeur est représentés à l’aide de représentation de complément à deux. Par exemple, « FF01 » et « F01 » représentent la valeur décimale -255. Pour différencier positif à partir de valeurs négatives, les valeurs positives doivent inclure un zéro non significatif. Les surcharges appropriées de la <xref:System.Numerics.BigInteger.ToString%2A> (méthode), lorsqu’ils sont passés à la chaîne de format « X », ajoutez un zéro non significatif à la chaîne hexadécimale retournée pour les valeurs positives. Cela rend possible pour effectuer un aller-retour <xref:System.Numerics.BigInteger> valeurs à l’aide de la <xref:System.Numerics.BigInteger.ToString%2A> et <xref:System.Numerics.BigInteger.Parse%2A> méthodes, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 Toutefois, les chaînes hexadécimales créées en appelant le `ToString` méthodes d’autres types intégraux ou des surcharges de la <xref:System.Convert.ToString%2A> méthode qui incluent un `toBase` paramètre n’indiquent pas le signe de la valeur ou le type de source de données à partir de laquelle la chaîne hexadécimale a été dérivée. Instanciation avec succès une <xref:System.Numerics.BigInteger> valeur d’une telle chaîne requiert une logique supplémentaire. L’exemple suivant fournit une implémentation possible.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Numerics.BigInteger" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Tableau de valeurs d'octets respectant un ordre avec primauté des octets de poids faible (little-endian).</param>
        <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Numerics.BigInteger" /> à l'aide des valeurs d'un tableau d'octets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque octet dans le `value` tableau doit être dans l’ordre de primauté, à partir de l’octet de poids le plus bas à l’octet de poids le plus élevé. Par exemple, la valeur numérique 1,000,000,000,000 est représentée comme indiqué dans le tableau suivant :  
  
|||  
|-|-|  
|Chaîne hexadécimale|E8D4A51000|  
|Tableau d’octets (index le moins élevé tout d’abord)|00 E8 DE D4 A5 10 00|  
  
 La plupart des méthodes qui convertissent des valeurs numériques aux tableaux d’octets, tels que <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> et <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, retournent des tableaux d’octets dans l’ordre little-endian.  
  
 Le constructeur attend des valeurs positives dans le tableau d’octets à utiliser la représentation sous forme de signe et magnitude et les valeurs négatives pour utiliser la représentation de complément à deux. En d’autres termes, si l’ordre le plus élevé de bits de l’octet de poids le plus élevé dans `value` est défini, résultant <xref:System.Numerics.BigInteger> valeur est négative. Selon la source du tableau d’octets, cela peut entraîner une valeur positive être interprété à tort comme une valeur négative. Tableaux d’octets sont généralement générés comme suit :  
  
-   En appelant le <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> (méthode). Étant donné que cette méthode retourne un tableau d’octets avec le bit d’ordre le plus élevé de l’octet de poids le plus élevé dans le tableau défini à zéro pour les valeurs positives, il n’existe aucun risque d’une mauvaise interprétation d’une valeur positive comme négative. Non modifiée de tableaux d’octets créés par le <xref:System.Numerics.BigInteger.ToByteArray%2A> méthode toujours un aller-retour lorsqu’ils sont transmis à la <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructeur.  
  
-   En appelant le <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> (méthode) et en lui passant un entier signé en tant que paramètre. Entiers signés ne gèrent la représentation sous forme de signe et magnitude et représentation de complément à deux, étant donné qu’aucune chance d’une mauvaise interprétation d’une valeur positive comme négative.  
  
-   En appelant le <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> (méthode) et en lui passant un entier non signé en tant que paramètre. Étant donné que les entiers non signés sont représentés par leur grandeur uniquement, les valeurs positives peuvent être mal interprétés en tant que valeurs négatives. Pour empêcher cette interprétation erronée, vous pouvez ajouter une valeur de zéro octet à la fin du tableau. L’exemple dans la section suivante fournit une illustration.  
  
-   En créant un tableau d’octets soit statiquement ou dynamiquement, sans nécessairement appeler une des méthodes précédentes, ou en modifiant un tableau d’octets. Pour éviter les valeurs positives d’être interprétées comme des valeurs négatives, vous pouvez ajouter une valeur de zéro octet à la fin du tableau.  
  
 Si `value` est vide <xref:System.Byte> tableau, la nouvelle <xref:System.Numerics.BigInteger> objet est initialisé à une valeur de <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Si `value` est `null`, le constructeur lève un <xref:System.ArgumentNullException>.  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Numerics.BigInteger> objet à partir d’un tableau d’octets de 5 éléments dont la valeur est {5, 4, 3, 2, 1}. Il affiche ensuite le <xref:System.Numerics.BigInteger> valeur, représentée sous forme de nombres décimaux et hexadécimaux, dans la console. Une comparaison du tableau d’entrée avec la sortie de texte permet d’identifier clairement pourquoi cette surcharge de la <xref:System.Numerics.BigInteger> le constructeur de classe crée un <xref:System.Numerics.BigInteger> objet dont la valeur est 4328719365 (ou 0 x 102030405). Le premier élément du tableau d’octets, dont la valeur est 5, définit la valeur de l’octet de poids le plus bas de la <xref:System.Numerics.BigInteger> objet, qui est 0 x 05. Le deuxième élément du tableau d’octets, dont la valeur est 4, définit la valeur du deuxième octet de la <xref:System.Numerics.BigInteger> objet, qui est 0 x 04 et ainsi de suite.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 L’exemple suivant instancie un nombre positif et négatif <xref:System.Numerics.BigInteger> valeur, les transmet à la <xref:System.Numerics.BigInteger.ToByteArray%2A> (méthode), puis restaure l’original <xref:System.Numerics.BigInteger> valeurs du tableau d’octets qui en résulte. Notez que les deux valeurs sont représentées par les tableaux d’octets identiques. La seule différence entre eux est dans le bit le plus significatif du dernier élément dans le tableau d’octets. Ce bit est défini (la valeur de l’octet est 0xFF) si le tableau est créé à partir d’une valeur négative <xref:System.Numerics.BigInteger> valeur. Le bit n’est pas défini (la valeur de l’octet est zéro), si le tableau est créé à partir d’un nombre positif <xref:System.Numerics.BigInteger> valeur.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 L’exemple suivant illustre comment s’assurer qu’une valeur positive n'est pas instanciée incorrectement comme une valeur négative en ajoutant un octet dont la valeur est égale à zéro à la fin du tableau.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Nombre décimal.</param>
        <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Numerics.BigInteger" /> à l'aide d'une valeur <see cref="T:System.Decimal" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat de l’appel de ce constructeur est identique à l’affectation explicitement un <xref:System.Decimal> valeur un <xref:System.Numerics.BigInteger> variable.  
  
 Appel de ce constructeur peut entraîner une perte de données ; toute partie décimale de `value` est tronquée lors de l’instanciation un <xref:System.Numerics.BigInteger> objet.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> constructeur pour instancier un <xref:System.Numerics.BigInteger> objet. Il définit un tableau de <xref:System.Decimal> de valeurs et puis passe chaque valeur à la <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> constructeur. Notez que le <xref:System.Decimal> valeur est tronquée et non arrondie lorsqu’elle est assignée à la <xref:System.Numerics.BigInteger> objet.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à virgule flottante double précision.</param>
        <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Numerics.BigInteger" /> à l'aide d'une valeur à virgule flottante double précision.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Toute partie décimale de la `value` paramètre est tronqué lorsque vous instanciez un <xref:System.Numerics.BigInteger> objet.  
  
 En raison du manque de précision de la <xref:System.Double> type de données, l’appel de ce constructeur peut entraîner la perte de données.  
  
 Le <xref:System.Numerics.BigInteger> valeur qui résulte de l’appel de ce constructeur est identique à la valeur qui résulte de l’assignation explicite un <xref:System.Double> valeur à un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> constructeur pour instancier un <xref:System.Numerics.BigInteger> objet. Il illustre également la perte de précision qui peut se produire lorsque vous utilisez le <xref:System.Double> type de données. Un <xref:System.Double> est affectée une valeur élevée, qui est ensuite assignée à un <xref:System.Numerics.BigInteger> objet. Comme le montre la sortie, cette assignation implique une perte de précision. Les deux valeurs sont ensuite incrémentés d’un. La sortie montre que le <xref:System.Numerics.BigInteger> objet reflète la valeur modifiée, tandis que le <xref:System.Double> n’est pas le cas de l’objet.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est <see cref="F:System.Double.NaN" />.  
  
- ou - 
La valeur de <paramref name="value" /> est <see cref="F:System.Double.NegativeInfinity" />.  
  
- ou - 
La valeur de <paramref name="value" /> est <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Entier signé 32 bits.</param>
        <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Numerics.BigInteger" /> à l'aide d'une valeur d'entier 32 bits signé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il est sans perte de précision lors de l’instanciation un <xref:System.Numerics.BigInteger> objet à l’aide de ce constructeur.  
  
 Le <xref:System.Numerics.BigInteger> valeur qui résulte de l’appel de ce constructeur est identique à la valeur qui résulte de l’assignation d’un <xref:System.Int32> valeur à un <xref:System.Numerics.BigInteger>.  
  
 Le <xref:System.Numerics.BigInteger> structure n’inclut pas de constructeurs avec un paramètre de type <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, ou <xref:System.UInt16>. Toutefois, le <xref:System.Int32> type prend en charge la conversion implicite des entiers signés et non signés 8 bits et 16 bits en entiers 32 bits signés. Par conséquent, ce constructeur est appelé si `value` est l’un de ces quatre types intégraux.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> constructeur pour instancier <xref:System.Numerics.BigInteger> valeurs à partir d’un tableau d’entiers 32 bits. Il utilise également la conversion implicite pour assigner chaque valeur d’entier 32 bits à un <xref:System.Numerics.BigInteger> variable. Il compare ensuite les deux valeurs pour déterminer que résultant <xref:System.Numerics.BigInteger> valeurs sont les mêmes.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Entier signé 64 bits.</param>
        <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Numerics.BigInteger" /> à l’aide d’une valeur d’entier 64 bits signé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il est sans perte de précision lors de l’instanciation un <xref:System.Numerics.BigInteger> objet à l’aide de ce constructeur.  
  
 Le <xref:System.Numerics.BigInteger> valeur qui résulte de l’appel de ce constructeur est identique à la valeur qui résulte de l’assignation d’un <xref:System.Int64> valeur à un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> constructeur pour instancier <xref:System.Numerics.BigInteger> valeurs à partir d’un tableau d’entiers 64 bits. Il utilise également la conversion implicite pour assigner chaque valeur d’entier 64 bits à un <xref:System.Numerics.BigInteger> variable. Il compare ensuite les deux valeurs pour déterminer que résultant <xref:System.Numerics.BigInteger> valeurs sont les mêmes.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à virgule flottante simple précision.</param>
        <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Numerics.BigInteger" /> à l'aide d'une valeur à virgule flottante simple précision.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Toute partie décimale de la `value` paramètre est tronqué lorsque vous instanciez un <xref:System.Numerics.BigInteger> objet.  
  
 En raison du manque de précision de la <xref:System.Single> type de données, l’appel de ce constructeur peut entraîner une perte de données.  
  
 Le <xref:System.Numerics.BigInteger> valeur qui résulte de l’appel de ce constructeur est identique à la valeur qui résulte de l’assignation explicite un <xref:System.Single> valeur à un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> constructeur pour instancier un <xref:System.Numerics.BigInteger> objet. Il illustre également la perte de précision qui peut se produire lorsque vous utilisez le <xref:System.Single> type de données. Un <xref:System.Single> est affectée une valeur négative élevée, qui est ensuite assignée à un <xref:System.Numerics.BigInteger> objet. Comme le montre la sortie, cette assignation implique une perte de précision. Les deux valeurs sont ensuite incrémentés d’un. La sortie montre que le <xref:System.Numerics.BigInteger> objet reflète la valeur modifiée, tandis que le <xref:System.Single> n’est pas le cas de l’objet.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est <see cref="F:System.Single.NaN" />.  
  
- ou - 
La valeur de <paramref name="value" /> est <see cref="F:System.Single.NegativeInfinity" />.  
  
- ou - 
La valeur de <paramref name="value" /> est <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valeur d'entier 32 bits non signé.</param>
        <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Numerics.BigInteger" /> à l'aide d'une valeur entière 32 bits non signée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il est sans perte de précision lors de l’instanciation un <xref:System.Numerics.BigInteger> à l’aide de ce constructeur.  
  
 Le <xref:System.Numerics.BigInteger> valeur qui résulte de l’appel de ce constructeur est identique à la valeur qui résulte de l’assignation d’un <xref:System.UInt32> valeur à un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> constructeur et une instruction d’assignation pour initialiser <xref:System.Numerics.BigInteger> valeurs à partir d’un tableau d’entiers 32 bits non signés. Il compare alors les deux valeurs pour prouver que les deux méthodes d’initialisation un <xref:System.Numerics.BigInteger> valeur produisent des résultats identiques.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Entier 64 bits non signé.</param>
        <summary>Initialise une nouvelle instance de la structure <see cref="T:System.Numerics.BigInteger" /> à l'aide d'une valeur entière 64 bits non signée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il est sans perte de précision lors de l’instanciation un <xref:System.Numerics.BigInteger> à l’aide de ce constructeur.  
  
 Le <xref:System.Numerics.BigInteger> valeur qui résulte de l’appel de ce constructeur est identique à la valeur qui résulte de l’assignation d’un <xref:System.UInt64> valeur à un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> constructeur pour instancier un <xref:System.Numerics.BigInteger> objet dont la valeur est égale à <xref:System.UInt64.MaxValue>.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Nombre.</param>
        <summary>Obtient la valeur absolue d'un objet <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Valeur absolue de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur absolue d’un nombre est ce nombre sans son signe, comme indiqué dans le tableau suivant.  
  
|Paramètre `value`|Valeur de retour|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 Le <xref:System.Numerics.BigInteger.Abs%2A> méthode est équivalente à la <xref:System.Math.Abs%2A?displayProperty=nameWithType> méthode pour les types numériques primitifs.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Numerics.BigInteger.Abs%2A> méthode pour convertir un <xref:System.Numerics.BigInteger> valeur à partir de la représentation du complément de deux à la représentation « signe et magnitude » avant de le sérialiser dans un fichier. Les données dans le fichier sont ensuite désérialisées et assignées à une nouvelle <xref:System.Numerics.BigInteger> objet.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à ajouter.</param>
        <param name="right">Seconde valeur à ajouter.</param>
        <summary>Ajoute deux valeurs <see cref="T:System.Numerics.BigInteger" /> et retourne le résultat.</summary>
        <returns>Somme de <paramref name="left" /> et <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les langages qui ne prennent pas en charge la surcharge d’opérateur ou les opérateurs personnalisés peuvent utiliser le <xref:System.Numerics.BigInteger.Add%2A> (méthode) à l’aide de l’addition <xref:System.Numerics.BigInteger> valeurs.  
  
 Le <xref:System.Numerics.BigInteger.Add%2A> méthode est un substitut utile pour l’opérateur d’addition lors de l’instanciation une <xref:System.Numerics.BigInteger> variable en lui assignant une somme qui résulte d’une addition, comme indiqué dans l’exemple suivant.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Compare deux valeurs <see cref="T:System.Numerics.BigInteger" /> et retourne un entier qui indique si la première valeur est inférieure, égale ou supérieure à la seconde valeur.</summary>
        <returns>Entier signé qui indique les valeurs relatives de <paramref name="left" /> et <paramref name="right" />, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Valeur  </term><description> Condition  </description></listheader><item><term> Inférieur à zéro  </term><description><paramref name="left" /> est inférieur à <paramref name="right" />.  </description></item><item><term> Zéro  </term><description><paramref name="left" /> égale <paramref name="right" />.  </description></item><item><term> Supérieur à zéro  </term><description><paramref name="left" /> est supérieur à <paramref name="right" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le <xref:System.Numerics.BigInteger> type ait aucune plage fixe, les comparaisons de <xref:System.Numerics.BigInteger> valeurs ne sont pas caractérisées par le manque de précision qui caractérise la comparaison de nombres à virgule flottante. L’exemple suivant compare deux <xref:System.Numerics.BigInteger> valeurs qui diffèrent par un et que chacun ont 1 896 chiffres. Le <xref:System.Numerics.BigInteger.Compare%2A> méthode signale correctement que les deux valeurs ne sont pas égales.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compare la valeur de cette instance à une autre valeur et retourne un entier qui indique si la valeur de l'instance est inférieure, égale ou supérieure à l'autre valeur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Entier 64 bits signé à comparer.</param>
        <summary>Compare cette instance à un entier 64 bits signé et retourne un entier qui indique si la valeur de cette instance est inférieure, égale ou supérieure à la valeur de l'entier 64 bits signé.</summary>
        <returns>Valeur entière signée qui indique la relation de cette instance par rapport à <paramref name="other" />, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Valeur de retour  </term><description> Description  </description></listheader><item><term> Inférieure à zéro  </term><description> L’instance actuelle est inférieure à <paramref name="other" />.  </description></item><item><term> Zéro  </term><description> L’instance actuelle est égale à <paramref name="other" />.  </description></item><item><term> Supérieure à zéro  </term><description> L’instance actuelle est supérieure à <paramref name="other" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `other` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque le <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> méthode est appelée.  
  
   
  
## Examples  
 L’exemple suivant illustre le résultat de l’appel la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> méthode avec des valeurs intégrales.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Objet à comparer.</param>
        <summary>Compare cette instance à un second <see cref="T:System.Numerics.BigInteger" /> et retourne un entier qui indique si la valeur de l'instance est inférieure, égale ou supérieure à la valeur de l'objet spécifié.</summary>
        <returns>Valeur entière signée qui indique la relation de cette instance par rapport à <paramref name="other" />, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Valeur de retour  </term><description> Description  </description></listheader><item><term> Inférieure à zéro  </term><description> L’instance actuelle est inférieure à <paramref name="other" />.  </description></item><item><term> Zéro  </term><description> L’instance actuelle est égale à <paramref name="other" />.  </description></item><item><term> Supérieure à zéro  </term><description> L’instance actuelle est supérieure à <paramref name="other" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de la <xref:System.Numerics.BigInteger.CompareTo%2A> méthode implémente la <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> (méthode). Il est utilisé par les objets de collection générique pour classer les éléments dans la collection.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> pour classer une liste de `StarInfo` objets. Chaque `StarInfo` objet fournit des informations sur le nom d’une étoile et sa distance à partir de la terre en miles. `StarInfo` implémente le <xref:System.IComparable%601> interface, ce qui permet `StarInfo` les objets à trier par les classes de collection générique. Son <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implémentation encapsule simplement un appel à <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 Le code suivant instancie ensuite quatre `StarInfo` objets et les stocke dans un générique <xref:System.Collections.Generic.List%601> objet. Après le <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> méthode est appelée, `StarInfo` objets sont affichés dans l’ordre de leur distance par rapport à la terre.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer.</param>
        <summary>Compare cette instance à un objet spécifié et retourne un entier qui indique si la valeur de cette instance est inférieure, égale ou supérieure à la valeur de l'objet spécifié.</summary>
        <returns>Entier signé qui indique la relation de l'instance actuelle par rapport au paramètre <paramref name="obj" />, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Valeur de retour  </term><description> Description  </description></listheader><item><term> Inférieure à zéro  </term><description> L’instance actuelle est inférieure à <paramref name="obj" />.  </description></item><item><term> Zéro  </term><description> L’instance actuelle est égale à <paramref name="obj" />.  </description></item><item><term> Supérieure à zéro  </term><description> L’instance actuelle est supérieure à <paramref name="obj" /> ou le paramètre <paramref name="obj" /> est <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de la <xref:System.Numerics.BigInteger.CompareTo%2A> méthode implémente la <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> (méthode). Il est utilisé par les objets de collection non générique pour classer les éléments dans la collection.  
  
 Le `obj` paramètre doit être une des opérations suivantes :  
  
-   Objet dont le type d’exécution est <xref:System.Numerics.BigInteger>.  
  
-   Un <xref:System.Object> variable dont la valeur est `null`. Si la valeur de la `obj` paramètre est `null`, la méthode retourne 1, ce qui indique que l’instance actuelle est supérieure à `obj`.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> méthode pour comparer un <xref:System.Numerics.BigInteger> valeur avec chaque élément dans un tableau d’objets  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> n'est pas un <see cref="T:System.Numerics.BigInteger" />.</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Entier 64 bits non signé à comparer.</param>
        <summary>Compare cette instance à un entier 64 bits non signé et retourne un entier qui indique si la valeur de cette instance est inférieure, égale ou supérieure à la valeur de l'entier 64 bits non signé.</summary>
        <returns>Entier signé qui indique la valeur relative de cette instance et de <paramref name="other" />, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Valeur de retour  </term><description> Description  </description></listheader><item><term> Inférieure à zéro  </term><description> L’instance actuelle est inférieure à <paramref name="other" />.  </description></item><item><term> Zéro  </term><description> L’instance actuelle est égale à <paramref name="other" />.  </description></item><item><term> Supérieure à zéro  </term><description> L’instance actuelle est supérieure à <paramref name="other" />.  </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valeur à diviser.</param>
        <param name="divisor">Valeur par laquelle diviser.</param>
        <summary>Divise une valeur <see cref="T:System.Numerics.BigInteger" /> par une autre et retourne le résultat.</summary>
        <returns>Quotient de la division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.Divide%2A> méthode effectue une division entière ; tout élément restant qui résulte de la division est ignoré. Pour effectuer la division d’entier en conservant le reste, appelez le <xref:System.Numerics.BigInteger.DivRem%2A> (méthode). Pour récupérer uniquement le reste, appelez le <xref:System.Numerics.BigInteger.Remainder%2A> (méthode).  
  
 Le <xref:System.Numerics.BigInteger.Divide%2A> méthode peut être utilisée par les langages qui ne prennent pas en charge la surcharge d’opérateur. Son comportement est identique à la division à l’aide de l’opérateur de division.  
  
   
  
## Examples  
 L’exemple suivant crée un tableau de <xref:System.Numerics.BigInteger> valeurs. Il utilise ensuite chaque élément comme quotient dans une opération de division qui utilise le <xref:System.Numerics.BigInteger.Divide%2A> (méthode), l’opérateur de division (/) et le <xref:System.Numerics.BigInteger.DivRem%2A> (méthode).  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> est égal à 0 (zéro).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">Valeur à diviser.</param>
        <param name="divisor">Valeur par laquelle diviser.</param>
        <param name="remainder">Lorsque cette méthode est retournée, contient une valeur <see cref="T:System.Numerics.BigInteger" /> qui représente le modulo de la division. Ce paramètre est passé sans être initialisé.</param>
        <summary>Divise une valeur <see cref="T:System.Numerics.BigInteger" /> par une autre, retourne le résultat, puis retourne le modulo dans un paramètre de sortie.</summary>
        <returns>Quotient de la division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet de conserver le quotient et le reste de la division d’entier. Si vous n’êtes pas intéressé par la suite, utilisez le <xref:System.Numerics.BigInteger.Divide%2A> méthode ou l’opérateur de division ; si vous êtes uniquement intéressé par la suite, utilisez le <xref:System.Numerics.BigInteger.Remainder%2A> (méthode).  
  
 Le signe de retourné `remainder` valeur est identique à celui de la `dividend` paramètre.  
  
 Le comportement de la <xref:System.Numerics.BigInteger.DivRem%2A> méthode est identique à celle de la <xref:System.Math.DivRem%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant crée un tableau de <xref:System.Numerics.BigInteger> valeurs. Il utilise ensuite chaque élément comme quotient dans une opération de division qui utilise le <xref:System.Numerics.BigInteger.Divide%2A> (méthode), l’opérateur de division (/) et le <xref:System.Numerics.BigInteger.DivRem%2A> (méthode).  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> est égal à 0 (zéro).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une valeur qui indique si deux valeurs numériques sont égales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Valeur entière 64 bits signée à comparer.</param>
        <summary>Retourne une valeur qui indique si l'instance actuelle et un entier 64 bits signé ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si l'entier 64 bits signé et l'instance actuelle ont la même valeur ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `other` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque la méthode est appelée.  
  
 Pour déterminer la relation entre les deux objets au lieu d’un simple test d’égalité, appelez le <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant instancie un <xref:System.Numerics.BigInteger> objet à partir de chaque type intégral sauf <xref:System.UInt64>. Il appelle ensuite la <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> méthode pour comparer la <xref:System.Numerics.BigInteger> valeur avec la valeur entière d’origine qui a été passée à la <xref:System.Numerics.BigInteger> constructeur. Comme le montre la sortie, les valeurs sont égales dans chaque cas.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Objet à comparer.</param>
        <summary>Retourne une valeur qui indique si l'instance actuelle et un objet <see cref="T:System.Numerics.BigInteger" /> spécifié ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si cet objet <see cref="T:System.Numerics.BigInteger" /> et <paramref name="other" /> ont la même valeur ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode implémente la <xref:System.IEquatable%601> interface et effectue légèrement meilleures que <xref:System.Numerics.BigInteger.Equals%28System.Object%29> , car il n’a pas à convertir le `other` paramètre à un <xref:System.Numerics.BigInteger> objet.  
  
 Pour déterminer la relation entre les deux <xref:System.Numerics.BigInteger> des objets au lieu d’un simple test d’égalité, appelez le <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant compare la distance approximative plusieurs étoiles à partir de la terre, la distance de ble Epsilon à partir de la terre pour déterminer s’ils sont égaux. L’exemple utilise chaque surcharge de la <xref:System.Numerics.BigInteger.Equals%2A> méthode pour tester l’égalité.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer.</param>
        <summary>Retourne une valeur qui indique si l'instance actuelle et un objet spécifié ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si l’argument <paramref name="obj" /> est un objet <see cref="T:System.Numerics.BigInteger" /> et si sa valeur est égale à la valeur de l’instance <see cref="T:System.Numerics.BigInteger" /> actuelle ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `obj` argument n’est pas un <xref:System.Numerics.BigInteger> valeur, la méthode retourne `false`. La méthode retourne `true` uniquement si `obj` est un <xref:System.Numerics.BigInteger> instance dont la valeur est égale à l’instance actuelle.  
  
 Pour déterminer la relation entre les deux objets au lieu d’un simple test d’égalité, appelez le <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> (méthode).  
  
   
  
## Examples  
 L’exemple suivant définit parallèle <xref:System.Object> et <xref:System.Numerics.BigInteger> tableaux. Chaque élément d’un tableau a la même valeur que l’élément correspondant du deuxième tableau. Comme la sortie de l’exemple, l’instance dans le <xref:System.Numerics.BigInteger> tableau est considéré comme égal à l’instance dans le <xref:System.Object> tableau uniquement si ce dernier est un <xref:System.Numerics.BigInteger> et leurs valeurs sont égales.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Entier 64 bits non signé à comparer.</param>
        <summary>Retourne une valeur qui indique si l'instance actuelle et un entier 64 bits non signé ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si l'instance actuelle et l'entier 64 bits non signé ont la même valeur ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour déterminer la relation entre les deux objets au lieu d’un simple test d’égalité, appelez le <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant compare la distance approximative plusieurs étoiles à partir de la terre, la distance de ble Epsilon à partir de la terre pour déterminer s’ils sont égaux. L’exemple utilise chaque surcharge de la <xref:System.Numerics.BigInteger.Equals%2A> méthode pour tester l’égalité.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage pour l'objet <see cref="T:System.Numerics.BigInteger" /> actuel.</summary>
        <returns>Code de hachage d'un entier signé 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur.</param>
        <param name="right">Seconde valeur.</param>
        <summary>Recherche le plus grand commun diviseur de deux valeurs <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Plus grand dénominateur commun de <paramref name="left" /> et <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le plus grand commun diviseur est le plus grand nombre dans lequel les deux <xref:System.Numerics.BigInteger> valeurs peuvent être divisées sans retourner de reste.  
  
 Si le `left` et `right` paramètres sont des nombres de zéro, la méthode retourne toujours au moins une valeur de 1, car tous les nombres peuvent être divisés par 1. Si des deux paramètres est égal à zéro, la méthode retourne la valeur absolue du paramètre non nulle. Si les deux valeurs sont nulles, la méthode retourne la valeur zéro.  
  
> [!NOTE]
>  Le plus grand commun diviseur de très grandes valeurs de l’informatique `left` et `right` peut être une opération très longue.  
  
 La valeur retournée par la <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> méthode est toujours positive, quel que soit le signe de la `left` et `right` paramètres.  
  
   
  
## Examples  
 L’exemple suivant illustre un appel à la <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> méthode et la gestion des exceptions nécessaire pour fournir des informations utiles concernant un <xref:System.ArgumentOutOfRangeException>. Le résultat indique que le plus grand commun diviseur de ces deux nombres est 1.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si la valeur de l'objet <see cref="T:System.Numerics.BigInteger" /> actif est un nombre pair.</summary>
        <value>
          <see langword="true" /> si la valeur de l'objet <see cref="T:System.Numerics.BigInteger" /> est un nombre pair ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est une fonctionnalité pratique qui indique si un <xref:System.Numerics.BigInteger> valeur est divisible par deux. Elle est équivalente à l’expression suivante :  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Si la valeur de la <xref:System.Numerics.BigInteger> objet est <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, la propriété retourne `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si la valeur de l'objet <see cref="T:System.Numerics.BigInteger" /> actif est <see cref="P:System.Numerics.BigInteger.One" />.</summary>
        <value>
          <see langword="true" /> si la valeur de l'objet <see cref="T:System.Numerics.BigInteger" /> est <see cref="P:System.Numerics.BigInteger.One" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété offre de bien meilleures performances que d’autres, tels que `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si la valeur de l'objet <see cref="T:System.Numerics.BigInteger" /> actif est une puissance de deux.</summary>
        <value>
          <see langword="true" /> si la valeur de l'objet <see cref="T:System.Numerics.BigInteger" /> est une puissance de deux ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété détermine si un <xref:System.Numerics.BigInteger> valeur a un seul bit de zéro à définir. Cela signifie qu’il retourne `true` si la valeur de la <xref:System.Numerics.BigInteger> objet est 1 (autrement dit, 2<sup>0</sup>) ou toute autre puissance de deux. Elle retourne `false` si la valeur de la <xref:System.Numerics.BigInteger> objet est égal à 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si la valeur de l'objet <see cref="T:System.Numerics.BigInteger" /> actif est <see cref="P:System.Numerics.BigInteger.Zero" />.</summary>
        <value>
          <see langword="true" /> si la valeur de l'objet <see cref="T:System.Numerics.BigInteger" /> est <see cref="P:System.Numerics.BigInteger.Zero" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété offre de bien meilleures performances que `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne le logarithme d'un nombre spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Nombre dont le logarithme doit être recherché.</param>
        <summary>Retourne le logarithme naturel (base <see langword="e" />) d'un nombre spécifié.</summary>
        <returns>Logarithme népérien (de base <see langword="e" />) de <paramref name="value" />, comme indiqué dans le tableau de la section Notes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `value` paramètre est spécifié comme un nombre de base 10.  
  
 Retour le précise la valeur de cette méthode dépend de la connexion de `value`, comme illustré dans le tableau suivant.  
  
|Se connecter de `value` paramètre|Valeur de retour|  
|-------------------------------|------------------|  
|Positif|Le logarithme népérien de `value`; autrement dit, à savoir ln `value`, ou log e`value`.|  
|Zéro|<xref:System.Double.NegativeInfinity>.|  
|Négatif|<xref:System.Double.NaN>.|  
  
 Pour calculer le logarithme base 10 d’un <xref:System.Numerics.BigInteger> valeur, appelez le <xref:System.Numerics.BigInteger.Log10%2A> (méthode). Pour calculer le logarithme d’un nombre dans une autre base, appelez le <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> (méthode).  
  
 Vous pouvez trouver la racine carrée d’un nombre en appelant le <xref:System.Numerics.BigInteger.Log%2A> méthode avec le <xref:System.Math.Exp%2A?displayProperty=nameWithType> (méthode). Notez que le résultat est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> si le résultat est supérieur à <xref:System.Double.MaxValue?displayProperty=nameWithType>. L’exemple suivant calcule la racine carrée de chaque élément dans un tableau de <xref:System.Numerics.BigInteger> valeurs.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Cette méthode correspond à la <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> méthode pour les types numériques primitifs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le logarithme népérien de <paramref name="value" /> est hors des limites du type de données <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Nombre dont le logarithme doit être recherché.</param>
        <param name="baseValue">Base du logarithme.</param>
        <summary>Retourne le logarithme d'un nombre spécifié dans une base spécifiée.</summary>
        <returns>Logarithme de base <paramref name="baseValue" /> de <paramref name="value" />, comme indiqué dans le tableau de la section Notes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `value` et `baseValue` paramètres sont spécifiés comme nombres de base 10.  
  
 De retour le précise la valeur de la méthode varie selon le signe de `value` et sur la connexion et la valeur de `baseValue`, comme illustré dans le tableau suivant.  
  
|Paramètre `value`|Paramètre `baseValue`|Valeur de retour|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1) - ou -(`baseValue` > 1)|logbaseValue (`value`)|  
|`value` < 0|(toute valeur)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(toute valeur)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(toute valeur)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(toute valeur)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Pour calculer le logarithme base 10 d’un <xref:System.Numerics.BigInteger> valeur, appelez le <xref:System.Numerics.BigInteger.Log10%2A> (méthode). Pour calculer le logarithme népérien d’un nombre, appelez le <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> (méthode).  
  
 Cette méthode correspond à la <xref:System.Math.Log%2A?displayProperty=nameWithType> méthode pour les types numériques primitifs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le logarithme de <paramref name="value" /> est hors des limites du type de données <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Nombre dont le logarithme doit être recherché.</param>
        <summary>Retourne le logarithme de base 10 d'un nombre spécifié.</summary>
        <returns>Logarithme de base 10 de <paramref name="value" />, comme indiqué dans le tableau de la section Notes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `value` paramètre est spécifié comme un nombre de base 10.  
  
 De retour le précise la valeur de la méthode varie selon le signe de `value`, comme illustré dans le tableau suivant.  
  
|Signe du paramètre de valeur|Valeur de retour|  
|-----------------------------|------------------|  
|Positif|Le logarithme de base 10 de `value`; autrement dit, log10`value`.|  
|Zéro|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.|  
|Négatif|<xref:System.Double.NaN?displayProperty=nameWithType>.|  
  
 Pour calculer le logarithme népérien d’un <xref:System.Numerics.BigInteger> valeur, appelez le <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> (méthode). Pour calculer le logarithme d’un nombre dans une autre base, appelez le <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> (méthode).  
  
 Cette méthode correspond à la <xref:System.Math.Log10%2A?displayProperty=nameWithType> méthode pour les types numériques primitifs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le logarithme de base 10 de <paramref name="value" /> est hors des limites du type de données <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne la plus grande des deux valeurs <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Paramètre <paramref name="left" /> ou <paramref name="right" /> (selon celui qui est le plus grand).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode correspond à la <xref:System.Math.Max%2A?displayProperty=nameWithType> méthode pour les types numériques primitifs.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Numerics.BigInteger.Max%2A> méthode afin de sélectionner le plus grand nombre dans un tableau de <xref:System.Numerics.BigInteger> valeurs.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne la plus petite des deux valeurs <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Paramètre <paramref name="left" /> ou <paramref name="right" /> (selon celui qui est le plus petit).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode correspond à la <xref:System.Math.Min%2A?displayProperty=nameWithType> méthode pour les types numériques primitifs.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Numerics.BigInteger.Min%2A> méthode afin de sélectionner le plus petit nombre dans un tableau de <xref:System.Numerics.BigInteger> valeurs.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui représente le nombre moins un (-1).</summary>
        <value>Entier dont la valeur est moins un (-1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.MinusOne%2A> propriété est utilisée pour comparer un <xref:System.Numerics.BigInteger> valeur -1 ou affecter la valeur -1 pour un <xref:System.Numerics.BigInteger> objet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Nombre à élever à la puissance <c>exponent</c>.</param>
        <param name="exponent">Exposant de <c>value</c>.</param>
        <param name="modulus">Nombre par lequel diviser <c>value</c> élevé à la puissance <c>exponent</c>.</param>
        <summary>Effectue une division avec coefficient sur un nombre élevé à la puissance d'un autre nombre.</summary>
        <returns>Reste de la division de <paramref name="value" /><sup>exposant</sup> par <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.ModPow%2A> méthode évalue l’expression suivante :  
  
 (baseValue ^ exposant) Modulo MOD  
  
 Pour effectuer l’élévation sur <xref:System.Numerics.BigInteger> valeurs sans division modulo, utilisez la <xref:System.Numerics.BigInteger.Pow%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant fournit une illustration simple de l’appel le <xref:System.Numerics.BigInteger.ModPow%2A> (méthode).  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="modulus" /> est égal à zéro.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="exponent" /> est un nombre négatif.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Premier nombre à multiplier.</param>
        <param name="right">Second nombre à multiplier.</param>
        <summary>Retourne le produit de deux valeurs <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Produit des paramètres <paramref name="left" /> et <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.Multiply%2A> méthode est implémentée pour les langages qui ne prennent pas en charge la surcharge d’opérateur. Son comportement est identique à la multiplication à l’aide de l’opérateur de multiplication. En outre, le <xref:System.Numerics.BigInteger.Multiply%2A> méthode est un substitut utile pour l’opérateur de multiplication lors de l’instanciation une <xref:System.Numerics.BigInteger> variable en lui assignant un produit qui résulte de la multiplication, comme indiqué dans l’exemple suivant.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 Si nécessaire, cette méthode exécute automatiquement une conversion implicite des autres types intégraux pour <xref:System.Numerics.BigInteger> objets. Ceci est illustré dans l’exemple dans la section suivante, où le <xref:System.Numerics.BigInteger.Multiply%2A> deux est transmis à la méthode <xref:System.Int64> valeurs.  
  
   
  
## Examples  
 L’exemple suivant tente d’effectuer une multiplication avec deux entiers longs. Étant donné que le résultat dépasse la plage d’un entier long, un <xref:System.OverflowException> est levée et le <xref:System.Numerics.BigInteger.Multiply%2A> méthode est appelée pour gérer la multiplication. Notez que c# requiert que vous utilisez le `checked` mot clé (comme dans cet exemple) ou le `/checked+` option du compilateur pour vous assurer d’une exception est levée sur un dépassement de capacité numérique.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à rendre négative.</param>
        <summary>Rend négative la valeur <see cref="T:System.Numerics.BigInteger" /> spécifiée.</summary>
        <returns>Résultat de la multiplication du paramètre <paramref name="value" /> par moins un (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Négation Obtient l’inverse additif d’un nombre. L’inverse additif d’un nombre est un nombre qui produit une valeur égale à zéro lorsqu’il est ajouté au nombre d’origine.  
  
 Le <xref:System.Numerics.BigInteger.Negate%2A> méthode est implémentée pour les langages qui ne prennent pas en charge les opérateurs personnalisés. Son comportement est identique à la négation à l’aide de l’opérateur de négation unaire. En outre, le <xref:System.Numerics.BigInteger.Negate%2A> méthode est un substitut utile pour l’opérateur de négation lors de l’instanciation un <xref:System.Numerics.BigInteger> variable, comme indiqué dans l’exemple suivant.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 L’exemple suivant illustre trois façons d’exclure la valeur d’un <xref:System.Numerics.BigInteger> objet.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui représente le nombre un (1).</summary>
        <value>Objet dont la valeur est un (1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.One%2A> propriété est généralement utilisée pour comparer un <xref:System.Numerics.BigInteger> valeur sur 1 ou assigner 1 à un <xref:System.Numerics.BigInteger> objet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à ajouter.</param>
        <param name="right">Seconde valeur à ajouter.</param>
        <summary>Ajoute les valeurs des deux objets <see cref="T:System.Numerics.BigInteger" /> spécifiés.</summary>
        <returns>Somme de <paramref name="left" /> et <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Addition%2A> méthode définit l’opération d’addition pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Add%2A> méthode à la place.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur.</param>
        <param name="right">Seconde valeur.</param>
        <summary>Effectue une opération de bits <see langword="And" /> sur deux valeurs <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Résultat de l'opération de bits <see langword="And" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> méthode définit l’opérateur de bits `And` opération pour <xref:System.Numerics.BigInteger> valeurs. L’opérateur de bits `And` opération définit un bit de résultat uniquement si les bits correspondants `left` et `right` sont également définis, comme indiqué dans le tableau suivant.  
  
|Bit dans `left`|Bit dans `right`|Bit de résultat|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 Le <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> méthode permet de code semblable au suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 Le <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> méthode effectue les opérations de bits `And` opération sur deux <xref:System.Numerics.BigInteger> valeurs comme si elles étaient toutes deux dans la représentation du deux complément avec extension de signe virtuel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur.</param>
        <param name="right">Seconde valeur.</param>
        <summary>Effectue une opération de bits <see langword="Or" /> sur deux valeurs <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Résultat de l'opération de bits <see langword="Or" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> méthode définit l’opérateur de bits `Or` opération pour <xref:System.Numerics.BigInteger> valeurs. L’opérateur de bits `Or` opération définit un bit de résultat uniquement si les deux bits correspondants dans `left` et `right` sont définis, comme indiqué dans le tableau suivant.  
  
|Bit dans `left`|Bit dans `right`|Bit de résultat|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 Le <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> méthode permet de code semblable au suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 Le <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> méthode effectue les opérations de bits `Or` opération sur deux <xref:System.Numerics.BigInteger> valeurs comme si elles étaient toutes deux dans la représentation du deux complément avec extension de signe virtuel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à décrémenter.</param>
        <summary>Décrémente une valeur <see cref="T:System.Numerics.BigInteger" /> de 1.</summary>
        <returns>Valeur du paramètre <paramref name="value" /> décrémenté de 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Decrement%2A> méthode définit l’opération de décrémentation pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Subtract%2A> méthode à la place. Exemple :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Étant donné que <xref:System.Numerics.BigInteger> objets sont immuables, le <xref:System.Numerics.BigInteger.op_Decrement%2A> opérateur crée un nouveau <xref:System.Numerics.BigInteger> objet dont la valeur est inférieure à la <xref:System.Numerics.BigInteger> objet représenté par `value`. Cela signifie que les appels répétés à <xref:System.Numerics.BigInteger.op_Decrement%2A> peut s’avérer coûteux.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valeur à diviser.</param>
        <param name="divisor">Valeur par laquelle diviser.</param>
        <summary>Divise une valeur <see cref="T:System.Numerics.BigInteger" /> spécifique par une autre valeur <see cref="T:System.Numerics.BigInteger" /> spécifique à l'aide d'une division entière.</summary>
        <returns>Résultat intégral de la division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Division%2A> méthode définit l’opération de division pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés et la surcharge d’opérateur peuvent appeler la <xref:System.Numerics.BigInteger.Divide%2A> méthode à la place.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 L’exemple suivant crée un tableau de <xref:System.Numerics.BigInteger> valeurs. Il utilise ensuite chaque élément comme quotient dans une opération de division qui utilise le <xref:System.Numerics.BigInteger.Divide%2A> (méthode), l’opérateur de division (/) et le <xref:System.Numerics.BigInteger.DivRem%2A> (méthode).  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> est égal à 0 (zéro).</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une valeur qui indique si deux valeurs sont égales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si la valeur d'un entier long signé et la valeur <see cref="T:System.Numerics.BigInteger" /> sont égales.</summary>
        <returns>
          <see langword="true" /> si les paramètres <paramref name="left" /> et <paramref name="right" /> ont la même valeur ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> méthode définit l’opération de comparaison d’égalité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> méthode d’instance à la place.  
  
 Si `left` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque l’opération est effectuée.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si la valeur <see cref="T:System.Numerics.BigInteger" /> et la valeur d'un entier long signé sont égales.</summary>
        <returns>
          <see langword="true" /> si les paramètres <paramref name="left" /> et <paramref name="right" /> ont la même valeur ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> méthode définit l’opération de comparaison d’égalité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> méthode d’instance à la place.  
  
 Si `right` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque l’opération est effectuée.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si les valeurs de deux objets <see cref="T:System.Numerics.BigInteger" /> sont égales.</summary>
        <returns>
          <see langword="true" /> si les paramètres <paramref name="left" /> et <paramref name="right" /> ont la même valeur ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> méthode définit l’opération de l’opérateur d’égalité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> méthode d’instance à la place.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si la valeur <see cref="T:System.Numerics.BigInteger" /> et la valeur d'un entier long non signé sont égales.</summary>
        <returns>
          <see langword="true" /> si les paramètres <paramref name="left" /> et <paramref name="right" /> ont la même valeur ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> méthode définit l’opération de comparaison d’égalité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> méthode d’instance à la place.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si la valeur d'un entier long non signé et la valeur <see cref="T:System.Numerics.BigInteger" /> sont égales.</summary>
        <returns>
          <see langword="true" /> si les paramètres <paramref name="left" /> et <paramref name="right" /> ont la même valeur ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> méthode définit l’opération de comparaison d’égalité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> méthode d’instance à la place.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur.</param>
        <param name="right">Seconde valeur.</param>
        <summary>Effectue une opération de bits <see langword="Or" /> (<see langword="XOr" />) exclusive sur deux valeurs <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Résultat de l'opération de bits <see langword="Or" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le résultat d’un OR exclusif `Or` opération est `true` si les valeurs des deux bits sont différentes ; sinon, il est `false`. Le tableau suivant illustre l’exclusif `Or` opération.  
  
|Bit x `left`|Bit x `right`|Valeur de retour|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 Le <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> méthode permet de code semblable au suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 Le <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> méthode effectue l’exclusif au niveau du bit `Or` opération sur deux <xref:System.Numerics.BigInteger> valeurs comme si elles étaient toutes deux dans la représentation du deux complément avec extension de signe virtuel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit une conversion explicite entre un objet <see cref="T:System.Numerics.BigInteger" /> et un autre type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Définit une conversion explicite d'un objet <see cref="T:System.Decimal" /> en valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Toute partie décimale de le `value` paramètre est tronqué avant la conversion.

 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Étant donné que la conversion de <xref:System.Decimal> à <xref:System.Numerics.BigInteger> peut impliquer de tronquer la partie décimale de `value`, les compilateurs de langage n’exécutent pas automatiquement cette conversion. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` en Visual Basic) est utilisé. Sinon, ils affichent une erreur du compilateur.   

 Pour les langages qui ne prennent pas en charge les opérateurs personnalisés, la méthode alternative est <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.


## Examples
 L’exemple suivant convertit les éléments individuels dans un tableau de <xref:System.Decimal> valeurs <xref:System.Numerics.BigInteger> objets, puis affiche le résultat de chaque conversion. Notez que toute fractions de seconde dans le cadre d’un <xref:System.Decimal> valeur est tronquée lors de la conversion.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Définit une conversion explicite d'une valeur <see cref="T:System.Double" /> en valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Toute partie décimale de le `value` paramètre est tronqué avant la conversion.

 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Étant donné que la conversion de <xref:System.Double> à <xref:System.Numerics.BigInteger> peut impliquer de tronquer la partie décimale de `value`, les compilateurs de langage n’exécutent pas automatiquement cette conversion. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` en Visual Basic) est utilisé. Sinon, ils affichent une erreur du compilateur.

 Pour les langages qui ne prennent pas en charge les opérateurs personnalisés, la méthode alternative est <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.


## Examples
 L’exemple suivant convertit les éléments individuels dans un tableau de <xref:System.Double> valeurs <xref:System.Numerics.BigInteger> objets, puis affiche le résultat de chaque conversion. Notez que toute fractions de seconde dans le cadre d’un <xref:System.Double> valeur est tronquée lors de la conversion.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est <see cref="F:System.Double.NaN" />.  
  
- ou - 
La valeur de <paramref name="value" /> est <see cref="F:System.Double.PositiveInfinity" />.
  
- ou - 
La valeur de <paramref name="value" /> est <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Byte" />.</param>
        <summary>Définit une conversion explicite d'un objet <see cref="T:System.Numerics.BigInteger" /> en valeur d'octet non signée.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` ou `CByte` en Visual Basic) est utilisé. Sinon, ils affichent une erreur du compilateur.   

 Étant donné que cette opération définit une conversion restrictive, il peut lever une <xref:System.OverflowException> au moment de l’exécution si le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.Byte> type de données. Il n’existe aucune perte de précision dans résultant <xref:System.Byte> valeur si la conversion a réussi.

## Examples
 L’exemple suivant illustre la conversion de <xref:System.Numerics.BigInteger> à <xref:System.Byte> valeurs. Il gère également une <xref:System.OverflowException> qui est levée, car le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.Byte> type de données.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est inférieure à <see cref="F:System.Byte.MinValue" />.  
  
- ou - 
La valeur de <paramref name="value" /> est supérieure à <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Decimal" />.</param>
        <summary>Définit une conversion explicite d'un objet <see cref="T:System.Numerics.BigInteger" /> en valeur <see cref="T:System.Decimal" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` ou `CDec` en Visual Basic) est utilisé.   

 Étant donné que cette opération définit une conversion restrictive, il peut lever une <xref:System.OverflowException> au moment de l’exécution si le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.Decimal> type de données. 

## Examples
 L’exemple suivant illustre la conversion de <xref:System.Numerics.BigInteger> à <xref:System.Decimal> valeurs. Il gère également une <xref:System.OverflowException> qui est levée, car le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.Decimal> type de données.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est inférieure à <see cref="F:System.Decimal.MinValue" />.  
  
- ou - 
La valeur de <paramref name="value" /> est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Double" />.</param>
        <summary>Définit une conversion explicite d'un objet <see cref="T:System.Numerics.BigInteger" /> en valeur <see cref="T:System.Double" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` ou `CDbl` en Visual Basic) est utilisé.   

 Étant donné que le <xref:System.Numerics.BigInteger> valeur peut être en dehors de la plage de la <xref:System.Double> de type de données, cette opération est une conversion restrictive. Si la conversion échoue, elle ne lève pas une <xref:System.OverflowException>. Au lieu de cela, si le <xref:System.Numerics.BigInteger> valeur est inférieure à <xref:System.Double.MinValue?displayProperty=nameWithType>, résultant <xref:System.Double> valeur est <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Si le <xref:System.Numerics.BigInteger> valeur est supérieure à <xref:System.Double.MaxValue?displayProperty=nameWithType>, résultant <xref:System.Double> valeur est <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.
 
 La conversion d’un <xref:System.Numerics.BigInteger> à un <xref:System.Double> peut impliquer une perte de précision. Dans certains cas, la perte de précision peut entraîner l’opération de conversion réussisse même si le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.Double> type de données. L'exemple suivant illustre cette situation. Il assigne la valeur maximale d’un <xref:System.Double> à deux <xref:System.Numerics.BigInteger> variables, incrémente une <xref:System.Numerics.BigInteger> variable par 9, 999e291 et teste l’égalité les deux variables. Comme prévu, l’appel à la <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> méthode montre qu’ils sont inégaux. Toutefois, la conversion du plus grand <xref:System.Numerics.BigInteger> valeur en un <xref:System.Double> réussit, bien que le <xref:System.Numerics.BigInteger> valeur dépasse maintenant <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 L’exemple suivant illustre la conversion de <xref:System.Numerics.BigInteger> à <xref:System.Double> valeurs.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en entier 16 bits signé.</param>
        <summary>Définit une conversion explicite d'un objet <see cref="T:System.Numerics.BigInteger" /> en valeur d'entier 16 bits signé.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` ou `CShort` en Visual Basic) est utilisé. Sinon, ils affichent une erreur du compilateur.   

 Étant donné que cette opération définit une conversion restrictive, il peut lever une <xref:System.OverflowException> au moment de l’exécution si le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.Int16> type de données. Il n’existe aucune perte de précision dans résultant <xref:System.Int16> valeur si la conversion a réussi.

## Examples
 L’exemple suivant illustre la conversion de <xref:System.Numerics.BigInteger> à <xref:System.Int16> valeurs. Il gère également une <xref:System.OverflowException> qui est levée, car le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.Int16> type de données.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est inférieure à <see cref="F:System.Int16.MinValue" />.  
  
- ou - 
La valeur de <paramref name="value" /> est supérieure à <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en entier 32 bits signé.</param>
        <summary>Définit une conversion explicite d’un objet <see cref="T:System.Numerics.BigInteger" /> en valeur d’entier 32 bits signé.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` ou `CInt` en Visual Basic) est utilisé. Sinon, ils affichent une erreur du compilateur.   

 Étant donné que cette opération définit une conversion restrictive, il peut lever une <xref:System.OverflowException> au moment de l’exécution si le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.Int32> type de données. Il n’existe aucune perte de précision dans résultant <xref:System.Int16> valeur si la conversion a réussi.

## Examples
 L’exemple suivant illustre la conversion de <xref:System.Numerics.BigInteger> à <xref:System.Int32> valeurs. Il gère également une <xref:System.OverflowException> qui est levée, car le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.Int32> type de données.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est inférieure à <see cref="F:System.Int32.MinValue" />.  
  
- ou - 
La valeur de <paramref name="value" /> est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en entier 64 bits signé.</param>
        <summary>Définit une conversion explicite d’un objet <see cref="T:System.Numerics.BigInteger" /> en valeur d’entier 64 bits signé.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` ou `CLng` en Visual Basic) est utilisé. Sinon, ils affichent une erreur du compilateur.  

 Étant donné que cette opération définit une conversion restrictive, il peut lever une <xref:System.OverflowException> au moment de l’exécution si le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.Int64> type de données. 

## Examples
 L’exemple suivant illustre la conversion de <xref:System.Numerics.BigInteger> à <xref:System.Int64> valeurs. Il gère également une <xref:System.OverflowException> qui est levée, car le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.Int64> type de données.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est inférieure à <see cref="F:System.Int64.MinValue" />.  
  
- ou - 
La valeur de <paramref name="value" /> est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en valeur 8 bits signée.</param>
        <summary>Définit une conversion explicite d'un objet <see cref="T:System.Numerics.BigInteger" /> en valeur 8 bits signée.  
  
Cette API n'est pas conforme CLS. L’alternative conforme est <see cref="T:System.Int16" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` ou `CSByte` en Visual Basic) est utilisé. Sinon, ils affichent une erreur du compilateur.  

 Étant donné que cette opération définit une conversion restrictive, il peut lever une <xref:System.OverflowException> au moment de l’exécution si le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.SByte> type de données. Il n’existe aucune perte de précision dans résultant <xref:System.SByte> valeur si la conversion a réussi.

## Examples
 L’exemple suivant illustre la conversion de <xref:System.Numerics.BigInteger> à <xref:System.SByte> valeurs. Il gère également une <xref:System.OverflowException> qui est levée, car le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.SByte> type de données.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est inférieure à <see cref="F:System.SByte.MinValue" />.  
  
- ou - 
La valeur de <paramref name="value" /> est supérieure à <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en valeur à virgule flottante simple précision.</param>
        <summary>Définit une conversion explicite d'un objet <see cref="T:System.Numerics.BigInteger" /> en valeur à virgule flottante simple précision.</summary>
        <returns>Objet qui contient la représentation la plus proche possible du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données ou une perte de précision. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` ou `CSng` en Visual Basic) est utilisé. Sinon, ils affichent une erreur du compilateur.    

 Étant donné que le <xref:System.Numerics.BigInteger> valeur peut être en dehors de la plage de la <xref:System.Single> de type de données, cette opération est une conversion restrictive. Si la conversion échoue, elle ne lève pas une <xref:System.OverflowException>. Au lieu de cela, si le <xref:System.Numerics.BigInteger> valeur est inférieure à <xref:System.Single.MinValue?displayProperty=nameWithType>, résultant <xref:System.Single> valeur est <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Si le <xref:System.Numerics.BigInteger> valeur est supérieure à <xref:System.Single.MaxValue?displayProperty=nameWithType>, résultant <xref:System.Single> valeur est <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.

 La conversion d’un <xref:System.Numerics.BigInteger> à un <xref:System.Single> peut impliquer une perte de précision. Dans certains cas, la perte de précision peut entraîner l’opération de conversion réussisse même si le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.Single> type de données. L'exemple suivant illustre cette situation. Il assigne la valeur maximale d’un <xref:System.Single> à deux <xref:System.Numerics.BigInteger> variables, incrémente une <xref:System.Numerics.BigInteger> variable par 9, 999e291 et teste l’égalité les deux variables. Comme prévu, l’appel à la <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> méthode montre qu’ils sont inégaux. Toutefois, la conversion du plus grand <xref:System.Numerics.BigInteger> valeur en un <xref:System.Single> réussit, bien que le <xref:System.Numerics.BigInteger> valeur dépasse maintenant <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 L’exemple suivant illustre la conversion de <xref:System.Numerics.BigInteger> à <xref:System.Single> valeurs.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en entier 16 bits non signé.</param>
        <summary>Définit une conversion explicite d'un objet <see cref="T:System.Numerics.BigInteger" /> en valeur entière 16 bits non signée.  
  
Cette API n'est pas conforme CLS. L’alternative conforme est <see cref="T:System.Int32" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` ou `CUShort` en Visual Basic) est utilisé. Sinon, ils affichent une erreur du compilateur.    

 Étant donné que cette opération définit une conversion restrictive, il peut lever une <xref:System.OverflowException> au moment de l’exécution si le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.UInt16> type de données. Il n’existe aucune perte de précision dans résultant <xref:System.UInt16> valeur si la conversion a réussi.

## Examples
 L’exemple suivant illustre la conversion de <xref:System.Numerics.BigInteger> à <xref:System.UInt16> valeurs. Il gère également une <xref:System.OverflowException> qui est levée, car le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.UInt16> type de données.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est inférieure à <see cref="F:System.UInt16.MinValue" />.  
  
- ou - 
La valeur de <paramref name="value" /> est supérieure à <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en entier 32 bits non signé.</param>
        <summary>Définit une conversion explicite d’un objet <see cref="T:System.Numerics.BigInteger" /> en valeur d’entier 32 bits non signé.  
  
Cette API n'est pas conforme CLS. L’alternative conforme est <see cref="T:System.Int64" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` ou `CUInt` en Visual Basic) est utilisé. Sinon, ils affichent une erreur du compilateur.    

 Étant donné que cette opération définit une conversion restrictive, il peut lever une <xref:System.OverflowException> au moment de l’exécution si le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.UInt32> type de données. Il n’existe aucune perte de précision dans résultant <xref:System.UInt32> valeur si la conversion a réussi.

## Examples
 L’exemple suivant illustre la conversion de <xref:System.Numerics.BigInteger> à <xref:System.UInt32> valeurs. Il gère également une <xref:System.OverflowException> qui est levée, car le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.UInt32> type de données.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est inférieure à <see cref="F:System.UInt32.MinValue" />.  
  
- ou - 
La valeur de <paramref name="value" /> est supérieure à <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en entier 64 bits non signé.</param>
        <summary>Définit une conversion explicite d’un objet <see cref="T:System.Numerics.BigInteger" /> en valeur d’entier 64 bits non signé.  
  
Cette API n'est pas conforme CLS. L’alternative conforme est <see cref="T:System.Double" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Les compilateurs de langage n’exécutent pas automatiquement cette conversion, car elle peut impliquer une perte de données. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` ou `CULng` en Visual Basic) est utilisé. Sinon, ils affichent une erreur du compilateur.    

 Étant donné que cette opération définit une conversion restrictive, il peut lever une <xref:System.OverflowException> au moment de l’exécution si le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.UInt64> type de données. Il n’existe aucune perte de précision dans résultant <xref:System.UInt64> valeur si la conversion a réussi.

## Examples
 L’exemple suivant illustre la conversion de <xref:System.Numerics.BigInteger> à <xref:System.UInt64> valeurs. Il gère également une <xref:System.OverflowException> qui est levée, car le <xref:System.Numerics.BigInteger> valeur est en dehors de la plage de la <xref:System.UInt64> type de données.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est inférieure à <see cref="F:System.UInt64.MinValue" />.  
  
- ou - 
La valeur de <paramref name="value" /> est supérieure à <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Définit une conversion explicite d'une valeur <see cref="T:System.Single" /> en valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Toute partie décimale de le `value` paramètre est tronqué avant la conversion.
 
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un <xref:System.Numerics.BigInteger> objet peut être converti. Étant donné que la conversion de <xref:System.Single> à <xref:System.Numerics.BigInteger> peut impliquer de tronquer la partie décimale de `value`, les compilateurs de langage n’exécutent pas automatiquement cette conversion. Au lieu de cela, ils exécutent la conversion uniquement si un opérateur de cast (en c#) ou une fonction de conversion (tel que `CType` en Visual Basic) est utilisé. Sinon, ils affichent une erreur du compilateur.

 Pour les langages qui ne prennent pas en charge les opérateurs personnalisés, la méthode alternative est <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.


## Examples
 L’exemple suivant convertit les éléments individuels dans un tableau de <xref:System.Single> valeurs <xref:System.Numerics.BigInteger> objets, puis affiche le résultat de chaque conversion. Notez que toute fractions de seconde dans le cadre d’un <xref:System.Single> valeur est tronquée lors de la conversion.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La valeur de <paramref name="value" /> est <see cref="F:System.Single.NaN" />.  
  
- ou - 
La valeur de <paramref name="value" /> est <see cref="F:System.Single.PositiveInfinity" />.
  
- ou - 
La valeur de <paramref name="value" /> est <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une valeur qui indique si une valeur spécifique est supérieure à une autre valeur spécifique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si un entier 64 bits signé est supérieur à une valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est supérieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_GreaterThan%2A> méthode définit l’opération de l’opérateur de supériorité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> méthode d’instance à la place. Certains langages peuvent également appeler le <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Si `left` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque l’opération est effectuée.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si <see cref="T:System.Numerics.BigInteger" /> est supérieur à une valeur d'entier 64 bits signé.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est supérieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_GreaterThan%2A> méthode définit l’opération de l’opérateur de supériorité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> méthode à la place. Certains langages peuvent également appeler le <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Si `right` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque l’opération est effectuée.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> est supérieure à une autre valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est supérieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_GreaterThan%2A> méthode définit l’opération de l’opérateur de supériorité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> méthode à la place. Elles peuvent également appeler le <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> est supérieure à un entier 64 bits non signé.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est supérieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_GreaterThan%2A> méthode définit l’opération de l’opérateur de supériorité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> méthode à la place. Certains langages peuvent également appeler le <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> est supérieure à un entier 64 bits non signé.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est supérieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_GreaterThan%2A> méthode définit l’opération de l’opérateur de supériorité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> méthode à la place. Certains langages peuvent également appeler le <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une valeur qui indique si une valeur spécifique est supérieure ou égale à une autre valeur spécifique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si un entier 64 bits signé est supérieur ou égal à une valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est supérieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> méthode définit l’opération de supérieur ou égal à l’opérateur pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> méthode à la place. Certains langages peuvent également appeler le <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Si `left` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque l’opération est effectuée.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> est supérieure ou égale à une valeur d'entier 64 bits signé.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est supérieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> méthode définit l’opération de supérieur ou égal à l’opérateur pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> méthode à la place. Certains langages peuvent également appeler le <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Si `right` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque l’opération est effectuée.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> est supérieure ou égale à une autre valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est supérieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> méthode définit l’opération de supérieur ou égal à l’opérateur pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> méthode à la place. Certains langages peuvent également appeler le <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> est supérieure ou égale à une valeur entière 64 bits non signée.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est supérieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> méthode définit l’opération de supérieur ou égal à l’opérateur pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> méthode à la place. Certains langages peuvent également appeler le <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si un entier 64 bits non signé est supérieur ou égal à une valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est supérieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> méthode définit l’opération de supérieur ou égal à l’opérateur pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> méthode à la place. Certains langages peuvent également appeler le <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit une conversion implicite entre un objet <see cref="T:System.Numerics.BigInteger" /> et un autre type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Définit une conversion implicite d'un octet non signé en valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Toute partie décimale de le `value` paramètre est tronqué avant la conversion.

 Pour les langages qui ne prennent pas en charge les opérateurs implicites, la méthode alternative est <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Les surcharges de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.BigInteger> valeur sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic). Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>. Cette surcharge permet au compilateur de gérer les conversions d’un <xref:System.Byte> valeur un <xref:System.Numerics.BigInteger> valeur, comme le montre l’exemple suivant.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Définit une conversion implicite d'un entier 16 bits signé en valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les langages qui ne prennent pas en charge les opérateurs implicites, la méthode alternative est <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Les surcharges de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.BigInteger> valeur sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic). Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>. Cette surcharge permet au compilateur de gérer les conversions d’un <xref:System.Int16> valeur un <xref:System.Numerics.BigInteger> valeur, comme le montre l’exemple suivant.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Définit une conversion implicite d’un entier 32 bits signé en valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les langages qui ne prennent pas en charge les opérateurs implicites, la méthode alternative est <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.  

 Les surcharges de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.BigInteger> valeur sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic). Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>. Cette surcharge permet au compilateur de gérer les conversions d’un <xref:System.Int32> valeur un <xref:System.Numerics.BigInteger> valeur, comme le montre l’exemple suivant.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Définit une conversion implicite d’un entier 64 bits signé en valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les langages qui ne prennent pas en charge les opérateurs implicites, la méthode alternative est <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.   
 
 Les surcharges de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.BigInteger> valeur sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic). Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>. Cette surcharge permet au compilateur de gérer les conversions d’un <xref:System.Int64> valeur un <xref:System.Numerics.BigInteger> valeur, comme le montre l’exemple suivant.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Définit une conversion implicite d'un entier 8 bits signé en valeur <see cref="T:System.Numerics.BigInteger" />.  
  
Cette API n'est pas conforme CLS. L’alternative conforme est <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les langages qui ne prennent pas en charge les opérateurs implicites, la méthode alternative est <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Les surcharges de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.BigInteger> valeur sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic). Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>. Cette surcharge permet au compilateur de gérer les conversions d’un <xref:System.SByte> valeur un <xref:System.Numerics.BigInteger> valeur, comme le montre l’exemple suivant.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Définit une conversion implicite d'un entier 16 bits non signé en valeur <see cref="T:System.Numerics.BigInteger" />.  
  
Cette API n'est pas conforme CLS. L’alternative conforme est <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les langages qui ne prennent pas en charge les opérateurs implicites, la méthode alternative est <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Les surcharges de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.BigInteger> valeur sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic). Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>. Cette surcharge permet au compilateur de gérer les conversions d’un <xref:System.UInt16> valeur un <xref:System.Numerics.BigInteger> valeur, comme le montre l’exemple suivant.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Définit une conversion implicite d’un entier 32 bits non signé en valeur <see cref="T:System.Numerics.BigInteger" />.  
  
Cette API n'est pas conforme CLS. L’alternative conforme est <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les langages qui ne prennent pas en charge les opérateurs implicites, la méthode alternative est <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Les surcharges de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.BigInteger> valeur sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic). Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>. Cette surcharge permet au compilateur de gérer les conversions d’un <xref:System.UInt32> valeur un <xref:System.Numerics.BigInteger> valeur, comme le montre l’exemple suivant.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à convertir en <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Définit une conversion implicite d’un entier 64 bits non signé en valeur <see cref="T:System.Numerics.BigInteger" />.  
  
Cette API n'est pas conforme CLS. L’alternative conforme est <see cref="T:System.Double" />.</summary>
        <returns>Objet qui contient la valeur du paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les langages qui ne prennent pas en charge les opérateurs implicites, la méthode alternative est <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.   

 Les surcharges de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> (méthode) définissent les types dans ou à partir de laquelle un compilateur peut convertir automatiquement un <xref:System.Numerics.BigInteger> valeur sans opérateur de cast explicite (en c#) ou un appel à une fonction de conversion (en Visual Basic). Ils sont des conversions étendues qui n’impliquent pas de perte de données et ne lèvent pas d’un <xref:System.OverflowException>. Cette surcharge permet au compilateur de gérer les conversions d’un <xref:System.UInt64> valeur un <xref:System.Numerics.BigInteger> valeur, comme le montre l’exemple suivant.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à incrémenter.</param>
        <summary>Incrémente une valeur <see cref="T:System.Numerics.BigInteger" /> de 1.</summary>
        <returns>Valeur du paramètre <paramref name="value" /> incrémenté de 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Increment%2A> méthode définit l’opération d’incrément pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Certains langages (par exemple, Visual Basic) qui ne disposent pas d’un opérateur d’incrémentation ou ne prennent pas en charge la surcharge d’opérateur peuvent appeler la <xref:System.Numerics.BigInteger.op_Increment%2A> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Étant donné que <xref:System.Numerics.BigInteger> objets sont immuables, le <xref:System.Numerics.BigInteger.op_Increment%2A> opérateur crée un nouveau <xref:System.Numerics.BigInteger> objet dont la valeur est supérieur à la <xref:System.Numerics.BigInteger> objet représenté par `value`. Par conséquent, les appels répétés à <xref:System.Numerics.BigInteger.op_Increment%2A> peut s’avérer coûteux.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une valeur qui indique si deux valeurs numériques ne sont pas égales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si un entier 64 bits signé et une valeur <see cref="T:System.Numerics.BigInteger" /> ne sont pas égaux.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> et <paramref name="right" /> ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Inequality%2A> méthode définit l’opération de l’opérateur d’inégalité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent tester l’inégalité en utilisant l’une des techniques suivantes :  
  
-   Appel de la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> l’instance de méthode, qui indique la relation entre un <xref:System.Numerics.BigInteger> et une valeur d’entier long signé.  
  
-   Appel de la <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> (méthode) et en inversant sa valeur de l’instance.  
  
 Si `left` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque l’opération est effectuée.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> et un entier 64 bits signé ne sont pas égaux.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> et <paramref name="right" /> ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Inequality%2A> méthode définit l’opération de l’opérateur d’inégalité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent tester l’inégalité en utilisant l’une des techniques suivantes :  
  
-   Appel de la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> (méthode), ce qui indique la relation entre un <xref:System.Numerics.BigInteger> et une valeur d’entier long signé.  
  
-   Appel de la <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> (méthode) et en inversant sa valeur.  
  
 Si `right` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque l’opération est effectuée.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si deux objets <see cref="T:System.Numerics.BigInteger" /> ont des valeurs différentes.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> et <paramref name="right" /> ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Inequality%2A> méthode définit l’opération de l’opérateur d’inégalité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent tester l’inégalité en utilisant l’une des techniques suivantes :  
  
-   Appel de la <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> (méthode), ce qui indique la relation entre deux <xref:System.Numerics.BigInteger> objets.  
  
-   Appel de la <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> (méthode) et en inversant sa valeur.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> et un entier 64 bits non signé ne sont pas égaux.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> et <paramref name="right" /> ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Inequality%2A> méthode définit l’opération de l’opérateur d’inégalité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent tester l’inégalité en utilisant l’une des techniques suivantes :  
  
-   Appel de la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> (méthode), ce qui indique la relation entre un <xref:System.Numerics.BigInteger> et une valeur d’entier long non signé.  
  
-   Appel de la <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> (méthode) et en inversant sa valeur.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si un entier 64 bits non signé et une valeur <see cref="T:System.Numerics.BigInteger" /> ne sont pas égaux.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> et <paramref name="right" /> ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Inequality%2A> méthode définit l’opération de l’opérateur d’inégalité pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent tester l’inégalité en utilisant l’une des techniques suivantes :  
  
-   Appel de la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> (méthode), ce qui indique la relation entre un <xref:System.Numerics.BigInteger> et une valeur d’entier long non signé.  
  
-   Appel de la <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> (méthode) et en inversant sa valeur.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valeur dont les bits doivent être décalés.</param>
        <param name="shift">Nombre de bits de décalage vers la gauche de <c>value</c>.</param>
        <summary>Décale une valeur <see cref="T:System.Numerics.BigInteger" /> d'un certain nombre de bits vers la gauche.</summary>
        <returns>Valeur décalée vers la gauche en fonction du nombre de bits spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_LeftShift%2A> méthode définit l’opération de l’opérateur de décalage vers la gauche au niveau du bit pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  Contrairement à l’opération de décalage vers la gauche au niveau du bit avec les primitives entières, la <xref:System.Numerics.BigInteger.op_LeftShift%2A> méthode conserve le signe de l’original <xref:System.Numerics.BigInteger> valeur.  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent exécuter une opération de décalage vers la gauche au niveau du bit en multipliant `value` par `BigInteger.Pow(2, shift)`. L’exemple suivant montre que les résultats sont identiques à ceux de l’utilisation de cet opérateur.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une valeur qui indique si une valeur spécifique est inférieure à une seconde valeur spécifique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si un entier 64 bits signé est inférieur à une valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est inférieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_LessThan%2A> méthode définit l’opération de l’opérateur inférieur à pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> méthode à la place. Certains langages peuvent également appeler le <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Si `left` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque l’opération est effectuée.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> est inférieure à un entier 64 bits signé.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est inférieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_LessThan%2A> méthode définit l’opération de l’opérateur inférieur à pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> méthode à la place. Certains langages peuvent également appeler le <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Si `right` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque l’opération est effectuée.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> est inférieure à une autre valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est inférieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_LessThan%2A> méthode définit l’opération de l’opérateur inférieur à pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> méthode à la place. Certains langages peuvent également appeler le <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> est inférieure à un entier 64 bits non signé.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est inférieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_LessThan%2A> méthode définit l’opération de l’opérateur inférieur à pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> méthode à la place. Elles peuvent également appeler le <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si un entier 64 bits non signé est inférieur à une valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est inférieur à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_LessThan%2A> méthode définit l’opération de l’opérateur inférieur à pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> méthode à la place. Elles peuvent également appeler le <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une valeur qui indique si une valeur spécifique est inférieure ou égale à une autre valeur spécifique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si un entier 64 bits signé est inférieur ou égal à une valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est inférieur ou égal à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> méthode définit l’opération d’inférieur ou égal à l’opérateur pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> méthode à la place. Elles peuvent également appeler le <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Si `left` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque l’opération est effectuée.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> est inférieure ou égale à un entier 64 bits signé.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est inférieur ou égal à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> méthode définit l’opération d’inférieur ou égal à l’opérateur pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> méthode à la place. Elles peuvent également appeler le <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Si `right` est un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valeur, il est implicitement converti en un <xref:System.Int64> valeur lorsque l’opération est effectuée.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> est inférieure ou égale à une autre valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est inférieur ou égal à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> méthode définit l’opération d’inférieur ou égal à l’opérateur pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Compare%2A> méthode à la place. Elles peuvent également appeler le <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si une valeur <see cref="T:System.Numerics.BigInteger" /> est inférieure ou égale à un entier 64 bits non signé.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est inférieur ou égal à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> méthode définit l’opération d’inférieur ou égal à l’opérateur pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> méthode à la place. Elles peuvent également appeler le <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à comparer.</param>
        <param name="right">Deuxième valeur à comparer.</param>
        <summary>Retourne une valeur qui indique si un entier 64 bits non signé est inférieur ou égal à une valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> est inférieur ou égal à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> méthode définit l’opération d’inférieur ou égal à l’opérateur pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> méthode à la place. Elles peuvent également appeler le <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> méthode directement, comme dans l’exemple suivant montre.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valeur à diviser.</param>
        <param name="divisor">Valeur par laquelle diviser.</param>
        <summary>Retourne le modulo de la division de deux valeurs <see cref="T:System.Numerics.BigInteger" /> spécifiques.</summary>
        <returns>Reste de la division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Modulus%2A> méthode définit l’opération de l’opérateur modulo pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> méthode à la place.  
  
 Le signe de la valeur retournée par l’opération de modulo varie selon le signe de `dividend`: si `dividend` est un nombre positif, l’opération modulo retourne un résultat positif ; s’il est négatif, l’opération modulo retourne un résultat négatif. Le comportement de l’opération modulo avec <xref:System.Numerics.BigInteger> valeurs est identique à l’opération modulo avec d’autres types intégrés.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> est égal à 0 (zéro).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Première valeur à multiplier.</param>
        <param name="right">Seconde valeur à multiplier.</param>
        <summary>Multiplie deux valeurs <see cref="T:System.Numerics.BigInteger" /> spécifiées.</summary>
        <returns>Produit de <paramref name="left" /> et <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Multiply%2A> méthode définit l’opération de l’opérateur de multiplication pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur entière.</param>
        <summary>Retourne le complément à un au niveau du bit d'une valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Complément à un au niveau du bit de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_OnesComplement%2A> méthode définit l’opération de l’opérateur de bits opérateur de complément pour <xref:System.Numerics.BigInteger> valeurs. L’opérateur de bits inverse de l’opérateur de complément de chaque bit d’une valeur numérique. Autrement dit, les bits dans `value` qui sont 0 sont définis sur 1 dans le résultat, et les bits sont 1 sont définies sur 0 dans le résultat. Le <xref:System.Numerics.BigInteger.op_OnesComplement%2A> méthode permet de code semblable au suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Les langues qui ne prennent pas en charge les opérateurs personnalisés peuvent être en mesure d’appeler le <xref:System.Numerics.BigInteger.op_OnesComplement%2A> méthode directement pour effectuer une opération de bits de compléter l’opération. Exemple :  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valeur dont les bits doivent être décalés.</param>
        <param name="shift">Nombre de bits de décalage vers la droite de <c>value</c>.</param>
        <summary>Décale une valeur <see cref="T:System.Numerics.BigInteger" /> d'un certain nombre de bits vers la droite.</summary>
        <returns>Valeur décalée vers la droite en fonction du nombre de bits spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_RightShift%2A> méthode définit l’opération de l’opérateur de décalage vers la droite au niveau du bit pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent exécuter une opération de décalage vers la droite au niveau du bit en divisant `value` par `BigInteger.Pow(2, shift)` et en soustrayant 1 fois `shift` pour les valeurs négatives. L’exemple suivant montre que les résultats sont identiques à ceux de l’utilisation de cet opérateur.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Si `shift` est supérieur ou égal au nombre de bits dans un nombre positif <xref:System.Numerics.BigInteger> valeur, le résultat de l’opération de décalage vers la droite est <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Si `shift` est supérieur au nombre de bits dans une valeur négative <xref:System.Numerics.BigInteger> valeur, le résultat de l’opération de décalage vers la droite est <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Valeur à laquelle appliquer la soustraction (diminuende).</param>
        <param name="right">Valeur à soustraire (diminuteur).</param>
        <summary>Soustrait une valeur <see cref="T:System.Numerics.BigInteger" /> d'une autre valeur <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Résultat de la soustraction de <paramref name="right" /> de <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_Subtraction%2A> méthode définit l’opération de l’opérateur de soustraction pour <xref:System.Numerics.BigInteger> valeurs. Il permet le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> méthode à la place.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à rendre négative.</param>
        <summary>Rend négative la valeur BigInteger spécifiée.</summary>
        <returns>Résultat de la multiplication du paramètre <paramref name="value" /> par moins un (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> méthode définit l’opération de l’opérateur de négation unaire (ou l’opérateur inverse additif) pour <xref:System.Numerics.BigInteger> valeurs. L’opération produit une valeur qui correspond à 0 (zéro) lorsqu’il est ajouté au nombre d’origine. Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent appeler la <xref:System.Numerics.BigInteger.Negate%2A> méthode à la place.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 L’exemple suivant illustre trois façons différentes d’exclure la valeur d’un <xref:System.Numerics.BigInteger> objet.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valeur entière.</param>
        <summary>Retourne la valeur de l'opérande <see cref="T:System.Numerics.BigInteger" />. (Le signe de l’opérande est inchangé.)</summary>
        <returns>Valeur de l'opérande <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> méthode définit l’opération de l’opérateur positif unaire pour <xref:System.Numerics.BigInteger> valeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la représentation sous forme de chaîne d'un nombre en sa représentation <see cref="T:System.Numerics.BigInteger" /> équivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne contenant le nombre à convertir.</param>
        <summary>Convertit la représentation sous forme de chaîne d'un nombre en sa représentation <see cref="T:System.Numerics.BigInteger" /> équivalente.</summary>
        <returns>Valeur équivalente au nombre spécifié dans le paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `value` paramètre doit être la représentation sous forme de chaîne d’un nombre sous la forme suivante.  
  
 [*ws*] [*connexion*]*chiffres*[*ws*]  
  
 Les éléments entre crochets ([ et ]) sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Espace blanc facultatif.|  
|*sign*|Un signe facultatif. Les caractères de signe valides sont déterminés par le <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> et <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propriétés de la culture actuelle.|  
|*digits*|Une séquence de chiffres allant de 0 à 9. Zéros non significatifs sont ignorés.|  
  
> [!NOTE]
>  La chaîne spécifiée par le `value` paramètre est interprété à l’aide de la <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style. Il ne peut pas contenir de séparateurs de groupes ou séparateur décimal, et il ne peut pas avoir une partie décimale.  
  
 Le `value` paramètre est analysé en utilisant les informations de mise en forme dans un <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> objet initialisé pour la culture système actuelle. Pour plus d'informations, consultez <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Pour analyser une chaîne en utilisant les informations de mise en forme d’une culture spécifique, utilisez le <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> (méthode).  
  
> [!IMPORTANT]
>  Si vous utilisez le <xref:System.Numerics.BigInteger.Parse%2A> méthode pour effectuer un aller-retour la représentation sous forme de chaîne d’un <xref:System.Numerics.BigInteger> valeur qui a été sorti par le <xref:System.Numerics.BigInteger.ToString%2A> (méthode), vous devez utiliser le <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> méthode avec le spécificateur de format « R » pour générer la représentation sous forme de chaîne de la <xref:System.Numerics.BigInteger> valeur. Sinon, la représentation sous forme de chaîne de la <xref:System.Numerics.BigInteger> conserve uniquement les 50 chiffres les plus significatifs de la valeur d’origine et les données peuvent être perdues lorsque vous utilisez le <xref:System.Numerics.BigInteger.Parse%2A> méthode pour restaurer le <xref:System.Numerics.BigInteger> valeur.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Numerics.BigInteger.Parse%28System.String%29> méthode pour instancier deux <xref:System.Numerics.BigInteger> objets. Il multiplie chaque objet par un autre nombre, puis appelle la <xref:System.Numerics.BigInteger.Compare%2A> méthode pour déterminer la relation entre les deux valeurs.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Le format de <paramref name="value" /> est incorrect.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne contenant un nombre à convertir.</param>
        <param name="style">Combinaison de bits de valeurs d’énumération qui spécifie le format autorisé de <c>value</c>.</param>
        <summary>Convertit la représentation d'un nombre sous forme de chaîne dans un style spécifié en son équivalent <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Valeur équivalente au nombre spécifié dans le paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `style` paramètre définit les éléments de style (par exemple, un espace blanc, le symbole de signe positif ou négatif, le symbole de séparateur de groupes ou le symbole de virgule décimale) qui sont autorisés dans les `value` paramètre pour l’opération d’analyse. `styles` doit être une combinaison d’indicateurs de bits de le <xref:System.Globalization.NumberStyles> énumération. Le `style` paramètre rend cette méthode de surcharge utile quand `value` contient la représentation sous forme de chaîne d’une valeur hexadécimale, lorsque le système de nombre (décimal ou hexadécimal) représenté par `value` est connu uniquement au moment de l’exécution, ou lorsque vous souhaitez interdire à un espace blanc ou un signe de symboles dans `value`.  
  
 Selon la valeur de `style`, le `value` paramètre peut inclure les éléments suivants :  
  
 [*ws*] [*$*] [*connexion*] [*chiffres*,]*chiffres*[.* chiffres fractionnaires*] [E [*connexion*]*chiffres_exponentiels*] [*ws*]  
  
 Si `style` inclut <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, le `value` paramètre peut contenir les éléments suivants :  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Les éléments entre crochets ([ et ]) sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Espace blanc facultatif. Espace blanc peut apparaître au début de `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> indicateur.|  
|*$*|Un symbole monétaire spécifique à la culture. Sa position dans la chaîne est définie par le <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> et <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriétés de la culture actuelle. Symbole de devise de la culture actuelle peut apparaître dans `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> indicateur.|  
|*sign*|Un signe facultatif. Le signe peut apparaître au début de `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> indicateur. Parenthèses peuvent être utilisées dans `value` pour indiquer une valeur négative si `style` inclut le <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> indicateur.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Une séquence de chiffres de 0 à 9. Pour *chiffres fractionnaires*, seul le chiffre 0 est valide.|  
|*,*|Un symbole de séparateur de groupe spécifique à la culture. Séparateur de groupes de la culture actuelle peut apparaître dans `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateur.|  
|*.*|Un symbole décimal spécifique à la culture. Symbole de virgule décimale de la culture actuelle peut apparaître dans `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur. Seul le chiffre 0 peut apparaître comme un chiffre fractionnaire pour l’opération d’analyse réussisse. Si *chiffres fractionnaires* inclut n’importe quel autre chiffre, une <xref:System.FormatException> est levée.|  
|E|Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique). Le `value` paramètre peut représenter un nombre en notation exponentielle si `style` inclut le <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> indicateur.|  
|*hexdigits*|Une séquence de chiffres hexadécimaux à partir de 0 à f, ou 0 et F.|  
  
 Une chaîne contenant uniquement des chiffres (qui correspond à la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) toujours analysée avec succès. La plupart des restant <xref:System.Globalization.NumberStyles> membres contrôlent des éléments qui peuvent être présents, mais ne sont pas requis pour être présents dans la chaîne d’entrée. Le tableau suivant indique comment chaque <xref:System.Globalization.NumberStyles> membres affectent les éléments qui peuvent être présents dans `value`.  
  
|Valeur `NumberStyles`|Éléments autorisés dans `value` en plus des chiffres|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Le *chiffres* élément uniquement.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|La virgule décimale (.) et *chiffres fractionnaires* éléments.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Le « e » ou un caractère « E », ce qui indique la notation exponentielle avec *chiffres_exponentiels*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Le *ws* élément au début de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Le *ws* élément à la fin de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Le *connexion* élément au début de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Le *connexion* élément à la fin de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Le *connexion* élément sous la forme de parenthèses entourant la valeur numérique.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|L’élément le séparateur de groupe.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Élément de devise ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tous les éléments. Toutefois, `value` ne peut pas représenter un nombre hexadécimal ou un nombre en notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Float>|Le *ws* élément au début ou à la fin de `value`, *connexion* au début de `value`et la virgule décimale (*.*) symbole. Le `value` paramètre peut également utiliser la notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Number>|Le `ws`, `sign`, séparateur de groupes (*,*) et la virgule décimale (*.*) éléments.|  
|<xref:System.Globalization.NumberStyles.Any>|Tous les éléments. Toutefois, `value` ne peut pas représenter un nombre hexadécimal.|  
  
> [!IMPORTANT]
>  Si vous utilisez le <xref:System.Numerics.BigInteger.Parse%2A> méthode pour effectuer un aller-retour la représentation sous forme de chaîne d’un <xref:System.Numerics.BigInteger> valeur qui a été sorti par le <xref:System.Numerics.BigInteger.ToString%2A> (méthode), vous devez utiliser le <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> méthode avec le spécificateur de format « R » pour générer la représentation sous forme de chaîne de la <xref:System.Numerics.BigInteger> valeur. Sinon, la représentation sous forme de chaîne de la <xref:System.Numerics.BigInteger> conserve uniquement les 50 chiffres les plus significatifs de la valeur d’origine et les données peuvent être perdues lorsque vous utilisez le <xref:System.Numerics.BigInteger.Parse%2A> méthode pour restaurer le <xref:System.Numerics.BigInteger> valeur.  
  
 Contrairement aux autres <xref:System.Globalization.NumberStyles> valeurs, qui permettent, mais ne nécessitent pas la présence d’éléments de style particulier dans `value`, le <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> valeur de style signifie que les caractères numériques dans `value` sont toujours interprétées comme caractères hexadécimaux. Les caractères hexadécimaux valides sont 0-9, A-F et a-f. Les seuls autres indicateurs qui peuvent être combinés avec le `style` paramètre sont <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> et <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Le <xref:System.Globalization.NumberStyles> énumération inclut un style de nombre composite, <xref:System.Globalization.NumberStyles.HexNumber>, qui inclut les deux indicateurs d’espace blanc.)  
  
> [!NOTE]
>  Si `value` est la représentation sous forme de chaîne d’un nombre hexadécimal, il ne peut pas être précédé d’aucune décoration (tel que `0x` ou `&h`) qui le différencie comme un nombre hexadécimal. Cela entraîne l’échec de la conversion.  
  
 Si `value` est une chaîne hexadécimale, les <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> méthode interprète `value` comme un nombre négatif stocké à l’aide de représentation de complément à deux si ses deux premiers chiffres hexadécimaux sont supérieur ou égal à `0x80`. En d’autres termes, la méthode interprète le bit d’ordre le plus élevé du premier octet dans `value` en tant que le bit de signe. Pour vous assurer qu’une chaîne hexadécimale est interprétée correctement comme un nombre positif, le premier chiffre de `value` doit avoir une valeur égale à zéro. Par exemple, la méthode interprète `0x80` comme une valeur négative, mais il interprète `0x080` ou `0x0080` comme une valeur positive. L’exemple suivant illustre la différence entre des chaînes hexadécimales qui représentent les valeurs positives et négatives.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Le `value` paramètre est analysé en utilisant les informations de mise en forme dans un <xref:System.Globalization.NumberFormatInfo> objet initialisé pour la culture système actuelle. Pour spécifier la culture dont les informations mise en forme sont utilisées pour l’opération d’analyse, appelez le <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> de surcharge.  
  
   
  
## Examples  
 L’exemple suivant illustre des appels à la <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> méthode avec plusieurs valeurs possibles pour le `style` paramètre. Il illustre comment interpréter une chaîne comme valeur hexadécimale et comment refuser les espaces et de symboles de signe.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> n’est pas une valeur <see cref="T:System.Globalization.NumberStyles" />.  
  
- ou - 
 <paramref name="style" /> inclut l'indicateur <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> ou <see cref="F:System.Globalization.NumberStyles.HexNumber" /> avec une autre valeur.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> ne se conforme pas avec le modèle d'entrée spécifié par <see cref="T:System.Globalization.NumberStyles" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne contenant un nombre à convertir.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture concernant <c>value</c>.</param>
        <summary>Convertit la représentation sous forme de chaîne d'un nombre, ayant un format spécifique à la culture spécifié, en sa représentation <see cref="T:System.Numerics.BigInteger" /> équivalente.</summary>
        <returns>Valeur équivalente au nombre spécifié dans le paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `value` paramètre doit être la représentation sous forme de chaîne d’un nombre sous la forme suivante :  
  
 [*ws*] [*connexion*]*chiffres*[*ws*]  
  
 Les éléments entre crochets ([ et ]) sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Espace blanc facultatif.|  
|*sign*|Un signe facultatif. Les caractères de signe valides sont déterminés par le <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> et <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propriétés de la <xref:System.Globalization.NumberFormatInfo> objet qui est retourné par la `provider` l’objet <xref:System.IFormatProvider.GetFormat%2A> (méthode).|  
|*digits*|Une séquence de chiffres allant de 0 à 9. Zéros non significatifs sont ignorés.|  
  
> [!NOTE]
>  La chaîne spécifiée par le `value` paramètre est interprété en utilisant le <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style. Il ne peut pas contenir de séparateurs de groupes ou séparateur décimal, et il ne peut pas avoir une partie décimale.  
  
> [!IMPORTANT]
>  Si vous utilisez le <xref:System.Numerics.BigInteger.Parse%2A> méthode pour effectuer un aller-retour la représentation sous forme de chaîne d’un <xref:System.Numerics.BigInteger> valeur qui a été sorti par le <xref:System.Numerics.BigInteger.ToString%2A> (méthode), vous devez utiliser le <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> méthode avec le spécificateur de format « R » pour générer la représentation sous forme de chaîne de la <xref:System.Numerics.BigInteger> valeur. Sinon, la représentation sous forme de chaîne de la <xref:System.Numerics.BigInteger> conserve uniquement les 50 chiffres les plus significatifs de la valeur d’origine et les données peuvent être perdues lorsque vous utilisez le <xref:System.Numerics.BigInteger.Parse%2A> méthode pour restaurer le <xref:System.Numerics.BigInteger> valeur.  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation dont <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme propres à la culture. Lorsque le <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> méthode est appelée, elle appelle le `provider` du paramètre <xref:System.IFormatProvider.GetFormat%2A> (méthode) et le transmet un <xref:System.Type> objet qui représente le <xref:System.Globalization.NumberFormatInfo> type. Le <xref:System.IFormatProvider.GetFormat%2A> méthode renvoie alors le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations sur le format de le `value` paramètre. Il existe trois façons d’utiliser le `provider` paramètre pour fournir des informations de mise en forme personnalisées à l’opération d’analyse :  
  
-   Vous pouvez passer un <xref:System.Globalization.CultureInfo> objet qui représente la culture qui fournit des informations de mise en forme. Son <xref:System.Globalization.CultureInfo.GetFormat%2A> méthode retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme numériques pour cette culture.  
  
-   Vous pouvez passer le texte réel <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme numériques. (Son implémentation de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retourne simplement lui-même.)  
  
-   Vous pouvez passer un objet personnalisé qui implémente <xref:System.IFormatProvider>. Son <xref:System.IFormatProvider.GetFormat%2A> méthode instancie et retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.  
  
 Si `provider` est `null`, la mise en forme de `value` est interprété selon le <xref:System.Globalization.NumberFormatInfo> objet de la culture actuelle.  
  
   
  
## Examples  
 Les exemples suivants montrent deux façons de définir le tilde (~) comme un signe négatif pour la mise en forme <xref:System.Numerics.BigInteger> valeurs. Notez que pour afficher le <xref:System.Numerics.BigInteger> valeurs dans le même format que les chaînes d’origine, votre code doit appeler la <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> (méthode) et lui passer le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.  
  
 Le premier exemple définit une classe qui implémente <xref:System.IFormatProvider> et utilise le <xref:System.IFormatProvider.GetFormat%2A> méthode pour retourner le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Un <xref:System.Numerics.BigInteger> objet peut ensuite être instancié avec le code suivant :  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 Le deuxième exemple est plus simple. Il transmet le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme à le `provider` paramètre.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Le format de <paramref name="value" /> est incorrect.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne contenant un nombre à convertir.</param>
        <param name="style">Combinaison de bits de valeurs d’énumération qui spécifie le format autorisé de <c>value</c>.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture concernant <c>value</c>.</param>
        <summary>Convertit la représentation sous forme de chaîne d'un nombre, ayant un style et un format propre à la culture spécifiés, en sa représentation <see cref="T:System.Numerics.BigInteger" /> équivalente.</summary>
        <returns>Valeur équivalente au nombre spécifié dans le paramètre <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `style` paramètre définit les éléments de style (par exemple, un espace blanc, le symbole de signe positif ou négatif, le symbole de séparateur de groupes ou le symbole de virgule décimale) qui sont autorisés dans les `value` paramètre pour l’opération d’analyse. `styles` doit être une combinaison d’indicateurs de bits de le <xref:System.Globalization.NumberStyles> énumération. Le `style` paramètre rend cette méthode de surcharge utile quand `value` contient la représentation sous forme de chaîne d’une valeur hexadécimale, lorsque le système de nombre (décimal ou hexadécimal) représenté par `value` est connu uniquement au moment de l’exécution, ou lorsque vous souhaitez interdire à un espace blanc ou un signe de symboles dans `value`.  
  
 Selon la valeur de `style`, le `value` paramètre peut inclure les éléments suivants :  
  
 [*ws*] [*$*] [*connexion*] [*chiffres*,]*chiffres*[*. chiffres fractionnaires*] [E [*connexion*]*chiffres_exponentiels*] [*ws*]  
  
 Si `style` inclut <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, le `value` paramètre peut inclure les éléments suivants :  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Les éléments entre crochets ([ et ]) sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Espace blanc facultatif. Espace blanc peut apparaître au début de `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> indicateur.|  
|*$*|Un symbole monétaire spécifique à la culture. Sa position dans la chaîne est définie par le <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> et <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriétés de la culture indiquée par le `provider` paramètre. Symbole de devise de la culture actuelle peut apparaître dans `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> indicateur.|  
|*sign*|Un signe facultatif. Le signe peut apparaître au début de `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> indicateur. Parenthèses peuvent être utilisées dans `value` pour indiquer une valeur négative si `style` inclut le <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> indicateur.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Une séquence de chiffres de 0 à 9. Pour *chiffres fractionnaires*, seul le chiffre 0 est valide.|  
|*,*|Un symbole de séparateur de groupe spécifique à la culture. Le symbole de séparateur de groupes de la culture spécifiée par `provider` peut apparaître dans `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateur.|  
|*.*|Un symbole décimal spécifique à la culture. Le symbole de virgule décimale de la culture désignée par `provider` peut apparaître dans `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur. Seul le chiffre 0 peut apparaître comme un chiffre fractionnaire pour l’opération d’analyse réussisse. Si *chiffres fractionnaires* inclut n’importe quel autre chiffre, une <xref:System.FormatException> est levée.|  
|E|Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique). Le `value` paramètre peut représenter un nombre en notation exponentielle si `style` inclut le <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> indicateur.|  
|*hexdigits*|Une séquence de chiffres hexadécimaux à partir de 0 à f, ou 0 et F.|  
  
 Une chaîne contenant uniquement des chiffres (qui correspond à la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) toujours analysée avec succès. La plupart des restant <xref:System.Globalization.NumberStyles> membres contrôlent des éléments qui peuvent être présents, mais ne sont pas requis pour être présents dans la chaîne d’entrée. Le tableau suivant indique comment chaque <xref:System.Globalization.NumberStyles> membres affectent les éléments qui peuvent être présents dans `value`.  
  
|Valeur NumberStyles|Éléments autorisés dans la valeur en plus des chiffres|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Le *chiffres* élément uniquement.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|La virgule décimale (.) et *chiffres fractionnaires* éléments.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Le « e » ou un caractère « E », ce qui indique la notation exponentielle. avec *chiffres_exponentiels*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Le *ws* élément au début de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Le *ws* élément à la fin de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Le *connexion* élément au début de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Le *connexion* élément à la fin de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Le *connexion* élément sous la forme de parenthèses entourant la valeur numérique.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|L’élément le séparateur de groupe.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Élément de devise ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Tous les éléments. Toutefois, `value` ne peut pas représenter un nombre hexadécimal ou un nombre en notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Float>|Le *ws* élément au début ou à la fin de `value`, *connexion* au début de `value`et le symbole de virgule décimale (.). Le `value` paramètre peut également utiliser la notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Number>|Le `ws`, `sign`, séparateur de groupes (,) et les éléments de la virgule décimale (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Tous les éléments. Toutefois, `value` ne peut pas représenter un nombre hexadécimal.|  
  
> [!IMPORTANT]
>  Si vous utilisez le <xref:System.Numerics.BigInteger.Parse%2A> méthode pour effectuer un aller-retour la représentation sous forme de chaîne d’un <xref:System.Numerics.BigInteger> valeur qui a été sorti par le <xref:System.Numerics.BigInteger.ToString%2A> (méthode), vous devez utiliser le <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> méthode avec le spécificateur de format « R » pour générer la représentation sous forme de chaîne de la <xref:System.Numerics.BigInteger> valeur. Sinon, la représentation sous forme de chaîne de la <xref:System.Numerics.BigInteger> conserve uniquement les 50 chiffres les plus significatifs de la valeur d’origine et les données peuvent être perdues lorsque vous utilisez le <xref:System.Numerics.BigInteger.Parse%2A> méthode pour restaurer le <xref:System.Numerics.BigInteger> valeur.  
  
 Contrairement aux autres <xref:System.Globalization.NumberStyles> valeurs, qui permettent mais ne nécessitent pas la présence d’éléments de style particulier dans `value`, le <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> valeur de style signifie que les caractères numériques dans `value` sont toujours interprétées comme caractères hexadécimaux. Les caractères hexadécimaux valides sont 0-9, A-F et a-f. Les seuls autres indicateurs qui peuvent être combinés avec le `style` paramètre sont <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> et <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Le <xref:System.Globalization.NumberStyles> énumération inclut un style de nombre composite, <xref:System.Globalization.NumberStyles.HexNumber>, qui inclut les deux indicateurs d’espace blanc.)  
  
> [!NOTE]
>  Si `value` est la représentation sous forme de chaîne d’un nombre hexadécimal, il ne peut pas être précédé d’aucune décoration (tel que `0x` ou `&h`) qui le différencie comme un nombre hexadécimal. Cela entraîne l’échec de la conversion.  
  
 Si `value` est une chaîne hexadécimale, les <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> méthode interprète `value` comme un nombre négatif stocké à l’aide de représentation de complément à deux si ses deux premiers chiffres hexadécimaux sont supérieur ou égal à `0x80`. En d’autres termes, la méthode interprète le bit d’ordre le plus élevé du premier octet dans `value` en tant que le bit de signe. Pour vous assurer qu’une chaîne hexadécimale est interprétée correctement comme un nombre positif, le premier chiffre de `value` doit avoir une valeur égale à zéro. Par exemple, la méthode interprète `0x80` comme une valeur négative, mais il interprète `0x080` ou `0x0080` comme une valeur positive. L’exemple suivant illustre la différence entre des chaînes hexadécimales qui représentent les valeurs positives et négatives.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation. Son <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations spécifiques à la culture concernant le format de `value`. En règle générale, `provider` peut prendre l’une des opérations suivantes :  
  
-   Un <xref:System.Globalization.CultureInfo> objet qui représente la culture qui fournit des informations de mise en forme numériques. Son <xref:System.Globalization.CultureInfo.GetFormat%2A> méthode retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme numériques.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme. (Son implémentation de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retourne simplement lui-même.)  
  
-   Un objet personnalisé qui implémente <xref:System.IFormatProvider> et utilise le <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> méthode pour instancier et retourner le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.  
  
 Si `provider` est `null`, le <xref:System.Globalization.NumberFormatInfo> de l’objet pour la culture actuelle est utilisée.  
  
   
  
## Examples  
 L’exemple suivant effectue plusieurs appels à la <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> méthode à l’aide de différentes combinaisons de valeurs pour le `style` et `provider` paramètres.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Un nombre d’appels individuels à la <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> méthode passer une instance de ce qui suit `BigIntegerFormatProvider` (classe), qui définit un tilde (~) en tant que le signe négatif.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> n’est pas une valeur <see cref="T:System.Globalization.NumberStyles" />.  
  
- ou - 
 <paramref name="style" /> inclut l'indicateur <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> ou <see cref="F:System.Globalization.NumberStyles.HexNumber" /> avec une autre valeur.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> ne se conforme pas avec le modèle d'entrée spécifié par <paramref name="style" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nombre à élever à la puissance <c>exponent</c>.</param>
        <param name="exponent">Exposant de <c>value</c>.</param>
        <summary>Élève une valeur <see cref="T:System.Numerics.BigInteger" /> à la puissance de la valeur spécifiée.</summary>
        <returns>Résultat de l'élévation de <paramref name="value" /> à la puissance représentée par <paramref name="exponent" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.Pow%2A> méthode retourne 1 si la valeur du paramètre exposant est 0, ou si les valeurs des deux le `value` et `exponent` paramètres ont pour valeur 0. Si `exponent` est 1, le <xref:System.Numerics.BigInteger.Pow%2A> retourne de la méthode `value`. Si `value` est négatif, la méthode retourne un résultat négatif.  
  
 Cette méthode correspond à la <xref:System.Math.Pow%2A?displayProperty=nameWithType> méthode pour les types numériques primitifs.  
  
   
  
## Examples  
 L’exemple suivant illustre l’élévation à la puissance à l’aide un <xref:System.Numerics.BigInteger> valeur et un exposant dont la valeur est comprise entre 0 et 10.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur du paramètre <paramref name="exponent" /> est négative.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valeur à diviser.</param>
        <param name="divisor">Valeur par laquelle diviser.</param>
        <summary>Effectue une division entière sur deux valeurs <see cref="T:System.Numerics.BigInteger" /> et retourne le modulo.</summary>
        <returns>Reste de la division de <paramref name="dividend" /> par <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le signe du reste est le signe de le `dividend` paramètre.  
  
 Le <xref:System.Numerics.BigInteger.Remainder%2A> méthode est implémentée pour les langages qui ne prennent pas en charge les opérateurs personnalisés. Son comportement est identique à la division à l’aide de l’opérateur modulo.  
  
 Si nécessaire, la méthode effectue automatiquement une conversion implicite des autres types intégraux pour <xref:System.Numerics.BigInteger> objets avant d’effectuer l’opération de modulo.  
  
   
  
## Examples  
 L’exemple suivant compare le reste de la <xref:System.Numerics.BigInteger.DivRem%2A> méthode avec le reste retourné par la <xref:System.Numerics.BigInteger.Remainder%2A> méthode pour établir que les deux méthodes calculent des restes identiques.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> est égal à 0 (zéro).</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un nombre qui indique le signe (négatif, positif ou zéro) de l'objet <see cref="T:System.Numerics.BigInteger" /> actif.</summary>
        <value>Nombre qui indique le signe de l'objet <see cref="T:System.Numerics.BigInteger" />, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Nombre </term><description> Description </description></listheader><item><term> -1 </term><description> la valeur de cet objet est négative.  </description></item><item><term> 0 </term><description> la valeur de cet objet est 0 (zéro).  </description></item><item><term> 1 </term><description> la valeur de cet objet est un nombre positive.  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.Sign%2A> propriété est équivalente à la <xref:System.Math.Sign%2A?displayProperty=nameWithType> méthode pour les types numériques primitifs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Valeur à laquelle appliquer la soustraction (diminuende).</param>
        <param name="right">Valeur à soustraire (diminuteur).</param>
        <summary>Soustrait une valeur <see cref="T:System.Numerics.BigInteger" /> d'une autre valeur et retourne le résultat.</summary>
        <returns>Résultat de la soustraction de <paramref name="right" /> de <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les langages qui ne prennent pas en charge les opérateurs personnalisés peuvent utiliser le <xref:System.Numerics.BigInteger.Subtract%2A> (méthode) à l’aide de la soustraction <xref:System.Numerics.BigInteger> valeurs.  
  
 Le <xref:System.Numerics.BigInteger.Subtract%2A> méthode est un substitut utile pour l’opérateur de soustraction lors de l’instanciation une <xref:System.Numerics.BigInteger> variable en lui assignant la différence qui résulte de la soustraction, comme indiqué dans l’exemple suivant.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convertit une valeur <see cref="T:System.Numerics.BigInteger" /> en tableau d'octets.</summary>
        <returns>Valeur de l'objet <see cref="T:System.Numerics.BigInteger" /> actif convertie en tableau d'octets.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les octets individuels dans le tableau retourné par cette méthode s’affichent dans l’ordre de primauté. Autrement dit, les octets de poids faible de la valeur précèdent les octets d’ordre supérieur. Le premier octet du tableau reflète les huit premiers bits de la <xref:System.Numerics.BigInteger> valeur, le deuxième octet reflète les huit bits suivants et ainsi de suite. Par exemple, la valeur 1024 ou 0 x 0400, est stocké en tant que le tableau de deux octets suivant :  
  
|Élément|Valeur d’octet|  
|-------------|----------------|  
|0|0 x 00|  
|1|0 x 04|  
  
 Les valeurs négatives sont écrites dans le tableau à l’aide de la représentation du deux complément dans le plus compact possible de formulaire. Par exemple, -1 est représenté comme un octet unique dont la valeur est `0xFF` au lieu d’en tant que tableau avec plusieurs éléments, tels que `0xFF`, `0xFF` ou `0xFF`, `0xFF`, `0xFF`, `0xFF`.  
  
 Étant donné que le complément à deux représentation toujours interprète le bit d’ordre le plus élevé du dernier octet dans le tableau (octet à la position <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) en tant que le bit de signe, la méthode retourne un tableau d’octets avec un élément supplémentaire dont la valeur est égale à zéro pour lever l’ambiguïté des valeurs positives sinon être interprétées comme ayant leurs bits de signe à définir. Par exemple, la valeur 120 ou `0x78` est représenté comme un tableau d’un octet : `0x78`. Toutefois, 128, ou `0x80`, est représenté comme un tableau à deux octets : `0x80`, `0x00`.  
  
 Vous pouvez effectuer un aller-retour d’une <xref:System.Numerics.BigInteger> valeur en la stockant dans un tableau d’octets et puis de restaurer à l’aide de la <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructeur.  
  
> [!CAUTION]
>  Si votre code modifie la valeur de chaque octet dans le tableau retourné par cette méthode avant qu’il restaure la valeur, il se peut que vous devez vous assurer que vous ne modifiez pas involontairement le bit de signe. Par exemple, si vos modifications augmentent une valeur positive afin que l’ordre le plus élevé de bits dans le dernier élément du tableau d’octets devient défini, que vous pouvez ajouter un nouvel octet dont la valeur est égale à zéro à la fin du tableau.  
  
   
  
## Examples  
 L’exemple suivant illustre comment certaines <xref:System.Numerics.BigInteger> les valeurs sont représentées dans les tableaux d’octets.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la valeur numérique de l'objet <see cref="T:System.Numerics.BigInteger" /> actuel dans sa représentation sous forme chaîne équivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convertit la valeur numérique de l'objet <see cref="T:System.Numerics.BigInteger" /> actuel dans sa représentation sous forme chaîne équivalente.</summary>
        <returns>Représentation sous forme de chaîne de la valeur actuelle de <see cref="T:System.Numerics.BigInteger" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.ToString> méthode formats un <xref:System.Numerics.BigInteger> valeur dans la « R », ou effectuer un aller-retour, format de la culture actuelle. Si vous souhaitez spécifier un autre format ou la culture, utilisez les autres surcharges de la <xref:System.Numerics.BigInteger.ToString%2A> méthode, comme suit :  
  
|Pour utiliser le format|Pour la culture|Utilisez la surcharge|  
|-------------------|-----------------|----------------------|  
|Format de Round-Trip ("R")|Une culture spécifique|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Un format spécifique|Culture par défaut (actuelle)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Un format spécifique|Une culture spécifique|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 La représentation sous forme de chaîne de la <xref:System.Numerics.BigInteger> valeur inclut un signe négatif si sa valeur est négative et une séquence de chiffres allant de 0 à 9 sans zéros non significatifs. Le signe négatif est défini par le <xref:System.Globalization.NumberFormatInfo> objet pour la culture actuelle.  
  
   
  
## Examples  
 L’exemple suivant affiche un <xref:System.Numerics.BigInteger> valeur à l’aide de la valeur par défaut <xref:System.Numerics.BigInteger.ToString> (méthode). Elle affiche également les représentations sous forme de chaîne de la <xref:System.Numerics.BigInteger> valeur obtenue à l’aide des spécificateurs de format standard. Les exemples sont affichés en utilisant les conventions de mise en forme de la culture en-US.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Convertit la valeur numérique de l’objet <see cref="T:System.Numerics.BigInteger" /> actuel en sa représentation sous forme de chaîne équivalente à l’aide des informations spécifiées de mise en forme spécifiques à la culture.</summary>
        <returns>Représentation sous forme de chaîne de la valeur actuelle de <see cref="T:System.Numerics.BigInteger" /> au format spécifié par le paramètre <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> méthode formats un <xref:System.Numerics.BigInteger> valeur dans le « R », ou effectuer un aller-retour, mettre en forme à l’aide de la <xref:System.Globalization.NumberFormatInfo> objet d’une culture spécifiée. Si vous souhaitez spécifier un autre format ou la culture actuelle, utilisez les autres surcharges de la <xref:System.Numerics.BigInteger.ToString%2A> méthode, comme suit :  
  
|Pour utiliser le format|Pour la culture|Utilisez la surcharge|  
|-------------------|-----------------|----------------------|  
|Format de Round-Trip ("R")|Culture par défaut (actuelle)|<xref:System.Numerics.BigInteger.ToString>|  
|Un format spécifique|Culture par défaut (actuelle)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Un format spécifique|Une culture spécifique|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation. Son <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations spécifiques à la culture sur le format de la chaîne retournée par cette méthode. Si `provider` est `null`, le <xref:System.Numerics.BigInteger> valeur est mise en forme à l’aide de la <xref:System.Globalization.NumberFormatInfo> objet de la culture actuelle. La seule propriété de la <xref:System.Globalization.NumberFormatInfo> objet qui contrôle la représentation sous forme de chaîne de la <xref:System.Numerics.BigInteger> valeur à l’aide du spécificateur de format général est <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, qui définit le caractère qui représente le signe négatif.  
  
 Le `provider` paramètre peut prendre l’une des opérations suivantes :  
  
-   Un <xref:System.Globalization.CultureInfo> objet qui représente la culture qui fournit des informations de mise en forme.  
  
-   Le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.  
  
-   Un objet personnalisé qui implémente <xref:System.IFormatProvider>. Son <xref:System.IFormatProvider.GetFormat%2A> méthode retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.  
  
   
  
## Examples  
 L’exemple suivant instancie un personnalisé <xref:System.Globalization.NumberFormatInfo> objet qui définit le tilde (~) comme un signe négatif. Le <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> méthode utilise ensuite personnalisé <xref:System.Globalization.NumberFormatInfo> objet pour afficher une valeur négative <xref:System.Numerics.BigInteger> valeur.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format numérique standard ou personnalisée.</param>
        <summary>Convertit la valeur numérique de l’objet <see cref="T:System.Numerics.BigInteger" /> actuel en sa représentation sous forme de chaîne équivalente en utilisant le format spécifié.</summary>
        <returns>Représentation sous forme de chaîne de la valeur actuelle de <see cref="T:System.Numerics.BigInteger" /> au format spécifié par le paramètre <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.ToString%28System.String%29> méthode formats un <xref:System.Numerics.BigInteger> valeur dans un format spécifié à l’aide un <xref:System.Globalization.NumberFormatInfo> objet qui représente les conventions de la culture actuelle. Si vous souhaitez utiliser le « R », ou effectuer un aller-retour, mettre en forme ou spécifier une autre culture, utilisez les autres surcharges de la <xref:System.Numerics.BigInteger.ToString%2A> méthode, comme suit :  
  
|Pour utiliser le format|Pour la culture|Utilisez la surcharge|  
|-------------------|-----------------|----------------------|  
|Format de Round-Trip ("R")|Culture par défaut (actuelle)|<xref:System.Numerics.BigInteger.ToString>|  
|Format de Round-Trip ("R")|Une culture spécifique|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Un format spécifique|Une culture spécifique|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Le `format` paramètre peut être valide [chaîne numérique standard](~/docs/standard/base-types/standard-numeric-format-strings.md), ou n’importe quelle combinaison de [chaînes de format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md). Si `format` est égal à <xref:System.String.Empty?displayProperty=nameWithType> ou est `null`, la valeur de retour du courant <xref:System.Numerics.BigInteger> objet est mis en forme avec le spécificateur de format aller-retour (« R »). Si `format` est une autre valeur, la méthode lève une exception une <xref:System.FormatException>.  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques de mise en forme suivantes :  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur la prise en charge de la mise en forme dans le .NET Framework, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Le format de la chaîne retournée est déterminé par le <xref:System.Globalization.NumberFormatInfo> objet pour la culture actuelle. Selon le `format` paramètre, cet objet contrôle les symboles tels que le signe négatif, le séparateur de groupes et le symbole de virgule décimale dans la chaîne de sortie. Pour fournir des informations de mise en forme pour les cultures autres que la culture actuelle, appelez le <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> de surcharge.  
  
   
  
## Examples  
 L’exemple suivant initialise un <xref:System.Numerics.BigInteger> valeur et l’affiche à l’aide de chaque chaîne de format standard et des chaînes de format personnalisé.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n’est pas une chaîne de format valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format numérique standard ou personnalisée.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Convertit la valeur numérique de l’objet <see cref="T:System.Numerics.BigInteger" /> actuel en sa représentation sous forme de chaîne équivalente à l’aide du format spécifié et des informations de mise en forme spécifiques à la culture.</summary>
        <returns>La représentation sous forme de chaîne de la valeur <see cref="T:System.Numerics.BigInteger" /> actuelle spécifiée par les paramètres <paramref name="format" /> et <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> méthode formats un <xref:System.Numerics.BigInteger> valeur dans un format spécifié à l’aide de la <xref:System.Globalization.NumberFormatInfo> objet d’une culture spécifiée. Si vous souhaitez utiliser le format aller-retour ou les paramètres de culture par défaut, utilisez les autres surcharges de la <xref:System.Numerics.BigInteger.ToString%2A> méthode, comme suit :  
  
|Pour utiliser le format|Pour la culture|Utilisez la surcharge|  
|-------------------|-----------------|----------------------|  
|Format de Round-Trip ("R")|Culture par défaut (actuelle)|<xref:System.Numerics.BigInteger.ToString>|  
|Format de Round-Trip ("R")|Une culture spécifique|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Un format spécifique|Culture par défaut (actuelle)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 Le `format` paramètre peut être valide [chaîne numérique standard](~/docs/standard/base-types/standard-numeric-format-strings.md), ou n’importe quelle combinaison de [chaînes de format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md). Si `format` est égal à <xref:System.String.Empty?displayProperty=nameWithType> ou est `null`, la valeur de retour du courant <xref:System.Numerics.BigInteger> objet est mis en forme avec le spécificateur de format aller-retour (« R »). Si `format` est une autre valeur, la méthode lève une exception une <xref:System.FormatException>.  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques de mise en forme suivantes :  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur la prise en charge de la mise en forme dans le .NET Framework, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation. Son <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations spécifiques à la culture sur le format de la chaîne retournée par cette méthode. Lorsque le <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> méthode est appelée, elle appelle le `provider` du paramètre <xref:System.IFormatProvider.GetFormat%2A> (méthode) et le transmet un <xref:System.Type> objet qui représente le <xref:System.Globalization.NumberFormatInfo> type. Le <xref:System.IFormatProvider.GetFormat%2A> méthode renvoie alors le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme le `value` paramètre, comme le symbole de signe négatif, le symbole de séparateur de groupes ou le symbole de virgule décimale. Il existe trois façons d’utiliser le `provider` paramètre pour fournir des informations de mise en forme à la <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> méthode :  
  
-   Vous pouvez passer un <xref:System.Globalization.CultureInfo> objet qui représente la culture qui fournit des informations de mise en forme. Son <xref:System.Globalization.CultureInfo.GetFormat%2A> méthode retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme numériques pour cette culture.  
  
-   Vous pouvez passer le texte réel <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme numériques. (Son implémentation de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retourne simplement lui-même.)  
  
-   Vous pouvez passer un objet personnalisé qui implémente <xref:System.IFormatProvider>. Son <xref:System.IFormatProvider.GetFormat%2A> méthode instancie et retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.  
  
 Si `provider` est `null`, la mise en forme de la chaîne retournée est basée sur le <xref:System.Globalization.NumberFormatInfo> objet de la culture actuelle.  
  
   
  
## Examples  
 L’exemple suivant initialise un <xref:System.Numerics.BigInteger> valeur et l’affiche dans la console à l’aide d’une chaîne de format standard et un <xref:System.Globalization.NumberFormatInfo> objet qui définit le tilde (~) comme un signe négatif.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n’est pas une chaîne de format valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Essaie de convertir la représentation sous forme de chaîne d'un nombre en son équivalent <see cref="T:System.Numerics.BigInteger" /> et retourne une valeur indiquant si la conversion a réussi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Représentation sous forme de chaîne d'un nombre.</param>
        <param name="result">Quand cette méthode est retournée, contient la valeur <see cref="T:System.Numerics.BigInteger" /> équivalente au nombre contenu dans <c>value</c>, ou zéro (0) en cas d’échec de la conversion. La conversion échoue si le paramètre <c>value</c> a la valeur <see langword="null" /> ou s’il n’est pas au format approprié. Ce paramètre est passé sans être initialisé.</param>
        <summary>Essaie de convertir la représentation sous forme de chaîne d'un nombre en son équivalent <see cref="T:System.Numerics.BigInteger" /> et retourne une valeur indiquant si la conversion a réussi.</summary>
        <returns>
          <see langword="true" /> si la conversion de <paramref name="value" /> est réussie ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> méthode est comparable à la <xref:System.Numerics.BigInteger.Parse%28System.String%29> (méthode), à ceci près qu’elle ne lève pas d’exception si la conversion échoue. Cette méthode vous évite de devoir utiliser la gestion des exceptions pour tester un <xref:System.FormatException> si `value` n’est pas valide et ne peut pas être analysée avec succès.  
  
 Le `value` paramètre doit être la représentation sous forme de chaîne d’un nombre décimal sous la forme suivante :  
  
 [*ws*] [*connexion*]*chiffres*[*ws*]  
  
 Les éléments entre crochets ([ et ]) sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Espace blanc facultatif.|  
|*sign*|Un signe facultatif. Les caractères de signe valides sont déterminés par le <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> et <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propriétés de la culture actuelle.|  
|*digits*|Une séquence de chiffres décimaux compris entre 0 et 9.|  
  
> [!NOTE]
>  La chaîne spécifiée par le `value` paramètre ne peut pas contenir de séparateurs de groupes ou séparateur décimal, et il ne peut pas avoir une partie décimale.  
  
 Le `value` paramètre est interprété à l’aide de la <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style. Outre les chiffres décimaux, uniquement espaces à gauche et avec un signe de début sont autorisés. Pour définir explicitement les éléments de style avec les informations de mise en forme propres à la culture qui peuvent être présents dans `value`, appelez le <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> (méthode).  
  
 Le `value` paramètre est analysé en utilisant les informations de mise en forme dans un <xref:System.Globalization.NumberFormatInfo> objet pour la culture actuelle. Pour plus d'informations, consultez <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Cette surcharge interprète tous les chiffres dans le `value` paramètre en tant que chiffres décimaux. Pour analyser la représentation sous forme de chaîne d’un nombre hexadécimal, appelez le <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> surcharger à la place.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> méthode pour instancier deux <xref:System.Numerics.BigInteger> objets. Si les conversions réussissent, il multiplie chaque objet par un autre nombre, puis appelle la <xref:System.Numerics.BigInteger.Compare%2A> méthode pour déterminer la relation entre les deux objets.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Représentation sous forme de chaîne d'un nombre. La chaîne est interprétée à l’aide du style spécifié par <c>style</c>.</param>
        <param name="style">Combinaison de bits de valeurs d’énumération qui indique les éléments de style qui peuvent être présents dans <c>value</c>. Une valeur typique à spécifier est <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture sur <c>value</c>.</param>
        <param name="result">Quand cette méthode est retournée, contient la valeur <see cref="T:System.Numerics.BigInteger" /> équivalente au nombre contenu dans <c>value</c>, ou <see cref="P:System.Numerics.BigInteger.Zero" /> en cas d’échec de la conversion. La conversion échoue si le paramètre <c>value</c> a la valeur <see langword="null" /> ou s’il n’est pas dans un format compatible avec <c>style</c>. Ce paramètre est passé sans être initialisé.</param>
        <summary>Essaie de convertir la représentation sous forme de chaîne d'un nombre ayant un style et un format spécifique à la culture spécifiés en son équivalent <see cref="T:System.Numerics.BigInteger" /> et retourne une valeur qui indique si la conversion a réussi.</summary>
        <returns>
          <see langword="true" /> si la conversion du paramètre <paramref name="value" /> a réussi ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> méthode est comparable à la <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> (méthode), à ceci près qu’elle ne lève pas d’exception si la conversion échoue. Cette méthode vous évite de devoir utiliser la gestion des exceptions pour tester un <xref:System.FormatException> si `value` n’est pas valide et ne peut pas être analysée avec succès.  
  
 Le `style` paramètre définit les éléments de style (par exemple, un espace blanc ou un signe positif ou négatif) qui sont autorisés dans les `value` paramètre pour l’opération d’analyse. Il doit être une combinaison d’indicateurs de bits de le <xref:System.Globalization.NumberStyles> énumération. Selon la valeur de `style`, le `value` paramètre peut inclure les éléments suivants :  
  
 [*ws*] [*$*] [*connexion*] [*chiffres*,]*chiffres*[.* chiffres fractionnaires*] [E [*connexion*]*chiffres_exponentiels*] [*ws*]  
  
 Si le `style` paramètre inclut <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, le `value` paramètre peut inclure les éléments suivants :  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Les éléments entre crochets ([ et ]) sont facultatifs. Le tableau suivant décrit chaque élément.  
  
|Élément|Description |  
|-------------|-----------------|  
|*ws*|Espace blanc facultatif. Espace blanc peut apparaître au début de `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> indicateur, ou à la fin de `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> indicateur.|  
|*$*|Un symbole monétaire spécifique à la culture. Sa position dans la chaîne est définie par le <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> propriété de la <xref:System.Globalization.NumberFormatInfo> objet retourné par la <xref:System.IFormatProvider.GetFormat%2A> méthode de le `provider` paramètre. Le symbole monétaire peut apparaître dans `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> indicateur.|  
|*sign*|Un signe facultatif. Le signe peut apparaître au début de `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> indicateur et il peuvent apparaître à la fin de `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> indicateur. Parenthèses peuvent être utilisées dans `value` pour indiquer une valeur négative si `style` inclut le <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> indicateur.|  
|*digits*|Une séquence de chiffres de 0 à 9.|  
|*,*|Un séparateur de groupe spécifique à la culture. Le séparateur de groupes de la culture spécifiée par `provider` peut apparaître dans `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> indicateur.|  
|*.*|Un symbole décimal spécifique à la culture. Le symbole de virgule décimale de la culture spécifiée par `provider` peut apparaître dans `value` si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.|  
|*fractional_digits*|Une ou plusieurs occurrences du chiffre 0. Les chiffres fractionnaires peuvent apparaître dans `value` uniquement si `style` inclut le <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> indicateur.|  
|E|Le « e » ou un caractère « E », ce qui indique que la valeur est représentée dans la notation exponentielle (scientifique). Le `value` paramètre peut représenter un nombre en notation exponentielle si `style` inclut le <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> indicateur.|  
|*exponential_digits*|Une séquence de chiffres de 0 à 9. Le `value` paramètre peut représenter un nombre en notation exponentielle si `style` inclut le <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> indicateur.|  
|*hexdigits*|Une séquence de chiffres hexadécimaux à partir de 0 à f, ou 0 et F.|  
  
 Une chaîne contenant uniquement des chiffres décimaux (qui correspond à la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> indicateur) toujours analysée avec succès. La plupart des restant <xref:System.Globalization.NumberStyles> membres contrôlent des éléments qui peuvent être présents, mais ne sont pas requis pour figurer dans cette chaîne d’entrée. Le tableau suivant indique comment chaque <xref:System.Globalization.NumberStyles> membres affectent les éléments qui peuvent être présents dans `value`.  
  
|Non composites `NumberStyles` valeurs|Éléments autorisés dans la valeur en plus des chiffres|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Uniquement des chiffres décimaux.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|La virgule décimale (*.*) et *chiffres fractionnaires* éléments. Toutefois, *chiffres fractionnaires* doit comporter un ou plusieurs chiffres de 0, ou la méthode retourne `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Le « e » ou un caractère « E », ce qui indique la notation exponentielle avec *chiffres_exponentiels*. Si `value` représente un nombre en notation exponentielle, il ne peut pas avoir un composant différent de zéro et fractionnaire.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Le *ws* élément au début de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Le *ws* élément à la fin de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Le *connexion* élément avant *chiffres*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Le *connexion* élément après *chiffres*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Le *connexion* élément sous la forme de parenthèses entourant la valeur numérique.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Le séparateur de groupes (*,*) élément.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|La devise (*$*) élément.|  
|<xref:System.Globalization.NumberStyles.Currency>|Tous les éléments. Toutefois, `value` ne peut pas représenter un nombre hexadécimal ou un nombre en notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Float>|Le *ws* élément au début ou à la fin de `value`, *connexion* au début de `value`et la virgule décimale (*.*) symbole. Le `value` paramètre peut également utiliser la notation exponentielle.|  
|<xref:System.Globalization.NumberStyles.Number>|Le *ws*, *connexion*, séparateur de groupes (*,*) et la virgule décimale (*.*) éléments.|  
|<xref:System.Globalization.NumberStyles.Any>|Tous les éléments. Toutefois, `value` ne peut pas représenter un nombre hexadécimal.|  
  
> [!IMPORTANT]
>  Si vous utilisez le <xref:System.Numerics.BigInteger.TryParse%2A> méthode pour effectuer un aller-retour la représentation sous forme de chaîne d’un <xref:System.Numerics.BigInteger> valeur qui a été sorti par le <xref:System.Numerics.BigInteger.ToString%2A> (méthode), vous devez utiliser le <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> méthode avec le spécificateur de format « R » pour générer la représentation sous forme de chaîne de la <xref:System.Numerics.BigInteger> valeur. Sinon, la représentation sous forme de chaîne de la <xref:System.Numerics.BigInteger> conserve uniquement les 50 chiffres les plus significatifs de la valeur d’origine et les données peuvent être perdues lorsque vous utilisez le <xref:System.Numerics.BigInteger.TryParse%2A> méthode pour restaurer le <xref:System.Numerics.BigInteger> valeur.  
  
 Si le <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> indicateur est utilisé, `value` doit être une valeur hexadécimale. Les seuls autres indicateurs qui peuvent être présents dans `style` sont <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> et <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Le <xref:System.Globalization.NumberStyles> énumération a un style composite, <xref:System.Globalization.NumberStyles.HexNumber>, qui inclut les deux indicateurs d’espace blanc.)  
  
> [!NOTE]
>  Si `value` est la représentation sous forme de chaîne d’un nombre hexadécimal, il ne peut pas être précédé d’aucune décoration (tel que `0x` ou `&h`) qui le différencie comme un nombre hexadécimal. Cela entraîne l’échec de la conversion.  
  
 Si `value` est une chaîne hexadécimale, les <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> méthode interprète `value` comme un nombre négatif stocké à l’aide de représentation de complément à deux si ses deux premiers chiffres hexadécimaux sont supérieur ou égal à `0x80`. En d’autres termes, la méthode interprète le bit d’ordre le plus élevé du premier octet dans `value` en tant que le bit de signe. Pour vous assurer qu’une chaîne hexadécimale est interprétée correctement comme un nombre positif, le premier chiffre de `value` doit avoir une valeur égale à zéro. Par exemple, la méthode interprète `0x80` comme une valeur négative, mais il interprète `0x080` ou `0x0080` comme une valeur positive. L’exemple suivant illustre la différence entre des chaînes hexadécimales qui représentent les valeurs positives et négatives.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 Le `provider` paramètre est un <xref:System.IFormatProvider> implémentation. Son <xref:System.IFormatProvider.GetFormat%2A> méthode retourne un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations spécifiques à la culture concernant le format de `value`. Le `provider` paramètre peut prendre l’une des opérations suivantes :  
  
-   Un <xref:System.Globalization.CultureInfo> objet qui représente la culture qui fournit des informations de mise en forme. Son <xref:System.Globalization.CultureInfo.GetFormat%2A> méthode retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme numériques pour cette culture.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme numériques. (Son implémentation de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retourne simplement lui-même.)  
  
-   Un objet personnalisé qui implémente <xref:System.IFormatProvider>. Son <xref:System.IFormatProvider.GetFormat%2A> méthode instancie et retourne le <xref:System.Globalization.NumberFormatInfo> objet qui fournit des informations de mise en forme.  
  
 Si `provider` est `null`, le <xref:System.Globalization.NumberFormatInfo> de l’objet pour la culture actuelle est utilisée.  
  
   
  
## Examples  
 L’exemple suivant effectue des appels à la <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> méthode à l’aide de différentes combinaisons de valeurs pour le `style` et `provider` paramètres.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Un nombre d’appels individuels à la <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> méthode passer une instance de ce qui suit `BigIntegerFormatProvider` (classe), qui définit un tilde (~) en tant que le signe négatif.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> n’est pas une valeur <see cref="T:System.Globalization.NumberStyles" />.  
  
- ou - 
 <paramref name="style" /> inclut l'indicateur <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> ou <see cref="F:System.Globalization.NumberStyles.HexNumber" /> avec une autre valeur.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui représente le nombre 0 (zéro).</summary>
        <value>Entier dont la valeur est 0 (zéro).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Numerics.BigInteger> objet retourné par cette propriété fournit une source pratique d’une valeur zéro pour une utilisation dans les assignations et les comparaisons.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>