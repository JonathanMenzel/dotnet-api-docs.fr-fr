<Type Name="IValueProvider" FullName="System.Windows.Automation.Provider.IValueProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8c1d51b87ec2caeb4da3cf10dd4b86c61eba2716" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30615913" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IValueProvider" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IValueProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Provider.IValueProvider" />
  <TypeSignature Language="VB.NET" Value="Public Interface IValueProvider" />
  <TypeSignature Language="C++ CLI" Value="public interface class IValueProvider" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationProvider</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("c7935180-6fb3-4201-b174-7df73adbf64a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.InterfaceType</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expose des méthodes et des propriétés pour prendre en charge l’accès du client UI Automation aux contrôles ayant une valeur intrinsèque qui ne couvre pas de plage et qui peut être représentée sous forme de chaîne.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur du contrôle peut ou ne peut pas être modifiée selon le contrôle et ses paramètres.  
  
 Implémentée sur un fournisseur UI Automation qui doit prendre en charge la <xref:System.Windows.Automation.ValuePattern> modèle de contrôle.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Automation.ValuePattern" />
  </Docs>
  <Members>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Provider.IValueProvider.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui spécifie si la valeur d'un contrôle est en lecture seule.</summary>
        <value>
          <see langword="true" /> si la valeur est en lecture seule ; <see langword="false" /> si elle peut être modifiée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contrôle doit avoir <xref:System.Windows.Automation.AutomationElement.IsEnabledProperty> défini sur `true` et <xref:System.Windows.Automation.ValuePattern.IsReadOnlyProperty> défini sur `false` avant d’autoriser un appel à <xref:System.Windows.Automation.Provider.IValueProvider.SetValue%2A>.  
  
   
  
## Examples  
 L’exemple suivant illustre une implémentation de cette méthode pour un contrôle qui permet à sa valeur doit être modifié.  
  
 [!code-csharp[UIAIValueProvider_snip#IsReadOnly](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAIValueProvider_snip/CSharp/ValueFragment.cs#isreadonly)]
 [!code-vb[UIAIValueProvider_snip#IsReadOnly](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAIValueProvider_snip/visualbasic/valuefragment.vb#isreadonly)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Provider.IValueProvider.SetValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à définir. Le fournisseur est chargé de convertir la valeur en type de données approprié.</param>
        <summary>Définit la valeur d’un contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les contrôles d’édition sur une ligne prennent en charge l’accès par programmation à leur contenu en implémentant <xref:System.Windows.Automation.Provider.IValueProvider>. Toutefois, les contrôles d’édition multilignes n’implémentent pas <xref:System.Windows.Automation.Provider.IValueProvider>. Ils fournissent plutôt un accès à leur contenu en implémentant <xref:System.Windows.Automation.Provider.ITextProvider>.  
  
 Les contrôles tels que <xref:System.Windows.Automation.ControlType.ListItem> et <xref:System.Windows.Automation.ControlType.TreeItem> doit implémenter <xref:System.Windows.Automation.Provider.IValueProvider> si la valeur d’un des éléments est modifiable, quel que soit l’actuel mode d’édition du contrôle. Le contrôle parent doit également implémenter <xref:System.Windows.Automation.Provider.IValueProvider> si les éléments enfants sont modifiables.  
  
 ![Élément de liste modifiable. ] (~/add/media/uia-valuepattern-editable-listitem.PNG "Élément de liste modifiable.")  
Exemple d’élément de liste modifiable  
  
   
  
## Examples  
 L’exemple de code suivant illustre un contrôle personnalisé qui permet à sa valeur soit définie sur une chaîne de longueur limitée.  
  
 [!code-csharp[UIAIValueProvider_snip#SetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAIValueProvider_snip/CSharp/ValueFragment.cs#setvalue)]
 [!code-vb[UIAIValueProvider_snip#SetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAIValueProvider_snip/visualbasic/valuefragment.vb#setvalue)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si des informations spécifiques de paramètres régionaux sont passées à un contrôle dans un format incorrect, par exemple, une date au format incorrect.</exception>
        <exception cref="T:System.ArgumentException">Si une nouvelle valeur ne peut pas être convertie d’une chaîne en un format reconnu par le contrôle.</exception>
        <exception cref="T:System.Windows.Automation.ElementNotEnabledException">Quand une tentative est effectuée pour manipuler un contrôle qui n’est pas activé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Provider.IValueProvider.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationProvider</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la valeur du contrôle.</summary>
        <value>Valeur du contrôle sous forme de chaîne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrôles d’édition sur une ligne prennent en charge l’accès par programme à leur contenu en implémentant <xref:System.Windows.Automation.Provider.IValueProvider> (en plus de <xref:System.Windows.Automation.Provider.ITextProvider>). Toutefois, les contrôles d’édition multilignes n’implémentent pas <xref:System.Windows.Automation.Provider.IValueProvider>.  
  
 Pour récupérer le contenu textuel de contrôles d’édition multiligne, les contrôles doivent implémenter <xref:System.Windows.Automation.Provider.ITextProvider>. Toutefois, <xref:System.Windows.Automation.Provider.ITextProvider> ne prend pas en charge la définition de la valeur d’un contrôle.  
  
 <xref:System.Windows.Automation.Provider.IValueProvider> ne prend pas en charge la récupération des informations de mise en forme ou des valeurs d’une sous-chaîne. Implémentez <xref:System.Windows.Automation.Provider.ITextProvider> dans ces scénarios.  
  
   
  
## Examples  
 L’exemple suivant illustre une implémentation de cette méthode pour un contrôle qui permet à sa valeur à récupérer.  
  
 [!code-csharp[UIAIValueProvider_snip#Value](~/samples/snippets/csharp/VS_Snippets_Wpf/UIAIValueProvider_snip/CSharp/ValueFragment.cs#value)]
 [!code-vb[UIAIValueProvider_snip#Value](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIAIValueProvider_snip/visualbasic/valuefragment.vb#value)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>