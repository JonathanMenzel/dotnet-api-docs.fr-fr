<Type Name="UTF8Encoding" FullName="System.Text.UTF8Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e943fbae64738440bc471e2c4be537f61581b3eb" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57934065" /></Metadata><TypeSignature Language="C#" Value="public class UTF8Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UTF8Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF8Encoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UTF8Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF8Encoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF8Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un encodage UTF-8 de caractères Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'encodage est le processus de transformation d'un jeu de caractères Unicode en une séquence d'octets. Le décodage est le processus de transformation d’une séquence d’octets codés en un jeu de caractères Unicode.  
  
 UTF-8 est un encodage qui Unicode représente chaque point de code sous la forme d’une séquence d’un à quatre octets. Contrairement aux encodages UTF-16 et UTF-32, l’encodage UTF-8 dispense « endianness » ; le schéma d’encodage est le même que le processeur soit big-endian ou little-endian. <xref:System.Text.UTF8Encoding> correspond à la page de codes 65001 de Windows. Pour plus d’informations sur les formats UTF et d’autres encodages pris en charge par <xref:System.Text>, consultez [encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Vous pouvez instancier un <xref:System.Text.UTF8Encoding> objet dans une de plusieurs façons, selon que vous souhaitiez lui fournir une marque d’ordre d’octet (BOM) et si vous souhaitez activer la détection d’erreur. Le tableau suivant répertorie les constructeurs et les <xref:System.Text.Encoding> propriété qui retournent un <xref:System.Text.UTF8Encoding> objet.  
  
|Membre|NOMENCLATURE|Détection d’erreurs|  
|------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>|Oui|Aucun (remplacement de secours)|  
|<xref:System.Text.UTF8Encoding.%23ctor?displayProperty=nameWithType>|Non|Aucun (remplacement de secours)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29?displayProperty=nameWithType>|Configurable|Aucun (remplacement de secours)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurable|Configurable|  
  
 Le <xref:System.Text.UTF8Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.UTF8Encoding.GetBytes%2A> méthode exécute le codage.  
  
 De même, le <xref:System.Text.UTF8Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et le <xref:System.Text.UTF8Encoding.GetChars%2A> et <xref:System.Text.UTF8Encoding.GetString%2A> méthodes effectuent le décodage réel.  
  
 Pour un encodeur ou un décodeur qui est en mesure d’enregistrer les informations d’état lors de l’encodage ou de décodage de données qui s’étend sur plusieurs blocs (par exemple, la chaîne de 1 million de caractères qui est encodé dans les segments de 100 000 caractères), utilisez le <xref:System.Text.UTF8Encoding.GetEncoder%2A> et <xref:System.Text.UTF8Encoding.GetDecoder%2A> propriétés, respectivement.  
  
 Si vous le souhaitez, le <xref:System.Text.UTF8Encoding> objet fournit une marque d’ordre d’octet (BOM), qui est un tableau d’octets qui peut être préfixé au début du flux d’octets qui résulte du processus de codage. Si un flux d’octets codée en UTF-8 est précédé d’une marque d’ordre d’octet (BOM), il aide le décodeur à déterminer l’ordre d’octet et que le format de transformation ou UTF. Notez, cependant, que la norme Unicode ne nécessite ni recommande un BOM UTF-8 encodé le flux. Pour plus d’informations sur l’ordre d’octet et la marque d’ordre d’octet, consultez la norme Unicode dans le [page d’accueil Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Si l’encodeur est configuré pour fournir une nomenclature, vous pouvez le récupérer en appelant le <xref:System.Text.UTF8Encoding.GetPreamble%2A> méthode ; sinon, la méthode retourne un tableau vide. Notez que, même si un <xref:System.Text.UTF8Encoding> objet est configuré pour prendre en charge de la nomenclature, vous devez inclure la marque BOM au début du flux d’octets encodé selon le cas ; les méthodes d’encodage de la <xref:System.Text.UTF8Encoding> classe ne le faites pas cela automatiquement.  
  
> [!CAUTION]
>  Pour activer la détection d’erreur et pour renforcer la sécurité de l’instance de classe, vous devez appeler la <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> constructeur et définissez le `throwOnInvalidBytes` paramètre `true`. Avec la détection d’erreurs, une méthode qui détecte une séquence de caractères ou d’octets non valide lève une <xref:System.ArgumentException> exception. Absence de détection d’erreur, aucune exception n’est levée, et la séquence non valide est généralement ignorée.  
  
> [!NOTE]
>  L’état d’un objet encodé UTF-8 n’est pas conservé si l’objet est sérialisé et désérialisé à l’aide de différentes versions de .NET Framework.  
  
   
  
## Examples  
 L’exemple suivant utilise un <xref:System.Text.UTF8Encoding> objet à encoder une chaîne de caractères Unicode et les stocker dans un tableau d’octets. La chaîne Unicode inclut deux caractères, Pi (U + 03A0) et Sigma (U + 03A3), qui sont en dehors de la plage de caractères ASCII. Une fois le tableau d’octets encodé est décodé en chaîne, les caractères de Pi et Sigma sont toujours présents.  
  
 [!code-cpp[System.Text.UTF8Encoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UTF8Encoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/snippet.vb#1)]  
  
 L’exemple suivant utilise la même chaîne que l’exemple précédent, sauf qu’il écrit les octets encodés dans un fichier et le flux d’octets avec une marque d’ordre d’octet (BOM) de préfixes. Elle lit ensuite le fichier de deux manières différentes : en tant qu’un fichier texte à l’aide un <xref:System.IO.StreamReader> de l’objet ; et comme un fichier binaire. Comme vous pouvez l’imaginer, aucune chaîne qui vient d’être en lecture inclut la nomenclature.  
  
 [!code-csharp[System.Text.UTF8Encoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UTF8Encoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Encodages de présentation</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.UTF8Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.UTF8Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée une instance qui ne fournit pas de marque d’ordre d’octet Unicode et ne lève pas d’exception lorsqu’un encodage non valide est détecté.  
  
> [!CAUTION]
>  Pour des raisons de sécurité, nous vous recommandons d’activer la détection d’erreur en appelant un constructeur avec un `throwOnInvalidBytes` paramètre et en définissant sa valeur sur `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Text.UTF8Encoding> de l’instance et affiche son nom.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding encoderShouldEmitUTF8Identifier" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier"><see langword="true" /> pour spécifier que la méthode <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> retourne une marque d'ordre d'octet Unicode ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.UTF8Encoding" />. Un paramètre spécifie si une marque d'ordre d'octet Unicode doit être fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée une instance qui ne lève pas d’exception lorsqu’un encodage non valide est détecté.  
  
> [!CAUTION]
>  Pour des raisons de sécurité, vous devez activer la détection d’erreur en appelant un constructeur qui inclut un `throwOnInvalidBytes` paramètre et en définissant sa valeur sur `true`.  
  
 Le `encoderShouldEmitUTF8Identifier` paramètre contrôle le fonctionnement de la <xref:System.Text.UTF8Encoding.GetPreamble%2A> (méthode). Si `true`, la méthode retourne un tableau d’octets contenant la marque d’ordre d’octet Unicode (BOM) au format UTF-8.  Si `false`, elle retourne un tableau d’octets de longueur nulle. Toutefois, l’affectation `encoderShouldEmitUTF8Identifier` à `true` n’entraîne pas la <xref:System.Text.UTF8Encoding.GetBytes%2A> (méthode) pour préfixer la nomenclature au début du tableau d’octets, et ne déclenche le <xref:System.Text.UTF8Encoding.GetByteCount%2A> méthode pour inclure le nombre d’octets dans la nomenclature dans le nombre d’octets.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Text.UTF8Encoding> de l’instance et spécifie que le préfixe de marque d’un ordre d’octet Unicode doit être émis par le <xref:System.Text.UTF8Encoding.GetPreamble%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetPreamble%2A> méthode renvoie alors le préfixe d’interrogation de l’ordre d’octet Unicode.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CPP/ctor-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CS/ctor-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/VB/ctor-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool * bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding (encoderShouldEmitUTF8Identifier, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier"><see langword="true" /> pour spécifier que la méthode <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> doit retourner une marque d'ordre d'octet Unicode ; sinon, <see langword="false" />.</param>
        <param name="throwOnInvalidBytes"><see langword="true" /> pour lever une exception lorsqu'un encodage non valide est détecté ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.UTF8Encoding" />. Les paramètres spécifient s'il faut fournir une marque d'ordre d'octet Unicode et si une exception doit être levée quand un encodage non valide est détecté.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `encoderShouldEmitUTF8Identifier` paramètre contrôle le fonctionnement de la <xref:System.Text.UTF8Encoding.GetPreamble%2A> (méthode). Si `true`, la méthode retourne un tableau d’octets contenant la marque d’ordre d’octet Unicode (BOM) au format UTF-8.  Si `false`, elle retourne un tableau d’octets de longueur nulle. Toutefois, l’affectation `encoderShouldEmitUTF8Identifier` à `true` n’entraîne pas la <xref:System.Text.UTF8Encoding.GetBytes%2A> (méthode) pour préfixer la nomenclature au début du tableau d’octets, et ne déclenche le <xref:System.Text.UTF8Encoding.GetByteCount%2A> méthode pour inclure le nombre d’octets dans la nomenclature dans le nombre d’octets.  
  
 Si `throwOnInvalidBytes` est `true`, une méthode qui détecte une séquence d’octets non valide lève une <xref:System.ArgumentException?displayProperty=nameWithType> exception. Sinon, la méthode ne lève pas d’exception et la séquence non valide est ignorée.  
  
> [!CAUTION]
>  Pour des raisons de sécurité, vous devez activer la détection d’erreur en appelant un constructeur qui inclut un `throwOnInvalidBytes` paramètre et en définissant ce paramètre sur `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Text.UTF8Encoding> instance, indiquant ainsi que la <xref:System.Text.UTF8Encoding.GetPreamble%2A> méthode ne doit pas émettre de préfixe de marque d’un ordre d’octet Unicode, et une exception doit être levée quand un encodage non valide est détecté. Le comportement de ce constructeur est comparé à la valeur par défaut <xref:System.Text.UTF8Encoding.%23ctor> constructeur, ce qui ne lève pas d’exception lorsqu’un encodage non valide est détecté. Les deux <xref:System.Text.UTF8Encoding> instances encoder un tableau de caractères qui contient deux substituts étendus (U + D801 et U + D802) dans une ligne, qui est une séquence de caractères non valide ; un caractère de substitution étendu doit toujours être suivi d’un substitut faible.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF8Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet à comparer à l'instance actuelle.</param>
        <summary>Détermine si l'objet spécifié est identique à l'objet <see cref="T:System.Text.UTF8Encoding" /> actuel.</summary>
        <returns><see langword="true" /> si <paramref name="value" /> est une instance de <see cref="T:System.Text.UTF8Encoding" /> et s'il est égal à l'objet actuel ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deux <xref:System.Text.UTF8Encoding> objets sont considérés comme égaux si toutes les conditions suivantes sont remplies :  
  
-   Les deux objets fournissent la marque d’ordre d’octet, ou les deux n’est pas le cas.  
  
-   Les deux objets utilisent le même encodeur de secours.  
  
-   Les deux objets utilisent le même décodeur de secours.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Text.UTF8Encoding.Equals%2A> méthode pour tester si actuel <xref:System.Text.UTF8Encoding> objet est égal à un autre <xref:System.Text.UTF8Encoding> objet. Quatre <xref:System.Text.UTF8Encoding> objets sont créés et comparées et les résultats des comparaisons sont affichés.  
  
 [!code-cpp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CPP/equals-object.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CS/equals-object.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/VB/equals-object.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ chars);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF8Encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="chars"><see cref="T:System.String" /> contenant le jeu de caractères à encoder.</param>
        <summary>Calcule le nombre d'octets générés en encodant les caractères dans le <see cref="T:System.String" /> spécifié.</summary>
        <returns>Nombre d'octets produits par l'encodage des caractères spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF8Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF8Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException> exception. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (tel qu’au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflété dans la valeur retournée par la <xref:System.Text.UTF8Encoding.GetByteCount%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> et <xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29> méthodes pour calculer le nombre maximal et réel d’octets requis pour encoder une chaîne. Il affiche également le nombre réel d’octets requis pour stocker un flux d’octets avec une marque d’ordre d’octet.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Pointeur du premier caractère à encoder.</param>
        <param name="count">Nombre de caractères à encoder.</param>
        <summary>Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères commençant au pointeur de caractère spécifié.</summary>
        <returns>Nombre d'octets produits par l'encodage des caractères spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par le <xref:System.Text.UTF8Encoding.GetBytes%2A> méthode pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF8Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException> exception. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (tel qu’au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflété dans la valeur retournée par la <xref:System.Text.UTF8Encoding.GetByteCount%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> est inférieur à zéro.  
  
ou 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tableau de caractères contenant le jeu de caractères à encoder.</param>
        <param name="index">Index du premier caractère à encoder.</param>
        <param name="count">Nombre de caractères à encoder.</param>
        <summary>Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères du tableau de caractères spécifié.</summary>
        <returns>Nombre d'octets produits par l'encodage des caractères spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF8Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez les utilisations <xref:System.Text.UTF8Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException> exception. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (tel qu’au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflété dans la valeur retournée par la <xref:System.Text.UTF8Encoding.GetByteCount%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant remplit un tableau avec un Latin en majuscules et minuscules et appelle le <xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> méthode pour déterminer le nombre d’octets nécessaires pour encoder les caractères latins minuscules. Il affiche ensuite ces informations ainsi que le nombre total d’octets nécessaire si une marque d’ordre d’octet est ajoutée. Il compare ce nombre avec la valeur retournée par la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (méthode), ce qui indique le nombre maximal d’octets nécessaires pour encoder les caractères latins minuscules.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
ou 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="chars" />.  
  
ou 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
La propriété <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Encode un jeu de caractères en une séquence d'octets.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="uTF8Encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne de caractères à encoder.</param>
        <summary>Encode les caractères contenus dans un objet <see cref="T:System.String" /> spécifié dans une séquence d'octets.</summary>
        <returns>Tableau d’octets qui contient les caractères encodés dans la chaîne spécifiée par le paramètre s.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Pointeur du premier caractère à encoder.</param>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <param name="bytes">Pointeur de l'emplacement où commencer l'écriture de la séquence d'octets obtenue.</param>
        <param name="byteCount">Nombre maximal d'octets à écrire.</param>
        <summary>Code une séquence de caractères commençant au pointeur de caractère spécifié en une séquence d'octets, qui sera stockée à partir du pointeur d'octet spécifié.</summary>
        <returns>Nombre réel d'octets écrits à l'emplacement indiqué par <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF8Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF8Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException> exception. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, utilisez le <xref:System.Text.Decoder> ou le <xref:System.Text.Encoder> retourné par la <xref:System.Text.UTF8Encoding.GetDecoder%2A> méthode ou le <xref:System.Text.UTF8Encoding.GetEncoder%2A> (méthode), respectivement.  
  
 Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur. Le <xref:System.Text.UTF8Encoding.GetBytes%2A> méthode ne doit pas un préambule au début d’une séquence d’octets encodées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> ou <paramref name="byteCount" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.  
  
ou 
 <paramref name="byteCount" /> est inférieur au nombre d'octets obtenus.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tableau de caractères contenant le jeu de caractères à encoder.</param>
        <param name="charIndex">Index du premier caractère à encoder.</param>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <param name="bytes">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</param>
        <param name="byteIndex">Index auquel commencer l'écriture de la séquence d'octets obtenue.</param>
        <summary>Encode un jeu de caractères du tableau de caractères spécifié dans le tableau d'octets indiqué.</summary>
        <returns>Nombre réel d'octets écrits dans <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF8Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF8Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException> exception. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, utilisez le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UTF8Encoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UTF8Encoding.GetEncoder%2A> (méthode), respectivement.  
  
 Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur. Le <xref:System.Text.UTF8Encoding.GetBytes%2A> méthode ne doit pas un préambule au début d’une séquence d’octets encodées.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Text.UTF8Encoding.GetBytes%2A> méthode pour encoder une plage de caractères à partir d’une chaîne et stocke les octets encodés dans une plage d’éléments dans un tableau d’octets.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> est inférieur à zéro.  
  
ou 
 <paramref name="charIndex" /> et <paramref name="charCount" /> ne désignent pas une plage valide dans <paramref name="chars" />.  
  
ou 
 <paramref name="byteIndex" /> n'est pas un index valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.  
  
ou 
 <paramref name="bytes" /> ne possède pas une capacité suffisante entre <paramref name="byteIndex" /> et la fin du tableau pour prendre en charge les octets obtenus.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s"><see cref="T:System.String" /> contenant le jeu de caractères à encoder.</param>
        <param name="charIndex">Index du premier caractère à encoder.</param>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <param name="bytes">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</param>
        <param name="byteIndex">Index auquel commencer l'écriture de la séquence d'octets obtenue.</param>
        <summary>Encode un jeu de caractères de la chaîne <see cref="T:System.String" /> spécifiée dans le tableau d'octets indiqué.</summary>
        <returns>Nombre réel d'octets écrits dans <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF8Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF8Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException> exception. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, utilisez le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UTF8Encoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UTF8Encoding.GetEncoder%2A> (méthode), respectivement.  
  
 Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur. Le <xref:System.Text.UTF8Encoding.GetBytes%2A> méthode ne doit pas un préambule au début d’une séquence d’octets encodées.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Text.UTF8Encoding.GetBytes%2A> méthode pour encoder une plage d’éléments à partir d’un tableau de caractères Unicode et stocker les octets encodés dans une plage d’éléments dans un tableau d’octets.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> est inférieur à zéro.  
  
ou 
 <paramref name="charIndex" /> et <paramref name="charCount" /> ne désignent pas une plage valide dans <paramref name="chars" />.  
  
ou 
 <paramref name="byteIndex" /> n'est pas un index valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="s" /> contient une séquence de caractères non valide.  
  
ou 
 <paramref name="bytes" /> ne possède pas une capacité suffisante entre <paramref name="byteIndex" /> et la fin du tableau pour prendre en charge les octets obtenus.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcule le nombre de caractères produits par le décodage d'une séquence d'octets.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Pointeur du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>Calcule le nombre de caractères produits par le décodage d'une séquence d'octets commençant au pointeur d'octet spécifié.</summary>
        <returns>Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF8Encoding.GetChars%2A> pour stocker les caractères obtenus, appelez le <xref:System.Text.UTF8Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException> exception. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> est inférieur à zéro.  
  
ou 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="index">Index du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>Calcule le nombre de caractères produits par le décodage d'une séquence d'octets du tableau d'octets spécifié.</summary>
        <returns>Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF8Encoding.GetChars%2A> pour stocker les caractères obtenus, appelez le <xref:System.Text.UTF8Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException> exception. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Text.UTF8Encoding.GetCharCount%2A> méthode pour retourner le nombre de caractères produits par le décodage d’une plage d’éléments dans un tableau d’octets.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
ou 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="bytes" />.  
  
ou 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Décode une séquence d'octets en un jeu de caractères.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Pointeur du premier octet à décoder.</param>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <param name="chars">Pointeur de l'emplacement où commencer l'écriture du jeu de caractères obtenu.</param>
        <param name="charCount">Nombre maximal de caractères à écrire.</param>
        <summary>Décode une séquence d'octets commençant au pointeur d'octet spécifié en un jeu de caractères qui sera stocké à partir du pointeur de caractère spécifié.</summary>
        <returns>Nombre réel de caractères écrits à l'emplacement indiqué par <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF8Encoding.GetChars%2A> pour stocker les caractères obtenus, appelez le <xref:System.Text.UTF8Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException> exception. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Si la plage d’octets à décoder inclut la marque d’ordre d’octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-BOM, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode. Vous pouvez le supprimer en appelant le <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, utilisez le <xref:System.Text.Decoder> ou le <xref:System.Text.Encoder> objet fourni par le <xref:System.Text.UTF8Encoding.GetDecoder%2A> méthode ou le <xref:System.Text.UTF8Encoding.GetEncoder%2A> (méthode), respectivement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="chars" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> ou <paramref name="charCount" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.  
  
ou 
 <paramref name="charCount" /> est inférieur au nombre de caractères obtenus.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="byteIndex">Index du premier octet à décoder.</param>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <param name="chars">Tableau de caractères destiné à contenir le jeu de caractères obtenu.</param>
        <param name="charIndex">Index auquel commencer l'écriture du jeu de caractères obtenu.</param>
        <summary>Décode une séquence d'octets du tableau d'octets spécifié dans le tableau de caractères spécifié.</summary>
        <returns>Nombre réel de caractères écrits dans <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF8Encoding.GetChars%2A> pour stocker les caractères obtenus, appelez le <xref:System.Text.UTF8Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException> exception. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Si la plage d’octets à décoder inclut la marque d’ordre d’octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-BOM, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode. Vous pouvez le supprimer en appelant le <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, utilisez le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UTF8Encoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UTF8Encoding.GetEncoder%2A> (méthode), respectivement.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Text.UTF8Encoding.GetChars%2A> méthode à décoder une plage d’éléments dans un tableau d’octets et stocker le résultat dans un tableau de caractères.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="chars" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" />, <paramref name="byteCount" /> ou <paramref name="charIndex" /> est inférieur à zéro.  
  
ou 
 <paramref name="byteindex" /> et <paramref name="byteCount" /> ne désignent pas une plage valide dans <paramref name="bytes" />.  
  
ou 
 <paramref name="charIndex" /> n'est pas un index valide dans <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.  
  
ou 
 <paramref name="chars" /> ne possède pas une capacité suffisante entre <paramref name="charIndex" /> et la fin du tableau pour prendre en charge les caractères obtenus.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF8Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un décodeur qui convertit une séquence d'octets encodée en UTF-8 en une séquence de caractères Unicode.</summary>
        <returns>Décodeur qui convertit une séquence d'octets encodée en UTF-8 en une séquence de caractères Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> méthode convertit des blocs d’octets séquentiels en blocs de caractères, d’une manière similaire à la <xref:System.Text.UTF8Encoding.GetChars%2A> méthode de cette classe. Toutefois, un <xref:System.Text.Decoder> conserve les informations d’état entre les appels, de sorte qu’il peut décoder correctement les séquences d’octets qui s’étendent sur des blocs. Le <xref:System.Text.Decoder> également conserve les octets de fin à la fin des blocs de données et utilise les octets de fin dans la prochaine opération de décodage. Par conséquent, <xref:System.Text.UTF8Encoding.GetDecoder%2A> et <xref:System.Text.UTF8Encoding.GetEncoder%2A> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.  
  
 Si la détection d’erreurs est activée, autrement dit, si le `throwOnInvalidCharacters` paramètre du constructeur est défini sur `true`, détection d’erreurs est également activée dans le <xref:System.Text.Decoder> retourné par cette méthode. Si la détection d’erreurs est activée et une séquence non valide est rencontrée, l’état du décodeur n’est pas défini et le traitement doit s’arrêter.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Text.UTF8Encoding.GetDecoder%2A> méthode pour obtenir un décodeur UTF-8. Le décodeur convertit une séquence d’octets en une séquence de caractères.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CPP/getdecoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CS/getdecoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/VB/getdecoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Encodages de présentation</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF8Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un encodeur qui convertit une séquence de caractères Unicode en une séquence d'octets encodée en UTF-8.</summary>
        <returns>Un <see cref="T:System.Text.Encoder" /> qui convertit une séquence de caractères Unicode en une séquence de caractères UTF-8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> méthode convertit des blocs de caractères séquentiels en blocs d’octets, d’une manière similaire à la <xref:System.Text.UTF8Encoding.GetBytes%2A> (méthode). Toutefois, un <xref:System.Text.Encoder> conserve les informations d’état entre les appels et peut donc encoder correctement les séquences de caractères qui s’étendent sur des blocs. Le <xref:System.Text.Encoder> également conserve fin caractères à la fin des blocs de données et utilise les caractères de fin de la prochaine opération de codage. Par exemple, un bloc de données peut se terminer par un substitut étendu non apparié, et le substitut faible correspondant peut se trouver dans le bloc de données suivant. Par conséquent, <xref:System.Text.UTF8Encoding.GetDecoder%2A> et <xref:System.Text.UTF8Encoding.GetEncoder%2A> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.  
  
 Si la détection d’erreurs est activée, autrement dit, si le `throwOnInvalidCharacters` paramètre du constructeur est défini sur `true`, détection d’erreurs est également activée dans le <xref:System.Text.Encoder> retourné par cette méthode. Si la détection d’erreurs est activée et une séquence non valide est rencontrée, l’état de l’encodeur n’est pas défini et le traitement doit s’arrêter.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Text.UTF8Encoding.GetEncoder%2A> séquence d’octets encodée en méthode pour obtenir un encodeur pour convertir une séquence de caractères UTF-8.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CPP/getencoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CS/getencoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/VB/getencoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Encodages de présentation</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF8Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage pour l'instance actuelle.</summary>
        <returns>Code de hachage de l'instance actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise le <xref:System.Text.UTF8Encoding.GetHashCode%2A> méthode pour retourner un code de hachage pour <xref:System.Text.UTF8Encoding> instances. Notez que le code de hachage retourné par cette méthode varie selon le constructeur utilisé pour créer le <xref:System.Text.UTF8Encoding> objet.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CPP/gethashcode-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CS/gethashcode-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/VB/gethashcode-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF8Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <summary>Calcule le nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</summary>
        <returns>Nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF8Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF8Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> est un nombre le plus défavorable, y compris le pire des cas pour actuellement sélectionné <xref:System.Text.EncoderFallback>. Si une procédure de secours est choisi avec une chaîne potentiellement grande, <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> peut retourner des valeurs élevées.  
  
 Dans la plupart des cas, cette méthode retourne un nombre raisonnable pour les petites chaînes. Pour les chaînes de grande taille, vous devrez peut-être choisir entre l’utilisation de mémoires tampons de grande et interception des erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est dépassée. Vous pourriez également envisager une approche différente à l’aide <xref:System.Text.UTF8Encoding.GetByteCount%2A> ou <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>. Par exemple, du texte en anglais et de nombreux autres langages doit souvent qu’un seul octet UTF-8 pour représenter un caractère, mais le nombre retourné par <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> doit tenir compte du fait que la chaîne à convertir se compose uniquement de caractères que que chaque nécessitent quatre octets.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> n’a aucun lien avec <xref:System.Text.UTF8Encoding.GetChars%2A>. Si votre application a besoin d’une fonction similaire à utiliser avec <xref:System.Text.UTF8Encoding.GetChars%2A>, il doit utiliser <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` n’est pas nécessairement la même valeur que `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> méthode pour retourner le nombre maximal d’octets nécessaires au codage d’un nombre spécifié de caractères.  
  
 [!code-cpp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> est inférieur à zéro.  
  
ou 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF8Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <summary>Calcule le nombre maximal de caractères produits par le décodage du nombre d'octets spécifié.</summary>
        <returns>Nombre maximal de caractères produits par le décodage du nombre d'octets spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF8Encoding.GetChars%2A> pour stocker les caractères obtenus, vous appelez le <xref:System.Text.UTF8Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.UTF8Encoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> est un nombre le plus défavorable, y compris le pire des cas pour actuellement sélectionné <xref:System.Text.DecoderFallback>. Si une procédure de secours est choisi avec une chaîne potentiellement grande, <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> peut retourner des valeurs élevées.  
  
 Dans la plupart des cas, cette méthode retourne un nombre raisonnable pour les petites chaînes. Pour les chaînes de grande taille, vous devrez peut-être choisir entre l’utilisation de mémoires tampons de grande et interception des erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est dépassée.  Vous pourriez également envisager une approche différente à l’aide <xref:System.Text.UTF8Encoding.GetCharCount%2A> ou <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> n’a aucun lien avec <xref:System.Text.UTF8Encoding.GetBytes%2A>. Si votre application a besoin d’une fonction similaire à utiliser avec <xref:System.Text.UTF8Encoding.GetBytes%2A>, il doit utiliser <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` n’est pas nécessairement la même valeur que `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> méthode pour retourner le nombre maximal de caractères produits par le décodage d’un nombre spécifié d’octets.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> est inférieur à zéro.  
  
ou 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF8Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une marque d'ordre d'octet Unicode au format UTF-8, si l'objet de codage <see cref="T:System.Text.UTF8Encoding" /> est configuré pour en fournir une.</summary>
        <returns>Tableau d'octets contenant la marque d'ordre d'octet Unicode, si l'objet de codage <see cref="T:System.Text.UTF8Encoding" /> est configuré pour en fournir une. Sinon, cette méthode retourne un tableau d'octets de longueur égale à zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.UTF8Encoding> objet peut fournir un préambule, c'est-à-dire un tableau d’octets qui peut porter comme préfixe à la séquence d’octets résultant du processus d’encodage. En le faisant précéder une séquence d’octets encodées avec une marque d’ordre d’octet (point de code U + FEFF) aide le décodeur à déterminer l’ordre d’octet et le format de transformation ou UTF. La marque d’ordre octet Unicode (BOM) est sérialisée en tant que 0xEF 0xBB 0xBF. Notez que la norme Unicode, aucune ne requiert ni ne recommande l’utilisation d’une nomenclature du codage UTF-8 encodés de flux de données.  
  
 Vous pouvez instancier un <xref:System.Text.UTF8Encoding> de l’objet dont la propriété <xref:System.Text.UTF8Encoding.GetPreamble%2A> méthode retourne une nomenclature valide comme suit :  
  
-   En récupérant le <xref:System.Text.UTF8Encoding> objet retourné par la <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> propriété.  
  
-   En appelant un <xref:System.Text.UTF8Encoding> constructeur avec un `encoderShouldEmitUTF8Identifier` paramètre et en définissant sa valeur est définie sur `true`.  
  
 Tous les autres <xref:System.Text.UTF8Encoding> objets sont configurés pour retourner un tableau vide, et non une marque BOM est valid.  
  
 La nomenclature fournissent certaine identification d’un encodage pour les fichiers qui ont perdu une référence à leur codage, telles que web sans balise ou incorrectement référencée données ou des fichiers texte aléatoires stockés lorsqu’une entreprise ne disposait pas des préoccupations internationale. Souvent les problèmes d’utilisateur peuvent être évités si les données sont balisées de façon cohérente et correctement.  
  
 Des normes qui fournissent un type de codage, un BOM est quelque peu redondant. Toutefois, il peut être utilisé pour aider à un serveur d’envoyer l’en-tête de codage correct. Ou bien, il peut être utilisé comme solution de secours si l’encodage est perdu.  
  
 Il existe certains inconvénients à l’utilisation d’une nomenclature. Par exemple, savoir comment limiter les champs de base de données qui utilisent un BOM peut être difficile. Concaténation de fichiers peut être un problème également, par exemple, lorsque les fichiers sont fusionnés de telle façon un caractère inutile peut se retrouver au milieu des données. Malgré le peu d’inconvénients, cependant, l’utilisation d’une nomenclature est hautement recommandée.  
  
 Pour plus d’informations sur l’ordre d’octet et la marque d’ordre d’octet, consultez la norme Unicode dans le [page d’accueil Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!IMPORTANT]
>  Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez faire précéder le début d’un flux d’octets encodés avec un préambule. Notez que le <xref:System.Text.UTF8Encoding.GetBytes%2A> méthode ne doit pas une nomenclature à une séquence d’octets encodés ; en fournissant une nomenclature au début d’un flux d’octets approprié est la responsabilité du développeur.
  
## Examples  
 L’exemple suivant utilise le <xref:System.Text.UTF8Encoding.GetPreamble%2A> encodé au format UTF-8 de marque d’ordre de méthode pour retourner l’octet Unicode. Notez que le constructeur par défaut <xref:System.Text.UTF8Encoding> ne fournit pas de préambule.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 L’exemple suivant instancie deux <xref:System.Text.UTF8Encoding> objets, la première en appelant sans paramètre <xref:System.Text.UTF8Encoding.%23ctor> constructeur qui ne fournit pas d’une nomenclature et le second en appelant le <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29> constructeur avec son `encoderShouldEmitUTF8Identifier` affectée à l’argument `true`. Il appelle ensuite la <xref:System.Text.UTF8Encoding.GetPreamble%2A> méthode pour écrire la marque BOM dans un fichier avant d’écrire une chaîne encodée UF8. Comme le montre la sortie de l’exemple de console, le fichier qui enregistre les octets à partir de la deuxième encodeur comporte trois davantage d’octets que la première.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/cs/getpreamble1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/vb/getpreamble1.vb#1)]  
  
 Vous pouvez également comparer les fichiers à l’aide de la `fc` commande dans une fenêtre de console, ou vous pouvez inspecter les fichiers dans un éditeur de texte qui inclut un mode d’affichage de format hexadécimal. Notez que lorsque le fichier est ouvert dans un éditeur qui prend en charge UTF-8, la marque BOM n’est pas affiché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF8Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="index">Index du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>Décode une plage d'octets d'un tableau d'octets en une chaîne.</summary>
        <returns><see cref="T:System.String" /> contenant les résultats du décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException> exception. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Si la plage d’octets à décoder inclut la marque d’ordre d’octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-BOM, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode. Vous pouvez le supprimer en appelant le <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, utilisez le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UTF8Encoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UTF8Encoding.GetEncoder%2A> (méthode), respectivement.  
  
   
  
## Examples  
 L’exemple suivant initialise un tableau en appelant le <xref:System.Text.UTF8Encoding.GetByteCount%2A> méthode pour déterminer exactement combien d’octets est nécessaires pour une chaîne encodée, puis en ajoutant la taille de la marque d’ordre d’octet (BOM). L’exemple appelle ensuite la <xref:System.Text.UTF8Encoding.GetPreamble%2A> méthode pour stocker la nomenclature dans le tableau avant d’appeler le <xref:System.Text.UTF8Encoding.GetBytes%2A> méthode pour stocker les octets encodés dans le tableau. L’exemple appelle ensuite la <xref:System.Text.UTF8Encoding.GetString%2A> méthode à décoder la chaîne.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Notez que dans ce cas la chaîne décodée diffère de la chaîne d’origine, dans la mesure où il commence par une marque d’ordre d’octet de 16 bits U + FFFD. Cela signifie que les deux chaînes sont considérés comme égaux, et que si la chaîne est sortie, la nomenclature s’affichera en tant que le caractère de remplacement « ? ». Pour supprimer la marque BOM au début de la chaîne, vous pouvez appeler la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
ou 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>
