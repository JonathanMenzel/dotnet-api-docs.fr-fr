<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="UTF8Encoding.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c200a67bc75e1bfe3c6bbe71ec68fec34b1455fc.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c200a67bc75e1bfe3c6bbe71ec68fec34b1455fc</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Represents a UTF-8 encoding of Unicode characters.</source>
          <target state="translated">Représente un encodage UTF-8 de caractères Unicode.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</source>
          <target state="translated">L'encodage est le processus de transformation d'un jeu de caractères Unicode en une séquence d'octets.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</source>
          <target state="translated">Le décodage est le processus de transformation d’une séquence d’octets codés en un jeu de caractères Unicode.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>UTF-8 is a Unicode encoding that represents each code point as a sequence of one to four bytes.</source>
          <target state="translated">UTF-8 est le codage Unicode représente chaque point de code sous la forme d’une séquence d’un à quatre octets.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Unlike the UTF-16 and UTF-32 encodings, the UTF-8 encoding does not require "endianness"; the encoding scheme is the same regardless of whether the processor is big-endian or little-endian.</source>
          <target state="translated">Contrairement aux encodages UTF-16 et UTF-32, l’encodage UTF-8 ne pas obliger « endianness » ; le schéma d’encodage est le même que le processeur soit big-endian ou little-endian.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> corresponds to the Windows code page 65001.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> correspond à la page de codes 65001 de Windows.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>For more information about the UTFs and other encodings supported by <ph id="ph1">&lt;xref:System.Text&gt;</ph>, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les formats UTF et d’autres encodages pris en charge par <ph id="ph1">&lt;xref:System.Text&gt;</ph>, consultez <bpt id="p1">[</bpt>l’encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM) and whether you want to enable error detection.</source>
          <target state="translated">Vous pouvez instancier un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet dans un nombre de façons, selon si vous souhaitez lui pour fournir une marque d’ordre octet (BOM) et si vous souhaitez activer la détection d’erreur.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The following table lists the constructors and the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> property that return a <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object.</source>
          <target state="translated">Le tableau suivant répertorie les constructeurs et les <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> propriétés qui retournent un <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Member</source>
          <target state="translated">Membre</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>BOM</source>
          <target state="translated">BOM</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Error detection</source>
          <target state="translated">Détection d’erreurs</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Yes</source>
          <target state="translated">Oui</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Aucun (stratégie de secours)</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>No</source>
          <target state="translated">Non</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Aucun (stratégie de secours)</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Configurable</source>
          <target state="translated">Configurable</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Aucun (stratégie de secours)</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Configurable</source>
          <target state="translated">Configurable</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Configurable</source>
          <target state="translated">Configurable</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> méthode exécute l’encodage réel.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Likewise, the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetString%2A&gt;</ph> methods perform the actual decoding.</source>
          <target state="translated">De même, la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> et <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetString%2A&gt;</ph> les méthodes effectuent le décodage réel.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> properties, respectively.</source>
          <target state="translated">Pour un encodeur ou un décodeur capable d’enregistrer les informations d’état lors de l’encodage ou de décodage des données qui s’étend sur plusieurs blocs (par exemple, la chaîne de 1 million de caractères est encodé dans les segments de 100 000 caractères), utilisez la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> propriétés, respectivement.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Optionally, the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the beginning of the byte stream that results from the encoding process.</source>
          <target state="translated">Si vous le souhaitez, le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet fournit une marque d’ordre octet (BOM), qui est un tableau d’octets qui peut être préfixé au début du flux d’octets qui résulte du processus de codage.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>If a UTF-8 encoded byte stream is prefaced with a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF.</source>
          <target state="translated">Si un flux d’octets codée en UTF-8 est précédé d’une marque d’ordre octet (BOM), il aide le décodeur à déterminer l’ordre d’octet et que le format de transformation ou UTF.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Note, however, that the Unicode Standard neither requires nor recommends a BOM in UTF-8 encoded streams.</source>
          <target state="translated">Toutefois, notez que la norme Unicode ne requiert ni recommande un marque BOM UTF-8 codé flux.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’ordre d’octet et la marque d’ordre, consultez la norme Unicode sur le <bpt id="p1">[</bpt>page d’accueil Unicode<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>If the encoder is configured to provide a BOM, you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method; otherwise, the method returns an empty array.</source>
          <target state="translated">Si l’encodeur est configuré pour fournir une nomenclature, vous pouvez le récupérer en appelant le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> méthode ; sinon, la méthode retourne un tableau vide.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Note that, even if a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> class do not do this automatically.</source>
          <target state="translated">Notez que, même si un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet est configuré pour prendre en charge de la nomenclature, vous devez inclure la nomenclature au début du flux d’octets encodés selon le cas, les méthodes de codage de la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> classe ne le faites pas automatiquement.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>To enable error detection and to make the class instance more secure, you should call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and set the <ph id="ph2">`throwOnInvalidBytes`</ph> parameter to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Pour activer la détection d’erreur et la sécurisation de l’instance de classe, vous devez appeler la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29&gt;</ph> constructeur et définissez la <ph id="ph2">`throwOnInvalidBytes`</ph> paramètre <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>With error detection enabled, a method that detects an invalid sequence of characters or bytes throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Avec la détection d’erreurs, une méthode qui détecte une séquence non valide de caractères ou d’octets lève une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Without error detection, no exception is thrown, and the invalid sequence is generally ignored.</source>
          <target state="translated">Sans détection d’erreurs, aucune exception n’est levée, et la séquence non valide est généralement ignorée.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The state of a UTF-8 encoded object is not preserved if the object is serialized and deserialized using different .NET Framework versions.</source>
          <target state="translated">L’état d’un objet encodé en UTF-8 n’est pas conservé si l’objet est sérialisé et désérialisé à l’aide de différentes versions du .NET Framework.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The following example uses a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object to encode a string of Unicode characters and store them in a byte array.</source>
          <target state="translated">L’exemple suivant utilise un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet à encoder une chaîne de caractères Unicode et les stocker dans un tableau d’octets.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The Unicode string includes two characters, Pi (U+03A0) and Sigma (U+03A3), that are outside the ASCII character range.</source>
          <target state="translated">La chaîne Unicode comprend deux caractères, Pi (U + 03A0) et Sigma (U + 03A3), qui sont en dehors de la plage de caractères ASCII.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>When the encoded byte array is decoded back to a string, the Pi and Sigma characters are still present.</source>
          <target state="translated">Lorsque le tableau d’octets encodé est décodé en chaîne, les caractères Pi et Sigma sont toujours présentes.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The following example uses the same string as the previous example, except that it writes the encoded bytes to a file and prefixes the byte stream with a byte order mark (BOM).</source>
          <target state="translated">L’exemple suivant utilise la même chaîne que l’exemple précédent, sauf qu’il écrit les octets encodés dans un fichier et les préfixes des flux d’octets avec une marque d’ordre octet (BOM).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>It then reads the file in two different ways: as a text file by using a <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> object; and as a binary file.</source>
          <target state="translated">Il lit ensuite le fichier de deux manières différentes : en tant qu’un fichier texte à l’aide un <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> de l’objet ; et dans un fichier binaire.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>As you would expect, in neither case is the BOM included in the newly read string.</source>
          <target state="translated">Comme pour tout, en aucun cas la nomenclature figure dans la chaîne qui vient d’être en lecture.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor">
          <source>This constructor creates an instance that does not provide a Unicode byte order mark and does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Ce constructeur crée une instance qui ne fournit pas de marque d’ordre d’octet Unicode et ne lève pas d’exception lorsqu’un encodage non valide est détecté.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor">
          <source>For security reasons, we recommend that you enable error detection by calling a constructor with a <ph id="ph1">`throwOnInvalidBytes`</ph> parameter and setting its value to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Pour des raisons de sécurité, nous vous recommandons d’activer la détection d’erreur en appelant un constructeur avec un <ph id="ph1">`throwOnInvalidBytes`</ph> paramètre et sa valeur <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instance and displays its name.</source>
          <target state="translated">L’exemple suivant crée un nouveau <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> de l’instance et affiche son nom.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that the <ph id="ph2">&lt;see cref="M:System.Text.UTF8Encoding.GetPreamble" /&gt;</ph> method returns a Unicode byte order mark; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour spécifier que la méthode <ph id="ph2">&lt;see cref="M:System.Text.UTF8Encoding.GetPreamble" /&gt;</ph> retourne une marque d'ordre d'octet Unicode ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>A parameter specifies whether to provide a Unicode byte order mark.</source>
          <target state="translated">Un paramètre spécifie si une marque d'ordre d'octet Unicode doit être fournie.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>This constructor creates an instance that does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Ce constructeur crée une instance qui ne lève pas d’exception lorsqu’un encodage non valide est détecté.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>For security reasons, you should enable error detection by calling a constructor that includes a <ph id="ph1">`throwOnInvalidBytes`</ph> parameter and setting its value to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Pour des raisons de sécurité, vous devez activer la détection d’erreur en appelant un constructeur qui inclut un <ph id="ph1">`throwOnInvalidBytes`</ph> paramètre et sa valeur <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>The <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> parameter controls the operation of the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> paramètre contrôle le fonctionnement de la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>If <ph id="ph1">`true`</ph>, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-8 format.</source>
          <target state="translated">Si <ph id="ph1">`true`</ph>, la méthode retourne un tableau d’octets contenant la marque d’ordre d’octet Unicode (BOM) au format UTF-8.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>If <ph id="ph1">`false`</ph>, it returns a zero-length byte array.</source>
          <target state="translated">Si <ph id="ph1">`false`</ph>, elle retourne un tableau d’octets de longueur nulle.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>However, setting <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> to <ph id="ph2">`true`</ph> does not cause the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to prefix the BOM at the beginning of the byte array, nor does it cause the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method to include the number of bytes in the BOM in the byte count.</source>
          <target state="translated">Toutefois, l’affectation <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> à <ph id="ph2">`true`</ph> n’entraîne pas la <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> méthode pour préfixer la nomenclature au début du tableau d’octets, et ne déclenche la <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> méthode pour inclure le nombre d’octets dans la nomenclature dans le nombre d’octets.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instance and specifies that a Unicode byte order mark prefix should be emitted by the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant crée un nouveau <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> de l’instance et spécifie que le préfixe de marque d’un ordre d’octet Unicode doit être émis par le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method then returns the Unicode byte order mark prefix.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> méthode retourne ensuite la marque de préfixe d’ordre d’octet Unicode.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that the <ph id="ph2">&lt;see cref="M:System.Text.UTF8Encoding.GetPreamble" /&gt;</ph> method should return a Unicode byte order mark; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour spécifier que la méthode <ph id="ph2">&lt;see cref="M:System.Text.UTF8Encoding.GetPreamble" /&gt;</ph> doit retourner une marque d'ordre d'octet Unicode ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception when an invalid encoding is detected; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour lever une exception quand un encodage non valide est détecté ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>Parameters specify whether to provide a Unicode byte order mark and whether to throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Les paramètres spécifient s'il faut fournir une marque d'ordre d'octet Unicode et si une exception doit être levée quand un encodage non valide est détecté.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> parameter controls the operation of the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> paramètre contrôle le fonctionnement de la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`true`</ph>, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-8 format.</source>
          <target state="translated">Si <ph id="ph1">`true`</ph>, la méthode retourne un tableau d’octets contenant la marque d’ordre d’octet Unicode (BOM) au format UTF-8.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`false`</ph>, it returns a zero-length byte array.</source>
          <target state="translated">Si <ph id="ph1">`false`</ph>, elle retourne un tableau d’octets de longueur nulle.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>However, setting <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> to <ph id="ph2">`true`</ph> does not cause the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to prefix the BOM at the beginning of the byte array, nor does it cause the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method to include the number of bytes in the BOM in the byte count.</source>
          <target state="translated">Toutefois, l’affectation <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> à <ph id="ph2">`true`</ph> n’entraîne pas la <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> méthode pour préfixer la nomenclature au début du tableau d’octets, et ne déclenche la <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> méthode pour inclure le nombre d’octets dans la nomenclature dans le nombre d’octets.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`throwOnInvalidBytes`</ph> is <ph id="ph2">`true`</ph>, a method that detects an invalid byte sequence throws an <ph id="ph3">&lt;xref:System.ArgumentException?displayProperty=nameWithType&gt;</ph> exception.</source>
          <target state="translated">Si <ph id="ph1">`throwOnInvalidBytes`</ph> est <ph id="ph2">`true`</ph>, une méthode qui détecte une séquence d’octets non valide lève une <ph id="ph3">&lt;xref:System.ArgumentException?displayProperty=nameWithType&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>Otherwise, the method does not throw an exception, and the invalid sequence is ignored.</source>
          <target state="translated">Sinon, la méthode ne lève pas d’exception et la séquence non valide est ignorée.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>For security reasons, you should enable error detection by calling a constructor that includes a <ph id="ph1">`throwOnInvalidBytes`</ph> parameter and setting that parameter to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Pour des raisons de sécurité, vous devez activer la détection d’erreur en appelant un constructeur qui inclut un <ph id="ph1">`throwOnInvalidBytes`</ph> paramètre et en définissant ce paramètre sur <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instance, specifying that the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method should not emit a Unicode byte order mark prefix, and an exception should be thrown when an invalid encoding is detected.</source>
          <target state="translated">L’exemple suivant crée un nouveau <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instance, en spécifiant que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> méthode ne doit émettre un marque de préfixe d’ordre d’octet Unicode, et une exception doit être levée quand un encodage non valide est détecté.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>The behavior of this constructor is compared to the default <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor&gt;</ph> constructor, which does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Le comportement de ce constructeur est comparé à la valeur par défaut <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor&gt;</ph> constructeur, ce qui ne lève pas d’exception lorsqu’un encodage non valide est détecté.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>The two <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instances encode a character array that contains two high surrogates (U+D801 and U+D802) in a row, which is an invalid character sequence; a high surrogate should always be followed by a low surrogate.</source>
          <target state="translated">Les deux <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instances encoder un tableau de caractères qui contient deux substituts haute (U + D801 et U + D802) dans une ligne, qui est une séquence de caractères non valide ; un caractère de substitution étendu doit toujours être suivi par un caractère de substitution faible.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">Objet à comparer à l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Determines whether the specified object is equal to the current <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> object.</source>
          <target state="translated">Détermine si l'objet spécifié est identique à l'objet <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is an instance of <ph id="ph3">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> and is equal to the current object; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est une instance de <ph id="ph3">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> et s'il est égal à l'objet actuel ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Two <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objects are considered equal if all of the following conditions are true:</source>
          <target state="translated">Deux <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objets sont considérés comme égaux si toutes les conditions suivantes sont remplies :</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Both objects provide the byte order mark, or both do not.</source>
          <target state="translated">Les deux objets fournissent la marque d’ordre, ou ne pas.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Both objects use the same encoder fallback.</source>
          <target state="translated">Les deux objets utilisent le même encodeur de secours.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Both objects use the same decoder fallback.</source>
          <target state="translated">Les deux objets utilisent le même décodeur de secours.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.Equals%2A&gt;</ph> method to test whether the current <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object is equal to a different <ph id="ph3">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.Equals%2A&gt;</ph> méthode pour tester si actuel <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet est égal à un autre <ph id="ph3">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Four <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objects are created and compared and the results of the comparisons are displayed.</source>
          <target state="translated">Quatre <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objets sont créés et comparées et les résultats des comparaisons sont affichés.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Calculates the number of bytes produced by encoding a set of characters.</source>
          <target state="translated">Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the set of characters to encode.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> contenant le jeu de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>Calculates the number of bytes produced by encoding the characters in the specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Calcule le nombre d'octets générés en encodant les caractères dans le <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">Nombre d'octets produits par l'encodage des caractères spécifiés.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> pour stocker les octets obtenus, vous appelez le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, vous appelez le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> méthode alloue généralement moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Avec la détection d’erreur, une séquence non valide provoque la levée de cette méthode une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sans la détection d’erreurs, les séquences non valides sont ignorées et aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Insérer le préambule au début d’un flux d’octets (comme au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflétée dans la valeur retournée par le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29&gt;</ph> methods to calculate the maximum and actual number of bytes required to encode a string.</source>
          <target state="translated">L’exemple suivant appelle la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29&gt;</ph> méthodes pour calculer le nombre maximal et réel d’octets requis pour encoder une chaîne.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>It also displays the actual number of bytes required to store a byte stream with a byte order mark.</source>
          <target state="translated">Il affiche également le nombre réel d’octets requis pour stocker un flux d’octets avec une marque d’ordre d’octet.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">La détection d’erreurs est activée et <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contient une séquence de caractères non valide.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Pointeur du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</source>
          <target state="translated">Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères commençant au pointeur de caractère spécifié.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">Nombre d'octets produits par l'encodage des caractères spécifiés.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the exact array size required by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> méthode pour stocker les octets obtenus, vous appelez le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, vous appelez le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> méthode alloue généralement moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Avec la détection d’erreur, une séquence non valide provoque la levée de cette méthode une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sans la détection d’erreurs, les séquences non valides sont ignorées et aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Insérer le préambule au début d’un flux d’octets (comme au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflétée dans la valeur retournée par le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">La détection d’erreurs est activée et <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contient une séquence de caractères non valide.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for a complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">Tableau de caractères contenant le jeu de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Index du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Calculates the number of bytes produced by encoding a set of characters from the specified character array.</source>
          <target state="translated">Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères du tableau de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">Nombre d'octets produits par l'encodage des caractères spécifiés.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the uses <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> pour stocker les octets obtenus, vous appelez les utilisations <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, vous appelez le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> méthode alloue généralement moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Avec la détection d’erreur, une séquence non valide provoque la levée de cette méthode une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sans la détection d’erreurs, les séquences non valides sont ignorées et aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Insérer le préambule au début d’un flux d’octets (comme au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflétée dans la valeur retournée par le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The following example populates an array with a Latin uppercase and lowercase characters and calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method to determine the number of bytes needed to encode the Latin lowercase characters.</source>
          <target state="translated">L’exemple suivant remplit un tableau avec un Latin en majuscules et minuscules et appelle le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> méthode pour déterminer le nombre d’octets requis pour encoder les caractères latins.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It then displays this information along with the total number of bytes needed if a byte order mark is added.</source>
          <target state="translated">Il affiche ensuite ces informations ainsi que le nombre total d’octets nécessaires si une marque d’ordre d’octet est ajoutée.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It compares this number with the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method, which indicates maximum number of bytes needed to encode the Latin lowercase characters.</source>
          <target state="translated">Il compare ce numéro avec la valeur retournée par le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> (méthode), ce qui indique le nombre maximal d’octets nécessaires pour coder les caractères latins.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">La détection d’erreurs est activée et <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contient une séquence de caractères non valide.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> property is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">La propriété <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Encodes a set of characters into a sequence of bytes.</source>
          <target state="translated">Encode un jeu de caractères en une séquence d'octets.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Pointeur du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Pointeur de l'emplacement où commencer l'écriture de la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Nombre maximal d'octets à écrire.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</source>
          <target state="translated">Code une séquence de caractères commençant au pointeur de caractère spécifié en une séquence d'octets, qui sera stockée à partir du pointeur d'octet spécifié.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The actual number of bytes written at the location indicated by <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">Nombre réel d'octets écrits à l'emplacement indiqué par <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> pour stocker les octets obtenus, vous appelez le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, vous appelez le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> méthode alloue généralement moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Avec la détection d’erreur, une séquence non valide provoque la levée de cette méthode une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sans la détection d’erreurs, les séquences non valides sont ignorées et aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Données à convertir, telles que les données lues à partir d’un flux de données peuvent être disponibles uniquement dans les blocs séquentiels.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> returned by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, utilisez le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou le <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> retournée par le <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> (méthode) ou <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Insérer le préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> méthode n’ajoutez pas un préambule au début d’une séquence d’octets encodées.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">La détection d’erreurs est activée et <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contient une séquence de caractères non valide.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than the resulting number of bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> est inférieur au nombre d'octets obtenus.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">Tableau de caractères contenant le jeu de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Index du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Index auquel commencer l'écriture de la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Encodes a set of characters from the specified character array into the specified byte array.</source>
          <target state="translated">Encode un jeu de caractères du tableau de caractères spécifié en un tableau d'octets.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">Nombre réel d'octets écrits dans <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> pour stocker les octets obtenus, vous appelez le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, vous appelez le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> méthode alloue généralement moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Avec la détection d’erreur, une séquence non valide provoque la levée de cette méthode une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sans la détection d’erreurs, les séquences non valides sont ignorées et aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Données à convertir, telles que les données lues à partir d’un flux de données peuvent être disponibles uniquement dans les blocs séquentiels.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, utilisez le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou le <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> (méthode) ou <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Insérer le préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> méthode n’ajoutez pas un préambule au début d’une séquence d’octets encodées.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to encode a range of characters from a string and stores the encoded bytes in a range of elements in a byte array.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> méthode pour encoder une plage de caractères à partir d’une chaîne et stocke les octets encodés dans une plage d’éléments dans un tableau d’octets.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> n'est pas un index valide dans <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">La détection d’erreurs est activée et <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contient une séquence de caractères non valide.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ne possède pas une capacité suffisante entre <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> et la fin du tableau pour prendre en charge les octets obtenus.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the set of characters to encode.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> contenant le jeu de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Index du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Index auquel commencer l'écriture de la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Encodes a set of characters from the specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into the specified byte array.</source>
          <target state="translated">Encode un jeu de caractères de la chaîne <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> spécifiée dans le tableau d'octets indiqué.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">Nombre réel d'octets écrits dans <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> pour stocker les octets obtenus, vous appelez le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, vous appelez le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> méthode alloue généralement moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Avec la détection d’erreur, une séquence non valide provoque la levée de cette méthode une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sans la détection d’erreurs, les séquences non valides sont ignorées et aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Données à convertir, telles que les données lues à partir d’un flux de données peuvent être disponibles uniquement dans les blocs séquentiels.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, utilisez le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou le <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> (méthode) ou <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Insérer le préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> méthode n’ajoutez pas un préambule au début d’une séquence d’octets encodées.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to encode a range of elements from a Unicode character array and store the encoded bytes in a range of elements in a byte array.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> pour encoder une plage d’éléments à partir d’un tableau de caractères Unicode et stocker les octets encodés dans une plage d’éléments dans un tableau d’octets.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> n'est pas un index valide dans <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="s" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">La détection d’erreurs est activée et <ph id="ph1">&lt;paramref name="s" /&gt;</ph> contient une séquence de caractères non valide.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ne possède pas une capacité suffisante entre <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> et la fin du tableau pour prendre en charge les octets obtenus.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Calculates the number of characters produced by decoding a sequence of bytes.</source>
          <target state="translated">Calcule le nombre de caractères produits par le décodage d'une séquence d'octets.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Pointeur du premier octet à décoder.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</source>
          <target state="translated">Calcule le nombre de caractères produits par le décodage d'une séquence d'octets commençant au pointeur d'octet spécifié.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> pour stocker les caractères obtenus, appelez le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau maximale, appelez le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> méthode alloue généralement moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Avec la détection d’erreur, une séquence non valide provoque la levée de cette méthode une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sans la détection d’erreurs, les séquences non valides sont ignorées et aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">La détection d’erreurs est activée et <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contient une séquence d’octets non valide.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Tableau d'octets contenant la séquence d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Index du premier octet à décoder.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</source>
          <target state="translated">Calcule le nombre de caractères produits par le décodage d'une séquence d'octets du tableau d'octets spécifié.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> pour stocker les caractères obtenus, appelez le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau maximale, appelez le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> méthode alloue généralement moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Avec la détection d’erreur, une séquence non valide provoque la levée de cette méthode une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sans la détection d’erreurs, les séquences non valides sont ignorées et aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method to return the number of characters produced by decoding a range of elements in a byte array.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> méthode pour retourner le nombre de caractères produits par le décodage d’une plage d’éléments dans un tableau d’octets.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">La détection d’erreurs est activée et <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contient une séquence d’octets non valide.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Decodes a sequence of bytes into a set of characters.</source>
          <target state="translated">Décode une séquence d'octets en un jeu de caractères.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Pointeur du premier octet à décoder.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting set of characters.</source>
          <target state="translated">Pointeur de l'emplacement où commencer l'écriture du jeu de caractères obtenu.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The maximum number of characters to write.</source>
          <target state="translated">Nombre maximal de caractères à écrire.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</source>
          <target state="translated">Décode une séquence d'octets commençant au pointeur d'octet spécifié en un jeu de caractères qui sera stocké à partir du pointeur de caractère spécifié.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The actual number of characters written at the location indicated by <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated">Nombre réel de caractères écrits à l'emplacement indiqué par <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> pour stocker les caractères obtenus, appelez le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau maximale, appelez le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> méthode alloue généralement moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Avec la détection d’erreur, une séquence non valide provoque la levée de cette méthode une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sans la détection d’erreurs, les séquences non valides sont ignorées et aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Si la plage d’octets à décoder inclut la marque d’ordre octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-nomenclature, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez le supprimer en appelant le <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Données à convertir, telles que les données lues à partir d’un flux de données peuvent être disponibles uniquement dans les blocs séquentiels.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, utilisez le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou le <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet fourni par le <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> (méthode) ou <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">La détection d’erreurs est activée et <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contient une séquence d’octets non valide.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than the resulting number of characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> est inférieur au nombre de caractères obtenus.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Tableau d'octets contenant la séquence d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Index du premier octet à décoder.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The character array to contain the resulting set of characters.</source>
          <target state="translated">Tableau de caractères destiné à contenir le jeu de caractères obtenu.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index at which to start writing the resulting set of characters.</source>
          <target state="translated">Index auquel commencer l'écriture du jeu de caractères obtenu.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Decodes a sequence of bytes from the specified byte array into the specified character array.</source>
          <target state="translated">Décode une séquence d'octets du tableau d'octets spécifié dans le tableau de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The actual number of characters written into <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated">Nombre réel de caractères écrits dans <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> pour stocker les caractères obtenus, appelez le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau maximale, appelez le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> méthode alloue généralement moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Avec la détection d’erreur, une séquence non valide provoque la levée de cette méthode une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sans la détection d’erreurs, les séquences non valides sont ignorées et aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Si la plage d’octets à décoder inclut la marque d’ordre octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-nomenclature, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez le supprimer en appelant le <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Données à convertir, telles que les données lues à partir d’un flux de données peuvent être disponibles uniquement dans les blocs séquentiels.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, utilisez le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou le <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> (méthode) ou <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> method to decode a range of elements in a byte array and store the result in a character array.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> pour décoder une plage d’éléments dans un tableau d’octets et stocker le résultat dans un tableau de caractères.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> n'est pas un index valide dans <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">La détection d’erreurs est activée et <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contient une séquence d’octets non valide.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> to the end of the array to accommodate the resulting characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> ne possède pas une capacité suffisante entre <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> et la fin du tableau pour prendre en charge les caractères obtenus.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>Obtains a decoder that converts a UTF-8 encoded sequence of bytes into a sequence of Unicode characters.</source>
          <target state="translated">Obtient un décodeur qui convertit une séquence d'octets encodée en UTF-8 en une séquence de caractères Unicode.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>A decoder that converts a UTF-8 encoded sequence of bytes into a sequence of Unicode characters.</source>
          <target state="translated">Décodeur qui convertit une séquence d'octets encodée en UTF-8 en une séquence de caractères Unicode.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> method of this class.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> méthode convertit des blocs d’octets en blocs séquentiels de caractères, d’une manière similaire à la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> méthode de cette classe.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> maintains state information between calls so it can correctly decode byte sequences that span blocks.</source>
          <target state="translated">Toutefois, un <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> conserve les informations d’état entre les appels, de sorte qu’il peut décoder correctement les séquences d’octets qui s’étendent sur des blocs.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> également conserve les octets de fin à la fin des blocs de données et les octets de fin dans la prochaine opération de décodage.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Par conséquent, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>If error detection is enabled, that is, the <ph id="ph1">`throwOnInvalidCharacters`</ph> parameter of the constructor is set to <ph id="ph2">`true`</ph>, error detection is also enabled in the <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> returned by this method.</source>
          <target state="translated">Si la détection d’erreurs est activée, autrement dit, si le <ph id="ph1">`throwOnInvalidCharacters`</ph> paramètre du constructeur est défini sur <ph id="ph2">`true`</ph>, détection d’erreurs est également activée dans le <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> retourné par cette méthode.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.</source>
          <target state="translated">Si la détection d’erreurs est activée et une séquence non valide est rencontrée, l’état du décodeur est indéfini et le traitement doit s’arrêter.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method to obtain a UTF-8 decoder.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> méthode pour obtenir un décodeur UTF-8.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>The decoder converts a sequence of bytes into a sequence of characters.</source>
          <target state="translated">Le décodeur convertit une séquence d’octets en une séquence de caractères.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>Obtains an encoder that converts a sequence of Unicode characters into a UTF-8 encoded sequence of bytes.</source>
          <target state="translated">Obtient un encodeur qui convertit une séquence de caractères Unicode en une séquence d'octets encodée en UTF-8.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> that converts a sequence of Unicode characters into a UTF-8 encoded sequence of bytes.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> qui convertit une séquence de caractères Unicode en une séquence de caractères UTF-8.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> méthode convertit des blocs de caractères en blocs séquentiels d’octets, d’une manière similaire à la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> maintains state information between calls so it can correctly encode character sequences that span blocks.</source>
          <target state="translated">Toutefois, un <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> conserve les informations d’état entre les appels et peut donc encoder correctement les séquences de caractères qui s’étendent sur des blocs.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> également conserve à la fin des caractères à la fin des blocs de données et utilise les caractères de fin dans la prochaine opération de codage.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</source>
          <target state="translated">Par exemple, un bloc de données peut se terminer par un substitut étendu non apparié, et le substitut faible correspondant peut être dans le bloc de données suivant.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Par conséquent, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>If error detection is enabled, that is, the <ph id="ph1">`throwOnInvalidCharacters`</ph> parameter of the constructor is set to <ph id="ph2">`true`</ph>, error detection is also enabled in the <ph id="ph3">&lt;xref:System.Text.Encoder&gt;</ph> returned by this method.</source>
          <target state="translated">Si la détection d’erreurs est activée, autrement dit, si le <ph id="ph1">`throwOnInvalidCharacters`</ph> paramètre du constructeur est défini sur <ph id="ph2">`true`</ph>, détection d’erreurs est également activée dans le <ph id="ph3">&lt;xref:System.Text.Encoder&gt;</ph> retourné par cette méthode.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.</source>
          <target state="translated">Si la détection d’erreurs est activée et une séquence non valide est rencontrée, l’état de l’encodeur n’est pas défini et le traitement doit s’arrêter.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method to obtain an encoder to convert a sequence of characters into a UTF-8 encoded sequence of bytes.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> séquence d’octets encodée de méthode pour obtenir un encodeur pour convertir une séquence de caractères UTF-8.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetHashCode">
          <source>Returns the hash code for the current instance.</source>
          <target state="translated">Retourne le code de hachage pour l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetHashCode">
          <source>The hash code for the current instance.</source>
          <target state="translated">Code de hachage de l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetHashCode">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetHashCode%2A&gt;</ph> method to return a hash code for <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instances.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetHashCode%2A&gt;</ph> méthode pour retourner un code de hachage pour <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instances.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetHashCode">
          <source>Notice that the hash code returned by this method depends on the constructor used to create the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object.</source>
          <target state="translated">Notez que le code de hachage retourné par cette méthode varie selon le constructeur utilisé pour créer le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>Calculates the maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">Calcule le nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">Nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> pour stocker les octets obtenus, vous appelez le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, vous appelez le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> méthode alloue généralement moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> is a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> est un nombre le plus défavorable, y compris le pire des cas actuellement sélectionné <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> can return large values.</source>
          <target state="translated">Si une stratégie de secours est choisi avec une chaîne potentiellement grande, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> peut retourner des valeurs élevées.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>In most cases, this method returns reasonable numbers for small strings.</source>
          <target state="translated">Dans la plupart des cas, cette méthode retourne un nombre raisonnable pour les petites chaînes.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</source>
          <target state="translated">Pour les chaînes de grande taille, vous devrez choisir entre l’utilisation de mémoires tampons de grande et d’intercepter les erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est dépassée.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vous pouvez également envisager une approche différente à l’aide de <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>For example, text in English and many other languages often needs only one UTF-8 byte to represent a character, but the number returned by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> has to allow for the possibility that the string to be converted will consist entirely of characters that each require four bytes.</source>
          <target state="translated">Par exemple, du texte en anglais et de nombreux autres langages doit souvent qu’un seul octet UTF-8 pour représenter un caractère, mais le nombre retourné par <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> a la possibilité que la chaîne à convertir se compose uniquement de caractères que que chaque nécessite quatre octets.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> n’a aucune relation avec <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>If your application needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph>, it should use <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Si votre application a besoin d’une fonction semblable à utiliser avec <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph>, elle doit utiliser <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">`GetMaxByteCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxByteCount(N)`</ph> n’est pas nécessairement la même valeur que <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method to return the maximum number of bytes required to encode a specified number of characters.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> méthode pour retourner le nombre maximal d’octets nécessaires au codage d’un nombre spécifié de caractères.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>Calculates the maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">Calcule le nombre maximal de caractères produits par le décodage du nombre d'octets spécifié.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">Nombre maximal de caractères produits par le décodage du nombre d'octets spécifié.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> pour stocker les caractères obtenus, vous appelez le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, vous appelez le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> méthode alloue généralement moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> is a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> est un nombre le plus défavorable, y compris le pire des cas actuellement sélectionné <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> can return large values.</source>
          <target state="translated">Si une stratégie de secours est choisi avec une chaîne potentiellement grande, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> peut retourner des valeurs élevées.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>In most cases, this method returns reasonable numbers for small strings.</source>
          <target state="translated">Dans la plupart des cas, cette méthode retourne un nombre raisonnable pour les petites chaînes.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</source>
          <target state="translated">Pour les chaînes de grande taille, vous devrez choisir entre l’utilisation de mémoires tampons de grande et d’intercepter les erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est dépassée.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vous pouvez également envisager une approche différente à l’aide de <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> n’a aucune relation avec <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>If your application needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph>, it should use <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph>.</source>
          <target state="translated">Si votre application a besoin d’une fonction semblable à utiliser avec <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph>, elle doit utiliser <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">`GetMaxCharCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxCharCount(N)`</ph> n’est pas nécessairement la même valeur que <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method to return the maximum number of characters produced by decoding a specified number of bytes.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> méthode pour retourner le nombre maximal de caractères produits par le décodage d’un nombre spécifié d’octets.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Returns a Unicode byte order mark encoded in UTF-8 format, if the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> encoding object is configured to supply one.</source>
          <target state="translated">Retourne une marque d'ordre d'octet Unicode au format UTF-8, si l'objet de codage <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> est configuré pour en fournir une.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>A byte array containing the Unicode byte order mark, if the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> encoding object is configured to supply one.</source>
          <target state="translated">Tableau d'octets contenant la marque d'ordre d'octet Unicode, si l'objet de codage <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> est configuré pour en fournir une.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Otherwise, this method returns a zero-length byte array.</source>
          <target state="translated">Sinon, cette méthode retourne un tableau d'octets de longueur égale à zéro.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object can provide a preamble, which is a byte array that can be prefixed to the sequence of bytes that result from the encoding process.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet peut fournir un préambule, qui est un tableau d’octets qui peut être un préfixe à la séquence d’octets résultant du processus de codage.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Prefacing a sequence of encoded bytes with a byte order mark (code point U+FEFF) helps the decoder determine the byte order and the transformation format, or UTF.</source>
          <target state="translated">En le faisant précéder une séquence d’octets encodées avec une marque d’ordre (point de code U + FEFF) aide le décodeur à déterminer l’ordre d’octet et le format de transformation ou UTF.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The Unicode byte order mark (BOM) is serialized as 0xEF 0xBB 0xBF.</source>
          <target state="translated">La marque d’ordre octet (BOM) Unicode est sérialisée comme 0xEF 0xBB 0xBF.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Note that the Unicode Standard neither requires nor recommends the use of a BOM for UTF-8 encoded streams.</source>
          <target state="translated">Notez que la norme Unicode ni requiert ni ne recommande l’utilisation d’une nomenclature du codage UTF-8 encodés de flux de données.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method returns a valid BOM in the following ways:</source>
          <target state="translated">Vous pouvez instancier un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> dont l’objet <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> méthode retourne une nomenclature valide comme suit :</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>By retrieving the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">En récupérant le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet retourné par la <ph id="ph2">&lt;xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>By calling a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> constructor with a <ph id="ph2">`encoderShouldEmitUTF8Identifier`</ph> parameter and setting its value set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">En appelant un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> constructeur avec un <ph id="ph2">`encoderShouldEmitUTF8Identifier`</ph> paramètre et en définissant sa valeur est définie sur <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>All other <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objects are configured to return an empty array rather than a valid BOM.</source>
          <target state="translated">Tous les autres <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objets sont configurés pour retourner un tableau vide, et non une marque BOM est valide.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The BOM provide nearly certain identification of an encoding for files that otherwise have lost a reference to their encoding, such as untagged or improperly tagged web data or random text files stored when a business did not have international concerns.</source>
          <target state="translated">La nomenclature fournissent certaine identification d’un encodage pour fichiers qui autrement ont perdu une référence à leur codage, telles que web sans balise ou incorrectement référencée données ou des fichiers texte aléatoires stockés lorsqu’une entreprise n’ont pas intérêts internationaux.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Often user problems might be avoided if data is consistently and properly tagged.</source>
          <target state="translated">Souvent des problèmes d’utilisateur peuvent être évités si les données sont balisées de manière cohérente et correctement configurée.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>For standards that provide an encoding type, a BOM is somewhat redundant.</source>
          <target state="translated">Des normes qui fournissent un type de codage, un BOM est quelque peu redondant.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>However, it can be used to help a server send the correct encoding header.</source>
          <target state="translated">Toutefois, il peut être utilisé pour aider un serveur à envoyer l’en-tête de codage correct.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</source>
          <target state="translated">Sinon, il peut être utilisé comme un secours au cas où l’encodage est perdu.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>There are some disadvantages to using a BOM.</source>
          <target state="translated">Il existe certains inconvénients à l’aide d’une nomenclature.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>For example, knowing how to limit the database fields that use a BOM can be difficult.</source>
          <target state="translated">Par exemple, le fait de savoir comment limiter les champs de base de données qui utilisent un BOM peut être difficile.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</source>
          <target state="translated">Concaténation de fichiers peut poser un problème également, par exemple, lors de la fusion des fichiers de telle façon un caractère inutile peut finir au milieu des données.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>In spite of the few disadvantages, however, the use of a BOM is highly recommended.</source>
          <target state="translated">En dépit de quelques inconvénients, toutefois, l’utilisation d’une nomenclature est hautement recommandée.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’ordre d’octet et la marque d’ordre, consultez la norme Unicode sur le <bpt id="p1">[</bpt>page d’accueil Unicode<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix the beginning of a stream of encoded bytes with a preamble.</source>
          <target state="translated">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer le début d’un flux d’octets encodés avec un préambule.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Note that the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.</source>
          <target state="translated">Notez que le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> méthode n’ajoutez pas une nomenclature à une séquence d’octets codés ; en fournissant une nomenclature au début d’un flux d’octets approprié est la responsabilité du développeur.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method to return the Unicode byte order mark encoded in UTF-8 format.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> encodé au format UTF-8 de marque d’ordre d’octet Unicode de retour de méthode.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Notice that the default constructor for <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> does not provide a preamble.</source>
          <target state="translated">Notez que le constructeur par défaut <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> ne fournit pas de préambule.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The following example instantiates two <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objects, the first by calling the parameterless <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.%23ctor&gt;</ph> constructor, which does not provide a BOM, and the second by calling the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29&gt;</ph> constructor with its <ph id="ph4">`encoderShouldEmitUTF8Identifier`</ph> argument set to <ph id="ph5">`true`</ph>.</source>
          <target state="translated">L’exemple suivant instancie deux <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objets, la première en appelant sans paramètre <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.%23ctor&gt;</ph> constructeur qui ne fournit pas d’une nomenclature et le second en appelant le <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29&gt;</ph> constructeur avec son <ph id="ph4">`encoderShouldEmitUTF8Identifier`</ph> affectée à l’argument <ph id="ph5">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method to write the BOM to a file before writing a UF8-encoded string.</source>
          <target state="translated">Il appelle ensuite la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> méthode pour écrire la nomenclature dans un fichier avant d’écrire une chaîne codée au format UF8.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>As the console output from the example shows, the file that saves the bytes from the second encoder has three more bytes than the first.</source>
          <target state="translated">Comme le montre la sortie de l’exemple de console, le fichier qui enregistre les octets à partir de l’encodeur deuxième possède trois octets plus que la première.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>You can also compare the files by using the <ph id="ph1">`fc`</ph> command in a console window, or you can inspect the files in a text editor that includes a Hex View mode.</source>
          <target state="translated">Vous pouvez également comparer les fichiers à l’aide de la <ph id="ph1">`fc`</ph> commande dans une fenêtre de console, ou vous pouvez inspecter les fichiers dans un éditeur de texte qui inclut un mode d’affichage de format hexadécimal.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Note that when the file is opened in an editor that supports UTF-8, the BOM is not displayed.</source>
          <target state="translated">Notez que lorsque le fichier est ouvert dans un éditeur qui prend en charge UTF-8, la nomenclature n’est pas affichée.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Tableau d'octets contenant la séquence d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Index du premier octet à décoder.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Decodes a range of bytes from a byte array into a string.</source>
          <target state="translated">Décode une plage d'octets d'un tableau d'octets en une chaîne.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the results of decoding the specified sequence of bytes.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> contenant les résultats du décodage de la séquence d'octets spécifiée.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Avec la détection d’erreur, une séquence non valide provoque la levée de cette méthode une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sans la détection d’erreurs, les séquences non valides sont ignorées et aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Si la plage d’octets à décoder inclut la marque d’ordre octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-nomenclature, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Vous pouvez le supprimer en appelant le <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Données à convertir, telles que les données lues à partir d’un flux de données peuvent être disponibles uniquement dans les blocs séquentiels.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, utilisez le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou le <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> (méthode) ou <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The following example initializes an array by calling the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method to determine exactly how many bytes are required for an encoded string and then adding the size of the byte order mark (BOM).</source>
          <target state="translated">L’exemple suivant initialise un tableau en appelant le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> méthode pour déterminer exactement combien d’octets est nécessaires pour une chaîne encodée, puis en ajoutant la taille de la marque d’ordre octet (BOM).</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method to store the BOM to the array before calling the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to store the encoded bytes to the array.</source>
          <target state="translated">L’exemple appelle ensuite la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> méthode pour stocker la nomenclature vers le tableau avant d’appeler le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> méthode pour stocker les octets encodés dans le tableau.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetString%2A&gt;</ph> method to decode the string.</source>
          <target state="translated">L’exemple appelle ensuite la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetString%2A&gt;</ph> méthode pour décoder la chaîne.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Note that in this case the decoded string differs from the original string, since it begins with a 16-bit byte order mark U+FFFD.</source>
          <target state="translated">Notez que dans ce cas la chaîne décodée diffère de la chaîne d’origine, car il commence par une marque d’ordre des octets de 16 bits U + FFFD.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>This means that the two strings will compare as unequal, and that if the string is output, the BOM will be displayed as the replacement character "?".</source>
          <target state="translated">Cela signifie que les deux chaînes sont considérés comme égaux, et que si la chaîne est la sortie, la nomenclature s’affichera en tant que le caractère de remplacement « ? ».</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>To remove the BOM at the beginning of the string, you can call the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Pour supprimer la nomenclature au début de la chaîne, vous pouvez appeler la <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">La détection d’erreurs est activée et <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contient une séquence d’octets non valide.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>