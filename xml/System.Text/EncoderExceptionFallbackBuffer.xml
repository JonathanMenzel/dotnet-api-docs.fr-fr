<Type Name="EncoderExceptionFallbackBuffer" FullName="System.Text.EncoderExceptionFallbackBuffer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d4865b8076e25b60fd65b7496258cdedc2538107" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58691484" /></Metadata><TypeSignature Language="C#" Value="public sealed class EncoderExceptionFallbackBuffer : System.Text.EncoderFallbackBuffer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit EncoderExceptionFallbackBuffer extends System.Text.EncoderFallbackBuffer" />
  <TypeSignature Language="DocId" Value="T:System.Text.EncoderExceptionFallbackBuffer" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EncoderExceptionFallbackBuffer&#xA;Inherits EncoderFallbackBuffer" />
  <TypeSignature Language="C++ CLI" Value="public ref class EncoderExceptionFallbackBuffer sealed : System::Text::EncoderFallbackBuffer" />
  <TypeSignature Language="F#" Value="type EncoderExceptionFallbackBuffer = class&#xA;    inherit EncoderFallbackBuffer" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.EncoderFallbackBuffer</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Lève une exception <see cref="T:System.Text.EncoderFallbackException" /> quand un caractère en entrée ne peut pas être converti en sortie en une séquence codée d'octets. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une raison courante pour un encodage ou de décodage opération échec est que si la classe d’encodage sous-jacente ne fournit pas un mappage entre un caractère et une séquence d’octets équivalent. Si le caractère d’entrée ne peut pas être converti en une séquence d’octets de sortie, l’opération d’encodage appelle le <xref:System.Text.EncoderExceptionFallbackBuffer.Fallback%2A> (méthode), qui lève une exception <xref:System.Text.EncoderFallbackException>.  
  
 Le <xref:System.Text.EncoderFallbackBuffer?displayProperty=nameWithType> (classe), qui représente une mémoire tampon de données utilisé dans une opération d’encodage, est la classe de base pour la <xref:System.Text.EncoderExceptionFallbackBuffer> classe. Toutefois, au lieu d’une mémoire tampon de données, la <xref:System.Text.EncoderExceptionFallbackBuffer> classe représente un comportement standard dans lequel une exception est levée si une opération d’encodage échoue. Aucun mémoire tampon n’existe et que les membres conçus pour manipuler cette mémoire tampon ne font aucun travail.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EncoderExceptionFallbackBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderExceptionFallbackBuffer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EncoderExceptionFallbackBuffer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.EncoderExceptionFallbackBuffer" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Fallback">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lève une exception parce que le caractère d'entrée ne peut pas être codé. La valeur de retour nominale n'est pas utilisée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public override bool Fallback (char charUnknown, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Fallback(char charUnknown, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderExceptionFallbackBuffer.Fallback(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Fallback (charUnknown As Char, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Fallback(char charUnknown, int index);" />
      <MemberSignature Language="F#" Value="override this.Fallback : char * int -&gt; bool" Usage="encoderExceptionFallbackBuffer.Fallback (charUnknown, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charUnknown" Type="System.Char" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charUnknown">Caractère d'entrée.</param>
        <param name="index">Position d'index du caractère dans la mémoire tampon d'entrée.</param>
        <summary>Lève une exception parce que le caractère d'entrée ne peut pas être codé. Les paramètres spécifient la valeur et la position d'index du caractère qui ne peut pas être converti.</summary>
        <returns>Aucun. Aucune valeur n'est retournée parce que la méthode <see cref="M:System.Text.EncoderExceptionFallbackBuffer.Fallback(System.Char,System.Int32)" /> lève toujours une exception.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoding.GetBytes%2A> et <xref:System.Text.Encoder.Convert%2A> appel de méthodes <xref:System.Text.EncoderExceptionFallbackBuffer.Fallback%2A> si elles rencontrent un caractère inconnu dans leur entrée. En réponse, <xref:System.Text.EncoderExceptionFallbackBuffer.Fallback%2A> lève toujours <xref:System.Text.EncoderFallbackException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Text.EncoderFallbackException"><paramref name="charUnknown" /> ne peut pas être codé. Cette méthode lève toujours une exception qui rapporte la valeur des paramètres <paramref name="charUnknown" /> et paramètres <paramref name="index" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public override bool Fallback (char charUnknownHigh, char charUnknownLow, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Fallback(char charUnknownHigh, char charUnknownLow, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderExceptionFallbackBuffer.Fallback(System.Char,System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Fallback (charUnknownHigh As Char, charUnknownLow As Char, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Fallback(char charUnknownHigh, char charUnknownLow, int index);" />
      <MemberSignature Language="F#" Value="override this.Fallback : char * char * int -&gt; bool" Usage="encoderExceptionFallbackBuffer.Fallback (charUnknownHigh, charUnknownLow, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charUnknownHigh" Type="System.Char" />
        <Parameter Name="charUnknownLow" Type="System.Char" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charUnknownHigh">Substitut étendu de la paire d'entrée.</param>
        <param name="charUnknownLow">Substitut faible de la paire d'entrée.</param>
        <param name="index">Position d'index de la paire de substitution dans la mémoire tampon d'entrée.</param>
        <summary>Lève une exception parce que le caractère d'entrée ne peut pas être codé. Les paramètres spécifient la valeur et la position d'index de la paire de substitution en entrée, et la valeur de retour nominale n'est pas utilisée.</summary>
        <returns>Aucun. Aucune valeur n'est retournée parce que la méthode <see cref="M:System.Text.EncoderExceptionFallbackBuffer.Fallback(System.Char,System.Char,System.Int32)" /> lève toujours une exception.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoding.GetBytes%2A> et <xref:System.Text.Encoder.Convert%2A> appel de méthodes <xref:System.Text.EncoderExceptionFallbackBuffer.Fallback%2A> s’ils rencontrent une paire de substitution en entrée. En réponse, <xref:System.Text.EncoderExceptionFallbackBuffer.Fallback%2A> lève toujours une exception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Text.EncoderFallbackException">Le caractère représenté par <paramref name="charUnknownHigh" /> et <paramref name="charUnknownLow" /> ne peut pas être codé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Soit <paramref name="charUnknownHigh" />, soit <paramref name="charUnknownLow" /> n'est pas valide. <paramref name="charUnknownHigh" /> n'est pas compris entre U+D800 et U+DBFF inclus, ou <paramref name="charUnknownLow" /> n'est pas compris entre U+DC00 et U+DFFF inclus.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNextChar">
      <MemberSignature Language="C#" Value="public override char GetNextChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance char GetNextChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderExceptionFallbackBuffer.GetNextChar" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNextChar () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override char GetNextChar();" />
      <MemberSignature Language="F#" Value="override this.GetNextChar : unit -&gt; char" Usage="encoderExceptionFallbackBuffer.GetNextChar " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère le caractère suivant de la mémoire tampon d'exception de secours.</summary>
        <returns>La valeur de retour est toujours le caractère Unicode NULL (U+0000).  
  
Une valeur de retour est définie, même si elle est invariable, parce que cette méthode implémente une méthode abstraite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que <xref:System.Text.EncoderExceptionFallbackBuffer> n’a aucune mémoire tampon d’exception réel, le <xref:System.Text.EncoderExceptionFallbackBuffer.GetNextChar%2A> méthode retourne toujours le caractère Unicode NULL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MovePrevious">
      <MemberSignature Language="C#" Value="public override bool MovePrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MovePrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderExceptionFallbackBuffer.MovePrevious" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MovePrevious () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MovePrevious();" />
      <MemberSignature Language="F#" Value="override this.MovePrevious : unit -&gt; bool" Usage="encoderExceptionFallbackBuffer.MovePrevious " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entraîne l'appel suivant à la méthode <see cref="M:System.Text.EncoderExceptionFallbackBuffer.GetNextChar" /> pour accéder à la position de caractère de la mémoire tampon des exceptions précédant la position en cours.</summary>
        <returns>La valeur de retour est toujours <see langword="false" />.  
  
Une valeur de retour est définie, même si elle est invariable, parce que cette méthode implémente une méthode abstraite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que <xref:System.Text.EncoderExceptionFallbackBuffer> n’a aucune mémoire tampon d’exception réel, le <xref:System.Text.EncoderExceptionFallbackBuffer.MovePrevious%2A> méthode retourne toujours `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remaining">
      <MemberSignature Language="C#" Value="public override int Remaining { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Remaining" />
      <MemberSignature Language="DocId" Value="P:System.Text.EncoderExceptionFallbackBuffer.Remaining" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Remaining As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Remaining { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Remaining : int" Usage="System.Text.EncoderExceptionFallbackBuffer.Remaining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de caractères dans l'objet <see cref="T:System.Text.EncoderExceptionFallbackBuffer" /> en cours qu'il reste à traiter.</summary>
        <value>La valeur de retour est toujours zéro.  
  
Une valeur de retour est définie, même si elle est invariable, parce que cette méthode implémente une méthode abstraite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que <xref:System.Text.EncoderExceptionFallbackBuffer> n’a aucune mémoire tampon d’exception réel, le <xref:System.Text.EncoderExceptionFallbackBuffer.Remaining%2A> propriété retourne toujours zéro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>