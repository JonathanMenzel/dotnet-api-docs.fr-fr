<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="adec01f981195b98a829302a2c5d5343b07e5e19" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39902923" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UnicodeEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnicodeEncoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UnicodeEncoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="1b050-101">Représente un encodage UTF-16 de caractères Unicode.</span>
      <span class="sxs-lookup">
        <span data-stu-id="1b050-101">Represents a UTF-16 encoding of Unicode characters.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-102">L'encodage est le processus de transformation d'un jeu de caractères Unicode en une séquence d'octets.</span><span class="sxs-lookup"><span data-stu-id="1b050-102">Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</span></span> <span data-ttu-id="1b050-103">Le décodage est le processus de transformation d’une séquence d’octets codés en un jeu de caractères Unicode.</span><span class="sxs-lookup"><span data-stu-id="1b050-103">Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</span></span>  
  
 <span data-ttu-id="1b050-104">Le [norme Unicode](http://go.microsoft.com/fwlink/?linkid=37123) assigne un point de code (nombre) à chaque caractère dans chaque script pris en charge.</span><span class="sxs-lookup"><span data-stu-id="1b050-104">The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) assigns a code point (a number) to each character in every supported script.</span></span> <span data-ttu-id="1b050-105">Un Format UTF (Unicode Transformation) est un moyen pour encoder ce point de code.</span><span class="sxs-lookup"><span data-stu-id="1b050-105">A Unicode Transformation Format (UTF) is a way to encode that code point.</span></span> <span data-ttu-id="1b050-106">Le [norme Unicode](http://go.microsoft.com/fwlink/?linkid=37123) utilise les formats UTF suivants :</span><span class="sxs-lookup"><span data-stu-id="1b050-106">The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) uses the following UTFs:</span></span>  
  
-   <span data-ttu-id="1b050-107">UTF-8, qui représente chaque point de code sous la forme d’une séquence d’un à quatre octets.</span><span class="sxs-lookup"><span data-stu-id="1b050-107">UTF-8, which represents each code point as a sequence of one to four bytes.</span></span>  
  
-   <span data-ttu-id="1b050-108">UTF-16, ce qui représente chaque point de code sous la forme d’une séquence d’entiers 16 bits d’une à deux.</span><span class="sxs-lookup"><span data-stu-id="1b050-108">UTF-16, which represents each code point as a sequence of one to two 16-bit integers.</span></span>  
  
-   <span data-ttu-id="1b050-109">UTF-32, ce qui représente chaque point de code sous la forme d’un entier 32 bits.</span><span class="sxs-lookup"><span data-stu-id="1b050-109">UTF-32, which represents each code point as a 32-bit integer.</span></span>  
  
 <span data-ttu-id="1b050-110">Pour plus d’informations sur les formats UTF et d’autres encodages pris en charge par <xref:System.Text>, consultez [encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="1b050-110">For more information about the UTFs and other encodings supported by <xref:System.Text>, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="1b050-111">Le <xref:System.Text.UnicodeEncoding> classe représente un encodage UTF-16.</span><span class="sxs-lookup"><span data-stu-id="1b050-111">The <xref:System.Text.UnicodeEncoding> class represents a UTF-16 encoding.</span></span> <span data-ttu-id="1b050-112">L’encodeur peut utiliser l’ordre de primauté des octets (octet le plus significatif premier) ou primauté des octets (octet le moins significatif premier).</span><span class="sxs-lookup"><span data-stu-id="1b050-112">The encoder can use either big endian byte order (most significant byte first) or little endian byte order (least significant byte first).</span></span> <span data-ttu-id="1b050-113">Par exemple, la lettre majuscule latine A (point de code U + 0041) est sérialisée comme suit (en hexadécimal) :</span><span class="sxs-lookup"><span data-stu-id="1b050-113">For example, the Latin Capital Letter A (code point U+0041) is serialized as follows (in hexadecimal):</span></span>  
  
-   <span data-ttu-id="1b050-114">Ordre de primauté des octets : 00 00 00 41</span><span class="sxs-lookup"><span data-stu-id="1b050-114">Big endian byte order: 00 00 00 41</span></span>  
  
-   <span data-ttu-id="1b050-115">Primauté des octets : 41 00 00 00</span><span class="sxs-lookup"><span data-stu-id="1b050-115">Little endian byte order: 41 00 00 00</span></span>  
  
 <span data-ttu-id="1b050-116">Il est généralement plus efficace pour stocker des caractères Unicode à l’aide de l’ordre d’octet natif d’une plateforme spécifique.</span><span class="sxs-lookup"><span data-stu-id="1b050-116">It is generally more efficient to store Unicode characters using the native byte order of a particular platform.</span></span> <span data-ttu-id="1b050-117">Par exemple, il est préférable d’utiliser l’ordre d’octet avec primauté sur des plateformes little-endian, tels que des ordinateurs Intel.</span><span class="sxs-lookup"><span data-stu-id="1b050-117">For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</span></span> <span data-ttu-id="1b050-118">Le <xref:System.Text.UnicodeEncoding> classe correspond aux pages de codes 1200 (ordre de primauté des octets little) et 1201 (ordre de primauté des octets) de Windows.</span><span class="sxs-lookup"><span data-stu-id="1b050-118">The <xref:System.Text.UnicodeEncoding> class corresponds to the Windows code pages 1200 (little endian byte order) and 1201 (big endian byte order).</span></span> <span data-ttu-id="1b050-119">Vous pouvez déterminer le « endianness » d’une architecture particulière en appelant le <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-119">You can determine the "endianness" of a particular architecture by calling the <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="1b050-120">Si vous le souhaitez, le <xref:System.Text.UnicodeEncoding> objet fournit une marque d’ordre d’octet (BOM), qui est un tableau d’octets qui peut porter comme préfixe à la séquence d’octets résultant du processus de codage.</span><span class="sxs-lookup"><span data-stu-id="1b050-120">Optionally, the <xref:System.Text.UnicodeEncoding> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</span></span> <span data-ttu-id="1b050-121">Si le préambule contient une marque d’ordre d’octet (BOM), il aide le décodeur à déterminer l’ordre d’octet et que le format de transformation ou UTF.</span><span class="sxs-lookup"><span data-stu-id="1b050-121">If the preamble contains a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF.</span></span>  
  
 <span data-ttu-id="1b050-122">Si le <xref:System.Text.UnicodeEncoding> instance est configurée pour fournir une nomenclature, vous pouvez le récupérer en appelant le <xref:System.Text.UnicodeEncoding.GetPreamble%2A> méthode ; sinon, la méthode retourne un tableau vide.</span><span class="sxs-lookup"><span data-stu-id="1b050-122">If the <xref:System.Text.UnicodeEncoding> instance is configured to provide a BOM, you can retrieve it by calling the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method; otherwise, the method returns an empty array.</span></span> <span data-ttu-id="1b050-123">Notez que, même si un <xref:System.Text.UnicodeEncoding> objet est configuré pour prendre en charge de la nomenclature, vous devez inclure la marque BOM au début du flux d’octets encodé selon le cas ; les méthodes d’encodage de la <xref:System.Text.UnicodeEncoding> classe ne le faites pas cela automatiquement.</span><span class="sxs-lookup"><span data-stu-id="1b050-123">Note that, even if a <xref:System.Text.UnicodeEncoding> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <xref:System.Text.UnicodeEncoding> class do not do this automatically.</span></span>  
  
 <span data-ttu-id="1b050-124">Pour activer la détection d’erreur et pour renforcer la sécurité de l’instance de classe, vous devez instancier un <xref:System.Text.UnicodeEncoding> objet en appelant le <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructeur et en définissant son `throwOnInvalidBytes` argument `true`.</span><span class="sxs-lookup"><span data-stu-id="1b050-124">To enable error detection and to make the class instance more secure, you should instantiate a <xref:System.Text.UnicodeEncoding> object by calling the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`.</span></span> <span data-ttu-id="1b050-125">Avec la détection d’erreurs, une méthode qui détecte une séquence de caractères ou d’octets non valide lève une <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="1b050-125">With error detection, a method that detects an invalid sequence of characters or bytes throws a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="1b050-126">Absence de détection d’erreur, aucune exception n’est levée, et la séquence non valide est généralement ignorée.</span><span class="sxs-lookup"><span data-stu-id="1b050-126">Without error detection, no exception is thrown, and the invalid sequence is generally ignored.</span></span>  
  
 <span data-ttu-id="1b050-127">Vous pouvez instancier un <xref:System.Text.UnicodeEncoding> objet dans un nombre de façons, selon que vous souhaitiez lui fournir une marque d’ordre d’octet (BOM), si vous souhaitez codage big-endian ou little-endian, et si vous souhaitez activer la détection d’erreur.</span><span class="sxs-lookup"><span data-stu-id="1b050-127">You can instantiate a <xref:System.Text.UnicodeEncoding> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM), whether you want big-endian or little-endian encoding, and whether you want to enable error detection.</span></span> <span data-ttu-id="1b050-128">Le tableau suivant répertorie les <xref:System.Text.UnicodeEncoding> constructeurs et les <xref:System.Text.Encoding> propriétés qui retournent un <xref:System.Text.UnicodeEncoding> objet.</span><span class="sxs-lookup"><span data-stu-id="1b050-128">The following table lists the <xref:System.Text.UnicodeEncoding> constructors and the <xref:System.Text.Encoding> properties that return a <xref:System.Text.UnicodeEncoding> object.</span></span>  
  
|<span data-ttu-id="1b050-129">Membre</span><span class="sxs-lookup"><span data-stu-id="1b050-129">Member</span></span>|<span data-ttu-id="1b050-130">Endianness</span><span class="sxs-lookup"><span data-stu-id="1b050-130">Endianness</span></span>|<span data-ttu-id="1b050-131">NOMENCLATURE</span><span class="sxs-lookup"><span data-stu-id="1b050-131">BOM</span></span>|<span data-ttu-id="1b050-132">Détection d’erreurs</span><span class="sxs-lookup"><span data-stu-id="1b050-132">Error detection</span></span>|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|<span data-ttu-id="1b050-133">Big-endian</span><span class="sxs-lookup"><span data-stu-id="1b050-133">Big-endian</span></span>|<span data-ttu-id="1b050-134">Oui</span><span class="sxs-lookup"><span data-stu-id="1b050-134">Yes</span></span>|<span data-ttu-id="1b050-135">Aucun (remplacement de secours)</span><span class="sxs-lookup"><span data-stu-id="1b050-135">No (Replacement fallback)</span></span>|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>|<span data-ttu-id="1b050-136">Little endian</span><span class="sxs-lookup"><span data-stu-id="1b050-136">Little-endian</span></span>|<span data-ttu-id="1b050-137">Oui</span><span class="sxs-lookup"><span data-stu-id="1b050-137">Yes</span></span>|<span data-ttu-id="1b050-138">Aucun (remplacement de secours)</span><span class="sxs-lookup"><span data-stu-id="1b050-138">No (Replacement fallback)</span></span>|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=nameWithType>|<span data-ttu-id="1b050-139">Little endian</span><span class="sxs-lookup"><span data-stu-id="1b050-139">Little-endian</span></span>|<span data-ttu-id="1b050-140">Oui</span><span class="sxs-lookup"><span data-stu-id="1b050-140">Yes</span></span>|<span data-ttu-id="1b050-141">Aucun (remplacement de secours)</span><span class="sxs-lookup"><span data-stu-id="1b050-141">No (Replacement fallback)</span></span>|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|<span data-ttu-id="1b050-142">Configurable</span><span class="sxs-lookup"><span data-stu-id="1b050-142">Configurable</span></span>|<span data-ttu-id="1b050-143">Configurable</span><span class="sxs-lookup"><span data-stu-id="1b050-143">Configurable</span></span>|<span data-ttu-id="1b050-144">Aucun (remplacement de secours)</span><span class="sxs-lookup"><span data-stu-id="1b050-144">No (Replacement fallback)</span></span>|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|<span data-ttu-id="1b050-145">Configurable</span><span class="sxs-lookup"><span data-stu-id="1b050-145">Configurable</span></span>|<span data-ttu-id="1b050-146">Configurable</span><span class="sxs-lookup"><span data-stu-id="1b050-146">Configurable</span></span>|<span data-ttu-id="1b050-147">Configurable</span><span class="sxs-lookup"><span data-stu-id="1b050-147">Configurable</span></span>|  
  
 <span data-ttu-id="1b050-148">Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode exécute le codage.</span><span class="sxs-lookup"><span data-stu-id="1b050-148">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method performs the actual encoding.</span></span>  
  
 <span data-ttu-id="1b050-149">De même, le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et le <xref:System.Text.UnicodeEncoding.GetChars%2A> et <xref:System.Text.UnicodeEncoding.GetString%2A> méthodes effectuent le décodage réel.</span><span class="sxs-lookup"><span data-stu-id="1b050-149">Likewise, the <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.UnicodeEncoding.GetChars%2A> and <xref:System.Text.UnicodeEncoding.GetString%2A> methods perform the actual decoding.</span></span>  
  
 <span data-ttu-id="1b050-150">Pour un encodeur ou un décodeur qui est en mesure d’enregistrer les informations d’état lors de l’encodage ou de décodage de données qui s’étend sur plusieurs blocs (par exemple, la chaîne de 1 million de caractères qui est encodé dans les segments de 100 000 caractères), utilisez le <xref:System.Text.UnicodeEncoding.GetEncoder%2A> et <xref:System.Text.UnicodeEncoding.GetDecoder%2A> propriétés, respectivement.</span><span class="sxs-lookup"><span data-stu-id="1b050-150">For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> and <xref:System.Text.UnicodeEncoding.GetDecoder%2A> properties, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-151">L’exemple suivant montre comment encoder une chaîne de caractères Unicode en tableau d’octets à l’aide un <xref:System.Text.UnicodeEncoding> objet.</span><span class="sxs-lookup"><span data-stu-id="1b050-151">The following example demonstrates how to encode a string of Unicode characters into a byte array by using a <xref:System.Text.UnicodeEncoding> object.</span></span> <span data-ttu-id="1b050-152">Le tableau d’octets est décodé en une chaîne pour montrer qu’il n’existe aucune perte de données.</span><span class="sxs-lookup"><span data-stu-id="1b050-152">The byte array is decoded into a string to demonstrate that there is no loss of data.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 <span data-ttu-id="1b050-153">L’exemple suivant utilise la même chaîne que la précédente, sauf qu’il écrit les octets encodés dans un fichier et le flux d’octets avec une marque d’ordre d’octet (BOM) de préfixes.</span><span class="sxs-lookup"><span data-stu-id="1b050-153">The following example uses the same string as the previous one, except that it writes the encoded bytes to a file and prefixes the byte stream with a byte order mark (BOM).</span></span> <span data-ttu-id="1b050-154">Elle lit ensuite le fichier de deux manières différentes : en tant qu’un fichier texte à l’aide un <xref:System.IO.StreamReader> de l’objet ; et comme un fichier binaire.</span><span class="sxs-lookup"><span data-stu-id="1b050-154">It then reads the file in two different ways: as a text file by using a <xref:System.IO.StreamReader> object; and as a binary file.</span></span> <span data-ttu-id="1b050-155">Comme vous pouvez l’imaginer, en aucun cas est la marque BOM inclus dans la chaîne récemment lue.</span><span class="sxs-lookup"><span data-stu-id="1b050-155">As you would expect, in neither case is the BOM included in the newly read string.</span></span>  
  
 [!code-csharp[System.Text.UnicodeEncoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1b050-156">Initialise une nouvelle instance de la classe <see cref="T:System.Text.UnicodeEncoding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-156">Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1b050-157">Initialise une nouvelle instance de la classe <see cref="T:System.Text.UnicodeEncoding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-157">Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-158">Ce constructeur crée une instance qui utilise l’ordre d’octet avec primauté, fournit la marque d’ordre d’octet Unicode et ne lève pas d’exception lorsqu’un encodage non valide est détecté.</span><span class="sxs-lookup"><span data-stu-id="1b050-158">This constructor creates an instance that uses the little endian byte order, provides a Unicode byte order mark, and does not throw an exception when an invalid encoding is detected.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1b050-159">Pour des raisons de sécurité, vous devez activer la détection d’erreur en appelant le <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructeur et en définissant son `throwOnInvalidBytes` argument `true`.</span><span class="sxs-lookup"><span data-stu-id="1b050-159">For security reasons, you should enable error detection by calling the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-160">L’exemple suivant montre comment créer un nouveau <xref:System.Text.UnicodeEncoding> instance et affichez le nom de l’encodage.</span><span class="sxs-lookup"><span data-stu-id="1b050-160">The following example demonstrates how to create a new <xref:System.Text.UnicodeEncoding> instance and display the name of the encoding.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <span data-ttu-id="1b050-161">
            <see langword="true" /> pour utiliser l'ordre d'octet avec primauté des octets de poids fort (big-endian) (octet le plus significatif en premier) ou <see langword="false" /> pour utiliser l'ordre d'octet avec primauté des octets de poids faible (little-endian) (octet le moins significatif en premier).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-161">
              <see langword="true" /> to use the big endian byte order (most significant byte first), or <see langword="false" /> to use the little endian byte order (least significant byte first).</span>
          </span>
        </param>
        <param name="byteOrderMark">
          <span data-ttu-id="1b050-162">
            <see langword="true" /> pour spécifier que la méthode <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> retourne une marque d'ordre d'octet Unicode ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-162">
              <see langword="true" /> to specify that the <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> method returns a Unicode byte order mark; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-163">Initialise une nouvelle instance de la classe <see cref="T:System.Text.UnicodeEncoding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-163">Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</span>
          </span>
          <span data-ttu-id="1b050-164">Les paramètres indiquent s'il faut utiliser l'ordre d'octet avec primauté des octets de poids fort (big-endian) et si la méthode <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> retourne une marque d'ordre d'octet Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-164">Parameters specify whether to use the big endian byte order and whether the <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> method returns a Unicode byte order mark.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-165">Ce constructeur crée une instance qui ne lève pas d’exception lorsqu’un encodage non valide est détecté.</span><span class="sxs-lookup"><span data-stu-id="1b050-165">This constructor creates an instance that does not throw an exception when an invalid encoding is detected.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1b050-166">Pour des raisons de sécurité, vous devez activer la détection d’erreur en appelant le <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructeur et en définissant son `throwOnInvalidBytes` argument `true`.</span><span class="sxs-lookup"><span data-stu-id="1b050-166">For security reasons, you should enable error detection by calling the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`.</span></span>  
  
 <span data-ttu-id="1b050-167">Le `byteOrderMark` paramètre contrôle le fonctionnement de la <xref:System.Text.UnicodeEncoding.GetPreamble%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-167">The `byteOrderMark` parameter controls the operation of the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method.</span></span> <span data-ttu-id="1b050-168">Si `true`, la méthode retourne un tableau d’octets contenant la marque d’ordre d’octet Unicode (BOM) au format UTF-16.</span><span class="sxs-lookup"><span data-stu-id="1b050-168">If `true`, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-16 format.</span></span>  <span data-ttu-id="1b050-169">Si `false`, elle retourne un tableau d’octets de longueur nulle.</span><span class="sxs-lookup"><span data-stu-id="1b050-169">If `false`, it returns a zero-length byte array.</span></span> <span data-ttu-id="1b050-170">Toutefois, l’affectation `byteOrderMark` à `true` n’entraîne pas la <xref:System.Text.UnicodeEncoding.GetBytes%2A> (méthode) pour préfixer la nomenclature au début du tableau d’octets, et ne déclenche le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode pour inclure le nombre d’octets dans la nomenclature dans le nombre d’octets.</span><span class="sxs-lookup"><span data-stu-id="1b050-170">However, setting `byteOrderMark` to `true` does not cause the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method to prefix the BOM at the beginning of the byte array, nor does it cause the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method to include the number of bytes in the BOM in the byte count.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-171">L’exemple suivant montre comment créer un nouveau <xref:System.Text.UnicodeEncoding> marque d’ordre d’instance en spécifiant s’il faut prendre en charge le classement des octets little endian ou big endian et l’octet Unicode.</span><span class="sxs-lookup"><span data-stu-id="1b050-171">The following example demonstrates how to create a new <xref:System.Text.UnicodeEncoding> instance specifying whether to support little endian or big endian byte ordering and the Unicode byte order mark.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <span data-ttu-id="1b050-172">
            <see langword="true" /> pour utiliser l'ordre d'octet avec primauté des octets de poids fort (big-endian) (octet le plus significatif en premier) ; <see langword="false" /> pour utiliser l'ordre d'octet avec primauté des octets de poids faible (little-endian) (octet le moins significatif en premier).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-172">
              <see langword="true" /> to use the big endian byte order (most significant byte first); <see langword="false" /> to use the little endian byte order (least significant byte first).</span>
          </span>
        </param>
        <param name="byteOrderMark">
          <span data-ttu-id="1b050-173">
            <see langword="true" /> pour spécifier que la méthode <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> retourne une marque d'ordre d'octet Unicode ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-173">
              <see langword="true" /> to specify that the <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> method returns a Unicode byte order mark; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="throwOnInvalidBytes">
          <span data-ttu-id="1b050-174">
            <see langword="true" /> pour spécifier qu'une exception doit être levée quand un encodage non valide est détecté ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-174">
              <see langword="true" /> to specify that an exception should be thrown when an invalid encoding is detected; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-175">Initialise une nouvelle instance de la classe <see cref="T:System.Text.UnicodeEncoding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-175">Initializes a new instance of the <see cref="T:System.Text.UnicodeEncoding" /> class.</span>
          </span>
          <span data-ttu-id="1b050-176">Les paramètres indiquent s'il faut utiliser l'ordre d'octet avec primauté des octets de poids fort (big-endian), fournir une marque d'ordre d'octet Unicode et lever une exception en cas de détection d'un encodage non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-176">Parameters specify whether to use the big endian byte order, whether to provide a Unicode byte order mark, and whether to throw an exception when an invalid encoding is detected.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-177">Le `byteOrderMark` paramètre contrôle le fonctionnement de la <xref:System.Text.UnicodeEncoding.GetPreamble%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-177">The `byteOrderMark` parameter controls the operation of the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method.</span></span> <span data-ttu-id="1b050-178">Si `true`, la méthode retourne un tableau d’octets contenant la marque d’ordre d’octet Unicode (BOM) au format UTF-16.</span><span class="sxs-lookup"><span data-stu-id="1b050-178">If `true`, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-16 format.</span></span>  <span data-ttu-id="1b050-179">Si `false`, elle retourne un tableau d’octets de longueur nulle.</span><span class="sxs-lookup"><span data-stu-id="1b050-179">If `false`, it returns a zero-length byte array.</span></span> <span data-ttu-id="1b050-180">Toutefois, l’affectation `byteOrderMark` à `true` n’entraîne pas la <xref:System.Text.UnicodeEncoding.GetBytes%2A> (méthode) pour préfixer la nomenclature au début du tableau d’octets, et ne déclenche le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode pour inclure le nombre d’octets dans la nomenclature dans le nombre d’octets.</span><span class="sxs-lookup"><span data-stu-id="1b050-180">However, setting `byteOrderMark` to `true` does not cause the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method to prefix the BOM at the beginning of the byte array, nor does it cause the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method to include the number of bytes in the BOM in the byte count.</span></span>  
  
 <span data-ttu-id="1b050-181">Si le `throwOnInvalidBytes` paramètre est `true`, une méthode qui détecte une séquence d’octets non valide lève <xref:System.ArgumentException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1b050-181">If the `throwOnInvalidBytes` parameter is `true`, a method that detects an invalid byte sequence throws <xref:System.ArgumentException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1b050-182">Sinon, la méthode ne lève pas d’exception et la séquence non valide est ignorée.</span><span class="sxs-lookup"><span data-stu-id="1b050-182">Otherwise, the method does not throw an exception, and the invalid sequence is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1b050-183">Pour des raisons de sécurité, il est recommandé d’utiliser ce constructeur pour créer une instance de vos applications le <xref:System.Text.UnicodeEncoding> classe et activer la détection d’erreur en définissant `throwOnInvalidBytes` à `true`.</span><span class="sxs-lookup"><span data-stu-id="1b050-183">For security reasons, your applications are recommended to use this constructor to create an instance of the <xref:System.Text.UnicodeEncoding> class and turn on error detection by setting `throwOnInvalidBytes` to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-184">L’exemple suivant illustre le comportement de <xref:System.Text.UnicodeEncoding>, avec la détection d’erreurs et sans.</span><span class="sxs-lookup"><span data-stu-id="1b050-184">The following example demonstrates the behavior of <xref:System.Text.UnicodeEncoding>, both with error detection enabled and without.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberSignature Language="VB.NET" Value="Public Const CharSize As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int CharSize = 2;" />
      <MemberSignature Language="F#" Value="val mutable CharSize : int" Usage="System.Text.UnicodeEncoding.CharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="1b050-185">Représente la taille des caractères Unicode en octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-185">Represents the Unicode character size in bytes.</span>
          </span>
          <span data-ttu-id="1b050-186">Ce champ est une constante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-186">This field is a constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-187">La valeur de ce champ est une constante signée de 32 bits avec la valeur 2.</span><span class="sxs-lookup"><span data-stu-id="1b050-187">The value of this field is a 32-bit signed constant with a value of 2.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-188">L’exemple suivant montre comment retourner la valeur de <xref:System.Text.UnicodeEncoding.CharSize> et l’afficher.</span><span class="sxs-lookup"><span data-stu-id="1b050-188">The following example demonstrates how to return the value of <xref:System.Text.UnicodeEncoding.CharSize> and display it.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="unicodeEncoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="1b050-189">Objet à comparer à l'objet actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-189">The object to compare with the current object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-190">Détermine si l'objet <see cref="T:System.Object" /> spécifié est égal à l'objet <see cref="T:System.Text.UnicodeEncoding" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-190">Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Text.UnicodeEncoding" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-191">
            <see langword="true" /> si <paramref name="value" /> est une instance de <see cref="T:System.Text.UnicodeEncoding" /> et s'il est égal à l'objet actuel ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-191">
              <see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.UnicodeEncoding" /> and is equal to the current object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-192">Deux <xref:System.Text.UnicodeEncoding> objets sont considérés comme égaux si toutes les conditions suivantes sont remplies :</span><span class="sxs-lookup"><span data-stu-id="1b050-192">Two <xref:System.Text.UnicodeEncoding> objects are considered equal if all of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="1b050-193">Les deux objets utilisent le même ordre d’octet (little-endian ou big-endian).</span><span class="sxs-lookup"><span data-stu-id="1b050-193">Both objects use the same byte order (little-endian or big-endian).</span></span>  
  
-   <span data-ttu-id="1b050-194">Les deux objets fournissent la marque d’ordre d’octet, ou les deux n’est pas le cas.</span><span class="sxs-lookup"><span data-stu-id="1b050-194">Both objects provide the byte order mark, or both do not.</span></span>  
  
-   <span data-ttu-id="1b050-195">Les deux objets utilisent le même encodeur de secours.</span><span class="sxs-lookup"><span data-stu-id="1b050-195">Both objects use the same encoder fallback.</span></span>  
  
-   <span data-ttu-id="1b050-196">Les deux objets utilisent le même décodeur de secours.</span><span class="sxs-lookup"><span data-stu-id="1b050-196">Both objects use the same decoder fallback.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-197">L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.Equals%2A> méthode pour tester si actuel <xref:System.Text.UnicodeEncoding> objet est égal à un autre <xref:System.Text.UnicodeEncoding> objet.</span><span class="sxs-lookup"><span data-stu-id="1b050-197">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.Equals%2A> method to test whether the current <xref:System.Text.UnicodeEncoding> object is equal to a different <xref:System.Text.UnicodeEncoding> object.</span></span> <span data-ttu-id="1b050-198">Cinq <xref:System.Text.UnicodeEncoding> objets sont créés et comparées, et les résultats des comparaisons sont affichés.</span><span class="sxs-lookup"><span data-stu-id="1b050-198">Five <xref:System.Text.UnicodeEncoding> objects are created and compared, and the results of the comparisons are displayed.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1b050-199">Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-199">Calculates the number of bytes produced by encoding a set of characters.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="unicodeEncoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="1b050-200">Chaîne contenant le jeu de caractères à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-200">The string that contains the set of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-201">Calcule le nombre d'octets générés en codant les caractères dans la chaîne spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-201">Calculates the number of bytes produced by encoding the characters in the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-202">Nombre d'octets produits par l'encodage des caractères spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-202">The number of bytes produced by encoding the specified characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-203">Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-203">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1b050-204">Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-204">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1b050-205">Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="1b050-205">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1b050-206">Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="1b050-206">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="1b050-207">Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="1b050-207">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1b050-208">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule.</span><span class="sxs-lookup"><span data-stu-id="1b050-208">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1b050-209">Insérer le préambule au début d’un flux d’octets (tel qu’au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflété dans la valeur retournée par la <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-209">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-210">L’exemple suivant appelle la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> et <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> méthodes pour calculer le nombre maximal et réel d’octets requis pour encoder une chaîne.</span><span class="sxs-lookup"><span data-stu-id="1b050-210">The following example calls the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> and <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> methods to calculate the maximum and actual number of bytes required to encode a string.</span></span> <span data-ttu-id="1b050-211">Il affiche également le nombre réel d’octets requis pour stocker un flux d’octets avec une marque d’ordre d’octet.</span><span class="sxs-lookup"><span data-stu-id="1b050-211">It also displays the actual number of bytes required to store a byte stream with a byte order mark.</span></span>  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1b050-212">
            <paramref name="s" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-212">
              <paramref name="s" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-213">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-213">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1b050-214">La détection d’erreurs est activée et <paramref name="s" /> contient une séquence de caractères non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-214">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="1b050-215">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-215">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-216">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-216">-and-</span>
          </span>
          <span data-ttu-id="1b050-217">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-217">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="1b050-218">Pointeur du premier caractère à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-218">A pointer to the first character to encode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="1b050-219">Nombre de caractères à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-219">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-220">Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères commençant au pointeur de caractère spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-220">Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-221">Nombre d'octets produits par l'encodage des caractères spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-221">The number of bytes produced by encoding the specified characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-222">Pour calculer la taille de tableau exact qui <xref:System.Text.UnicodeEncoding.GetBytes%2A> requiert pour stocker les octets obtenus, vous devez appeler la <xref:System.Text.UnicodeEncoding.GetByteCount%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-222">To calculate the exact array size that <xref:System.Text.UnicodeEncoding.GetBytes%2A> requires to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1b050-223">Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-223">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1b050-224">Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="1b050-224">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1b050-225">Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="1b050-225">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="1b050-226">Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="1b050-226">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1b050-227">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule.</span><span class="sxs-lookup"><span data-stu-id="1b050-227">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1b050-228">Insérer le préambule au début d’un flux d’octets (tel qu’au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflété dans la valeur retournée par la <xref:System.Text.UTF8Encoding.GetByteCount%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-228">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UTF8Encoding.GetByteCount%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1b050-229">
            <paramref name="chars" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-229">
              <paramref name="chars" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-230">
            <paramref name="count" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-230">
              <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="1b050-231">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-231">-or-</span>
          </span>
          <span data-ttu-id="1b050-232">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-232">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1b050-233">La détection d'erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-233">Error detection is enabled and <paramref name="chars" /> contains an invalid sequence of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="1b050-234">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-234">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-235">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-235">-and-</span>
          </span>
          <span data-ttu-id="1b050-236">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-236">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="1b050-237">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-237">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="1b050-238">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-238">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="1b050-239">Tableau de caractères contenant le jeu de caractères à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-239">The character array containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="1b050-240">Index du premier caractère à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-240">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="1b050-241">Nombre de caractères à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-241">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-242">Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères du tableau de caractères spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-242">Calculates the number of bytes produced by encoding a set of characters from the specified character array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-243">Nombre d'octets produits par l'encodage des caractères spécifiés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-243">The number of bytes produced by encoding the specified characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-244">Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetBytes%2A> pour stocker les octets obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-244">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, the application uses <xref:System.Text.UnicodeEncoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1b050-245">Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-245">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1b050-246">Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="1b050-246">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1b050-247">Avec la détection d’erreurs, une séquence non valide provoque la levée de cette méthode une <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="1b050-247">With error detection enabled, an invalid sequence causes this method to throw an <xref:System.ArgumentException>.</span></span> <span data-ttu-id="1b050-248">Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="1b050-248">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1b050-249">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule.</span><span class="sxs-lookup"><span data-stu-id="1b050-249">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1b050-250">Insérer le préambule au début d’un flux d’octets (tel qu’au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflété dans la valeur retournée par la <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-250">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-251">L’exemple suivant remplit un tableau avec un Latin en majuscules et minuscules et appelle le <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> méthode pour déterminer le nombre d’octets nécessaires pour encoder les caractères latins minuscules.</span><span class="sxs-lookup"><span data-stu-id="1b050-251">The following example populates an array with a Latin uppercase and lowercase characters and calls the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to determine the number of bytes needed to encode the Latin lowercase characters.</span></span> <span data-ttu-id="1b050-252">Il affiche ensuite ces informations ainsi que le nombre total d’octets nécessaire si une marque d’ordre d’octet est ajoutée.</span><span class="sxs-lookup"><span data-stu-id="1b050-252">It then displays this information along with the total number of bytes needed if a byte order mark is added.</span></span> <span data-ttu-id="1b050-253">Il compare ce nombre avec la valeur retournée par la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode), ce qui indique le nombre maximal d’octets nécessaires pour encoder les caractères latins minuscules.</span><span class="sxs-lookup"><span data-stu-id="1b050-253">It compares this number with the value returned by the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method, which indicates maximum number of bytes needed to encode the Latin lowercase characters.</span></span> <span data-ttu-id="1b050-254">L’exemple suivant remplit un tableau avec une combinaison de caractères grec et cyrillique et appelle le <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> méthode pour déterminer le nombre d’octets nécessaires pour encoder les caractères cyrilliques.</span><span class="sxs-lookup"><span data-stu-id="1b050-254">The following example populates an array with a combination of Greek and Cyrillic characters and calls the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to determine the number of bytes needed to encode the Cyrillic characters.</span></span> <span data-ttu-id="1b050-255">Il affiche ensuite ces informations ainsi que le nombre total d’octets nécessaire si une marque d’ordre d’octet est ajoutée.</span><span class="sxs-lookup"><span data-stu-id="1b050-255">It then displays this information along with the total number of bytes needed if a byte order mark is added.</span></span> <span data-ttu-id="1b050-256">Il compare ce nombre avec la valeur retournée par la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode), ce qui indique le nombre maximal d’octets nécessaires pour encoder les caractères cyrilliques.</span><span class="sxs-lookup"><span data-stu-id="1b050-256">It compares this number with the value returned by the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method, which indicates maximum number of bytes needed to encode the Cyrillic characters.</span></span>  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1b050-257">
            <paramref name="chars" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-257">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-258">
            <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-258">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="1b050-259">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-259">-or-</span>
          </span>
          <span data-ttu-id="1b050-260">
            <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-260">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
          <span data-ttu-id="1b050-261">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-261">-or-</span>
          </span>
          <span data-ttu-id="1b050-262">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-262">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1b050-263">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-263">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="1b050-264">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-264">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-265">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-265">-and-</span>
          </span>
          <span data-ttu-id="1b050-266">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-266">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1b050-267">Encode un jeu de caractères en une séquence d'octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-267">Encodes a set of characters into a sequence of bytes.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="unicodeEncoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="1b050-268">Pointeur du premier caractère à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-268">A pointer to the first character to encode.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="1b050-269">Nombre de caractères à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-269">The number of characters to encode.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="1b050-270">Pointeur de l'emplacement où commencer l'écriture de la séquence d'octets obtenue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-270">A pointer to the location at which to start writing the resulting sequence of bytes.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="1b050-271">Nombre maximal d'octets à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-271">The maximum number of bytes to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-272">Code une séquence de caractères commençant au pointeur de caractère spécifié en une séquence d'octets, qui sera stockée à partir du pointeur d'octet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-272">Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-273">Nombre réel d'octets écrits à l'emplacement indiqué par le paramètre <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-273">The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-274">Pour calculer la taille de tableau exact qui <xref:System.Text.UnicodeEncoding.GetBytes%2A> requiert pour stocker les octets obtenus, vous devez appeler la <xref:System.Text.UnicodeEncoding.GetByteCount%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-274">To calculate the exact array size that <xref:System.Text.UnicodeEncoding.GetBytes%2A> requires to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1b050-275">Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-275">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1b050-276">Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="1b050-276">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1b050-277">Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="1b050-277">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="1b050-278">Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="1b050-278">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1b050-279">Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels.</span><span class="sxs-lookup"><span data-stu-id="1b050-279">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1b050-280">Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou le <xref:System.Text.Encoder> objet fourni par le <xref:System.Text.UnicodeEncoding.GetDecoder%2A> ou <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (méthode), respectivement.</span><span class="sxs-lookup"><span data-stu-id="1b050-280">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1b050-281">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule.</span><span class="sxs-lookup"><span data-stu-id="1b050-281">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1b050-282">Insérer le préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur.</span><span class="sxs-lookup"><span data-stu-id="1b050-282">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="1b050-283">Le <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode ne doit pas un préambule au début d’une séquence d’octets encodées.</span><span class="sxs-lookup"><span data-stu-id="1b050-283">The <xref:System.Text.UnicodeEncoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1b050-284">
            <paramref name="chars" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-284">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
          <span data-ttu-id="1b050-285">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-285">-or-</span>
          </span>
          <span data-ttu-id="1b050-286">
            <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-286">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-287">
            <paramref name="charCount" /> ou <paramref name="byteCount" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-287">
              <paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1b050-288">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-288">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span>
          </span>
          <span data-ttu-id="1b050-289">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-289">-or-</span>
          </span>
          <span data-ttu-id="1b050-290">
            <paramref name="byteCount" /> est inférieur au nombre d'octets obtenus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-290">
              <paramref name="byteCount" /> is less than the resulting number of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="1b050-291">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-291">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-292">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-292">-and-</span>
          </span>
          <span data-ttu-id="1b050-293">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-293">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="1b050-294">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-294">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="1b050-295">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-295">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="1b050-296">Tableau de caractères contenant le jeu de caractères à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-296">The character array containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="charIndex">
          <span data-ttu-id="1b050-297">Index du premier caractère à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-297">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="1b050-298">Nombre de caractères à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-298">The number of characters to encode.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="1b050-299">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-299">The byte array to contain the resulting sequence of bytes.</span>
          </span>
        </param>
        <param name="byteIndex">
          <span data-ttu-id="1b050-300">Index auquel commencer l'écriture de la séquence d'octets obtenue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-300">The index at which to start writing the resulting sequence of bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-301">Encode un jeu de caractères du tableau de caractères spécifié en un tableau d'octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-301">Encodes a set of characters from the specified character array into the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-302">Nombre réel d'octets écrits dans <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-302">The actual number of bytes written into <paramref name="bytes" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-303">Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-303">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1b050-304">Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-304">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1b050-305">Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="1b050-305">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1b050-306">Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="1b050-306">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="1b050-307">Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="1b050-307">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1b050-308">Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels.</span><span class="sxs-lookup"><span data-stu-id="1b050-308">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1b050-309">Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UnicodeEncoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (méthode), respectivement.</span><span class="sxs-lookup"><span data-stu-id="1b050-309">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> method or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1b050-310">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule.</span><span class="sxs-lookup"><span data-stu-id="1b050-310">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1b050-311">Insérer le préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur.</span><span class="sxs-lookup"><span data-stu-id="1b050-311">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="1b050-312">Le <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode ne doit pas un préambule au début d’une séquence d’octets encodées.</span><span class="sxs-lookup"><span data-stu-id="1b050-312">The <xref:System.Text.UnicodeEncoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-313">L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode pour encoder une plage de caractères à partir d’un <xref:System.String> et stocker les octets encodés dans une plage d’éléments dans un tableau d’octets.</span><span class="sxs-lookup"><span data-stu-id="1b050-313">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method to encode a range of characters from a <xref:System.String> and store the encoded bytes in a range of elements in a byte array.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1b050-314">
            <paramref name="chars" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-314">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
          <span data-ttu-id="1b050-315">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-315">-or-</span>
          </span>
          <span data-ttu-id="1b050-316">
            <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-316">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-317">
            <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-317">
              <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="1b050-318">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-318">-or-</span>
          </span>
          <span data-ttu-id="1b050-319">
            <paramref name="charIndex" /> et <paramref name="charCount" /> ne désignent pas une plage valide dans <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-319">
              <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
          <span data-ttu-id="1b050-320">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-320">-or-</span>
          </span>
          <span data-ttu-id="1b050-321">
            <paramref name="byteIndex" /> n'est pas un index valide dans <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-321">
              <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1b050-322">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-322">Error detection is enabled, and <paramref name="chars" /> contains an invalid sequence of characters.</span>
          </span>
          <span data-ttu-id="1b050-323">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-323">-or-</span>
          </span>
          <span data-ttu-id="1b050-324">
            <paramref name="bytes" /> ne possède pas une capacité suffisante entre <paramref name="byteIndex" /> et la fin du tableau pour prendre en charge les octets obtenus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-324">
              <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="1b050-325">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-325">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-326">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-326">-and-</span>
          </span>
          <span data-ttu-id="1b050-327">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-327">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="1b050-328">Chaîne contenant le jeu de caractères à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-328">The string containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="charIndex">
          <span data-ttu-id="1b050-329">Index du premier caractère à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-329">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="1b050-330">Nombre de caractères à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-330">The number of characters to encode.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="1b050-331">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-331">The byte array to contain the resulting sequence of bytes.</span>
          </span>
        </param>
        <param name="byteIndex">
          <span data-ttu-id="1b050-332">Index auquel commencer l'écriture de la séquence d'octets obtenue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-332">The index at which to start writing the resulting sequence of bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-333">Encode un jeu de caractères de la chaîne <see cref="T:System.String" /> spécifiée dans le tableau d'octets indiqué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-333">Encodes a set of characters from the specified <see cref="T:System.String" /> into the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-334">Nombre réel d'octets écrits dans <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-334">The actual number of bytes written into <paramref name="bytes" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-335">Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-335">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="1b050-336">Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-336">To calculate the maximum array size, you call the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="1b050-337">Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="1b050-337">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1b050-338">Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="1b050-338">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="1b050-339">Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="1b050-339">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1b050-340">Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels.</span><span class="sxs-lookup"><span data-stu-id="1b050-340">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1b050-341">Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UnicodeEncoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (méthode), respectivement.</span><span class="sxs-lookup"><span data-stu-id="1b050-341">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> method or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1b050-342">Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule.</span><span class="sxs-lookup"><span data-stu-id="1b050-342">To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1b050-343">Insérer le préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur.</span><span class="sxs-lookup"><span data-stu-id="1b050-343">Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</span></span> <span data-ttu-id="1b050-344">Le <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode ne doit pas un préambule au début d’une séquence d’octets encodées.</span><span class="sxs-lookup"><span data-stu-id="1b050-344">The <xref:System.Text.UnicodeEncoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-345">L’exemple suivant montre comment encoder une plage d’éléments à partir d’un tableau de caractères Unicode et stocker les octets encodés dans une plage d’éléments dans un tableau d’octets.</span><span class="sxs-lookup"><span data-stu-id="1b050-345">The following example demonstrates how to encode a range of elements from a Unicode character array and store the encoded bytes in a range of elements in a byte array.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1b050-346">
            <paramref name="s" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-346">
              <paramref name="s" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="1b050-347">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-347">-or-</span>
          </span>
          <span data-ttu-id="1b050-348">
            <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-348">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-349">
            <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-349">
              <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="1b050-350">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-350">-or-</span>
          </span>
          <span data-ttu-id="1b050-351">
            <paramref name="charIndex" /> et <paramref name="charCount" /> ne désignent pas une plage valide dans <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-351">
              <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
          <span data-ttu-id="1b050-352">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-352">-or-</span>
          </span>
          <span data-ttu-id="1b050-353">
            <paramref name="byteIndex" /> n'est pas un index valide dans <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-353">
              <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1b050-354">La détection d’erreurs est activée et <paramref name="s" /> contient une séquence de caractères non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-354">Error detection is enabled, and <paramref name="s" /> contains an invalid sequence of characters.</span>
          </span>
          <span data-ttu-id="1b050-355">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-355">-or-</span>
          </span>
          <span data-ttu-id="1b050-356">
            <paramref name="bytes" /> ne possède pas une capacité suffisante entre <paramref name="byteIndex" /> et la fin du tableau pour prendre en charge les octets obtenus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-356">
              <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="1b050-357">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-357">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-358">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-358">-and-</span>
          </span>
          <span data-ttu-id="1b050-359">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-359">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1b050-360">Calcule le nombre de caractères produits par le décodage d'une séquence d'octets.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-360">Calculates the number of characters produced by decoding a sequence of bytes.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="1b050-361">Pointeur du premier octet à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-361">A pointer to the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="1b050-362">Nombre d'octets à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-362">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-363">Calcule le nombre de caractères produits par le décodage d'une séquence d'octets commençant au pointeur d'octet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-363">Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-364">Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-364">The number of characters produced by decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-365">Pour calculer la taille de tableau exact qui <xref:System.Text.UnicodeEncoding.GetChars%2A> pour stocker les caractères obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-365">To calculate the exact array size that <xref:System.Text.UnicodeEncoding.GetChars%2A> requires to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1b050-366">Pour calculer la taille maximale du tableau, l’application doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-366">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="1b050-367">Le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="1b050-367">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1b050-368">Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="1b050-368">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="1b050-369">Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="1b050-369">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1b050-370">
            <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-370">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-371">
            <paramref name="count" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-371">
              <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="1b050-372">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-372">-or-</span>
          </span>
          <span data-ttu-id="1b050-373">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-373">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1b050-374">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-374">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="1b050-375">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-375">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-376">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-376">-and-</span>
          </span>
          <span data-ttu-id="1b050-377">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-377">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="1b050-378">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-378">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="1b050-379">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-379">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="1b050-380">Tableau d'octets contenant la séquence d'octets à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-380">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="1b050-381">Index du premier octet à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-381">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="1b050-382">Nombre d'octets à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-382">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-383">Calcule le nombre de caractères produits par le décodage d'une séquence d'octets du tableau d'octets spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-383">Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-384">Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-384">The number of characters produced by decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-385">Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetChars%2A> pour stocker les caractères obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-385">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetChars%2A> to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1b050-386">Pour calculer la taille maximale du tableau, l’application doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-386">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="1b050-387">Le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="1b050-387">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1b050-388">Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="1b050-388">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="1b050-389">Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="1b050-389">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-390">L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode pour retourner le nombre de caractères produits par le décodage d’une plage d’éléments dans un tableau d’octets à l’aide <xref:System.Text.UnicodeEncoding>.</span><span class="sxs-lookup"><span data-stu-id="1b050-390">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method to return the number of characters produced by decoding a range of elements in a byte array using <xref:System.Text.UnicodeEncoding>.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1b050-391">
            <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-391">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-392">
            <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-392">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="1b050-393">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-393">-or-</span>
          </span>
          <span data-ttu-id="1b050-394">
            <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-394">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
          <span data-ttu-id="1b050-395">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-395">-or-</span>
          </span>
          <span data-ttu-id="1b050-396">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-396">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1b050-397">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-397">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="1b050-398">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-398">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-399">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-399">-and-</span>
          </span>
          <span data-ttu-id="1b050-400">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-400">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="1b050-401">Décode une séquence d'octets en un jeu de caractères.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-401">Decodes a sequence of bytes into a set of characters.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="1b050-402">Pointeur du premier octet à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-402">A pointer to the first byte to decode.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="1b050-403">Nombre d'octets à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-403">The number of bytes to decode.</span>
          </span>
        </param>
        <param name="chars">
          <span data-ttu-id="1b050-404">Pointeur de l'emplacement où commencer l'écriture du jeu de caractères obtenu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-404">A pointer to the location at which to start writing the resulting set of characters.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="1b050-405">Nombre maximal de caractères à écrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-405">The maximum number of characters to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-406">Décode une séquence d'octets commençant au pointeur d'octet spécifié en un jeu de caractères qui sera stocké à partir du pointeur de caractère spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-406">Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-407">Nombre réel de caractères écrits à l'emplacement indiqué par le paramètre <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-407">The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-408">Pour calculer la taille de tableau exact qui <xref:System.Text.UnicodeEncoding.GetChars%2A> pour stocker les caractères obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-408">To calculate the exact array size that <xref:System.Text.UnicodeEncoding.GetChars%2A> requires to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1b050-409">Pour calculer la taille maximale du tableau, l’application doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-409">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="1b050-410">Le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="1b050-410">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1b050-411">Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="1b050-411">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="1b050-412">Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="1b050-412">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1b050-413">Si la plage d’octets à décoder inclut la marque d’ordre d’octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-BOM, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="1b050-413">If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</span></span> <span data-ttu-id="1b050-414">Vous pouvez le supprimer en appelant le <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-414">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="1b050-415">Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels.</span><span class="sxs-lookup"><span data-stu-id="1b050-415">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1b050-416">Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou le <xref:System.Text.Encoder> objet fourni par le <xref:System.Text.UnicodeEncoding.GetDecoder%2A> ou <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (méthode), respectivement.</span><span class="sxs-lookup"><span data-stu-id="1b050-416">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1b050-417">
            <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-417">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
          <span data-ttu-id="1b050-418">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-418">-or-</span>
          </span>
          <span data-ttu-id="1b050-419">
            <paramref name="chars" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-419">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-420">
            <paramref name="byteCount" /> ou <paramref name="charCount" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-420">
              <paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1b050-421">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-421">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
          <span data-ttu-id="1b050-422">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-422">-or-</span>
          </span>
          <span data-ttu-id="1b050-423">
            <paramref name="charCount" /> est inférieur au nombre de caractères obtenus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-423">
              <paramref name="charCount" /> is less than the resulting number of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="1b050-424">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-424">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-425">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-425">-and-</span>
          </span>
          <span data-ttu-id="1b050-426">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-426">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="1b050-427">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-427">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="1b050-428">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-428">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="1b050-429">Tableau d'octets contenant la séquence d'octets à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-429">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="byteIndex">
          <span data-ttu-id="1b050-430">Index du premier octet à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-430">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="1b050-431">Nombre d'octets à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-431">The number of bytes to decode.</span>
          </span>
        </param>
        <param name="chars">
          <span data-ttu-id="1b050-432">Tableau de caractères destiné à contenir le jeu de caractères obtenu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-432">The character array to contain the resulting set of characters.</span>
          </span>
        </param>
        <param name="charIndex">
          <span data-ttu-id="1b050-433">Index auquel commencer l'écriture du jeu de caractères obtenu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-433">The index at which to start writing the resulting set of characters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-434">Décode une séquence d'octets du tableau d'octets spécifié dans le tableau de caractères spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-434">Decodes a sequence of bytes from the specified byte array into the specified character array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-435">Nombre réel de caractères écrits dans <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-435">The actual number of characters written into <paramref name="chars" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-436">Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetChars%2A> pour stocker les caractères obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-436">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetChars%2A> to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1b050-437">Pour calculer la taille maximale du tableau, l’application doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-437">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="1b050-438">Le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="1b050-438">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1b050-439">Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="1b050-439">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="1b050-440">Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="1b050-440">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1b050-441">Si la plage d’octets à décoder inclut la marque d’ordre d’octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-BOM, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="1b050-441">If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</span></span> <span data-ttu-id="1b050-442">Vous pouvez le supprimer en appelant le <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-442">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="1b050-443">Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels.</span><span class="sxs-lookup"><span data-stu-id="1b050-443">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1b050-444">Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UnicodeEncoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (méthode), respectivement.</span><span class="sxs-lookup"><span data-stu-id="1b050-444">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> method or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-445">L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.GetChars%2A> méthode à décoder une plage d’éléments dans un tableau d’octets et stocker le résultat dans un tableau de caractères.</span><span class="sxs-lookup"><span data-stu-id="1b050-445">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetChars%2A> method to decode a range of elements in a byte array and store the result in a character array.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1b050-446">
            <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-446">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
          <span data-ttu-id="1b050-447">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-447">-or-</span>
          </span>
          <span data-ttu-id="1b050-448">
            <paramref name="chars" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-448">
              <paramref name="chars" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-449">
            <paramref name="byteIndex" />, <paramref name="byteCount" /> ou <paramref name="charIndex" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-449">
              <paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="1b050-450">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-450">-or-</span>
          </span>
          <span data-ttu-id="1b050-451">
            <paramref name="byteindex" /> et <paramref name="byteCount" /> ne désignent pas une plage valide dans <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-451">
              <paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
          <span data-ttu-id="1b050-452">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-452">-or-</span>
          </span>
          <span data-ttu-id="1b050-453">
            <paramref name="charIndex" /> n'est pas un index valide dans <paramref name="chars" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-453">
              <paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1b050-454">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-454">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
          <span data-ttu-id="1b050-455">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-455">-or-</span>
          </span>
          <span data-ttu-id="1b050-456">
            <paramref name="chars" /> ne possède pas une capacité suffisante entre <paramref name="charIndex" /> et la fin du tableau pour prendre en charge les caractères obtenus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-456">
              <paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="1b050-457">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-457">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-458">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-458">-and-</span>
          </span>
          <span data-ttu-id="1b050-459">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-459">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="unicodeEncoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1b050-460">Obtient un décodeur qui convertit une séquence d'octets encodée en UTF-16 en une séquence de caractères Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-460">Obtains a decoder that converts a UTF-16 encoded sequence of bytes into a sequence of Unicode characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-461">
            <see cref="T:System.Text.Decoder" /> qui convertit une séquence d'octets encodée en UTF-16 en une séquence de caractères Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-461">A <see cref="T:System.Text.Decoder" /> that converts a UTF-16 encoded sequence of bytes into a sequence of Unicode characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-462">Le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> méthode convertit des blocs d’octets séquentiels en blocs de caractères, d’une manière similaire à la <xref:System.Text.UnicodeEncoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-462">The <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.UnicodeEncoding.GetChars%2A>.</span></span> <span data-ttu-id="1b050-463">Toutefois, un <xref:System.Text.Decoder> conserve les informations d’état entre les appels, de sorte qu’il peut décoder correctement les séquences d’octets qui s’étendent sur des blocs.</span><span class="sxs-lookup"><span data-stu-id="1b050-463">However, a <xref:System.Text.Decoder> maintains state information between calls so it can correctly decode byte sequences that span blocks.</span></span> <span data-ttu-id="1b050-464">Le <xref:System.Text.Decoder> également conserve les octets de fin à la fin des blocs de données et utilise les octets de fin dans la prochaine opération de décodage.</span><span class="sxs-lookup"><span data-stu-id="1b050-464">The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</span></span> <span data-ttu-id="1b050-465">Par conséquent, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> et <xref:System.Text.UnicodeEncoding.GetEncoder%2A> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.</span><span class="sxs-lookup"><span data-stu-id="1b050-465">Therefore, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> and <xref:System.Text.UnicodeEncoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 <span data-ttu-id="1b050-466">Si la détection d’erreurs est activée, autrement dit, si le `throwOnInvalidBytes` paramètre du constructeur est défini sur `true`, détection d’erreurs est également activée dans le <xref:System.Text.Decoder> retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="1b050-466">If error detection is enabled, that is, the `throwOnInvalidBytes` parameter of the constructor is set to `true`, error detection is also enabled in the <xref:System.Text.Decoder> returned by this method.</span></span> <span data-ttu-id="1b050-467">Si la détection d’erreurs est activée et une séquence non valide est rencontrée, l’état du décodeur n’est pas défini et le traitement doit s’arrêter.</span><span class="sxs-lookup"><span data-stu-id="1b050-467">If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-468">L’exemple suivant utilise un encodeur et un décodeur pour encoder une chaîne en un tableau d’octets, puis décode les octets dans un tableau de caractères.</span><span class="sxs-lookup"><span data-stu-id="1b050-468">The following example uses an encoder and a decoder to encode a string into an array of bytes, and then decode the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="unicodeEncoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1b050-469">Obtient un encodeur qui convertit une séquence de caractères Unicode en une séquence d'octets encodée en UTF-16.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-469">Obtains an encoder that converts a sequence of Unicode characters into a UTF-16 encoded sequence of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-470">Un objet <see cref="T:System.Text.Encoder" /> qui convertit une séquence de caractères Unicode en une séquence d'octets encodée en UTF-16.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-470">A <see cref="T:System.Text.Encoder" /> object that converts a sequence of Unicode characters into a UTF-16 encoded sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-471">Le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> méthode convertit des blocs de caractères séquentiels en blocs d’octets d’une manière similaire à la <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode de cette classe.</span><span class="sxs-lookup"><span data-stu-id="1b050-471">The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method converts sequential blocks of characters into sequential blocks of bytes in a manner similar to the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method of this class.</span></span> <span data-ttu-id="1b050-472">Toutefois, un <xref:System.Text.Encoder> objet conserve les informations d’état entre les appels et peut donc encoder correctement les séquences de caractères qui s’étendent sur des blocs.</span><span class="sxs-lookup"><span data-stu-id="1b050-472">However, a <xref:System.Text.Encoder> object maintains state information between calls so that it can correctly encode character sequences that span blocks.</span></span> <span data-ttu-id="1b050-473">Le <xref:System.Text.Encoder> objet également conserve les caractères de fin à la fin des blocs de données et utilise les caractères de fin de la prochaine opération de codage.</span><span class="sxs-lookup"><span data-stu-id="1b050-473">The <xref:System.Text.Encoder> object also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</span></span> <span data-ttu-id="1b050-474">Par exemple, un bloc de données peut se terminer par un substitut étendu non apparié, et le substitut faible correspondant peut se trouver dans le bloc de données suivant.</span><span class="sxs-lookup"><span data-stu-id="1b050-474">For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</span></span> <span data-ttu-id="1b050-475">Par conséquent, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> et <xref:System.Text.UnicodeEncoding.GetEncoder%2A> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.</span><span class="sxs-lookup"><span data-stu-id="1b050-475">Therefore, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> and <xref:System.Text.UnicodeEncoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 <span data-ttu-id="1b050-476">Si la détection d’erreurs est activée, autrement dit, si le `throwOnInvalidBytes` paramètre du constructeur est défini sur `true`, détection d’erreurs est également activée dans le <xref:System.Text.Encoder> objet retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="1b050-476">If error detection is enabled, that is, the `throwOnInvalidBytes` parameter of the constructor is set to `true`, error detection is also enabled in the <xref:System.Text.Encoder> object returned by this method.</span></span> <span data-ttu-id="1b050-477">Si la détection d’erreurs est activée et une séquence non valide est rencontrée, l’état de l’encodeur n’est pas défini et le traitement doit s’arrêter.</span><span class="sxs-lookup"><span data-stu-id="1b050-477">If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-478">L’exemple suivant utilise un encodeur et un décodeur pour encoder une chaîne en un tableau d’octets, puis décode les octets dans un tableau de caractères.</span><span class="sxs-lookup"><span data-stu-id="1b050-478">The following example uses an encoder and a decoder to encode a string into an array of bytes, and then decode the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="unicodeEncoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1b050-479">Retourne le code de hachage pour l'instance actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-479">Returns the hash code for the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-480">Code de hachage pour l'objet <see cref="T:System.Text.UnicodeEncoding" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-480">The hash code for the current <see cref="T:System.Text.UnicodeEncoding" /> object.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="unicodeEncoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">
          <span data-ttu-id="1b050-481">Nombre de caractères à encoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-481">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-482">Calcule le nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-482">Calculates the maximum number of bytes produced by encoding the specified number of characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-483">Nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-483">The maximum number of bytes produced by encoding the specified number of characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-484">Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetBytes%2A> pour stocker les octets obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-484">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetBytes%2A> to store the resulting bytes, the application uses <xref:System.Text.UnicodeEncoding.GetByteCount%2A>.</span></span> <span data-ttu-id="1b050-485">Pour calculer la taille maximale du tableau, l’application doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-485">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.</span></span> <span data-ttu-id="1b050-486">Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="1b050-486">The <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1b050-487"><xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Récupère un nombre le plus défavorable, y compris le pire des cas correspondant à votre actuellement <xref:System.Text.EncoderFallback>.</span><span class="sxs-lookup"><span data-stu-id="1b050-487"><xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>.</span></span> <span data-ttu-id="1b050-488">Si une procédure de secours est choisi avec une chaîne potentiellement grande, <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> peut retourner des valeurs élevées.</span><span class="sxs-lookup"><span data-stu-id="1b050-488">If a fallback is chosen with a potentially large string, <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> can return large values.</span></span>  
  
 <span data-ttu-id="1b050-489">Dans la plupart des cas, cette méthode récupère un nombre raisonnable pour les petites chaînes.</span><span class="sxs-lookup"><span data-stu-id="1b050-489">In most cases, this method retrieves reasonable numbers for small strings.</span></span> <span data-ttu-id="1b050-490">Pour les chaînes de grande taille, vous devrez peut-être choisir entre l’utilisation de mémoires tampons de grande et interception des erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est dépassée.</span><span class="sxs-lookup"><span data-stu-id="1b050-490">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</span></span> <span data-ttu-id="1b050-491">Vous pourriez également envisager une approche différente à l’aide <xref:System.Text.UnicodeEncoding.GetByteCount%2A> ou <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1b050-491">You might also want to consider a different approach using <xref:System.Text.UnicodeEncoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1b050-492"><xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> n’a aucun lien avec <xref:System.Text.UnicodeEncoding.GetChars%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-492"><xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> has no relation to <xref:System.Text.UnicodeEncoding.GetChars%2A>.</span></span> <span data-ttu-id="1b050-493">Si votre application a besoin d’une fonction similaire à utiliser avec <xref:System.Text.UnicodeEncoding.GetChars%2A>, il doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-493">If your application needs a similar function to use with <xref:System.Text.UnicodeEncoding.GetChars%2A>, it should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1b050-494">`GetMaxByteCount(N)` n’est pas nécessairement la même valeur que `N* GetMaxByteCount(1)`.</span><span class="sxs-lookup"><span data-stu-id="1b050-494">`GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-495">L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode pour retourner le nombre maximal d’octets nécessaires au codage d’un nombre spécifié de caractères.</span><span class="sxs-lookup"><span data-stu-id="1b050-495">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method to return the maximum number of bytes required to encode a specified number of characters.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-496">
            <paramref name="charCount" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-496">
              <paramref name="charCount" /> is less than zero.</span>
          </span>
          <span data-ttu-id="1b050-497">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-497">-or-</span>
          </span>
          <span data-ttu-id="1b050-498">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-498">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="1b050-499">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-499">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-500">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-500">-and-</span>
          </span>
          <span data-ttu-id="1b050-501">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-501">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="unicodeEncoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">
          <span data-ttu-id="1b050-502">Nombre d'octets à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-502">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-503">Calcule le nombre maximal de caractères produits par le décodage du nombre d'octets spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-503">Calculates the maximum number of characters produced by decoding the specified number of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-504">Nombre maximal de caractères produits par le décodage du nombre d'octets spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-504">The maximum number of characters produced by decoding the specified number of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-505">Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetChars%2A> pour stocker les caractères obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-505">To calculate the exact array size required by <xref:System.Text.UnicodeEncoding.GetChars%2A> to store the resulting characters, the application uses <xref:System.Text.UnicodeEncoding.GetCharCount%2A>.</span></span> <span data-ttu-id="1b050-506">Pour calculer la taille maximale du tableau, l’application doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-506">To calculate the maximum array size, the application should use <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.</span></span> <span data-ttu-id="1b050-507">Le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="1b050-507">The <xref:System.Text.UnicodeEncoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="1b050-508"><xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Récupère un nombre le plus défavorable, y compris le pire des cas correspondant à votre actuellement <xref:System.Text.DecoderFallback>.</span><span class="sxs-lookup"><span data-stu-id="1b050-508"><xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>.</span></span> <span data-ttu-id="1b050-509">Si une procédure de secours est choisi avec une chaîne potentiellement grande, <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> récupère des valeurs élevées.</span><span class="sxs-lookup"><span data-stu-id="1b050-509">If a fallback is chosen with a potentially large string, <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> retrieves large values.</span></span>  
  
 <span data-ttu-id="1b050-510">Dans la plupart des cas, cette méthode récupère un nombre raisonnable pour les petites chaînes.</span><span class="sxs-lookup"><span data-stu-id="1b050-510">In most cases, this method retrieves reasonable numbers for small strings.</span></span> <span data-ttu-id="1b050-511">Pour les chaînes de grande taille, vous devrez peut-être choisir entre l’utilisation de mémoires tampons de grande et interception des erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est dépassée.</span><span class="sxs-lookup"><span data-stu-id="1b050-511">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</span></span> <span data-ttu-id="1b050-512">Vous pourriez également envisager une approche différente à l’aide <xref:System.Text.UnicodeEncoding.GetCharCount%2A> ou <xref:System.Text.Decoder.Convert%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-512">You might also want to consider a different approach using <xref:System.Text.UnicodeEncoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A>.</span></span>  
  
 <span data-ttu-id="1b050-513"><xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> n’a aucun lien avec <xref:System.Text.UnicodeEncoding.GetBytes%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-513"><xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.UnicodeEncoding.GetBytes%2A>.</span></span> <span data-ttu-id="1b050-514">Si votre application a besoin d’une fonction similaire à utiliser avec <xref:System.Text.UnicodeEncoding.GetBytes%2A>, il doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.</span><span class="sxs-lookup"><span data-stu-id="1b050-514">If your application needs a similar function to use with <xref:System.Text.UnicodeEncoding.GetBytes%2A>, it should use <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1b050-515">`GetMaxCharCount(N)` n’est pas nécessairement la même valeur que `N* GetMaxCharCount(1)`.</span><span class="sxs-lookup"><span data-stu-id="1b050-515">`GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-516">L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> méthode pour retourner le nombre maximal de caractères produits par le décodage d’un nombre spécifié d’octets.</span><span class="sxs-lookup"><span data-stu-id="1b050-516">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> method to return the maximum number of characters produced by decoding a specified number of bytes.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-517">
            <paramref name="byteCount" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-517">
              <paramref name="byteCount" /> is less than zero.</span>
          </span>
          <span data-ttu-id="1b050-518">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-518">-or-</span>
          </span>
          <span data-ttu-id="1b050-519">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-519">The resulting number of bytes is greater than the maximum number that can be returned as an integer.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="1b050-520">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-520">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-521">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-521">-and-</span>
          </span>
          <span data-ttu-id="1b050-522">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-522">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="unicodeEncoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="1b050-523">Retourne une marque d'ordre d'octet Unicode au format UTF-16 si le constructeur de cette instance demande une marque d'ordre d'octet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-523">Returns a Unicode byte order mark encoded in UTF-16 format, if the constructor for this instance requests a byte order mark.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-524">Tableau d'octets contenant la marque d'ordre d'octet Unicode, si l'objet <see cref="T:System.Text.UnicodeEncoding" /> est configuré pour en fournir une.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-524">A byte array containing the Unicode byte order mark, if the <see cref="T:System.Text.UnicodeEncoding" /> object is configured to supply one.</span>
          </span>
          <span data-ttu-id="1b050-525">Sinon, cette méthode retourne un tableau d'octets de longueur égale à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-525">Otherwise, this method returns a zero-length byte array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-526">Le <xref:System.Text.UnicodeEncoding> objet peut fournir un préambule, c'est-à-dire un tableau d’octets qui peut porter comme préfixe à la séquence d’octets résultant du processus de codage.</span><span class="sxs-lookup"><span data-stu-id="1b050-526">The <xref:System.Text.UnicodeEncoding> object can provide a preamble, which is a byte array that can be prefixed to the sequence of bytes resulting from the encoding process.</span></span> <span data-ttu-id="1b050-527">En le faisant précéder une séquence d’octets encodées avec une marque d’ordre d’octet (point de code U + FEFF) aide le décodeur à déterminer l’ordre d’octet et que le format de transformation ou UTF.</span><span class="sxs-lookup"><span data-stu-id="1b050-527">Prefacing a sequence of encoded bytes with a byte order mark (code point U+FEFF) helps the decoder determine the byte order and the transformation format or UTF.</span></span> <span data-ttu-id="1b050-528">La marque d’ordre octet Unicode (BOM) est sérialisée comme suit (hexadécimal) :</span><span class="sxs-lookup"><span data-stu-id="1b050-528">The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</span></span>  
  
-   <span data-ttu-id="1b050-529">Ordre de primauté des octets : FE FF</span><span class="sxs-lookup"><span data-stu-id="1b050-529">Big endian byte order: FE FF</span></span>  
  
-   <span data-ttu-id="1b050-530">Primauté des octets : FF FE</span><span class="sxs-lookup"><span data-stu-id="1b050-530">Little endian byte order: FF FE</span></span>  
  
 <span data-ttu-id="1b050-531">Vous pouvez instancier un <xref:System.Text.UnicodeEncoding> de l’objet dont la propriété <xref:System.Text.UnicodeEncoding.GetPreamble%2A> méthode retourne une nomenclature valide comme suit :</span><span class="sxs-lookup"><span data-stu-id="1b050-531">You can instantiate a <xref:System.Text.UnicodeEncoding> object whose <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method returns a valid BOM in the following ways:</span></span>  
  
-   <span data-ttu-id="1b050-532">En récupérant le <xref:System.Text.UnicodeEncoding> objet retourné par la <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> ou <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="1b050-532">By retrieving the <xref:System.Text.UnicodeEncoding> object returned by the <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> or <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> property.</span></span>  
  
-   <span data-ttu-id="1b050-533">En appelant sans paramètre <xref:System.Text.UnicodeEncoding.%23ctor> constructeur pour instancier un <xref:System.Text.UnicodeEncoding> objet.</span><span class="sxs-lookup"><span data-stu-id="1b050-533">By calling the parameterless <xref:System.Text.UnicodeEncoding.%23ctor> constructor to instantiate a <xref:System.Text.UnicodeEncoding> object.</span></span>  
  
-   <span data-ttu-id="1b050-534">En fournissant `true` comme valeur de la `byteOrderMark` l’argument de la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> ou <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructeurs.</span><span class="sxs-lookup"><span data-stu-id="1b050-534">By supplying `true` as the value of the `byteOrderMark` argument to the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> or <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructors.</span></span>  
  
 <span data-ttu-id="1b050-535">Nous recommandons que vous utilisez la nomenclature, dans la mesure où il fournit une certaine identification d’un encodage pour les fichiers qui ont perdu une référence à leur codage, telles que sans balise ou incorrectement référencées données web ou des fichiers texte aléatoires stockés lorsqu’une entreprise ne disposait pas problèmes internationaux.</span><span class="sxs-lookup"><span data-stu-id="1b050-535">We recommended that you use the BOM, since it provides nearly certain identification of an encoding for files that otherwise have lost a reference to their encoding, such as untagged or improperly tagged web data or random text files stored when a business did not have international concerns.</span></span> <span data-ttu-id="1b050-536">Souvent les problèmes d’utilisateur peuvent être évités si les données sont balisées de façon cohérente et correctement.</span><span class="sxs-lookup"><span data-stu-id="1b050-536">Often user problems might be avoided if data is consistently and properly tagged.</span></span>  
  
 <span data-ttu-id="1b050-537">Des normes qui fournissent un type de codage, un BOM est quelque peu redondant.</span><span class="sxs-lookup"><span data-stu-id="1b050-537">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="1b050-538">Toutefois, il peut être utilisé pour aider à un serveur d’envoyer l’en-tête de codage correct.</span><span class="sxs-lookup"><span data-stu-id="1b050-538">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="1b050-539">Ou bien, il peut être utilisé comme solution de secours si l’encodage est perdu.</span><span class="sxs-lookup"><span data-stu-id="1b050-539">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>  
  
 <span data-ttu-id="1b050-540">Il existe certains inconvénients à l’utilisation d’une nomenclature.</span><span class="sxs-lookup"><span data-stu-id="1b050-540">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="1b050-541">Par exemple, savoir comment limiter les champs de base de données qui utilisent un BOM peut être difficile.</span><span class="sxs-lookup"><span data-stu-id="1b050-541">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="1b050-542">Concaténation de fichiers peut être un problème également, par exemple, lorsque les fichiers sont fusionnés de telle façon un caractère inutile peut se retrouver au milieu des données.</span><span class="sxs-lookup"><span data-stu-id="1b050-542">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="1b050-543">Malgré le peu d’inconvénients, cependant, l’utilisation d’une nomenclature est hautement recommandée.</span><span class="sxs-lookup"><span data-stu-id="1b050-543">In spite of the few disadvantages, however, the use of a BOM is highly recommended.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="1b050-544">Pour vous assurer que les octets encodés sont décodés correctement, vous devez précéder le début d’un flux d’octets encodés avec un préambule.</span><span class="sxs-lookup"><span data-stu-id="1b050-544">To ensure that the encoded bytes are decoded properly, you should prefix the beginning of a stream of encoded bytes with a preamble.</span></span> <span data-ttu-id="1b050-545">Notez que le <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode ne doit pas une nomenclature à une séquence d’octets encodés ; en fournissant une nomenclature au début d’un flux d’octets approprié est la responsabilité du développeur.</span><span class="sxs-lookup"><span data-stu-id="1b050-545">Note that the <xref:System.Text.UnicodeEncoding.GetBytes%2A> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-546">L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.GetPreamble%2A> méthode pour récupérer la marque d’ordre d’octet Unicode dans le big endian ou little ordre de primauté des octets d’une instance d’un <xref:System.Text.UnicodeEncoding>.</span><span class="sxs-lookup"><span data-stu-id="1b050-546">The following example demonstrates how to use the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method to retrieve the Unicode byte order mark in big endian or little endian byte order for an instance of a <xref:System.Text.UnicodeEncoding>.</span></span>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 <span data-ttu-id="1b050-547">L’exemple suivant instancie deux <xref:System.Text.UnicodeEncoding> objets, le premier d'entre eux ne fournit pas une nomenclature et qui effectue la deuxième.</span><span class="sxs-lookup"><span data-stu-id="1b050-547">The following example instantiates two <xref:System.Text.UnicodeEncoding> objects, the first of which does not provide a BOM, and the second of which does.</span></span> <span data-ttu-id="1b050-548">Il appelle ensuite la <xref:System.Text.UnicodeEncoding.GetPreamble%2A> méthode pour écrire la marque BOM dans un fichier avant d’écrire une chaîne encodée en Unicode.</span><span class="sxs-lookup"><span data-stu-id="1b050-548">It then calls the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method to write the BOM to a file before writing a Unicode-encoded string.</span></span> <span data-ttu-id="1b050-549">Comme le montre la sortie de l’exemple de console, le fichier qui enregistre les octets à partir de la deuxième encodeur comporte trois davantage d’octets que la première.</span><span class="sxs-lookup"><span data-stu-id="1b050-549">As the console output from the example shows, the file that saves the bytes from the second encoder has three more bytes than the first.</span></span>  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 <span data-ttu-id="1b050-550">Vous pouvez également comparer les fichiers à l’aide de la `fc` commande dans une fenêtre de console, ou vous pouvez inspecter les fichiers dans un éditeur de texte qui inclut un mode d’affichage de format hexadécimal.</span><span class="sxs-lookup"><span data-stu-id="1b050-550">You can also compare the files by using the `fc` command in a console window, or you can inspect the files in a text editor that includes a Hex View mode.</span></span> <span data-ttu-id="1b050-551">Notez que lorsque le fichier est ouvert dans un éditeur qui prend en charge l’encodage UTF-16, la marque BOM n’est pas affiché.</span><span class="sxs-lookup"><span data-stu-id="1b050-551">Note that when the file is opened in an editor that supports UTF-16 encoding, the BOM is not displayed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="unicodeEncoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="1b050-552">Tableau d'octets contenant la séquence d'octets à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-552">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="1b050-553">Index du premier octet à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-553">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="1b050-554">Nombre d'octets à décoder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-554">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="1b050-555">Décode une plage d'octets d'un tableau d'octets en une chaîne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-555">Decodes a range of bytes from a byte array into a string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="1b050-556">Objet <see cref="T:System.String" /> contenant les résultats du décodage de la séquence d'octets spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-556">A <see cref="T:System.String" /> object containing the results of decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1b050-557">Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="1b050-557">With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>.</span></span> <span data-ttu-id="1b050-558">Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="1b050-558">Without error detection, invalid sequences are ignored, and no exception is thrown.</span></span>  
  
 <span data-ttu-id="1b050-559">Si la plage d’octets à décoder inclut la marque d’ordre d’octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-BOM, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode.</span><span class="sxs-lookup"><span data-stu-id="1b050-559">If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</span></span> <span data-ttu-id="1b050-560">Vous pouvez le supprimer en appelant le <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-560">You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="1b050-561">Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels.</span><span class="sxs-lookup"><span data-stu-id="1b050-561">Data to be converted, such as data read from a stream, might be available only in sequential blocks.</span></span> <span data-ttu-id="1b050-562">Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou le <xref:System.Text.Encoder> objet fourni par le <xref:System.Text.UnicodeEncoding.GetDecoder%2A> ou <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (méthode), respectivement.</span><span class="sxs-lookup"><span data-stu-id="1b050-562">In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.UnicodeEncoding.GetDecoder%2A> or the <xref:System.Text.UnicodeEncoding.GetEncoder%2A> method, respectively.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1b050-563">L’exemple suivant initialise un tableau en appelant le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode pour déterminer exactement combien d’octets est nécessaires pour une chaîne encodée, puis en ajoutant la taille de la marque d’ordre d’octet (BOM).</span><span class="sxs-lookup"><span data-stu-id="1b050-563">The following example initializes an array by calling the <xref:System.Text.UnicodeEncoding.GetByteCount%2A> method to determine exactly how many bytes are required for an encoded string and then adding the size of the byte order mark (BOM).</span></span> <span data-ttu-id="1b050-564">L’exemple appelle ensuite la <xref:System.Text.UnicodeEncoding.GetPreamble%2A> méthode pour stocker la nomenclature dans le tableau avant d’appeler le <xref:System.Text.Encoding.GetBytes%2A> méthode pour stocker les octets encodés dans le tableau.</span><span class="sxs-lookup"><span data-stu-id="1b050-564">The example then calls the <xref:System.Text.UnicodeEncoding.GetPreamble%2A> method to store the BOM to the array before calling the <xref:System.Text.Encoding.GetBytes%2A> method to store the encoded bytes to the array.</span></span> <span data-ttu-id="1b050-565">L’exemple appelle ensuite la <xref:System.Text.UnicodeEncoding.GetString%2A> méthode à décoder la chaîne.</span><span class="sxs-lookup"><span data-stu-id="1b050-565">The example then calls the <xref:System.Text.UnicodeEncoding.GetString%2A> method to decode the string.</span></span>  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 <span data-ttu-id="1b050-566">Notez que dans ce cas la chaîne décodée diffère de la chaîne d’origine, dans la mesure où il commence par une marque d’ordre d’octet de 16 bits U + FFFD.</span><span class="sxs-lookup"><span data-stu-id="1b050-566">Note that in this case the decoded string differs from the original string, since it begins with a 16-bit byte order mark U+FFFD.</span></span> <span data-ttu-id="1b050-567">Cela signifie que les deux chaînes sont considérés comme égaux, et que si la chaîne est sortie, la nomenclature s’affichera en tant que le caractère de remplacement « ? ».</span><span class="sxs-lookup"><span data-stu-id="1b050-567">This means that the two strings will compare as unequal, and that if the string is output, the BOM will be displayed as the replacement character "?".</span></span> <span data-ttu-id="1b050-568">Pour supprimer la marque BOM au début de la chaîne, vous pouvez appeler la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="1b050-568">To remove the BOM at the beginning of the string, you can call the <xref:System.String.TrimStart%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="1b050-569">
            <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-569">
              <paramref name="bytes" /> is <see langword="null" /> (<see langword="Nothing" />).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="1b050-570">
            <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-570">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="1b050-571">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-571">-or-</span>
          </span>
          <span data-ttu-id="1b050-572">
            <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="bytes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-572">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="1b050-573">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-573">Error detection is enabled, and <paramref name="bytes" /> contains an invalid sequence of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="1b050-574">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète)</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-574">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for fuller explanation)</span>
          </span>
          <span data-ttu-id="1b050-575">-et-</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-575">-and-</span>
          </span>
          <span data-ttu-id="1b050-576">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="1b050-576">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>