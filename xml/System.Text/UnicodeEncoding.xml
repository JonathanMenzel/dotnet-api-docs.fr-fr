<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d2a94f37e28b665d37de1abced900273f0f295e0" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52376020" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UnicodeEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnicodeEncoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UnicodeEncoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un encodage UTF-16 de caractères Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'encodage est le processus de transformation d'un jeu de caractères Unicode en une séquence d'octets. Le décodage est le processus de transformation d’une séquence d’octets codés en un jeu de caractères Unicode.  
  
 Le [norme Unicode](https://go.microsoft.com/fwlink/?linkid=37123) assigne un point de code (nombre) à chaque caractère dans chaque script pris en charge. Un Format UTF (Unicode Transformation) est un moyen pour encoder ce point de code. Le [norme Unicode](https://go.microsoft.com/fwlink/?linkid=37123) utilise les formats UTF suivants :  
  
-   UTF-8, qui représente chaque point de code sous la forme d’une séquence d’un à quatre octets.  
  
-   UTF-16, ce qui représente chaque point de code sous la forme d’une séquence d’entiers 16 bits d’une à deux.  
  
-   UTF-32, ce qui représente chaque point de code sous la forme d’un entier 32 bits.  
  
 Pour plus d’informations sur les formats UTF et d’autres encodages pris en charge par <xref:System.Text>, consultez [encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Le <xref:System.Text.UnicodeEncoding> classe représente un encodage UTF-16. L’encodeur peut utiliser l’ordre de primauté des octets (octet le plus significatif premier) ou primauté des octets (octet le moins significatif premier). Par exemple, la lettre majuscule latine A (point de code U + 0041) est sérialisée comme suit (en hexadécimal) :  
  
-   Ordre de primauté des octets : 00 00 00 41  
  
-   Primauté des octets : 41 00 00 00  
  
 Il est généralement plus efficace pour stocker des caractères Unicode à l’aide de l’ordre d’octet natif d’une plateforme spécifique. Par exemple, il est préférable d’utiliser l’ordre d’octet avec primauté sur des plateformes little-endian, tels que des ordinateurs Intel. Le <xref:System.Text.UnicodeEncoding> classe correspond aux pages de codes 1200 (ordre de primauté des octets little) et 1201 (ordre de primauté des octets) de Windows. Vous pouvez déterminer le « endianness » d’une architecture particulière en appelant le <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> (méthode).  
  
 Si vous le souhaitez, le <xref:System.Text.UnicodeEncoding> objet fournit une marque d’ordre d’octet (BOM), qui est un tableau d’octets qui peut porter comme préfixe à la séquence d’octets résultant du processus de codage. Si le préambule contient une marque d’ordre d’octet (BOM), il aide le décodeur à déterminer l’ordre d’octet et que le format de transformation ou UTF.  
  
 Si le <xref:System.Text.UnicodeEncoding> instance est configurée pour fournir une nomenclature, vous pouvez le récupérer en appelant le <xref:System.Text.UnicodeEncoding.GetPreamble%2A> méthode ; sinon, la méthode retourne un tableau vide. Notez que, même si un <xref:System.Text.UnicodeEncoding> objet est configuré pour prendre en charge de la nomenclature, vous devez inclure la marque BOM au début du flux d’octets encodé selon le cas ; les méthodes d’encodage de la <xref:System.Text.UnicodeEncoding> classe ne le faites pas cela automatiquement.  
  
 Pour activer la détection d’erreur et pour renforcer la sécurité de l’instance de classe, vous devez instancier un <xref:System.Text.UnicodeEncoding> objet en appelant le <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructeur et en définissant son `throwOnInvalidBytes` argument `true`. Avec la détection d’erreurs, une méthode qui détecte une séquence de caractères ou d’octets non valide lève une <xref:System.ArgumentException>. Absence de détection d’erreur, aucune exception n’est levée, et la séquence non valide est généralement ignorée.  
  
 Vous pouvez instancier un <xref:System.Text.UnicodeEncoding> objet dans un nombre de façons, selon que vous souhaitiez lui fournir une marque d’ordre d’octet (BOM), si vous souhaitez codage big-endian ou little-endian, et si vous souhaitez activer la détection d’erreur. Le tableau suivant répertorie les <xref:System.Text.UnicodeEncoding> constructeurs et les <xref:System.Text.Encoding> propriétés qui retournent un <xref:System.Text.UnicodeEncoding> objet.  
  
|Membre|Endianness|NOMENCLATURE|Détection d’erreurs|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|Big-endian|Oui|Aucun (remplacement de secours)|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>|Little endian|Oui|Aucun (remplacement de secours)|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=nameWithType>|Little endian|Oui|Aucun (remplacement de secours)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|Configurable|Configurable|Aucun (remplacement de secours)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurable|Configurable|Configurable|  
  
 Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode exécute le codage.  
  
 De même, le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et le <xref:System.Text.UnicodeEncoding.GetChars%2A> et <xref:System.Text.UnicodeEncoding.GetString%2A> méthodes effectuent le décodage réel.  
  
 Pour un encodeur ou un décodeur qui est en mesure d’enregistrer les informations d’état lors de l’encodage ou de décodage de données qui s’étend sur plusieurs blocs (par exemple, la chaîne de 1 million de caractères qui est encodé dans les segments de 100 000 caractères), utilisez le <xref:System.Text.UnicodeEncoding.GetEncoder%2A> et <xref:System.Text.UnicodeEncoding.GetDecoder%2A> propriétés, respectivement.  
  
   
  
## Examples  
 L’exemple suivant montre comment encoder une chaîne de caractères Unicode en tableau d’octets à l’aide un <xref:System.Text.UnicodeEncoding> objet. Le tableau d’octets est décodé en une chaîne pour montrer qu’il n’existe aucune perte de données.  
  
 [!code-cpp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 L’exemple suivant utilise la même chaîne que la précédente, sauf qu’il écrit les octets encodés dans un fichier et le flux d’octets avec une marque d’ordre d’octet (BOM) de préfixes. Elle lit ensuite le fichier de deux manières différentes : en tant qu’un fichier texte à l’aide un <xref:System.IO.StreamReader> de l’objet ; et comme un fichier binaire. Comme vous pouvez l’imaginer, aucune chaîne qui vient d’être en lecture inclut la nomenclature.  
  
 [!code-csharp[System.Text.UnicodeEncoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Encodages de présentation</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.UnicodeEncoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.UnicodeEncoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée une instance qui utilise l’ordre d’octet avec primauté, fournit la marque d’ordre d’octet Unicode et ne lève pas d’exception lorsqu’un encodage non valide est détecté.  
  
> [!NOTE]
>  Pour des raisons de sécurité, vous devez activer la détection d’erreur en appelant le <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructeur et en définissant son `throwOnInvalidBytes` argument `true`.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un nouveau <xref:System.Text.UnicodeEncoding> instance et affichez le nom de l’encodage.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> pour utiliser l'ordre d'octet avec primauté des octets de poids fort (big-endian) (octet le plus significatif en premier) ou <see langword="false" /> pour utiliser l'ordre d'octet avec primauté des octets de poids faible (little-endian) (octet le moins significatif en premier).</param>
        <param name="byteOrderMark">
          <see langword="true" /> pour spécifier que la méthode <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> retourne une marque d'ordre d'octet Unicode ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.UnicodeEncoding" />. Les paramètres indiquent s'il faut utiliser l'ordre d'octet avec primauté des octets de poids fort (big-endian) et si la méthode <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> retourne une marque d'ordre d'octet Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée une instance qui ne lève pas d’exception lorsqu’un encodage non valide est détecté.  
  
> [!NOTE]
>  Pour des raisons de sécurité, vous devez activer la détection d’erreur en appelant le <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructeur et en définissant son `throwOnInvalidBytes` argument `true`.  
  
 Le `byteOrderMark` paramètre contrôle le fonctionnement de la <xref:System.Text.UnicodeEncoding.GetPreamble%2A> (méthode). Si `true`, la méthode retourne un tableau d’octets contenant la marque d’ordre d’octet Unicode (BOM) au format UTF-16.  Si `false`, elle retourne un tableau d’octets de longueur nulle. Toutefois, l’affectation `byteOrderMark` à `true` n’entraîne pas la <xref:System.Text.UnicodeEncoding.GetBytes%2A> (méthode) pour préfixer la nomenclature au début du tableau d’octets, et ne déclenche le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode pour inclure le nombre d’octets dans la nomenclature dans le nombre d’octets.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer un nouveau <xref:System.Text.UnicodeEncoding> marque d’ordre d’instance en spécifiant s’il faut prendre en charge le classement des octets little endian ou big endian et l’octet Unicode.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> pour utiliser l'ordre d'octet avec primauté des octets de poids fort (big-endian) (octet le plus significatif en premier) ; <see langword="false" /> pour utiliser l'ordre d'octet avec primauté des octets de poids faible (little-endian) (octet le moins significatif en premier).</param>
        <param name="byteOrderMark">
          <see langword="true" /> pour spécifier que la méthode <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> retourne une marque d'ordre d'octet Unicode ; sinon, <see langword="false" />.</param>
        <param name="throwOnInvalidBytes">
          <see langword="true" /> pour spécifier qu'une exception doit être levée quand un encodage non valide est détecté ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.UnicodeEncoding" />. Les paramètres indiquent s'il faut utiliser l'ordre d'octet avec primauté des octets de poids fort (big-endian), fournir une marque d'ordre d'octet Unicode et lever une exception en cas de détection d'un encodage non valide.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `byteOrderMark` paramètre contrôle le fonctionnement de la <xref:System.Text.UnicodeEncoding.GetPreamble%2A> (méthode). Si `true`, la méthode retourne un tableau d’octets contenant la marque d’ordre d’octet Unicode (BOM) au format UTF-16.  Si `false`, elle retourne un tableau d’octets de longueur nulle. Toutefois, l’affectation `byteOrderMark` à `true` n’entraîne pas la <xref:System.Text.UnicodeEncoding.GetBytes%2A> (méthode) pour préfixer la nomenclature au début du tableau d’octets, et ne déclenche le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode pour inclure le nombre d’octets dans la nomenclature dans le nombre d’octets.  
  
 Si le `throwOnInvalidBytes` paramètre est `true`, une méthode qui détecte une séquence d’octets non valide lève <xref:System.ArgumentException?displayProperty=nameWithType>. Sinon, la méthode ne lève pas d’exception et la séquence non valide est ignorée.  
  
> [!NOTE]
>  Pour des raisons de sécurité, il est recommandé d’utiliser ce constructeur pour créer une instance de vos applications le <xref:System.Text.UnicodeEncoding> classe et activer la détection d’erreur en définissant `throwOnInvalidBytes` à `true`.  
  
   
  
## Examples  
 L’exemple suivant illustre le comportement de <xref:System.Text.UnicodeEncoding>, avec la détection d’erreurs et sans.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberSignature Language="VB.NET" Value="Public Const CharSize As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int CharSize = 2;" />
      <MemberSignature Language="F#" Value="val mutable CharSize : int" Usage="System.Text.UnicodeEncoding.CharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Représente la taille des caractères Unicode en octets. Ce champ est une constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de ce champ est une constante signée de 32 bits avec la valeur 2.  
  
   
  
## Examples  
 L’exemple suivant montre comment retourner la valeur de <xref:System.Text.UnicodeEncoding.CharSize> et l’afficher.  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="unicodeEncoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet à comparer à l'objet actuel.</param>
        <summary>Détermine si l'objet <see cref="T:System.Object" /> spécifié est égal à l'objet <see cref="T:System.Text.UnicodeEncoding" /> actuel.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> est une instance de <see cref="T:System.Text.UnicodeEncoding" /> et s'il est égal à l'objet actuel ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deux <xref:System.Text.UnicodeEncoding> objets sont considérés comme égaux si toutes les conditions suivantes sont remplies :  
  
-   Les deux objets utilisent le même ordre d’octet (little-endian ou big-endian).  
  
-   Les deux objets fournissent la marque d’ordre d’octet, ou les deux n’est pas le cas.  
  
-   Les deux objets utilisent le même encodeur de secours.  
  
-   Les deux objets utilisent le même décodeur de secours.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.Equals%2A> méthode pour tester si actuel <xref:System.Text.UnicodeEncoding> objet est égal à un autre <xref:System.Text.UnicodeEncoding> objet. Cinq <xref:System.Text.UnicodeEncoding> objets sont créés et comparées, et les résultats des comparaisons sont affichés.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="unicodeEncoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant le jeu de caractères à encoder.</param>
        <summary>Calcule le nombre d'octets générés en codant les caractères dans la chaîne spécifiée.</summary>
        <returns>Nombre d'octets produits par l'encodage des caractères spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
> [!NOTE]
>  Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (tel qu’au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflété dans la valeur retournée par la <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> (méthode).  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> et <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> méthodes pour calculer le nombre maximal et réel d’octets requis pour encoder une chaîne. Il affiche également le nombre réel d’octets requis pour stocker un flux d’octets avec une marque d’ordre d’octet.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="s" /> contient une séquence de caractères non valide.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Pointeur du premier caractère à encoder.</param>
        <param name="count">Nombre de caractères à encoder.</param>
        <summary>Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères commençant au pointeur de caractère spécifié.</summary>
        <returns>Nombre d'octets produits par l'encodage des caractères spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille de tableau exact qui <xref:System.Text.UnicodeEncoding.GetBytes%2A> requiert pour stocker les octets obtenus, vous devez appeler la <xref:System.Text.UnicodeEncoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
> [!NOTE]
>  Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (tel qu’au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflété dans la valeur retournée par la <xref:System.Text.UTF8Encoding.GetByteCount%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d'erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tableau de caractères contenant le jeu de caractères à encoder.</param>
        <param name="index">Index du premier caractère à encoder.</param>
        <param name="count">Nombre de caractères à encoder.</param>
        <summary>Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères du tableau de caractères spécifié.</summary>
        <returns>Nombre d'octets produits par l'encodage des caractères spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetBytes%2A> pour stocker les octets obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection d’erreurs, une séquence non valide provoque la levée de cette méthode une <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (tel qu’au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflété dans la valeur retournée par la <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> (méthode).  
  
   
  
## Examples  
 L’exemple suivant remplit un tableau avec un Latin en majuscules et minuscules et appelle le <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> méthode pour déterminer le nombre d’octets nécessaires pour encoder les caractères latins minuscules. Il affiche ensuite ces informations ainsi que le nombre total d’octets nécessaire si une marque d’ordre d’octet est ajoutée. Il compare ce nombre avec la valeur retournée par la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode), ce qui indique le nombre maximal d’octets nécessaires pour encoder les caractères latins minuscules. L’exemple suivant remplit un tableau avec une combinaison de caractères grec et cyrillique et appelle le <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> méthode pour déterminer le nombre d’octets nécessaires pour encoder les caractères cyrilliques. Il affiche ensuite ces informations ainsi que le nombre total d’octets nécessaire si une marque d’ordre d’octet est ajoutée. Il compare ce nombre avec la valeur retournée par la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode), ce qui indique le nombre maximal d’octets nécessaires pour encoder les caractères cyrilliques.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="chars" />.  
  
- ou - 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Encode un jeu de caractères en une séquence d'octets.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="unicodeEncoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Pointeur du premier caractère à encoder.</param>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <param name="bytes">Pointeur de l'emplacement où commencer l'écriture de la séquence d'octets obtenue.</param>
        <param name="byteCount">Nombre maximal d'octets à écrire.</param>
        <summary>Code une séquence de caractères commençant au pointeur de caractère spécifié en une séquence d'octets, qui sera stockée à partir du pointeur d'octet spécifié.</summary>
        <returns>Nombre réel d'octets écrits à l'emplacement indiqué par le paramètre <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille de tableau exact qui <xref:System.Text.UnicodeEncoding.GetBytes%2A> requiert pour stocker les octets obtenus, vous devez appeler la <xref:System.Text.UnicodeEncoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou le <xref:System.Text.Encoder> objet fourni par le <xref:System.Text.UnicodeEncoding.GetDecoder%2A> ou <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (méthode), respectivement.  
  
> [!NOTE]
>  Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur. Le <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode ne doit pas un préambule au début d’une séquence d’octets encodées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).  
  
- ou - 
 <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> ou <paramref name="byteCount" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.  
  
- ou - 
 <paramref name="byteCount" /> est inférieur au nombre d'octets obtenus.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tableau de caractères contenant le jeu de caractères à encoder.</param>
        <param name="charIndex">Index du premier caractère à encoder.</param>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <param name="bytes">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</param>
        <param name="byteIndex">Index auquel commencer l'écriture de la séquence d'octets obtenue.</param>
        <summary>Encode un jeu de caractères du tableau de caractères spécifié en un tableau d'octets.</summary>
        <returns>Nombre réel d'octets écrits dans <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UnicodeEncoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (méthode), respectivement.  
  
> [!NOTE]
>  Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur. Le <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode ne doit pas un préambule au début d’une séquence d’octets encodées.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode pour encoder une plage de caractères à partir d’un <xref:System.String> et stocker les octets encodés dans une plage d’éléments dans un tableau d’octets.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).  
  
- ou - 
 <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="charIndex" /> et <paramref name="charCount" /> ne désignent pas une plage valide dans <paramref name="chars" />.  
  
- ou - 
 <paramref name="byteIndex" /> n'est pas un index valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.  
  
- ou - 
 <paramref name="bytes" /> ne possède pas une capacité suffisante entre <paramref name="byteIndex" /> et la fin du tableau pour prendre en charge les octets obtenus.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant le jeu de caractères à encoder.</param>
        <param name="charIndex">Index du premier caractère à encoder.</param>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <param name="bytes">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</param>
        <param name="byteIndex">Index auquel commencer l'écriture de la séquence d'octets obtenue.</param>
        <summary>Encode un jeu de caractères de la chaîne <see cref="T:System.String" /> spécifiée dans le tableau d'octets indiqué.</summary>
        <returns>Nombre réel d'octets écrits dans <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UnicodeEncoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (méthode), respectivement.  
  
> [!NOTE]
>  Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur. Le <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode ne doit pas un préambule au début d’une séquence d’octets encodées.  
  
   
  
## Examples  
 L’exemple suivant montre comment encoder une plage d’éléments à partir d’un tableau de caractères Unicode et stocker les octets encodés dans une plage d’éléments dans un tableau d’octets.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="charIndex" /> et <paramref name="charCount" /> ne désignent pas une plage valide dans <paramref name="chars" />.  
  
- ou - 
 <paramref name="byteIndex" /> n'est pas un index valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="s" /> contient une séquence de caractères non valide.  
  
- ou - 
 <paramref name="bytes" /> ne possède pas une capacité suffisante entre <paramref name="byteIndex" /> et la fin du tableau pour prendre en charge les octets obtenus.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcule le nombre de caractères produits par le décodage d'une séquence d'octets.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Pointeur du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>Calcule le nombre de caractères produits par le décodage d'une séquence d'octets commençant au pointeur d'octet spécifié.</summary>
        <returns>Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille de tableau exact qui <xref:System.Text.UnicodeEncoding.GetChars%2A> pour stocker les caractères obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Pour calculer la taille maximale du tableau, l’application doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="index">Index du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>Calcule le nombre de caractères produits par le décodage d'une séquence d'octets du tableau d'octets spécifié.</summary>
        <returns>Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetChars%2A> pour stocker les caractères obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Pour calculer la taille maximale du tableau, l’application doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode pour retourner le nombre de caractères produits par le décodage d’une plage d’éléments dans un tableau d’octets à l’aide <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="bytes" />.  
  
- ou - 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Décode une séquence d'octets en un jeu de caractères.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Pointeur du premier octet à décoder.</param>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <param name="chars">Pointeur de l'emplacement où commencer l'écriture du jeu de caractères obtenu.</param>
        <param name="charCount">Nombre maximal de caractères à écrire.</param>
        <summary>Décode une séquence d'octets commençant au pointeur d'octet spécifié en un jeu de caractères qui sera stocké à partir du pointeur de caractère spécifié.</summary>
        <returns>Nombre réel de caractères écrits à l'emplacement indiqué par le paramètre <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille de tableau exact qui <xref:System.Text.UnicodeEncoding.GetChars%2A> pour stocker les caractères obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Pour calculer la taille maximale du tableau, l’application doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Si la plage d’octets à décoder inclut la marque d’ordre d’octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-BOM, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode. Vous pouvez le supprimer en appelant le <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou le <xref:System.Text.Encoder> objet fourni par le <xref:System.Text.UnicodeEncoding.GetDecoder%2A> ou <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (méthode), respectivement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).  
  
- ou - 
 <paramref name="chars" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> ou <paramref name="charCount" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.  
  
- ou - 
 <paramref name="charCount" /> est inférieur au nombre de caractères obtenus.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="byteIndex">Index du premier octet à décoder.</param>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <param name="chars">Tableau de caractères destiné à contenir le jeu de caractères obtenu.</param>
        <param name="charIndex">Index auquel commencer l'écriture du jeu de caractères obtenu.</param>
        <summary>Décode une séquence d'octets du tableau d'octets spécifié dans le tableau de caractères spécifié.</summary>
        <returns>Nombre réel de caractères écrits dans <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetChars%2A> pour stocker les caractères obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Pour calculer la taille maximale du tableau, l’application doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Si la plage d’octets à décoder inclut la marque d’ordre d’octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-BOM, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode. Vous pouvez le supprimer en appelant le <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UnicodeEncoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (méthode), respectivement.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.GetChars%2A> méthode à décoder une plage d’éléments dans un tableau d’octets et stocker le résultat dans un tableau de caractères.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).  
  
- ou - 
 <paramref name="chars" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />, <paramref name="byteCount" /> ou <paramref name="charIndex" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="byteindex" /> et <paramref name="byteCount" /> ne désignent pas une plage valide dans <paramref name="bytes" />.  
  
- ou - 
 <paramref name="charIndex" /> n'est pas un index valide dans <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.  
  
- ou - 
 <paramref name="chars" /> ne possède pas une capacité suffisante entre <paramref name="charIndex" /> et la fin du tableau pour prendre en charge les caractères obtenus.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="unicodeEncoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un décodeur qui convertit une séquence d'octets encodée en UTF-16 en une séquence de caractères Unicode.</summary>
        <returns>
          <see cref="T:System.Text.Decoder" /> qui convertit une séquence d'octets encodée en UTF-16 en une séquence de caractères Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> méthode convertit des blocs d’octets séquentiels en blocs de caractères, d’une manière similaire à la <xref:System.Text.UnicodeEncoding.GetChars%2A>. Toutefois, un <xref:System.Text.Decoder> conserve les informations d’état entre les appels, de sorte qu’il peut décoder correctement les séquences d’octets qui s’étendent sur des blocs. Le <xref:System.Text.Decoder> également conserve les octets de fin à la fin des blocs de données et utilise les octets de fin dans la prochaine opération de décodage. Par conséquent, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> et <xref:System.Text.UnicodeEncoding.GetEncoder%2A> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.  
  
 Si la détection d’erreurs est activée, autrement dit, si le `throwOnInvalidBytes` paramètre du constructeur est défini sur `true`, détection d’erreurs est également activée dans le <xref:System.Text.Decoder> retourné par cette méthode. Si la détection d’erreurs est activée et une séquence non valide est rencontrée, l’état du décodeur n’est pas défini et le traitement doit s’arrêter.  
  
   
  
## Examples  
 L’exemple suivant utilise un encodeur et un décodeur pour encoder une chaîne en un tableau d’octets, puis décode les octets dans un tableau de caractères.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Encodages de présentation</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="unicodeEncoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un encodeur qui convertit une séquence de caractères Unicode en une séquence d'octets encodée en UTF-16.</summary>
        <returns>Un objet <see cref="T:System.Text.Encoder" /> qui convertit une séquence de caractères Unicode en une séquence d'octets encodée en UTF-16.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> méthode convertit des blocs de caractères séquentiels en blocs d’octets d’une manière similaire à la <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode de cette classe. Toutefois, un <xref:System.Text.Encoder> objet conserve les informations d’état entre les appels et peut donc encoder correctement les séquences de caractères qui s’étendent sur des blocs. Le <xref:System.Text.Encoder> objet également conserve les caractères de fin à la fin des blocs de données et utilise les caractères de fin de la prochaine opération de codage. Par exemple, un bloc de données peut se terminer par un substitut étendu non apparié, et le substitut faible correspondant peut se trouver dans le bloc de données suivant. Par conséquent, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> et <xref:System.Text.UnicodeEncoding.GetEncoder%2A> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.  
  
 Si la détection d’erreurs est activée, autrement dit, si le `throwOnInvalidBytes` paramètre du constructeur est défini sur `true`, détection d’erreurs est également activée dans le <xref:System.Text.Encoder> objet retourné par cette méthode. Si la détection d’erreurs est activée et une séquence non valide est rencontrée, l’état de l’encodeur n’est pas défini et le traitement doit s’arrêter.  
  
   
  
## Examples  
 L’exemple suivant utilise un encodeur et un décodeur pour encoder une chaîne en un tableau d’octets, puis décode les octets dans un tableau de caractères.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Encodages de présentation</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="unicodeEncoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage pour l'instance actuelle.</summary>
        <returns>Code de hachage pour l'objet <see cref="T:System.Text.UnicodeEncoding" /> actuel.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="unicodeEncoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <summary>Calcule le nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</summary>
        <returns>Nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetBytes%2A> pour stocker les octets obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Pour calculer la taille maximale du tableau, l’application doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>. Le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Récupère un nombre le plus défavorable, y compris le pire des cas correspondant à votre actuellement <xref:System.Text.EncoderFallback>. Si une procédure de secours est choisi avec une chaîne potentiellement grande, <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> peut retourner des valeurs élevées.  
  
 Dans la plupart des cas, cette méthode récupère un nombre raisonnable pour les petites chaînes. Pour les chaînes de grande taille, vous devrez peut-être choisir entre l’utilisation de mémoires tampons de grande et interception des erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est dépassée. Vous pourriez également envisager une approche différente à l’aide <xref:System.Text.UnicodeEncoding.GetByteCount%2A> ou <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> n’a aucun lien avec <xref:System.Text.UnicodeEncoding.GetChars%2A>. Si votre application a besoin d’une fonction similaire à utiliser avec <xref:System.Text.UnicodeEncoding.GetChars%2A>, il doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` n’est pas nécessairement la même valeur que `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> méthode pour retourner le nombre maximal d’octets nécessaires au codage d’un nombre spécifié de caractères.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> est inférieur à zéro.  
  
- ou - 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="unicodeEncoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <summary>Calcule le nombre maximal de caractères produits par le décodage du nombre d'octets spécifié.</summary>
        <returns>Nombre maximal de caractères produits par le décodage du nombre d'octets spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UnicodeEncoding.GetChars%2A> pour stocker les caractères obtenus, l’application utilise <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Pour calculer la taille maximale du tableau, l’application doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Le <xref:System.Text.UnicodeEncoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Récupère un nombre le plus défavorable, y compris le pire des cas correspondant à votre actuellement <xref:System.Text.DecoderFallback>. Si une procédure de secours est choisi avec une chaîne potentiellement grande, <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> récupère des valeurs élevées.  
  
 Dans la plupart des cas, cette méthode récupère un nombre raisonnable pour les petites chaînes. Pour les chaînes de grande taille, vous devrez peut-être choisir entre l’utilisation de mémoires tampons de grande et interception des erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est dépassée. Vous pourriez également envisager une approche différente à l’aide <xref:System.Text.UnicodeEncoding.GetCharCount%2A> ou <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> n’a aucun lien avec <xref:System.Text.UnicodeEncoding.GetBytes%2A>. Si votre application a besoin d’une fonction similaire à utiliser avec <xref:System.Text.UnicodeEncoding.GetBytes%2A>, il doit utiliser <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` n’est pas nécessairement la même valeur que `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> méthode pour retourner le nombre maximal de caractères produits par le décodage d’un nombre spécifié d’octets.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> est inférieur à zéro.  
  
- ou - 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="unicodeEncoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une marque d'ordre d'octet Unicode au format UTF-16 si le constructeur de cette instance demande une marque d'ordre d'octet.</summary>
        <returns>Tableau d'octets contenant la marque d'ordre d'octet Unicode, si l'objet <see cref="T:System.Text.UnicodeEncoding" /> est configuré pour en fournir une. Sinon, cette méthode retourne un tableau d'octets de longueur égale à zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.UnicodeEncoding> objet peut fournir un préambule, c'est-à-dire un tableau d’octets qui peut porter comme préfixe à la séquence d’octets résultant du processus de codage. En le faisant précéder une séquence d’octets encodées avec une marque d’ordre d’octet (point de code U + FEFF) aide le décodeur à déterminer l’ordre d’octet et que le format de transformation ou UTF. La marque d’ordre octet Unicode (BOM) est sérialisée comme suit (hexadécimal) :  
  
-   Ordre de primauté des octets : FE FF  
  
-   Primauté des octets : FF FE  
  
 Vous pouvez instancier un <xref:System.Text.UnicodeEncoding> de l’objet dont la propriété <xref:System.Text.UnicodeEncoding.GetPreamble%2A> méthode retourne une nomenclature valide comme suit :  
  
-   En récupérant le <xref:System.Text.UnicodeEncoding> objet retourné par la <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> ou <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> propriété.  
  
-   En appelant sans paramètre <xref:System.Text.UnicodeEncoding.%23ctor> constructeur pour instancier un <xref:System.Text.UnicodeEncoding> objet.  
  
-   En fournissant `true` comme valeur de la `byteOrderMark` l’argument de la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> ou <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructeurs.  
  
 Nous recommandons que vous utilisez la nomenclature, dans la mesure où il fournit une certaine identification d’un encodage pour les fichiers qui ont perdu une référence à leur codage, telles que sans balise ou incorrectement référencées données web ou des fichiers texte aléatoires stockés lorsqu’une entreprise ne disposait pas problèmes internationaux. Souvent les problèmes d’utilisateur peuvent être évités si les données sont balisées de façon cohérente et correctement.  
  
 Des normes qui fournissent un type de codage, un BOM est quelque peu redondant. Toutefois, il peut être utilisé pour aider à un serveur d’envoyer l’en-tête de codage correct. Ou bien, il peut être utilisé comme solution de secours si l’encodage est perdu.  
  
 Il existe certains inconvénients à l’utilisation d’une nomenclature. Par exemple, savoir comment limiter les champs de base de données qui utilisent un BOM peut être difficile. Concaténation de fichiers peut être un problème également, par exemple, lorsque les fichiers sont fusionnés de telle façon un caractère inutile peut se retrouver au milieu des données. Malgré le peu d’inconvénients, cependant, l’utilisation d’une nomenclature est hautement recommandée.  
  
> [!CAUTION]
>  Pour vous assurer que les octets encodés sont décodés correctement, vous devez précéder le début d’un flux d’octets encodés avec un préambule. Notez que le <xref:System.Text.UnicodeEncoding.GetBytes%2A> méthode ne doit pas une nomenclature à une séquence d’octets encodés ; en fournissant une nomenclature au début d’un flux d’octets approprié est la responsabilité du développeur.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Text.UnicodeEncoding.GetPreamble%2A> méthode pour récupérer la marque d’ordre d’octet Unicode dans le big endian ou little ordre de primauté des octets d’une instance d’un <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 L’exemple suivant instancie deux <xref:System.Text.UnicodeEncoding> objets, le premier d'entre eux ne fournit pas une nomenclature et qui effectue la deuxième. Il appelle ensuite la <xref:System.Text.UnicodeEncoding.GetPreamble%2A> méthode pour écrire la marque BOM dans un fichier avant d’écrire une chaîne encodée en Unicode. Comme le montre la sortie de l’exemple de console, le fichier qui enregistre les octets à partir de la deuxième encodeur comporte trois davantage d’octets que la première.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 Vous pouvez également comparer les fichiers à l’aide de la `fc` commande dans une fenêtre de console, ou vous pouvez inspecter les fichiers dans un éditeur de texte qui inclut un mode d’affichage de format hexadécimal. Notez que lorsque le fichier est ouvert dans un éditeur qui prend en charge l’encodage UTF-16, la marque BOM n’est pas affiché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="unicodeEncoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="index">Index du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>Décode une plage d'octets d'un tableau d'octets en une chaîne.</summary>
        <returns>Objet <see cref="T:System.String" /> contenant les résultats du décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Si la plage d’octets à décoder inclut la marque d’ordre d’octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-BOM, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode. Vous pouvez le supprimer en appelant le <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou le <xref:System.Text.Encoder> objet fourni par le <xref:System.Text.UnicodeEncoding.GetDecoder%2A> ou <xref:System.Text.UnicodeEncoding.GetEncoder%2A> (méthode), respectivement.  
  
   
  
## Examples  
 L’exemple suivant initialise un tableau en appelant le <xref:System.Text.UnicodeEncoding.GetByteCount%2A> méthode pour déterminer exactement combien d’octets est nécessaires pour une chaîne encodée, puis en ajoutant la taille de la marque d’ordre d’octet (BOM). L’exemple appelle ensuite la <xref:System.Text.UnicodeEncoding.GetPreamble%2A> méthode pour stocker la nomenclature dans le tableau avant d’appeler le <xref:System.Text.Encoding.GetBytes%2A> méthode pour stocker les octets encodés dans le tableau. L’exemple appelle ensuite la <xref:System.Text.UnicodeEncoding.GetString%2A> méthode à décoder la chaîne.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Notez que dans ce cas la chaîne décodée diffère de la chaîne d’origine, dans la mesure où il commence par une marque d’ordre d’octet de 16 bits U + FFFD. Cela signifie que les deux chaînes sont considérés comme égaux, et que si la chaîne est sortie, la nomenclature s’affichera en tant que le caractère de remplacement « ? ». Pour supprimer la marque BOM au début de la chaîne, vous pouvez appeler la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> a la valeur <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour une explication plus complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>