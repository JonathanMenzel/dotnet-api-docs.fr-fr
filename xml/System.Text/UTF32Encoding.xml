<Type Name="UTF32Encoding" FullName="System.Text.UTF32Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ccd193b7e09452036979782b216bac3eccbd9f66" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51937599" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class UTF32Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit UTF32Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF32Encoding" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class UTF32Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF32Encoding sealed : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF32Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un encodage UTF-32 de caractères Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'encodage est le processus de transformation d'un jeu de caractères Unicode en une séquence d'octets. Le décodage est le processus de transformation d’une séquence d’octets codés en un jeu de caractères Unicode.  
  
 Le [norme Unicode](https://go.microsoft.com/fwlink/?linkid=37123) assigne un point de code (nombre) à chaque caractère dans chaque script pris en charge. Un Format UTF (Unicode Transformation) est un moyen pour encoder ce point de code. Le [norme Unicode](https://go.microsoft.com/fwlink/?linkid=37123) utilise les formats UTF suivants :  
  
-   UTF-8, qui représente chaque point de code sous la forme d’une séquence d’un à quatre octets.  
  
-   UTF-16, ce qui représente chaque point de code sous la forme d’une séquence d’entiers 16 bits d’une à deux.  
  
-   UTF-32, ce qui représente chaque point de code sous la forme d’un entier 32 bits.  
  
 Pour plus d’informations sur les formats UTF et d’autres encodages pris en charge par <xref:System.Text>, consultez [encodage de caractères dans .NET](~/docs/standard/base-types/character-encoding.md).
  
 Le <xref:System.Text.UTF32Encoding> classe représente un encodage UTF-32. L’encodeur peut utiliser l’ordre de primauté des octets (octet le plus significatif premier) ou l’ordre d’octet avec primauté (octet le moins significatif premier). Par exemple, la lettre majuscule latine A (point de code U + 0041) est sérialisée comme suit (en hexadécimal) :  
  
-   Ordre de primauté des octets : 00 00 00 41  
  
-   Primauté des octets : 41 00 00 00  
  
 Il est généralement plus efficace pour stocker des caractères Unicode à l’aide de l’ordre d’octet natif. Par exemple, il est préférable d’utiliser l’ordre d’octet avec primauté sur des plateformes little-endian, tels que des ordinateurs Intel. <xref:System.Text.UTF32Encoding> correspond aux pages de codes Windows 12000 (little endian) et 12001 (ordre de primauté des octets). Vous pouvez déterminer le « endianness » d’une architecture particulière en appelant le <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> (méthode).  
  
 Si vous le souhaitez, le <xref:System.Text.UTF32Encoding> objet fournit une marque d’ordre d’octet (BOM), qui est un tableau d’octets qui peut porter comme préfixe à la séquence d’octets résultant du processus de codage. Si le préambule contient une marque d’ordre d’octet (BOM), il aide le décodeur à déterminer l’ordre d’octet et que le format de transformation ou UTF d’un tableau d’octets.  
  
 Si le <xref:System.Text.UTF32Encoding> instance est configurée pour fournir une nomenclature, vous pouvez le récupérer en appelant le <xref:System.Text.UTF32Encoding.GetPreamble%2A> méthode ; sinon, la méthode retourne un tableau vide. Notez que, même si un <xref:System.Text.UTF32Encoding> objet est configuré pour prendre en charge de la nomenclature, vous devez inclure la marque BOM au début du flux d’octets encodé selon le cas ; les méthodes d’encodage de la <xref:System.Text.UTF32Encoding> classe ne le faites pas cela automatiquement.  
  
 Pour activer la détection d’erreur et pour renforcer la sécurité de l’instance de classe, vous devez instancier un <xref:System.Text.UTF32Encoding> objet en appelant le <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructeur et en définissant son `throwOnInvalidBytes` argument `true`. Avec la détection d’erreurs, une méthode qui détecte une séquence de caractères ou d’octets non valide lève une <xref:System.ArgumentException> exception. Absence de détection d’erreur, aucune exception n’est levée, et la séquence non valide est généralement ignorée.  
  
 Vous pouvez instancier un <xref:System.Text.UTF32Encoding> objet dans un nombre de façons, selon que vous souhaitiez lui fournir une marque d’ordre d’octet (BOM), si vous souhaitez codage big-endian ou little-endian, et si vous souhaitez activer la détection d’erreur. Le tableau suivant répertorie les <xref:System.Text.UTF32Encoding> constructeurs et les <xref:System.Text.Encoding> propriétés qui retournent un <xref:System.Text.UnicodeEncoding> objet.  
  
|Membre|Endianness|NOMENCLATURE|Détection d’erreurs|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>|Little endian|Oui|Aucun (remplacement de secours)|  
|<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=nameWithType>|Little endian|Oui|Aucun (remplacement de secours)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurable|Configurable|Aucun (remplacement de secours)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurable|Configurable|Configurable|  
  
 Le <xref:System.Text.UTF32Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.UTF32Encoding.GetBytes%2A> méthode exécute le codage.  
  
 De même, le <xref:System.Text.UTF32Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et le <xref:System.Text.UTF32Encoding.GetChars%2A> et <xref:System.Text.UTF32Encoding.GetString%2A> méthodes effectuent le décodage réel.  
  
 Pour un encodeur ou un décodeur qui est en mesure d’enregistrer les informations d’état lors de l’encodage ou de décodage de données qui s’étend sur plusieurs blocs (par exemple, la chaîne de 1 million de caractères qui est encodé dans les segments de 100 000 caractères), utilisez le <xref:System.Text.UTF32Encoding.GetEncoder%2A> et <xref:System.Text.UTF32Encoding.GetDecoder%2A> propriétés, respectivement.  
  
   
  
## Examples  
 L’exemple suivant illustre le comportement de <xref:System.Text.UTF32Encoding> objets avec et sans détection d’erreurs. Il crée un tableau d’octets dont quatre derniers octets représentent une paire de substitution non valide ; substitut étendu U + D8FF est suivi par un U + 01FF, qui est en dehors de la plage des substituts faible (0xDC00 et 0xDFFF). Absence de détection d’erreur, le décodeur UTF32 utilise le remplacement de secours pour remplacer la paire de substitution non valide par le caractère de remplacement (U + FFFD).  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 L’exemple suivant encode une chaîne de caractères Unicode dans un tableau d’octets en utilisant un <xref:System.Text.UTF32Encoding> objet. Le tableau d’octets est ensuite décodé en une chaîne pour montrer qu’il n’existe aucune perte de données.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/snippet.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/snippet.vb#1)]  
  
 L’exemple suivant utilise la même chaîne que la précédente, sauf qu’il écrit les octets encodés dans un fichier et le flux d’octets avec une marque d’ordre d’octet (BOM) de préfixes. Elle lit ensuite le fichier de deux manières différentes : en tant qu’un fichier texte à l’aide un <xref:System.IO.StreamReader> de l’objet ; et comme un fichier binaire. Comme vous pouvez l’imaginer, aucune chaîne qui vient d’être en lecture inclut la nomenclature.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/bom1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Text.UnicodeEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Encodages de présentation</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.UTF32Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.UTF32Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée une instance qui utilise l’ordre d’octet avec primauté, fournit la marque d’ordre d’octet Unicode et ne lève pas d’exception lorsqu’un encodage non valide est détecté.  
  
> [!NOTE]
>  Pour des raisons de sécurité, vous devez activer la détection d’erreur en appelant le <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructeur et en définissant son `throwOnInvalidCharacters` argument `true`.  
  
   
  
## Examples  
 L’exemple récupère et affiche l’ordre d’octet marquer pour différents suivants <xref:System.Text.UTF32Encoding> instances.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> pour utiliser l'ordre d'octet avec primauté des octets de poids fort (big-endian) (octet le plus significatif en premier) ou <see langword="false" /> pour utiliser l'ordre d'octet avec primauté des octets de poids faible (little-endian) (octet le moins significatif en premier).</param>
        <param name="byteOrderMark">
          <see langword="true" /> pour spécifier qu'une marque d'ordre d'octet Unicode est fournie ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.UTF32Encoding" />. Les paramètres indiquent s'il faut utiliser l'ordre d'octet avec primauté des octets de poids fort (big-endian) et si la méthode <see cref="M:System.Text.UTF32Encoding.GetPreamble" /> retourne une marque d'ordre d'octet Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur crée une instance qui ne lève pas d’exception lorsqu’un encodage non valide est détecté.  
  
> [!NOTE]
>  Pour des raisons de sécurité, vous devez activer la détection d’erreur en appelant le <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructeur et en définissant son `throwOnInvalidCharacters` argument `true`.  
  
   
  
## Examples  
 L’exemple récupère et affiche l’ordre d’octet marquer pour différents suivants <xref:System.Text.UTF32Encoding> instances.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidCharacters As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark, throwOnInvalidCharacters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidCharacters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> pour utiliser l'ordre d'octet avec primauté des octets de poids fort (big-endian) (octet le plus significatif en premier) ou <see langword="false" /> pour utiliser l'ordre d'octet avec primauté des octets de poids faible (little-endian) (octet le moins significatif en premier).</param>
        <param name="byteOrderMark">
          <see langword="true" /> pour spécifier qu'une marque d'ordre d'octet Unicode est fournie ; sinon, <see langword="false" />.</param>
        <param name="throwOnInvalidCharacters">
          <see langword="true" /> pour spécifier qu'une exception doit être levée quand un encodage non valide est détecté ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.UTF32Encoding" />. Les paramètres indiquent s'il faut utiliser l'ordre d'octet avec primauté des octets de poids fort (big-endian), fournir une marque d'ordre d'octet Unicode et lever une exception en cas de détection d'un encodage non valide.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `throwOnInvalidCharacters` est `true`, une méthode qui détecte une séquence d’octets non valide lève <xref:System.ArgumentException?displayProperty=nameWithType>. Sinon, la méthode ne lève pas d’exception et la séquence non valide est ignorée.  
  
> [!NOTE]
>  Pour des raisons de sécurité, vous devez activer la détection d’erreur en appelant le <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructeur et en définissant son `throwOnInvalidCharacters` argument `true`.  
  
   
  
## Examples  
 L’exemple suivant illustre le comportement de <xref:System.Text.UTF32Encoding>, avec la détection d’erreurs et sans.  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF32Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet <see cref="T:System.Object" /> à comparer à l'objet actuel.</param>
        <summary>Détermine si l'objet <see cref="T:System.Object" /> spécifié est égal à l'objet <see cref="T:System.Text.UTF32Encoding" /> actuel.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> est une instance de <see cref="T:System.Text.UTF32Encoding" /> et s'il est égal à l'objet actuel ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deux <xref:System.Text.UTF32Encoding> objets sont considérés comme égaux si toutes les conditions suivantes sont remplies :  
  
-   Les deux objets utilisent le même ordre d’octet.  
  
-   Les deux objets fournissent la marque d’ordre d’octet, ou les deux n’est pas le cas.  
  
-   Les deux objets utilisent le même encodeur de secours.  
  
-   Les deux objets utilisent le même décodeur de secours.  
  
   
  
## Examples  
 L’exemple suivant crée <xref:System.Text.UTF32Encoding> objets à l’aide de valeurs de paramètre différentes et vérifie ensuite leur égalité.  
  
 [!code-cpp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF32Encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> contenant le jeu de caractères à encoder.</param>
        <summary>Calcule le nombre d'octets générés en encodant les caractères dans le <see cref="T:System.String" /> spécifié.</summary>
        <returns>Nombre d'octets produits par l'encodage des caractères spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF32Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF32Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF32Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insérer le préambule au début d’un flux d’octets (tel qu’au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflété dans la valeur retournée par la <xref:System.Text.UTF32Encoding.GetByteCount%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> et <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> méthodes pour calculer le nombre maximal et réel d’octets requis pour encoder une chaîne. Il affiche également le nombre réel d’octets requis pour stocker un flux d’octets avec une marque d’ordre d’octet.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="s" /> contient une séquence de caractères non valide.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Pointeur du premier caractère à encoder.</param>
        <param name="count">Nombre de caractères à encoder.</param>
        <summary>Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères commençant au pointeur de caractère spécifié.</summary>
        <returns>Nombre d'octets produits par l'encodage des caractères spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF32Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF32Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Le <xref:System.Text.UTF32Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant qu’un fichier ou un flux de données, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insertion d’un préambule au début d’un flux d’octets (tel qu’au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflété dans la valeur retournée par la <xref:System.Text.UTF32Encoding.GetByteCount%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tableau de caractères contenant le jeu de caractères à encoder.</param>
        <param name="index">Index du premier caractère à encoder.</param>
        <param name="count">Nombre de caractères à encoder.</param>
        <summary>Calcule le nombre d'octets produits par l'encodage d'un jeu de caractères du tableau de caractères spécifié.</summary>
        <returns>Nombre d'octets produits par l'encodage des caractères spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF32Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF32Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF32Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant qu’un fichier ou un flux de données, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insertion d’un préambule au début d’un flux d’octets (tel qu’au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur et le nombre d’octets dans le préambule n’est pas reflété dans la valeur retournée par la <xref:System.Text.UTF32Encoding.GetByteCount%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant remplit un tableau avec un Latin en majuscules et minuscules et appelle le <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> méthode pour déterminer le nombre d’octets nécessaires pour encoder les caractères latins minuscules. Il affiche ensuite ces informations ainsi que le nombre total d’octets nécessaire si une marque d’ordre d’octet est ajoutée. Il compare ce nombre avec la valeur retournée par la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode), ce qui indique le nombre maximal d’octets nécessaires pour encoder les caractères latins minuscules. L’exemple suivant remplit un tableau avec une combinaison de caractères grec et cyrillique et appelle le <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> méthode pour déterminer le nombre d’octets nécessaires pour encoder les caractères cyrilliques. Il affiche ensuite ces informations ainsi que le nombre total d’octets nécessaire si une marque d’ordre d’octet est ajoutée. Il compare ce nombre avec la valeur retournée par la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> (méthode), ce qui indique le nombre maximal d’octets nécessaires pour encoder les caractères cyrilliques.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="chars" />.  
  
- ou - 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Encode un jeu de caractères en une séquence d'octets.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Pointeur du premier caractère à encoder.</param>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <param name="bytes">Pointeur de l'emplacement où commencer l'écriture de la séquence d'octets obtenue.</param>
        <param name="byteCount">Nombre maximal d'octets à écrire.</param>
        <summary>Code une séquence de caractères commençant au pointeur de caractère spécifié en une séquence d'octets, qui sera stockée à partir du pointeur d'octet spécifié.</summary>
        <returns>Nombre réel d'octets écrits à l'emplacement indiqué par le paramètre <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF32Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF32Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF32Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application utilise le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UTF32Encoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UTF32Encoding.GetEncoder%2A> (méthode), respectivement.  
  
> [!NOTE]
>  Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insertion d’un préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur. Le <xref:System.Text.UTF32Encoding.GetBytes%2A> méthode ne doit pas un préambule au début d’une séquence d’octets encodées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> ou <paramref name="byteCount" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.  
  
- ou - 
 <paramref name="byteCount" /> est inférieur au nombre d'octets obtenus.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tableau de caractères contenant le jeu de caractères à encoder.</param>
        <param name="charIndex">Index du premier caractère à encoder.</param>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <param name="bytes">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</param>
        <param name="byteIndex">Index auquel commencer l'écriture de la séquence d'octets obtenue.</param>
        <summary>Encode un jeu de caractères du tableau de caractères spécifié en un tableau d'octets.</summary>
        <returns>Nombre réel d'octets écrits dans <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF32Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF32Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF32Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application utilise le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UTF32Encoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UTF32Encoding.GetEncoder%2A> (méthode), respectivement.  
  
> [!NOTE]
>  Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insertion d’un préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur. Le <xref:System.Text.UTF32Encoding.GetBytes%2A> méthode ne doit pas un préambule au début d’une séquence d’octets encodées.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder trois caractères d’un tableau de caractères, puis encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/VB/GetBytes_CharArr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="charIndex" /> et <paramref name="charCount" /> ne désignent pas une plage valide dans <paramref name="chars" />.  
  
- ou - 
 <paramref name="byteIndex" /> n'est pas un index valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="chars" /> contient une séquence de caractères non valide.  
  
- ou - 
 <paramref name="bytes" /> ne possède pas une capacité suffisante entre <paramref name="byteIndex" /> et la fin du tableau pour prendre en charge les octets obtenus.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> contenant le jeu de caractères à encoder.</param>
        <param name="charIndex">Index du premier caractère à encoder.</param>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <param name="bytes">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</param>
        <param name="byteIndex">Index auquel commencer l'écriture de la séquence d'octets obtenue.</param>
        <summary>Encode un jeu de caractères de la chaîne <see cref="T:System.String" /> spécifiée dans le tableau d'octets indiqué.</summary>
        <returns>Nombre réel d'octets écrits dans <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF32Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF32Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF32Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application utilise le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UTF32Encoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UTF32Encoding.GetEncoder%2A> (méthode), respectivement.  
  
> [!NOTE]
>  Pour vous assurer que les octets encodés sont décodés correctement lorsqu’ils sont enregistrés en tant que fichier ou en tant que flux, vous pouvez préfixer un flux d’octets encodés avec un préambule. Insertion d’un préambule au début d’un flux d’octets (par exemple au début d’une série d’octets à écrire dans un fichier) est la responsabilité du développeur. Le <xref:System.Text.UTF32Encoding.GetBytes%2A> méthode ne doit pas un préambule au début d’une séquence d’octets encodées.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder une chaîne, puis encode la chaîne et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="charIndex" /> et <paramref name="charCount" /> ne désignent pas une plage valide dans <paramref name="chars" />.  
  
- ou - 
 <paramref name="byteIndex" /> n'est pas un index valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="s" /> contient une séquence de caractères non valide.  
  
- ou - 
 <paramref name="bytes" /> ne possède pas une capacité suffisante entre <paramref name="byteIndex" /> et la fin du tableau pour prendre en charge les octets obtenus.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcule le nombre de caractères produits par le décodage d'une séquence d'octets.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Pointeur du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>Calcule le nombre de caractères produits par le décodage d'une séquence d'octets commençant au pointeur d'octet spécifié.</summary>
        <returns>Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding.GetCharCount%2A> calcule la taille exacte de tableau requise par la <xref:System.Text.UTF32Encoding.GetChars%2A> méthode pour stocker les caractères obtenus. Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.UTF32Encoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="index">Index du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>Calcule le nombre de caractères produits par le décodage d'une séquence d'octets du tableau d'octets spécifié.</summary>
        <returns>Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.UTF32Encoding.GetCharCount%2A> méthode calcule la taille exacte de tableau requise par la <xref:System.Text.UTF32Encoding.GetChars%2A> méthode pour stocker les caractères obtenus. Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.UTF32Encoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne dans un tableau d’octets, puis décode les octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="bytes" />.  
  
- ou - 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Décode une séquence d'octets en un jeu de caractères.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Pointeur du premier octet à décoder.</param>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <param name="chars">Pointeur de l'emplacement où commencer l'écriture du jeu de caractères obtenu.</param>
        <param name="charCount">Nombre maximal de caractères à écrire.</param>
        <summary>Décode une séquence d'octets commençant au pointeur d'octet spécifié en un jeu de caractères qui sera stocké à partir du pointeur de caractère spécifié.</summary>
        <returns>Nombre réel de caractères écrits à l'emplacement indiqué par <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF32Encoding.GetChars%2A> pour stocker les caractères obtenus, appelez le <xref:System.Text.UTF32Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.UTF32Encoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Si la plage d’octets à décoder inclut la marque d’ordre d’octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-BOM, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode. Vous pouvez le supprimer en appelant le <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application utilise le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UTF32Encoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UTF32Encoding.GetEncoder%2A> (méthode), respectivement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="chars" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> ou <paramref name="charCount" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.  
  
- ou - 
 <paramref name="charCount" /> est inférieur au nombre de caractères obtenus.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="byteIndex">Index du premier octet à décoder.</param>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <param name="chars">Tableau de caractères destiné à contenir le jeu de caractères obtenu.</param>
        <param name="charIndex">Index auquel commencer l'écriture du jeu de caractères obtenu.</param>
        <summary>Décode une séquence d'octets du tableau d'octets spécifié dans le tableau de caractères spécifié.</summary>
        <returns>Nombre réel de caractères écrits dans <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF32Encoding.GetChars%2A> pour stocker les caractères obtenus, appelez le <xref:System.Text.UTF32Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.UTF32Encoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Si la plage d’octets à décoder inclut la marque d’ordre d’octet (BOM) et le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-BOM, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode. Vous pouvez le supprimer en appelant le <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application utilise le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UTF32Encoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UTF32Encoding.GetEncoder%2A> (méthode), respectivement.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne dans un tableau d’octets, puis décode les octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="chars" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />, <paramref name="byteCount" /> ou <paramref name="charIndex" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="byteindex" /> et <paramref name="byteCount" /> ne désignent pas une plage valide dans <paramref name="bytes" />.  
  
- ou - 
 <paramref name="charIndex" /> n'est pas un index valide dans <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.  
  
- ou - 
 <paramref name="chars" /> ne possède pas une capacité suffisante entre <paramref name="charIndex" /> et la fin du tableau pour prendre en charge les caractères obtenus.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF32Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un décodeur qui convertit une séquence d'octets encodée en UTF-32 en une séquence de caractères Unicode.</summary>
        <returns>
          <see cref="T:System.Text.Decoder" /> qui convertit une séquence d'octets encodée en UTF-32 en une séquence de caractères Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> méthode convertit des blocs d’octets séquentiels en blocs de caractères, d’une manière similaire à la <xref:System.Text.UTF32Encoding.GetChars%2A> (méthode). Toutefois, un <xref:System.Text.Decoder> conserve les informations d’état entre les appels, de sorte qu’il peut décoder correctement les séquences d’octets qui s’étendent sur des blocs. Le <xref:System.Text.Decoder> également conserve les octets de fin à la fin des blocs de données et utilise les octets de fin dans la prochaine opération de décodage. Par conséquent, <xref:System.Text.UTF32Encoding.GetDecoder%2A> et <xref:System.Text.UTF32Encoding.GetEncoder%2A> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.  
  
 Si la détection d’erreurs est activée, autrement dit, si le `throwOnInvalidCharacters` paramètre du constructeur a été défini sur `true`, détection d’erreurs est également activée dans le <xref:System.Text.Decoder> retourné par cette méthode. Si la détection d’erreurs est activée et une séquence non valide est rencontrée, l’état du décodeur n’est pas défini et le traitement doit s’arrêter.  
  
   
  
## Examples  
 L’exemple suivant utilise un encodeur et un décodeur pour encoder une chaîne en un tableau d’octets, puis décode les octets dans un tableau de caractères.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Encodages de présentation</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF32Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un encodeur qui convertit une séquence de caractères Unicode en une séquence d'octets encodée en UTF-32.</summary>
        <returns>Un <see cref="T:System.Text.Encoder" /> qui convertit une séquence de caractères Unicode en une séquence de caractères UTF-32.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> méthode convertit des blocs de caractères séquentiels en blocs d’octets, d’une manière similaire à la <xref:System.Text.UTF32Encoding.GetBytes%2A> (méthode). Toutefois, un <xref:System.Text.Encoder> conserve les informations d’état entre les appels et peut donc encoder correctement les séquences de caractères qui s’étendent sur des blocs. Le <xref:System.Text.Encoder> également conserve fin caractères à la fin des blocs de données et utilise les caractères de fin de la prochaine opération de codage. Par exemple, un bloc de données peut se terminer par un substitut étendu non apparié, et le substitut faible correspondant peut se trouver dans le bloc de données suivant. Par conséquent, <xref:System.Text.UTF32Encoding.GetDecoder%2A> et <xref:System.Text.UTF32Encoding.GetEncoder%2A> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.  
  
 Si la détection d’erreurs est activée, autrement dit, si le `throwOnInvalidCharacters` paramètre du constructeur a été défini sur `true`, détection d’erreurs est également activée dans le <xref:System.Text.Encoder> retourné par cette méthode. Si la détection d’erreurs est activée et une séquence non valide est rencontrée, l’état de l’encodeur n’est pas défini et le traitement doit s’arrêter.  
  
   
  
## Examples  
 L’exemple suivant utilise un encodeur et un décodeur pour encoder une chaîne en un tableau d’octets, puis décode les octets dans un tableau de caractères.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Encodages de présentation</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF32Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage pour l'instance actuelle.</summary>
        <returns>Code de hachage pour l'objet <see cref="T:System.Text.UTF32Encoding" /> actuel.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF32Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <summary>Calcule le nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</summary>
        <returns>Nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF32Encoding.GetBytes%2A> pour stocker les octets obtenus, vous appelez le <xref:System.Text.UTF32Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.UTF32Encoding.GetByteCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> est un nombre le plus défavorable, y compris le pire des cas pour actuellement sélectionné <xref:System.Text.EncoderFallback>. Si une procédure de secours est choisi avec une chaîne potentiellement grande, <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> peut retourner des valeurs élevées.  
  
 Dans la plupart des cas, cette méthode retourne un nombre raisonnable pour les petites chaînes. Pour les chaînes de grande taille, vous devrez peut-être choisir entre l’utilisation de mémoires tampons de grande et interception des erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est dépassée. Vous pourriez également envisager une approche différente et utiliser <xref:System.Text.UTF32Encoding.GetByteCount%2A> ou <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> n’a aucune relation avec <xref:System.Text.UTF32Encoding.GetChars%2A>. Si vous avez besoin d’une fonction similaire à utiliser avec <xref:System.Text.UTF32Encoding.GetChars%2A>, utilisez <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` n’est pas nécessairement la même valeur que `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder une chaîne, puis encode la chaîne et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> est inférieur à zéro.  
  
- ou - 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF32Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <summary>Calcule le nombre maximal de caractères produits par le décodage du nombre d'octets spécifié.</summary>
        <returns>Nombre maximal de caractères produits par le décodage du nombre d'octets spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.UTF32Encoding.GetChars%2A> pour stocker les caractères obtenus, vous appelez le <xref:System.Text.UTF32Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, vous appelez le <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.UTF32Encoding.GetCharCount%2A> méthode alloue généralement moins de mémoire, tandis que le <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> est un nombre le plus défavorable, y compris le pire des cas pour actuellement sélectionné <xref:System.Text.DecoderFallback>. Si une procédure de secours est choisi avec une chaîne potentiellement grande, <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> peut retourner des valeurs élevées.  
  
 Dans la plupart des cas, cette méthode retourne un nombre raisonnable pour les petites chaînes. Pour les chaînes de grande taille, vous devrez peut-être choisir entre l’utilisation de mémoires tampons de grande et interception des erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est dépassée. Vous pourriez également envisager une approche différente et utiliser <xref:System.Text.UTF32Encoding.GetCharCount%2A> ou <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> n’a aucune relation avec <xref:System.Text.UTF32Encoding.GetBytes%2A>. Si vous avez besoin d’une fonction similaire à utiliser avec <xref:System.Text.UTF32Encoding.GetBytes%2A>, utilisez <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` n’est pas nécessairement la même valeur que `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne dans un tableau d’octets, puis décode les octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> est inférieur à zéro.  
  
- ou - 
Le nombre d’octets résultant est supérieur au nombre maximal accepté pour un entier.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF32Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une marque d'ordre d'octet Unicode encodée au format UTF-32 si l'objet <see cref="T:System.Text.UTF32Encoding" /> est configuré pour en fournir une.</summary>
        <returns>Tableau d'octets contenant la marque d'ordre d'octet Unicode, si l'objet <see cref="T:System.Text.UTF32Encoding" /> est configuré pour en fournir une. Sinon, cette méthode retourne un tableau d'octets de longueur égale à zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.UTF32Encoding> objet peut fournir un préambule, qui est un tableau d’octets qui peut porter comme préfixe à la séquence d’octets résultant du processus de codage. En le faisant précéder une séquence d’octets encodées avec une marque d’ordre d’octet (points de code U + 0000 U + FEFF) aide le décodeur à déterminer l’ordre d’octet et le format de transformation ou UTF. La marque d’ordre octet Unicode (BOM) est sérialisée comme suit (hexadécimal) :  
  
-   Ordre de primauté des octets : 00 00 FE FF  
  
-   Primauté des octets : FF FE 00 00  
  
 Vous pouvez instancier un <xref:System.Text.UTF32Encoding> de l’objet dont la propriété <xref:System.Text.UTF32Encoding.GetPreamble%2A> méthode retourne une nomenclature valide comme suit :  
  
-   En récupérant le <xref:System.Text.UTF32Encoding> objet retourné par la <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType> propriété.  
  
-   En appelant sans paramètre <xref:System.Text.UTF32Encoding.%23ctor> constructeur pour instancier un <xref:System.Text.UTF32Encoding> objet.  
  
-   En fournissant `true` comme valeur de la `byteOrderMark` l’argument de la <xref:System.Text.UTF32Encoding.%23ctor%2A> et <xref:System.Text.UTF32Encoding.%23ctor%2A> constructeurs.  
  
 Nous vous recommandons d’utiliser la nomenclature, dans la mesure où il fournit une certaine identification d’un encodage pour fichiers qui autres ont perdu la référence à la <xref:System.Text.UTF32Encoding> objet, par exemple, sans balise ou incorrectement référencées données web ou des fichiers texte aléatoires stockés quand un entreprise n’avait pas d’intérêts internationaux ou autres données. Souvent, les problèmes d’utilisateur peuvent être évités si les données sont balisées de façon cohérente et correctement.  
  
 Des normes qui fournissent un type de codage, un BOM est quelque peu redondant. Toutefois, il peut être utilisé pour aider à un serveur d’envoyer l’en-tête de codage correct. Ou bien, il peut être utilisé comme solution de secours si l’encodage est perdu.  
  
 Il existe certains inconvénients à l’utilisation d’une nomenclature. Par exemple, savoir comment limiter les champs de base de données qui utilisent un BOM peut être difficile. Concaténation de fichiers peut être un problème également, par exemple, lorsque les fichiers sont fusionnés de telle façon un caractère inutile peut se retrouver au milieu des données. Malgré le peu d’inconvénients, cependant, l’utilisation d’une nomenclature est hautement recommandée.  
  
 Pour plus d’informations sur l’ordre d’octet et la marque d’ordre d’octet, consultez la norme Unicode dans le [page d’accueil Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Pour vous assurer que les octets encodés sont décodés correctement, vous devez précéder les octets encodés avec un préambule. Notez que le <xref:System.Text.UTF32Encoding.GetBytes%2A> méthode ne doit pas une nomenclature à une séquence d’octets encodés ; en fournissant une nomenclature au début d’un flux d’octets approprié est la responsabilité du développeur.  
  
   
  
## Examples  
 Le code exemple récupère et affiche l’ordre d’octet marquer pour différents suivants <xref:System.Text.UTF32Encoding> instances.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 L’exemple suivant instancie deux <xref:System.Text.UTF32Encoding> objets, le premier d'entre eux ne fournit pas une nomenclature et le second de qui effectue. Il appelle ensuite la <xref:System.Text.UTF32Encoding.GetPreamble%2A> méthode pour écrire la marque BOM dans un fichier avant d’écrire une chaîne encodée en UTF-32. Comme le montre la sortie de l’exemple, le fichier qui enregistre les octets à partir de la deuxième encodeur a quatre octets plus que le premier.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/getpreamble1.vb#2)]  
  
 Vous pouvez également comparer les fichiers à l’aide de la `fc` commande dans une fenêtre de console, ou vous pouvez inspecter les fichiers dans un éditeur de texte qui inclut un mode d’affichage de format hexadécimal. Notez que lorsque le fichier est ouvert dans un éditeur qui prend en charge UTF-32, la marque BOM n’est pas affiché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF32Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="index">Index du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>Décode une plage d'octets d'un tableau d'octets en une chaîne.</summary>
        <returns>Chaîne contenant les résultats du décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avec la détection de l’erreur, une séquence non valide provoque cette méthode lève un <xref:System.ArgumentException>. Absence de détection d’erreur, les séquences non valides sont ignorées et aucune exception n’est levée.  
  
 Si la plage d’octets à décoder contient la marque d’ordre d’octet (BOM) et que le tableau d’octets a été retourné par une méthode d’un type prenant en charge non-BOM, le caractère U + FFFE est inclus dans le tableau de caractères retourné par cette méthode. Vous pouvez le supprimer en appelant le <xref:System.String.TrimStart%2A?displayProperty=nameWithType> (méthode).  
  
 Données à convertir, telles que les données lues à partir d’un flux, peuvent être disponibles uniquement dans les blocs séquentiels. Dans ce cas, ou si la quantité de données est tellement importante qu’il doit être divisée en blocs plus petits, l’application doit utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournies par le <xref:System.Text.UTF32Encoding.GetDecoder%2A> (méthode) ou le <xref:System.Text.UTF32Encoding.GetEncoder%2A> (méthode), respectivement.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne en deux tableaux de tableaux d’octets, dans un ordre little-endian et l’autre dans l’ordre big-endian. Ensuite, il décode les octets en une chaîne.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/getstring.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString.vb#1)]  
  
 L’exemple suivant initialise un tableau en appelant le <xref:System.Text.UTF32Encoding.GetByteCount%2A> méthode pour déterminer exactement combien d’octets est nécessaires pour une chaîne encodée, puis en ajoutant la taille de la marque d’ordre d’octet (BOM). L’exemple appelle ensuite la <xref:System.Text.UTF32Encoding.GetPreamble%2A> méthode pour stocker la nomenclature dans le tableau avant d’appeler le <xref:System.Text.UTF32Encoding.GetBytes%2A> méthode pour stocker les octets encodés dans le tableau. L’exemple appelle ensuite la <xref:System.Text.UTF32Encoding.GetString%2A> méthode à décoder la chaîne.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/GetString1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString1.vb#2)]  
  
 Notez que dans ce cas la chaîne décodée diffère de la chaîne d’origine, dans la mesure où il commence par une marque d’ordre d’octet 32 bits U + FFFE U + 0000. Cela signifie que les deux chaînes sont considérés comme égaux, et que si la chaîne est sortie, la nomenclature s’affichera en tant que le caractère de remplacement « ? ».  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">La détection d’erreurs est activée et <paramref name="bytes" /> contient une séquence d’octets non valide.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>