<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Encoder.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5935e8a3f446a4bf08e1efb7afb01e36886d1cd6f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">935e8a3f446a4bf08e1efb7afb01e36886d1cd6f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.Encoder">
          <source>Converts a set of characters into a sequence of bytes.</source>
          <target state="translated">Convertit un jeu de caractères en une séquence d'octets.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>To obtain an instance of an implementation of the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> class, the application should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method of an <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> implementation.</source>
          <target state="translated">Pour obtenir une instance d’une implémentation de la <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> (classe), l’application doit utiliser le <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> méthode d’un <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> implémentation.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> méthode exécute l’encodage réel.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>There are several versions of both of these methods available in the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> class.</source>
          <target state="translated">Il existe plusieurs versions de ces deux méthodes disponibles dans la <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>A <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object maintains state information between successive calls to <ph id="ph2">`GetBytes`</ph> or <ph id="ph3">&lt;xref:System.Text.Decoder.Convert%2A&gt;</ph> methods so that it can correctly encode character sequences that span blocks.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> objet conserve les informations d’état entre les appels successifs à <ph id="ph2">`GetBytes`</ph> ou <ph id="ph3">&lt;xref:System.Text.Decoder.Convert%2A&gt;</ph> méthodes afin qu’elle peut encoder correctement les séquences de caractères qui s’étendent sur des blocs.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> également conserve à la fin des caractères à la fin des blocs de données et utilise les caractères de fin dans la prochaine opération de codage.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</source>
          <target state="translated">Par exemple, un bloc de données peut se terminer par un substitut étendu non apparié, et le substitut faible correspondant peut être dans le bloc de données suivant.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Par conséquent, <ph id="ph1">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>When the application is done with a stream of data it should make sure that the state information is flushed by setting the <ph id="ph1">`flush`</ph> parameter to <ph id="ph2">`true`</ph> in the appropriate method call.</source>
          <target state="translated">Lorsque l’application est terminée avec un flux de données, elle doit s’assurer que les informations d’état sont vidées en définissant le <ph id="ph1">`flush`</ph> paramètre <ph id="ph2">`true`</ph> dans l’appel de méthode approprié.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>If an exception occurs or if the application switches streams, it should call <ph id="ph1">&lt;xref:System.Text.Encoder.Reset%2A&gt;</ph> to clear the internal state of the <ph id="ph2">`Encoder`</ph> object.</source>
          <target state="translated">Si une exception se produit ou si l’application inverse les flux, il doit appeler <ph id="ph1">&lt;xref:System.Text.Encoder.Reset%2A&gt;</ph> pour effacer l’état interne de la <ph id="ph2">`Encoder`</ph> objet.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>Version Considerations</source>
          <target state="translated">Considérations relatives à la version</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>A <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object can be serialized during a conversion operation.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet peut être sérialisé pendant une opération de conversion.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>The state of the object is retained if it is deserialized in the same version of the .NET Framework, but lost if it is deserialized in another version.</source>
          <target state="translated">L’état de l’objet est conservé s’il est désérialisé dans la même version du .NET Framework, mais est perdu s’il est désérialisé dans une autre version.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>The following example demonstrates how to convert an array of Unicode characters into blocks of bytes using a specified encoding.</source>
          <target state="translated">L’exemple suivant montre comment convertir un tableau de caractères Unicode en blocs d’octets à l’aide d’un encodage spécifié.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>For comparison, the array of characters is first encoded using <ph id="ph1">&lt;xref:System.Text.UTF7Encoding&gt;</ph>.</source>
          <target state="translated">Pour la comparaison, le tableau de caractères est d’abord encodé à l’aide de <ph id="ph1">&lt;xref:System.Text.UTF7Encoding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>Next, the array of characters is encoded using an <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph>.</source>
          <target state="translated">Ensuite, le tableau de caractères est encodé à l’aide un <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoder">
          <source>When your application inherits from this class, it must override all the members.</source>
          <target state="translated">Lorsque votre application hérite de cette classe, il doit substituer tous les membres.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.#ctor">
          <source>To obtain an instance of an implementation of this class, the application should use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method of an <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> implementation.</source>
          <target state="translated">Pour obtenir une instance d’une implémentation de cette classe, l’application doit utiliser le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> méthode d’un <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> mise en œuvre.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.#ctor">
          <source>The following example demonstrates two techniques for initializing a new <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> instance.</source>
          <target state="translated">L’exemple suivant illustre deux techniques pour initialiser un nouveau <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="T:System.Text.Encoder">
          <source>Converts a buffer or array of Unicode characters to an encoded byte sequence.</source>
          <target state="translated">Convertit une mémoire tampon ou un tableau de caractères Unicode en une séquence d'octets encodée.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The address of a string of UTF-16 encoded characters to convert.</source>
          <target state="translated">Adresse d’une chaîne de caractères UTF-16 encodés à convertir.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The number of characters in <bpt id="p1">&lt;c&gt;</bpt>chars<ept id="p1">&lt;/c&gt;</ept> to convert.</source>
          <target state="translated">Nombre de caractères dans <bpt id="p1">&lt;c&gt;</bpt>chars<ept id="p1">&lt;/c&gt;</ept> à convertir.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The address of a buffer to store the converted bytes.</source>
          <target state="translated">Adresse d’une mémoire tampon pour stocker les octets convertis.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The maximum number of bytes in <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept> to use in the conversion.</source>
          <target state="translated">Nombre maximal d’octets dans <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept> à utiliser dans la conversion.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to indicate no further data is to be converted; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour indiquer qu’aucune autre donnée ne doit être convertie ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>When this method returns, contains the number of characters from <bpt id="p1">&lt;c&gt;</bpt>chars<ept id="p1">&lt;/c&gt;</ept> that were used in the conversion.</source>
          <target state="translated">Quand cette méthode est retournée, contient le nombre de caractères de <bpt id="p1">&lt;c&gt;</bpt>chars<ept id="p1">&lt;/c&gt;</ept> qui ont été utilisés dans la conversion.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Ce paramètre est passé sans être initialisé.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>When this method returns, contains the number of bytes that were used in the conversion.</source>
          <target state="translated">Quand cette méthode est retournée, contient le nombre d’octets qui ont été utilisés dans la conversion.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Ce paramètre est passé sans être initialisé.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if all the characters specified by <bpt id="p1">&lt;c&gt;</bpt>charCount<ept id="p1">&lt;/c&gt;</ept> were converted; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Quand cette méthode est retournée, contient <ph id="ph1">&lt;see langword="true" /&gt;</ph> si tous les caractères spécifiés par <bpt id="p1">&lt;c&gt;</bpt>charCount<ept id="p1">&lt;/c&gt;</ept> ont été convertis ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Ce paramètre est passé sans être initialisé.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>Converts a buffer of Unicode characters to an encoded byte sequence and stores the result in another buffer.</source>
          <target state="translated">Convertit une mémoire tampon de caractères Unicode en séquence d’octets encodée et stocke le résultat dans une autre mémoire tampon.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>Remember that the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object saves state between calls to <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph>.</source>
          <target state="translated">N’oubliez pas que le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> objet enregistre l’état entre les appels à <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>When the application is done with a stream of data, it should set the <ph id="ph1">`flush`</ph> parameter to <ph id="ph2">`true`</ph> to make sure that the state information is flushed.</source>
          <target state="translated">Lorsque l’application est faite avec un flux de données, elle doit affecter la <ph id="ph1">`flush`</ph> paramètre <ph id="ph2">`true`</ph> pour vous assurer que les informations d’état sont vidées.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>With this setting, the encoder ignores invalid bytes at the end of the data block and clears the internal buffer.</source>
          <target state="translated">Avec ce paramètre, l’encodeur ignore les octets non valides à la fin du bloc de données et efface la mémoire tampon interne.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>Any remaining processed data that is part of a logical unit, such as the high surrogate of a surrogate pair, is converted according to the current fallback settings.</source>
          <target state="translated">Les données traitées restantes qui fait partie d’une unité logique, telles que le substitut étendu d’une paire de substitution sont converties selon les paramètres de secours actifs.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The <ph id="ph1">`Convert`</ph> method is designed to be used in a loop to encode an arbitrary amount of input, such as data read from a file or stream.</source>
          <target state="translated">Le <ph id="ph1">`Convert`</ph> méthode est conçue pour être utilisée dans une boucle pour encoder une quantité arbitraire d’entrées, telles que les données lues à partir d’un fichier ou un flux.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>It stores the output of the encoding operation in a fixed-size buffer.</source>
          <target state="translated">Il stocke la sortie de l’opération de codage dans une mémoire tampon de taille fixe.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> will throw an exception if the output buffer isn't large enough, but <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> will fill as much space as possible and return the chars read and bytes written.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> lève une exception si la mémoire tampon de sortie n’est pas assez grand, mais <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> remplira autant d’espace que possible et retournera les caractères lus et les octets écrits.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>Also see the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> topic for more comments.</source>
          <target state="translated">Consultez également le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> rubrique pour plus de commentaires.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The <ph id="ph1">`completed`</ph> output parameter indicates whether all the data in the input buffer was converted and stored in the output buffer.</source>
          <target state="translated">Le <ph id="ph1">`completed`</ph> paramètre de sortie indique si toutes les données dans la mémoire tampon d’entrée a été convertie et stockée dans le tampon de sortie.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>This parameter is set to <ph id="ph1">`false`</ph> if the number of characters specified by the <ph id="ph2">`charCount`</ph> parameter cannot be converted without exceeding the number of bytes specified by the <ph id="ph3">`byteCount`</ph> parameter.</source>
          <target state="translated">Ce paramètre est défini sur <ph id="ph1">`false`</ph> si le nombre de caractères spécifié par le <ph id="ph2">`charCount`</ph> paramètre ne peut pas être converti sans dépasser le nombre d’octets spécifié par le <ph id="ph3">`byteCount`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>In that situation, the application should use the contents of the output buffer or provide a new output buffer, increment the <ph id="ph1">`chars`</ph> parameter by the number of characters specified by the <ph id="ph2">`charsUsed`</ph> parameter, then call the <ph id="ph3">`Convert`</ph> method again to process the remaining input.</source>
          <target state="translated">Dans ce cas, l’application doit utiliser le contenu de la mémoire tampon de sortie ou fournir une nouvelle mémoire tampon de sortie, incrément le <ph id="ph1">`chars`</ph> paramètre par le nombre de caractères spécifié par le <ph id="ph2">`charsUsed`</ph> paramètre, puis appelez le <ph id="ph3">`Convert`</ph> à nouveau (méthode) pour traiter l’entrée restante.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The <ph id="ph1">`completed`</ph> parameter can also be set to <ph id="ph2">`false`</ph>, even though the <ph id="ph3">`charsUsed`</ph> and <ph id="ph4">`charCount`</ph> parameters are equal.</source>
          <target state="translated">Le <ph id="ph1">`completed`</ph> paramètre peut également être défini sur <ph id="ph2">`false`</ph>, même si le <ph id="ph3">`charsUsed`</ph> et <ph id="ph4">`charCount`</ph> paramètres sont égaux.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>This situation occurs if there is still data in the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object that has not been stored in the <ph id="ph2">`chars`</ph> buffer.</source>
          <target state="translated">Cette situation se produit s’il existe toujours des données dans le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> objet n’a pas été stockée dans le <ph id="ph2">`chars`</ph> mémoire tampon.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> or <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> (<ph id="ph4">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph> (<ph id="ph4">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The output buffer is too small to contain any of the converted input.</source>
          <target state="translated">La mémoire tampon de sortie est trop petite pour contenir l’une des entrées converties.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The output buffer should be greater than or equal to the size indicated by the <ph id="ph1">&lt;see cref="Overload:System.Text.Encoder.GetByteCount" /&gt;</ph> method.</source>
          <target state="translated">La mémoire tampon de sortie doit être supérieure ou égale à la taille indiquée par la méthode <ph id="ph1">&lt;see cref="Overload:System.Text.Encoder.GetByteCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour une explication plus complète)</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>An array of characters to convert.</source>
          <target state="translated">Tableau de caractères à convertir.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The first element of <bpt id="p1">&lt;c&gt;</bpt>chars<ept id="p1">&lt;/c&gt;</ept> to convert.</source>
          <target state="translated">Premier élément de <bpt id="p1">&lt;c&gt;</bpt>chars<ept id="p1">&lt;/c&gt;</ept> à convertir.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The number of elements of <bpt id="p1">&lt;c&gt;</bpt>chars<ept id="p1">&lt;/c&gt;</ept> to convert.</source>
          <target state="translated">Nombre d’éléments de <bpt id="p1">&lt;c&gt;</bpt>chars<ept id="p1">&lt;/c&gt;</ept> à convertir.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>An array where the converted bytes are stored.</source>
          <target state="translated">Tableau dans lequel sont stockés les octets convertis.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The first element of <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept> in which data is stored.</source>
          <target state="translated">Premier élément de <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept> dans lequel sont stockées les données.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The maximum number of elements of <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept> to use in the conversion.</source>
          <target state="translated">Nombre maximal d’éléments de <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept> à utiliser dans la conversion.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to indicate no further data is to be converted; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour indiquer qu’aucune autre donnée ne doit être convertie ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>When this method returns, contains the number of characters from <bpt id="p1">&lt;c&gt;</bpt>chars<ept id="p1">&lt;/c&gt;</ept> that were used in the conversion.</source>
          <target state="translated">Quand cette méthode est retournée, contient le nombre de caractères de <bpt id="p1">&lt;c&gt;</bpt>chars<ept id="p1">&lt;/c&gt;</ept> qui ont été utilisés dans la conversion.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Ce paramètre est passé sans être initialisé.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>When this method returns, contains the number of bytes that were produced by the conversion.</source>
          <target state="translated">Quand cette méthode est retournée, contient le nombre d’octets qui ont été produits par la conversion.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Ce paramètre est passé sans être initialisé.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if all the characters specified by <bpt id="p1">&lt;c&gt;</bpt>charCount<ept id="p1">&lt;/c&gt;</ept> were converted; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Quand cette méthode est retournée, contient <ph id="ph1">&lt;see langword="true" /&gt;</ph> si tous les caractères spécifiés par <bpt id="p1">&lt;c&gt;</bpt>charCount<ept id="p1">&lt;/c&gt;</ept> ont été convertis ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Ce paramètre est passé sans être initialisé.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>Converts an array of Unicode characters to an encoded byte sequence and stores the result in an array of bytes.</source>
          <target state="translated">Convertit un tableau de caractères Unicode en séquence d’octets encodée et stocke le résultat dans un tableau d’octets.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>Remember that the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object saves state between calls to <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph>.</source>
          <target state="translated">N’oubliez pas que le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> objet enregistre l’état entre les appels à <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>When the application is done with a stream of data, it should set the <ph id="ph1">`flush`</ph> parameter to <ph id="ph2">`true`</ph> to make sure that the state information is flushed.</source>
          <target state="translated">Lorsque l’application est faite avec un flux de données, elle doit affecter la <ph id="ph1">`flush`</ph> paramètre <ph id="ph2">`true`</ph> pour vous assurer que les informations d’état sont vidées.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>With this setting, the encoder ignores invalid bytes at the end of the data block and clears the internal buffer.</source>
          <target state="translated">Avec ce paramètre, l’encodeur ignore les octets non valides à la fin du bloc de données et efface la mémoire tampon interne.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>Any remaining processed data that is part of a logical unit, such as the high surrogate of a surrogate pair, is converted according to the current fallback settings.</source>
          <target state="translated">Les données traitées restantes qui fait partie d’une unité logique, telles que le substitut étendu d’une paire de substitution sont converties selon les paramètres de secours actifs.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The <ph id="ph1">`Convert`</ph> method is designed to be used in a loop to decode an arbitrary amount of input, such as data read from a file or stream.</source>
          <target state="translated">Le <ph id="ph1">`Convert`</ph> méthode est conçue pour être utilisée dans une boucle pour décoder une quantité arbitraire d’entrées, telles que les données lues à partir d’un fichier ou un flux.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>It stores the output of the encoding operation in a fixed-size buffer.</source>
          <target state="translated">Il stocke la sortie de l’opération de codage dans une mémoire tampon de taille fixe.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> will throw an exception if the output buffer isn't large enough, but <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> will fill as much space as possible and return the chars read and bytes written.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> lève une exception si la mémoire tampon de sortie n’est pas assez grand, mais <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> remplira autant d’espace que possible et retournera les caractères lus et les octets écrits.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>Also see the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> topic for more comments.</source>
          <target state="translated">Consultez également le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> rubrique pour plus de commentaires.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The <ph id="ph1">`completed`</ph> output parameter indicates whether all the data in the input buffer was converted and stored in the output buffer.</source>
          <target state="translated">Le <ph id="ph1">`completed`</ph> paramètre de sortie indique si toutes les données dans la mémoire tampon d’entrée a été convertie et stockée dans le tampon de sortie.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>This parameter is set to <ph id="ph1">`false`</ph> if the number of characters specified by the <ph id="ph2">`charCount`</ph> parameter cannot be converted without exceeding the number of bytes specified by the <ph id="ph3">`byteCount`</ph> parameter.</source>
          <target state="translated">Ce paramètre est défini sur <ph id="ph1">`false`</ph> si le nombre de caractères spécifié par le <ph id="ph2">`charCount`</ph> paramètre ne peut pas être converti sans dépasser le nombre d’octets spécifié par le <ph id="ph3">`byteCount`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>In that situation, the application should use the contents of the output buffer or provide a new output buffer, increment the <ph id="ph1">`chars`</ph> parameter by the number of characters specified by the <ph id="ph2">`charsUsed`</ph> parameter, then call the <ph id="ph3">`Convert`</ph> method again to process the remaining input.</source>
          <target state="translated">Dans ce cas, l’application doit utiliser le contenu de la mémoire tampon de sortie ou fournir une nouvelle mémoire tampon de sortie, incrément le <ph id="ph1">`chars`</ph> paramètre par le nombre de caractères spécifié par le <ph id="ph2">`charsUsed`</ph> paramètre, puis appelez le <ph id="ph3">`Convert`</ph> à nouveau (méthode) pour traiter l’entrée restante.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The <ph id="ph1">`completed`</ph> parameter can also be set to <ph id="ph2">`false`</ph>, even though the <ph id="ph3">`charsUsed`</ph> and <ph id="ph4">`charCount`</ph> parameters are equal.</source>
          <target state="translated">Le <ph id="ph1">`completed`</ph> paramètre peut également être défini sur <ph id="ph2">`false`</ph>, même si le <ph id="ph3">`charsUsed`</ph> et <ph id="ph4">`charCount`</ph> paramètres sont égaux.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>This situation occurs if there is still data in the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object that has not been stored in the <ph id="ph2">`chars`</ph> buffer.</source>
          <target state="translated">Cette situation se produit s’il existe toujours des données dans le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> objet n’a pas été stockée dans le <ph id="ph2">`chars`</ph> mémoire tampon.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> method to convert a file of UTF-16 characters to UTF-8, then uses the <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A&gt;</ph> method to convert the UTF-8 characters back to UTF-16 characters.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> méthode pour convertir un fichier de format UTF-16 de caractères UTF-8, puis utilise la <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A&gt;</ph> méthode pour convertir les caractères UTF-8 en caractères UTF-16.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> or <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> (<ph id="ph4">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph> a la valeur <ph id="ph3">&lt;see langword="null" /&gt;</ph> (<ph id="ph4">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph>, <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph>, <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> ou <ph id="ph4">&lt;paramref name="byteCount" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The length of <ph id="ph1">&lt;paramref name="chars" /&gt;</ph><ph id="ph2"> - </ph><ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> is less than <ph id="ph4">&lt;paramref name="charCount" /&gt;</ph>.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="chars" /&gt;</ph><ph id="ph2"> - </ph><ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> est inférieure à <ph id="ph4">&lt;paramref name="charCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The length of <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph><ph id="ph2"> - </ph><ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than <ph id="ph4">&lt;paramref name="byteCount" /&gt;</ph>.</source>
          <target state="translated">La longueur de <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph><ph id="ph2"> - </ph><ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> est inférieure à <ph id="ph4">&lt;paramref name="byteCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The output buffer is too small to contain any of the converted input.</source>
          <target state="translated">La mémoire tampon de sortie est trop petite pour contenir l’une des entrées converties.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>The output buffer should be greater than or equal to the size indicated by the <ph id="ph1">&lt;see cref="Overload:System.Text.Encoder.GetByteCount" /&gt;</ph> method.</source>
          <target state="translated">La mémoire tampon de sortie doit être supérieure ou égale à la taille indiquée par la méthode <ph id="ph1">&lt;see cref="Overload:System.Text.Encoder.GetByteCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour une explication plus complète)</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="P:System.Text.Encoder.Fallback">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallback" /&gt;</ph> object for the current <ph id="ph2">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> object.</source>
          <target state="translated">Obtient ou définit un objet <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallback" /&gt;</ph> pour l'objet <ph id="ph2">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoder.Fallback">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallback" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoder.Fallback">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> objet représente un gestionnaire d’erreurs qui est appelé lorsqu’un caractère ne peut pas être converti en séquence d’octets encodée.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="P:System.Text.Encoder.Fallback">
          <source>The value in a set operation is <ph id="ph1">&lt;see langword="null" /&gt;</ph> (<ph id="ph2">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated">Dans une opération set, la valeur est <ph id="ph1">&lt;see langword="null" /&gt;</ph> (<ph id="ph2">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="P:System.Text.Encoder.Fallback">
          <source>A new value cannot be assigned in a set operation because the current <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallbackBuffer" /&gt;</ph> object contains data that has not been encoded yet.</source>
          <target state="translated">Il n'est pas possible d'assigner une nouvelle valeur dans une opération ensembliste, car l'objet <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallbackBuffer" /&gt;</ph> en cours contient des données qui n'ont pas encore été encodées.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="P:System.Text.Encoder.Fallback">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour une explication plus complète)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="P:System.Text.Encoder.Fallback">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="P:System.Text.Encoder.Fallback">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="P:System.Text.Encoder.FallbackBuffer">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallbackBuffer" /&gt;</ph> object associated with the current <ph id="ph2">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> object.</source>
          <target state="translated">Obtient l'objet <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallbackBuffer" /&gt;</ph> associé à l'objet <ph id="ph2">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoder.FallbackBuffer">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallbackBuffer" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallbackBuffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoder.FallbackBuffer">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder.FallbackBuffer%2A&gt;</ph> object represents data used by the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph> object.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder.FallbackBuffer%2A&gt;</ph> objet représente les données utilisées par le <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoder.FallbackBuffer">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> objet représente un gestionnaire d’erreurs qui est appelé lorsqu’un caractère ne peut pas être converti en séquence d’octets encodée.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="T:System.Text.Encoder">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage d'un jeu de caractères.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Pointeur du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to simulate clearing the internal state of the encoder after the calculation; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour simuler l’effacement de l’état interne de l’encodeur après le calcul ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage d'un jeu de caractères commençant au pointeur de caractère spécifié.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>A parameter indicates whether to clear the internal state of the encoder after the calculation.</source>
          <target state="translated">Un paramètre indique si l'état interne de l'encodeur doit être effacé après le calcul.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>The number of bytes produced by encoding the specified characters and any characters in the internal buffer.</source>
          <target state="translated">Nombre d'octets produits en encodant les caractères spécifiés et ceux de la mémoire tampon interne.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>This method does not affect the state of the encoder.</source>
          <target state="translated">Cette méthode n’affecte pas l’état de l’encodeur.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> requires to store the resulting bytes, the application should use <ph id="ph2">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Pour calculer la taille de tableau exact qui <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> requiert pour stocker les octets obtenus, l’application doit utiliser <ph id="ph2">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`GetBytes`</ph> is called with <ph id="ph2">`flush`</ph> set to <ph id="ph3">`false`</ph>, the encoder stores trailing characters at the end of the data block in an internal buffer and uses them in the next encoding operation.</source>
          <target state="translated">Si <ph id="ph1">`GetBytes`</ph> est appelée avec <ph id="ph2">`flush`</ph> la valeur <ph id="ph3">`false`</ph>, l’encodeur stocke les caractères de fin à la fin du bloc de données dans une mémoire tampon interne et les utilise dans la prochaine opération de codage.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>The application should call <ph id="ph1">`GetByteCount`</ph> on a block of data immediately before calling <ph id="ph2">`GetBytes`</ph> on the same block, so that any trailing characters from the previous block are included in the calculation.</source>
          <target state="translated">L’application doit appeler <ph id="ph1">`GetByteCount`</ph> sur un bloc de données juste avant d’appeler <ph id="ph2">`GetBytes`</ph> sur le même bloc, afin que toute fin des caractères à partir du bloc précédent sont inclus dans le calcul.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic .NET).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic .NET).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour une explication plus complète)</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">Tableau de caractères contenant le jeu de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Index du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to simulate clearing the internal state of the encoder after the calculation; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour simuler l’effacement de l’état interne de l’encodeur après le calcul ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage d'un jeu de caractères du tableau de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>A parameter indicates whether to clear the internal state of the encoder after the calculation.</source>
          <target state="translated">Un paramètre indique si l'état interne de l'encodeur doit être effacé après le calcul.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>The number of bytes produced by encoding the specified characters and any characters in the internal buffer.</source>
          <target state="translated">Nombre d'octets produits en encodant les caractères spécifiés et ceux de la mémoire tampon interne.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>This method does not affect the state of the encoder.</source>
          <target state="translated">Cette méthode n’affecte pas l’état de l’encodeur.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> requires to store the resulting bytes, the application should use <ph id="ph2">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Pour calculer la taille de tableau exact qui <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> requiert pour stocker les octets obtenus, l’application doit utiliser <ph id="ph2">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`GetBytes`</ph> is called with <ph id="ph2">`flush`</ph> set to <ph id="ph3">`false`</ph>, the encoder stores trailing characters at the end of the data block in an internal buffer and uses them in the next encoding operation.</source>
          <target state="translated">Si <ph id="ph1">`GetBytes`</ph> est appelée avec <ph id="ph2">`flush`</ph> la valeur <ph id="ph3">`false`</ph>, l’encodeur stocke les caractères de fin à la fin du bloc de données dans une mémoire tampon interne et les utilise dans la prochaine opération de codage.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>The application should call <ph id="ph1">`GetByteCount`</ph> on a block of data immediately before calling <ph id="ph2">`GetBytes`</ph> on the same block, so that any trailing characters from the previous block are included in the calculation.</source>
          <target state="translated">L’application doit appeler <ph id="ph1">`GetByteCount`</ph> sur un bloc de données juste avant d’appeler <ph id="ph2">`GetBytes`</ph> sur le même bloc, afin que toute fin des caractères à partir du bloc précédent sont inclus dans le calcul.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph> method to return the number of bytes required to encode an array of characters using a Unicode <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph> méthode pour retourner le nombre d’octets requis pour encoder un tableau de caractères Unicode à l’aide de <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour une explication plus complète)</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="T:System.Text.Encoder">
          <source>When overridden in a derived class, encodes a set of characters into a sequence of bytes.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, encode un jeu de caractères en séquence d'octets.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Pointeur du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>A pointer to the location at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Pointeur de l'emplacement où commencer l'écriture de la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Nombre maximal d'octets à écrire.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to clear the internal state of the encoder after the conversion; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour effacer l'état interne de l'encodeur après la conversion ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>When overridden in a derived class, encodes a set of characters starting at the specified character pointer and any characters in the internal buffer into a sequence of bytes that are stored starting at the specified byte pointer.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, encode un jeu de caractères démarrant au pointeur de caractère spécifié et les caractères de la mémoire tampon interne en une séquence d'octets stockés à partir du pointeur d'octet spécifié.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>A parameter indicates whether to clear the internal state of the encoder after the conversion.</source>
          <target state="translated">Un paramètre indique si l'état interne de l'encodeur doit être effacé après la conversion.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>The actual number of bytes written at the location indicated by the <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> parameter.</source>
          <target state="translated">Nombre réel d'octets écrits à l'emplacement indiqué par le paramètre <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>Remember that the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object saves state between calls to <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">N’oubliez pas que le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> objet enregistre l’état entre les appels à <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>When the application is done with a stream of data, it should set the <ph id="ph1">`flush`</ph> parameter to <ph id="ph2">`true`</ph> in the last call to <ph id="ph3">`GetBytes`</ph> to make sure that the state information is flushed and that the encoded bytes are properly terminated.</source>
          <target state="translated">Lorsque l’application est faite avec un flux de données, elle doit affecter la <ph id="ph1">`flush`</ph> paramètre <ph id="ph2">`true`</ph> dans le dernier appel à <ph id="ph3">`GetBytes`</ph> pour vous assurer que les informations d’état sont vidées et que les octets encodés sont correctement terminées.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>With this setting, the encoder ignores invalid bytes at the end of the data block, such as unmatched surrogates or incomplete combining sequences, and clears the internal buffer.</source>
          <target state="translated">Avec ce paramètre, l’encodeur ignore les octets non valides à la fin du bloc de données, telles que les substituts non appariés ou les séquences de combinaison incomplètes et efface la mémoire tampon interne.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>To calculate the exact buffer size that <ph id="ph1">`GetBytes`</ph> requires to store the resulting characters, the application should use <ph id="ph2">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Pour calculer la taille de la mémoire tampon exacte qui <ph id="ph1">`GetBytes`</ph> requiert pour stocker les caractères obtenus, l’application doit utiliser <ph id="ph2">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`GetBytes`</ph> is called with <ph id="ph2">`flush`</ph> set to <ph id="ph3">`false`</ph>, the encoder stores trailing bytes at the end of the data block in an internal buffer and uses them in the next encoding operation.</source>
          <target state="translated">Si <ph id="ph1">`GetBytes`</ph> est appelée avec <ph id="ph2">`flush`</ph> la valeur <ph id="ph3">`false`</ph>, l’encodeur stocke les octets de fin à la fin du bloc de données dans une mémoire tampon interne et les utilise dans la prochaine opération de codage.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>The application should call <ph id="ph1">`GetByteCount`</ph> on a block of data immediately before calling <ph id="ph2">`GetBytes`</ph> on the same block, so that any trailing characters from the previous block are included in the calculation.</source>
          <target state="translated">L’application doit appeler <ph id="ph1">`GetByteCount`</ph> sur un bloc de données juste avant d’appeler <ph id="ph2">`GetBytes`</ph> sur le même bloc, afin que toute fin des caractères à partir du bloc précédent sont inclus dans le calcul.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>If your application is to convert many segments of an input stream, consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> method.</source>
          <target state="translated">Si votre application consiste à convertir les nombreux segments d’un flux d’entrée, envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> will throw an exception if the output buffer isn't large enough, but <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> will fill as much space as possible and return the chars read and bytes written.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> lève une exception si la mémoire tampon de sortie n’est pas assez grand, mais <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> remplira autant d’espace que possible et retournera les caractères lus et les octets écrits.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>Also see the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> topic for more comments.</source>
          <target state="translated">Consultez également le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> rubrique pour plus de commentaires.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than the resulting number of bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> est inférieur au nombre d'octets obtenus.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour une explication plus complète)</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">Tableau de caractères contenant le jeu de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Index du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Index auquel commencer l'écriture de la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to clear the internal state of the encoder after the conversion; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour effacer l'état interne de l'encodeur après la conversion ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>When overridden in a derived class, encodes a set of characters from the specified character array and any characters in the internal buffer into the specified byte array.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, encode un jeu de caractères du tableau de caractères spécifié et les caractères de la mémoire tampon interne dans le tableau d'octets spécifié.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>A parameter indicates whether to clear the internal state of the encoder after the conversion.</source>
          <target state="translated">Un paramètre indique si l'état interne de l'encodeur doit être effacé après la conversion.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">Nombre réel d'octets écrits dans <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>Remember that the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object saves state between calls to <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">N’oubliez pas que le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> objet enregistre l’état entre les appels à <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>When the application is done with a stream of data, it should set the <ph id="ph1">`flush`</ph> parameter to <ph id="ph2">`true`</ph> in the last call to <ph id="ph3">`GetBytes`</ph> to make sure that the state information is flushed and that the encoded bytes are properly terminated.</source>
          <target state="translated">Lorsque l’application est faite avec un flux de données, elle doit affecter la <ph id="ph1">`flush`</ph> paramètre <ph id="ph2">`true`</ph> dans le dernier appel à <ph id="ph3">`GetBytes`</ph> pour vous assurer que les informations d’état sont vidées et que les octets encodés sont correctement terminées.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>With this setting, the encoder ignores invalid bytes at the end of the data block, such as unmatched surrogates or incomplete combining sequences, and clears the internal buffer.</source>
          <target state="translated">Avec ce paramètre, l’encodeur ignore les octets non valides à la fin du bloc de données, telles que les substituts non appariés ou les séquences de combinaison incomplètes et efface la mémoire tampon interne.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>To calculate the exact buffer size that <ph id="ph1">`GetBytes`</ph> requires to store the resulting characters, the application should use <ph id="ph2">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Pour calculer la taille de la mémoire tampon exacte qui <ph id="ph1">`GetBytes`</ph> requiert pour stocker les caractères obtenus, l’application doit utiliser <ph id="ph2">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`GetBytes`</ph> is called with <ph id="ph2">`flush`</ph> set to <ph id="ph3">`false`</ph>, the encoder stores trailing bytes at the end of the data block in an internal buffer and uses them in the next encoding operation.</source>
          <target state="translated">Si <ph id="ph1">`GetBytes`</ph> est appelée avec <ph id="ph2">`flush`</ph> la valeur <ph id="ph3">`false`</ph>, l’encodeur stocke les octets de fin à la fin du bloc de données dans une mémoire tampon interne et les utilise dans la prochaine opération de codage.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>The application should call <ph id="ph1">`GetByteCount`</ph> on a block of data immediately before calling <ph id="ph2">`GetBytes`</ph> on the same block, so that any trailing characters from the previous block are included in the calculation.</source>
          <target state="translated">L’application doit appeler <ph id="ph1">`GetByteCount`</ph> sur un bloc de données juste avant d’appeler <ph id="ph2">`GetBytes`</ph> sur le même bloc, afin que toute fin des caractères à partir du bloc précédent sont inclus dans le calcul.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>If your application is to convert many segments of an input stream, consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> method.</source>
          <target state="translated">Si votre application consiste à convertir les nombreux segments d’un flux d’entrée, envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> will throw an exception if the output buffer isn't large enough, but <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> will fill as much space as possible and return the chars read and bytes written.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> lève une exception si la mémoire tampon de sortie n’est pas assez grand, mais <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A&gt;</ph> remplira autant d’espace que possible et retournera les caractères lus et les octets écrits.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>Also see the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> topic for more comments.</source>
          <target state="translated">Consultez également le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> rubrique pour plus de commentaires.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>The following example demonstrates how to encode a range of elements from a character array and store the encoded bytes in a range of elements in a byte array.</source>
          <target state="translated">L’exemple suivant montre comment encoder une plage d’éléments à partir d’un tableau de caractères et stocker les octets encodés dans une plage d’éléments dans un tableau d’octets.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph> method is used to determine the size of the array required by <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph> méthode est utilisée pour déterminer la taille du tableau requise par <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph> (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> n'est pas un index valide dans <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ne possède pas une capacité suffisante entre <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> et la fin du tableau pour prendre en charge les octets obtenus.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for fuller explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour une explication plus complète)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoder.Fallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Text.Encoder.Reset">
          <source>When overridden in a derived class, sets the encoder back to its initial state.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, redéfinit l'encodeur à son état initial.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Reset">
          <source>This method clears the internal state of the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object.</source>
          <target state="translated">Cette méthode efface l’état interne de la <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Reset">
          <source>The method clears any state information preserved from a previous call to <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A&gt;</ph>, including trailing characters at the end of the previous data block, such as an unmatched high surrogate.</source>
          <target state="translated">La méthode efface toutes les informations d’état conservées à partir d’un appel précédent à <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A&gt;</ph>, y compris les caractères à la fin du bloc de données précédent, comme un substitut étendu non apparié.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoder.Reset">
          <source>Your application should call the <ph id="ph1">`Reset`</ph> method if it wants to reuse the same encoder even after an exception is thrown by <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph>, or if the application switches streams.</source>
          <target state="translated">Votre application doit appeler la <ph id="ph1">`Reset`</ph> méthode s’il souhaite réutiliser le même encodeur même après une exception est levée par <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Text.Encoder.GetByteCount%2A&gt;</ph>, ou si l’application inverse les flux.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>