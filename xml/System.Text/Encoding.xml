<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d95c61143e58621b3de218589a87909c382856a6" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39903183" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un encodage de caractères.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'encodage est le processus de transformation d'un jeu de caractères Unicode en une séquence d'octets. En revanche, le décodage est le processus de transformation d’une séquence d’octets codés en un jeu de caractères Unicode. Pour plus d’informations sur les Formats (formats UTF) et d’autres encodages pris en charge par <xref:System.Text.Encoding>, consultez [encodage de caractères dans .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Notez que <xref:System.Text.Encoding> est destiné à opérer sur des caractères Unicode au lieu des données binaires arbitraires, tels que des tableaux d’octets. Si vous devez encoder des données binaires arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 .NET fournit les implémentations suivantes de la <xref:System.Text.Encoding> classe pour prendre en charge les encodages Unicode et autres :  
  
-   <xref:System.Text.ASCIIEncoding> encode les caractères Unicode comme des caractères ASCII 7 bits uniques. Cet encodage ne prend en charge que les valeurs de caractère comprises entre U + 0000 et U + 007F. Page de codes 20127. Également disponible via le <xref:System.Text.Encoding.ASCII%2A> propriété.  
  
-   <xref:System.Text.UTF7Encoding> encode les caractères Unicode à l’aide de l’encodage UTF-7. Cet encodage prend en charge toutes les valeurs de caractère Unicode. Page de codes 65000. Également disponible via le <xref:System.Text.Encoding.UTF7%2A> propriété.  
  
-   <xref:System.Text.UTF8Encoding> encode les caractères Unicode à l’aide de l’encodage UTF-8. Cet encodage prend en charge toutes les valeurs de caractère Unicode. Page de codes 65001. Également disponible via le <xref:System.Text.Encoding.UTF8%2A> propriété.  
  
-   <xref:System.Text.UnicodeEncoding> encode les caractères Unicode à l’aide de l’encodage UTF-16. Les deux commandes octets little endian et big endian sont pris en charge. Également disponible via le <xref:System.Text.Encoding.Unicode%2A> propriété et le <xref:System.Text.Encoding.BigEndianUnicode%2A> propriété.  
  
-   <xref:System.Text.UTF32Encoding> encode les caractères Unicode à l’aide de l’encodage UTF-32. À la fois little endian (page de codes 12000) et les octets big endian (page de codes 12001) ordres sont pris en charge. Également disponible via le <xref:System.Text.Encoding.UTF32%2A> propriété.  
  
 Le <xref:System.Text.Encoding> classe est principalement destinée à effectuer une conversion entre différents encodages et Unicode. Une des classes Unicode dérivées est souvent le bon choix pour votre application.  
  
 Utilisez le <xref:System.Text.Encoding.GetEncoding%2A> méthode pour obtenir d’autres encodages et appelez le <xref:System.Text.Encoding.GetEncodings%2A> méthode pour obtenir une liste de tous les encodages.  
  
 Le tableau suivant répertorie les encodages pris en charge par .NET Framework et .NET Core. Il répertorie le numéro de page de code de chaque codage et les valeurs du codage <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> et <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> propriétés. Une coche dans le **prise en charge de .NET Framework** et **prise en charge .NET Core** colonnes indique que la page de codes est prise en charge par cette implémentation de .NET, quelle que soit la plateforme sous-jacente. Pour .NET Framework, la disponibilité d’autres encodages répertoriées dans le tableau varie selon le système d’exploitation. Pour .NET Core, les autres encodages sont disponibles à l’aide de la <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> classe ou par dérivation à partir de la <xref:System.Text.EncodingProvider?displayProperty=nameWithType> classe.  

> [!NOTE]
> Pages de codes dont <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> propriété correspond à une norme internationale ne sont pas nécessairement conformes dans sa totalité à cette norme. 

|Page de codes|Name|Nom affiché|Prise en charge de .NET framework| Support de .NET Core | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC (États-Unis-Canada)|||  
|437|IBM437|OEM-USA|||  
|500|IBM500|IBM EBCDIC (International)|||  
|708|ASMO-708|Arabe (ASMO 708)|||  
|720|DOS-720|Arabe (DOS)|||  
|737|ibm737|Grec (DOS)|||  
|775|ibm775|Baltique (DOS)|||  
|850|ibm850|Europe de l’Ouest (DOS)|||  
|852|ibm852|Europe centrale (DOS)|||  
|855|IBM855|Cyrilice OEM|||  
|857|ibm857|Turc (DOS)|||  
|858|IBM00858|Latin multilingue OEM je|||  
|860|IBM860|Portugais (DOS)|||  
|861|ibm861|Islandais (DOS)|||  
|862|DOS-862|Hébreu (DOS)|||  
|863|IBM863|Français canadien (DOS)|||  
|864|IBM864|Arabe (864)|||  
|865|IBM865|Severské Jazyky (DOS)|||  
|866|cp866|Cyrilice (DOS)|||  
|869|ibm869|Grec, moderne (DOS)|||  
|870|IBM870|IBM EBCDIC (Latin-2 multilingue)|||  
|874|Windows-874|Thaï (Windows)|||  
|875|cp875|IBM EBCDIC (grec moderne)|||  
|932|Shift_JIS|Japonais (Shift-JIS)|||  
|936|gb2312|Chinois simplifié (GB2312)|✓||  
|949|ks_c_5601-1987|Coréen|||  
|950|Big5|Chinois traditionnel (Big5)|||  
|1026|IBM1026|IBM EBCDIC (turc Latin-5)|||  
|1047|IBM01047|IBM Latin-1|||  
|1140|IBM01140|IBM EBCDIC (États-Unis-Canada-Europe)|||  
|1141|IBM01141|IBM EBCDIC (Allemagne-Europe)|||  
|1142|IBM01142|IBM EBCDIC (Danemark-Norvège-Europe)|||  
|1143|IBM01143|IBM EBCDIC (Finlande-Suède-Europe)|||  
|1144|IBM01144|IBM EBCDIC (Italie-Europe)|||  
|1145|IBM01145|IBM EBCDIC (Espagne-Europe)|||  
|1146|IBM01146|IBM EBCDIC (Royaume-Uni-Europe)|||  
|1147|IBM01147|IBM EBCDIC (Francie-Euro)|||  
|1148|IBM01148|IBM EBCDIC (International-Europe)|||  
|1149|IBM01149|IBM EBCDIC (Island-Euro)|||  
|1200|UTF-16|Unicode|✓|✓|  
|1201|unicodeFFFE|Unicode (Big endian)|✓|✓|  
|1250|Windows-1250|Europe centrale (Windows)|||  
|1251|Windows-1251|Cyrillique (Windows)|||  
|1252|Windows-1252|Europe occidentale (Windows)|✓||  
|1253|windows-1253|Grec (Windows)|||  
|1254|Windows-1254|Turc (Windows)|||  
|1255|Windows-1255|Hébreu (Windows)|||  
|1256|Windows-1256|Arabe (Windows)|||  
|1257|Windows-1257|Baltique (Windows)|||  
|1258|windows-1258|Vietnamien (Windows)|||  
|1361|Johab|Coréen (Johab)|||  
|10000|Macintosh|Europe de l’Ouest (Mac)|||  
|10001|x-mac-japonais|Japonais (Mac)|||  
|10002|x-mac-chinesetrad|Chinois traditionnel (Mac)|||  
|10003|x-mac-coréen|Coréen (Mac)|✓||  
|10004|x-mac-arabe|Arabe (Mac)|||  
|10005|x-mac-hébreu|Hébreu (Mac)|||  
|10006|x-mac-grec|Grec (Mac)|||  
|10007|x-mac-cyrillique|Cyrillique (Mac)|||  
|10008|x-mac-chinesesimp|Chinois simplifié (Mac)|✓||  
|10010|x-mac-roumain|Roumain (Mac)|||  
|10017|x-mac-ukrainien|Ukrainien (Mac)|||  
|10021|x-mac-thaï|Thaï (Mac)|||  
|10029|x-mac-ce|Europe centrale (Mac)|||  
|10079|x-mac-islandais|Islandais (Mac)|||  
|10081|x-mac-turc|Turc (Mac)|||  
|10082|x-mac-croate|Croate (Mac)|||  
|12000|UTF-32|Unicode (UTF-32)|✓|✓|  
|12001|UTF-32be ne|Unicode (UTF-32 Big endian)|✓|✓|  
|20000|Chinois-x-CNS|Chinois traditionnel (CNS)|||  
|20001|x-cp20001|WAN TCA|||  
|20002|Chinois-x-Eten|Chinois traditionnel (Eten)|||  
|20003|x-cp20003|WAN Ibm5550|||  
|20004|x-cp20004|WAN TeleText|||  
|20005|x-cp20005|Tchaj-WAN Wang|||  
|20105|x-IA5|Europe de l’Ouest (IA5)|||  
|20106|x-IA5-allemand|Allemand (IA5)|||  
|20107|x-IA5-suédois|Suédois (IA5)|||  
|20108|x-IA5-norvégien|Norvégien (IA5)|||  
|20127|us-ascii|US-ASCII|✓|✓|  
|20261|x-cp20261|T.61|||  
|20269|x-cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC (Allemagne)|||  
|20277|IBM277|IBM EBCDIC (Danemark-Norvège)|||  
|20278|IBM278|IBM EBCDIC (Finlande-Suède)|||  
|20280|IBM280|IBM EBCDIC (Italie)|||  
|20284|IBM284|IBM EBCDIC (Espagne)|||  
|20285|IBM285|IBM EBCDIC (ROYAUME-UNI)|||  
|20290|IBM290|IBM EBCDIC (japonais katakana)|||  
|20297|IBM297|IBM EBCDIC (France)|||  
|20420|IBM420|IBM EBCDIC (arabe)|||  
|20423|IBM423|IBM EBCDIC (grec)|||  
|20424|IBM424|IBM EBCDIC (hébreu)|||  
|20833|EBCDIC-x-KoreanExtended|IBM EBCDIC (coréen étendu)|||  
|20838|IBM-thaï|IBM EBCDIC (thaï)|||  
|20866|koi8-r|Cyrillique (KOI8-R)|||  
|20871|IBM871|IBM EBCDIC (islandais)|||  
|20880|IBM880|IBM EBCDIC (Russe cyrillique)|||  
|20905|IBM905|IBM EBCDIC (turc)|||  
|20924|IBM00924|IBM Latin-1|||  
|20932|EUC-JP|Japonais (JIS 0208-1990 et 0212-1990)|||  
|20936|x-cp20936|Chinois simplifié (GB2312-80)|✓||  
|20949|x-cp20949|Coréen Wansung|✓||  
|21025|cp1025|IBM EBCDIC (serbe cyrillique-bulgare)|||  
|21866|koi8-u|Cyrillique (KOI8-U)|||  
|28591|ISO-8859-1|Europe occidentale (ISO)|✓|✓|  
|28592|ISO-8859-2|Europe centrale (ISO)|||  
|28593|ISO-8859-3|3 latin (ISO)|||  
|28594|ISO-8859-4|Baltique (ISO)|||  
|28595|ISO-8859-5|Cyrillique (ISO)|||  
|28596|ISO-8859-6|Arabe (ISO)|||  
|28597|ISO-8859-7|Grec (ISO)|||  
|28598|ISO-8859-8|Hébreu (ISO-visuel)|✓||  
|28599|ISO-8859-9|Turc (ISO)|||  
|28603|ISO-8859-13|Estonien (ISO)|||  
|28605|ISO-8859-15|Latin 9 (ISO)|||  
|29001|x-Europa|Europa|||  
|38598|ISO-8859-8-i|Hébreu (ISO-logique)|✓||  
|50220|ISO-2022-jp|Japonais (JIS)|✓||  
|50221|csISO2022JP|Japonais (JIS-autorise Kana 1 octet)|✓||  
|50222|ISO-2022-jp|Japonais (JIS-Autoriser 1 octet Kana - donc / SI)|✓||  
|50225|ISO-2022-kr|Coréen (ISO)|✓||  
|50227|x-cp50227|Chinois simplifié (ISO-2022)|✓||  
|51932|euc-jp|Japonais (EUC)|✓||  
|51936|EUC-CN|Chinois simplifié (EUC)|✓||  
|51949|euc-kr|Coréen (EUC)|✓||  
|52936|Hz-Go-2312|Chinois simplifié (HZ)|✓||  
|54936|GB18030|Chinois simplifié (GB18030)|✓||  
|57002|x-iscii-fr|Devanagari ISCII|✓||  
|57003|être x-iscii|Bengali ISCII|✓||  
|57004|x-iscii-ta|Tamoul ISCII|✓||  
|57005|x-iscii-te|Telugu ISCII|✓||  
|57006|x-iscii-en tant que|Assamais ISCII|✓||  
|57007|iscii x ou|Oriya ISCII|✓||  
|57008|x-iscii-ka|Kannada ISCII|✓||  
|57009|x-iscii-ma|Malayalam ISCII|✓||  
|57010|x-iscii-gu|Gujarati ISCII|✓||  
|57011|x-iscii-pa|Pendjabi ISCII|✓||  
|65000|utf-7|Unicode (UTF-7)|✓|✓|  
|65001|utf-8|Unicode (UTF-8)|✓|✓|  
  
 L’exemple suivant appelle la <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> et <xref:System.Text.Encoding.GetEncoding%28System.String%29> méthodes pour obtenir le grec (Windows) de l’encodage de page de code. Il compare la <xref:System.Text.Encoding> objets retournés par les appels de méthode pour montrer qu’ils sont égaux et mappages affiche ensuite le point de code Unicode et la valeur de page de code correspondante pour chaque caractère dans l’alphabet grec.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Si les données à convertir seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou le <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le format UTF-16 et les encodeurs UTF-32 peuvent utiliser l’ordre de primauté des octets (octet le plus significatif premier) ou l’ordre d’octet avec primauté (octet le moins significatif premier). Par exemple, la lettre majuscule latine A (U + 0041) est sérialisée comme suit (en hexadécimal) :  
  
-   UTF-16 primauté des octets : 00 41  
  
-   Ordre de primauté des octets little UTF-16 : 41 00  
  
-   UTF-32 primauté des octets : 00 00 00 41  
  
-   Ordre de primauté des octets UTF-32 little : 41 00 00 00  
  
 Il est généralement plus efficace pour stocker des caractères Unicode à l’aide de l’ordre d’octet natif. Par exemple, il est préférable d’utiliser l’ordre d’octet avec primauté sur des plateformes little-endian, tels que des ordinateurs Intel.  
  
 Le <xref:System.Text.Encoding.GetPreamble%2A> méthode récupère un tableau d’octets qui inclut la marque d’ordre d’octet (BOM). Si ce tableau d’octets est ajouté en préfixe un flux encodé, il aide le décodeur pour identifier le format d’encodage utilisé.  
  
 Pour plus d’informations sur l’ordre d’octet et la marque d’ordre d’octet, consultez la norme Unicode dans le [page d’accueil Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Notez que les classes d’encodage qu’une erreur :  
  
-   Modifier en mode silencieux à un « ? » caractères.  
  
-   Utiliser un caractère « best fit ».  
  
-   Passez à un comportement spécifique à l’application à l’aide de la <xref:System.Text.EncoderFallback> et <xref:System.Text.DecoderFallback> classes avec le caractère de remplacement Unicode U + FFFD.  
  
 Vous devez lever une exception en cas d’erreur de flux de données. Une application utilise un indicateur « throwonerror » lorsqu’elle est applicable ou les <xref:System.Text.EncoderExceptionFallback> et <xref:System.Text.DecoderExceptionFallback> classes. Secours le mieux adapté est généralement pas recommandé, car elle peut entraîner une perte de données ou de la confusion et est plus lent que les remplacements de caractères simple. Pour les encodages ANSI, le comportement le mieux adapté est la valeur par défaut.  
  
   
  
## Examples  
 L’exemple suivant convertit une chaîne d’un encodage à un autre.  
  
> [!NOTE]
>  Le tableau de byte [] est le seul type dans cet exemple qui contient les données encodées. Les types .NET Char et String sont eux-mêmes Unicode, donc la <xref:System.Text.Encoding.GetChars%2A> appel décode les données en Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées substituer ce constructeur.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">Identificateur de la page de codes de l'encodage préféré.  
  
- ou - 
0, pour utiliser l'encodage par défaut.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.Encoding" /> qui correspond à la page de codes spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les classes dérivées substituer ce constructeur.  
  
 Créent des appels à ce constructeur à partir d’une classe dérivée un <xref:System.Text.Encoding> objet qui utilise le secours la mieux adaptée pour l’encodage et les opérations de décodage. À la fois le <xref:System.Text.Encoding.DecoderFallback%2A> et <xref:System.Text.Encoding.EncoderFallback%2A> propriétés sont en lecture seule et ne peut pas être modifiées. Pour contrôler la stratégie de secours pour une classe dérivée de <xref:System.Text.Encoding>, appelez le <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> est inférieur à zéro.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">Identificateur de la page de code d'encodage.</param>
        <param name="encoderFallback">Objet qui fournit une procédure de gestion d'erreurs quand un caractère ne peut pas être encodé avec l'encodage actuel.</param>
        <param name="decoderFallback">Objet qui fournit une procédure de gestion d'erreurs quand une séquence d'octets ne peut pas être décodée avec l'encodage actuel.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Text.Encoding" /> qui correspond à la page de code spécifiée avec les stratégies de secours d'encodeur et de décodeur spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est `protected`; dérivées les classes substituent.  
  
 Vous appelez ce constructeur à partir d’une classe dérivée pour contrôler l’encodage et décodage des stratégies de secours. Le <xref:System.Text.Encoding> constructeurs de classe de créent des objets de codage en lecture seule qui n’autorisent pas encodeur ou le décodeur de secours à définir une fois que l’objet est créé.  
  
 Si `encoderFallback` ou `decoderFallback` est null, secours la mieux adaptée est utilisé en tant que la stratégie de secours correspondante.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un encodage pour le jeu de caractères ASCII (7 bits).</summary>
        <value>Encodage pour le jeu de caractères ASCII (7 bits).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les caractères ASCII sont limités aux 128 caractères Unicode plus bas, à partir de U + 0000 à U + 007F.  
  
 Lorsque vous sélectionnez l’encodage ASCII pour votre application, considérez les points suivants :  
  
-   L’encodage ASCII convient généralement pour les protocoles qui requièrent ASCII.  
  
-   Si vous nécessite l’encodage 8 bits (qui est parfois nommé de façon incorrecte « ASCII »), l’encodage UTF-8 est préférable de l’ASCII encodage. Pour les caractères 0-7F, les résultats sont identiques, mais utilisez UTF-8 permet d’éviter une perte de données en permettant la représentation sous forme de tous les caractères Unicode qui peuvent être représentées. Notez que l’encodage ASCII a une 8 bits ambiguïté qui peut autoriser l’utilisation malveillante, mais l’encodage UTF-8 supprime toute ambiguïté sur le 8ème bit.  
  
-   Avant le .NET Framework version 2.0, le .NET Framework autorisés l’usurpation d’identité en ignorant la 8ème bit. À compter de .NET Framework 2.0, les points de code non-ASCII revient pendant le décodage.  
  
 Le <xref:System.Text.ASCIIEncoding> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application. Il utilise le secours de remplacement pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par un point d’interrogation (« ? ») caractères. Au lieu de cela, vous pouvez appeler la <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> méthode pour instancier un <xref:System.Text.ASCIIEncoding> objet dont exception de secours est un <xref:System.Text.EncoderFallbackException> ou un <xref:System.Text.DecoderFallbackException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant montre l’effet de l’encodage ASCII sur les caractères situés en dehors de la plage ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un encodage pour le format UTF-16 qui utilise l'ordre d'octet avec primauté des octets de poids fort (big-endian).</summary>
        <value>Objet d'encodage pour le format UTF-16 avec primauté des octets de poids fort (big-endian).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.UnicodeEncoding> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application. Il utilise le secours de remplacement pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par un point d’interrogation (« ? ») caractères. Au lieu de cela, vous pouvez appeler la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructeur pour instancier un big endian <xref:System.Text.UnicodeEncoding> objet dont exception de secours est un <xref:System.Text.EncoderFallbackException> ou un <xref:System.Text.DecoderFallbackException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Retourné <xref:System.Text.UnicodeEncoding> objet a <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, et <xref:System.Text.Encoding.WebName%2A> propriétés, qui génèrent le nom « unicodeFFFE ». Bien que la marque d’ordre de primauté des octets UTF-16 est hexadécimale FEFF, le nom « unicodeFFFE » a été choisi parce que la marque d’ordre d’octet apparaît en tant que valeur hexadécimale FFFE sur des ordinateurs Windows primautés peu.  
  
   
  
## Examples  
 L’exemple suivant lit un fichier texte avec l’encodage UTF-16 à l’aide de l’ordre de primauté des octets.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient un nom pour l’encodage actuel qui peut être utilisé avec les étiquettes de corps de texte de l’agent de messagerie.</summary>
        <value>Nom du <see cref="T:System.Text.Encoding" /> actuel qui peut être utilisé avec les balises de corps de texte de l'agent de messagerie.  
  
- ou - 
Une chaîne vide (""), si le <see cref="T:System.Text.Encoding" /> actuel ne peut pas être utilisé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous avez besoin d’un encodage pour un nom de corps, vous devez appeler <xref:System.Text.Encoding.GetEncoding%2A> avec le <xref:System.Text.Encoding.BodyName%2A> propriété. La méthode extrait souvent un encodage différent à partir de l’encodage de test fourni dans l’appel. En général uniquement les applications de messagerie nécessaire extraire un tel encodage ; la plupart des autres applications qui doivent décrire un encodage doivent utiliser son <xref:System.Text.Encoding.WebName%2A>.  
  
 Dans certains cas, la valeur de la <xref:System.Text.Encoding.BodyName%2A> propriété correspond à la norme internationale qui définit cet encodage. Cela ne signifie pas que l’implémentation est conforme à l’intégralité de cette norme.  
  
   
  
## Examples  
 L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms qui diffèrent des <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Il affiche <xref:System.Text.Encoding.EncodingName%2A> mais n’est pas considéré contre lui.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, crée une copie superficielle de l'objet <see cref="T:System.Text.Encoding" /> actuel.</summary>
        <returns>Copie de l'objet <see cref="T:System.Text.Encoding" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le clone est accessible en écriture même si la version d’origine <xref:System.Text.Encoding> objet est en lecture seule. Par conséquent, les propriétés du clone peuvent être modifiées.  
  
 Une copie superficielle d’un objet est une copie de l’objet uniquement. Si l’objet contient des références à d’autres objets, la copie superficielle ne crée pas de copie les objets référencés. Il fait référence aux objets d’origine à la place. En revanche, une copie complète d’un objet crée une copie de l’objet et une copie de tous les éléments référencés directement ou indirectement par cet objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient l'identificateur de la page de codes du <see cref="T:System.Text.Encoding" /> actuel.</summary>
        <value>Identificateur de la page de codes du <see cref="T:System.Text.Encoding" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms qui diffèrent des <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Il affiche <xref:System.Text.Encoding.EncodingName%2A> mais n’est pas considéré contre lui.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit un tableau d'octets d'un encodage à un autre.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Format d’encodage de <c>bytes</c>.</param>
        <param name="dstEncoding">Format d'encodage cible.</param>
        <param name="bytes">Octets à convertir.</param>
        <summary>Convertit un tableau d'octets entier d'un encodage à un autre.</summary>
        <returns>Tableau de type <see cref="T:System.Byte" /> contenant le résultat de la conversion de <paramref name="bytes" /> de <paramref name="srcEncoding" /> en <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant convertit une chaîne codé en Unicode à une chaîne encodée en ASCII. Étant donné que l’objet d’encodage ASCII retourné par la <xref:System.Text.Encoding.ASCII%2A> propriété utilise le remplacement de secours et le caractère Pi ne fait pas partie du jeu de caractères ASCII, le caractère Pi est remplacé par un point d’interrogation, comme la sortie de l’exemple.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="dstEncoding" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Encodage du tableau source, <c>bytes</c>.</param>
        <param name="dstEncoding">Encodage du tableau de sortie.</param>
        <param name="bytes">Tableau d'octets à convertir.</param>
        <param name="index">Index du premier élément de <c>bytes</c> à convertir.</param>
        <param name="count">Nombre d'octets à convertir.</param>
        <summary>Convertit une plage d'octets d'un encodage à un autre dans un tableau d'octets.</summary>
        <returns>Tableau de type <see cref="T:System.Byte" /> contenant le résultat de la conversion d'une plage d'octets de <paramref name="bytes" /> de <paramref name="srcEncoding" /> en <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="dstEncoding" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> et <paramref name="count" /> ne spécifient pas une plage valide du tableau d'octets.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet <see cref="T:System.Text.DecoderFallback" /> actuel de l'objet <see cref="T:System.Text.Encoding" /> actuel.</summary>
        <value>Objet de secours de décodeur pour l'objet <see cref="T:System.Text.Encoding" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.DecoderFallback> objet représente un gestionnaire d’erreurs qui est appelé quand une séquence d’octets encodée ne peut pas être décodée en un caractère. L’un des types de gestionnaires suivants est prise en charge :  
  
-   Gestionnaire de secours ajusté, qui remplace des octets qui ne peut pas être décodé par un caractère de remplacement approprié.  
  
-   Un gestionnaire de remplacement de secours, qui remplace des octets qui ne peut pas être décodé par un caractère de remplacement arbitraire. .NET inclut un gestionnaire de secours de remplacement, <xref:System.Text.DecoderFallback>, qui par défaut remplace les octets qui ne peut pas être décodé par un point d’interrogation (« ? ») caractères.  
  
-   Un gestionnaire d’exceptions de secours, qui lève une exception lorsque les octets ne peut pas être décodées. .NET inclut un gestionnaire d’exceptions de secours, <xref:System.Text.DecoderExceptionFallback>, qui lève une <xref:System.Text.DecoderFallbackException> quand les octets ne peut pas être décodés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Dans une opération ensembliste, la valeur est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une valeur ne peut pas être attribuée dans une opération ensembliste parce que l'objet <see cref="T:System.Text.Encoding" /> en cours est en lecture seule.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l’encodage par défaut pour cette implémentation .NET.</summary>
        <value>Le codage par défaut pour cette implémentation .NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Ordinateurs différents peuvent utiliser des encodages différents comme la valeur par défaut, et l’encodage par défaut peut modifier sur un seul ordinateur. Si vous utilisez le <xref:System.Text.Encoding.Default%2A> encodage pour encoder et décoder des données en continu entre les ordinateurs ou récupérées à des moments différents sur le même ordinateur, il peut incorrectement traduire ces données. En outre, l’encodage retourné par la <xref:System.Text.Encoding.Default%2A> propriété utilise le secours la mieux adaptée pour mapper les caractères non pris en charge pour les caractères pris en charge par la page de codes. Pour ces raisons, à l’aide de l’encodage par défaut n’est pas recommandé. Pour garantir que les octets encodés sont décodés correctement, vous devez utiliser un encodage Unicode, tels que <xref:System.Text.UTF8Encoding> ou <xref:System.Text.UnicodeEncoding>. Vous pouvez également utiliser un protocole de niveau supérieur pour garantir que le même format est utilisé pour encoder et décoder.  

### <a name="the-default-property-in-the-net-framework"></a>La propriété par défaut dans le .NET Framework

Dans le .NET Framework sur le bureau Windows, le <xref:System.Text.Encoding.Default%2A> propriété toujours Obtient la page de codes active du système et crée un <xref:System.Text.Encoding> objet qui correspond à ce dernier. La page de codes active peut être une page de codes ANSI, ce qui inclut le jeu, ainsi que des caractères supplémentaires qui varient par page de codes de caractères ASCII. Étant donné que tous les <xref:System.Text.Encoding.Default%2A> encodages basés sur les pages de codes ANSI de perdre des données, envisagez d’utiliser le <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> encodage à la place. UTF-8 est souvent identique U + 00 à U + 7F plage, mais peut encoder des caractères en dehors de la plage ASCII sans perte.

## <a name="the-default-property-on-net-core"></a>La propriété par défaut sur .NET Core

Sur .NET Core, le <xref:System.Text.Encoding.Default%2A> propriété retourne toujours le <xref:System.Text.UTF8Encoding>. UTF-8 est pris en charge sur tous les systèmes d’exploitation (Windows, Linux et Max OS X) sur les applications .NET Core s’exécuter.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet <see cref="T:System.Text.EncoderFallback" /> actuel de l'objet <see cref="T:System.Text.Encoding" /> actuel.</summary>
        <value>Objet de secours d'encodeur pour l'objet <see cref="T:System.Text.Encoding" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.EncoderFallback> objet représente un gestionnaire d’erreurs qui est appelé lorsqu’un caractère ne peut pas être converti en séquence d’octets encodée. L’un des types de gestionnaires suivants est prise en charge :  
  
-   Gestionnaire de secours ajusté, qui remplace les caractères qui ne peut pas être encodés avec un caractère de remplacement approprié.  
  
-   Un gestionnaire de remplacement de secours, qui remplace les caractères qui ne peut pas être encodés avec un caractère de remplacement arbitraire. .NET inclut un gestionnaire de secours de remplacement, <xref:System.Text.EncoderFallback>, qui par défaut remplace les caractères qui ne peut pas être encodés avec un point d’interrogation (« ? ») caractères.  
  
-   Un gestionnaire d’exceptions de secours, qui lève une exception lorsque les caractères ne peut pas être encodés. .NET inclut un gestionnaire d’exceptions de secours, <xref:System.Text.EncoderExceptionFallback>, qui lève une <xref:System.Text.EncoderFallbackException> quand les caractères ne peut pas être décodés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Dans une opération ensembliste, la valeur est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Une valeur ne peut pas être attribuée dans une opération ensembliste parce que l'objet <see cref="T:System.Text.Encoding" /> en cours est en lecture seule.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient la description explicite de l'encodage actuel.</summary>
        <value>Description explicite du <see cref="T:System.Text.Encoding" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoding.EncodingName%2A> propriété est conçue pour l’affichage. Pour rechercher un nom qui peut être passé à la <xref:System.Text.Encoding.GetEncoding%2A> (méthode), utilisez le <xref:System.Text.Encoding.WebName%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms qui diffèrent des <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Il affiche <xref:System.Text.Encoding.EncodingName%2A> mais n’est pas considéré contre lui.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> à comparer à l'instance actuelle.</param>
        <summary>Détermine si le <see cref="T:System.Object" /> spécifié est égal à l'instance actuelle.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> est une instance de <see cref="T:System.Text.Encoding" /> et s'il est égal à l'instance actuelle ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deux instances de <xref:System.Text.Encoding> sont considérées comme égales si elles correspondent à la même page de codes et leurs `EncoderFallback` et `DecoderFallback` objets sont égaux. En particulier, les pages de codes dérivé aient une page de codes de 0 et leurs solutions de secours sont normalement `null` (`Nothing` dans Visual Basic .NET). Par conséquent, elles sont toutes considérées comme égales entre elles. Une des conséquences sont que lorsque <xref:System.Text.Encoding.Equals%2A> est utilisé pour remplir une table de hachage, tous les encodages dérivés sont égaux et se situent dans le même emplacement de table de hachage.  
  
   
  
## Examples  
 L’exemple suivant obtient deux instances du même encodage (une par page de codes) et une autre par nom et vérifie leur égalité.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage d'un jeu de caractères.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Tableau de caractères contenant les caractères à encoder.</param>
        <summary>En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage de tous les caractères du tableau de caractères spécifié.</summary>
        <returns>Nombre d'octets produits par l'encodage de tous les caractères du tableau de caractères spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetBytes%2A> pour stocker les octets obtenus, appelez le <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.Encoding.GetBytes%2A> méthode exécute le codage. Le <xref:System.Text.Encoding.GetBytes%2A> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un seul flux d’entrée.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin encoder le nombre de caractères d’entrée à une page de codes et de traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé.  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser les versions de chaîne de la <xref:System.Text.Encoding.GetBytes%2A> (méthode).  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, vous devez réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant le jeu de caractères à encoder.</param>
        <summary>En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage des caractères de la chaîne spécifiée.</summary>
        <returns>Nombre d'octets produits par l'encodage des caractères spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetBytes%2A> pour stocker les octets obtenus, appelez le <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.Encoding.GetBytes%2A> méthode exécute le codage. Le <xref:System.Text.Encoding.GetBytes%2A> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un seul flux d’entrée.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin encoder le nombre de caractères d’entrée à une page de codes et de traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé.  
  
-   Si votre application gère des entrées de chaîne, la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A> est recommandé.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder une chaîne ou une plage dans la chaîne, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Pointeur du premier caractère à encoder.</param>
        <param name="count">Nombre de caractères à encoder.</param>
        <summary>En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage d'un jeu de caractères commençant au pointeur de caractère spécifié.</summary>
        <returns>Nombre d'octets produits par l'encodage des caractères spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille de tableau exact qui <xref:System.Text.Encoding.GetBytes%2A> requiert pour stocker les octets obtenus, vous devez appeler la <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> méthode exécute le codage. Le <xref:System.Text.Encoding.GetBytes%2A> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un seul flux d’entrée.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Certaines considérations sur l’utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin encoder le nombre de caractères d’entrée à une page de codes et de traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé.  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de la <xref:System.Text.Encoding.GetBytes%2A> (méthode).  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%2A> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est inférieur à zéro.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tableau de caractères contenant le jeu de caractères à encoder.</param>
        <param name="index">Index du premier caractère à encoder.</param>
        <param name="count">Nombre de caractères à encoder.</param>
        <summary>En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage d'un jeu de caractères du tableau de caractères spécifié.</summary>
        <returns>Nombre d'octets produits par l'encodage des caractères spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetBytes%2A> pour stocker les octets obtenus, appelez le <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.Encoding.GetBytes%2A> méthode exécute le codage. Le <xref:System.Text.Encoding.GetBytes%2A> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un seul flux d’entrée.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin encoder le nombre de caractères d’entrée à une page de codes et de traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé.  
  
-   Si votre application gère des entrées de chaîne, la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A> est recommandé.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder trois caractères d’un tableau de caractères, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, encode un jeu de caractères en séquence d'octets.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Tableau de caractères contenant les caractères à encoder.</param>
        <summary>En cas de substitution dans une classe dérivée, encode tous les caractères du tableau de caractères spécifié en séquence d'octets.</summary>
        <returns>Tableau d'octets contenant les résultats de l'encodage du jeu de caractères spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les données à convertir seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou le <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.Encoding.GetBytes%2A> méthode exécute le codage. Le <xref:System.Text.Encoding.GetBytes%2A> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un seul flux d’entrée.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin encoder le nombre de caractères d’entrée à une page de codes et de traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé. (Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu. Le <xref:System.Text.Encoder> mémorisent ce substitut afin qu’il peut être associé à un substitut faible au début d’un appel suivant. <xref:System.Text.Encoding> ne sera pas en mesure de maintenir l’état, le caractère est envoyés à la <xref:System.Text.EncoderFallback>.)  
  
-   Si votre application gère des entrées de chaîne, vous devez appeler la version de chaîne de la <xref:System.Text.Encoding.GetBytes%2A> (méthode).  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant les caractères à encoder.</param>
        <summary>En cas de substitution dans une classe dérivée, encode tous les caractères de la chaîne spécifiée en séquence d'octets.</summary>
        <returns>Tableau d'octets contenant les résultats de l'encodage du jeu de caractères spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les données à convertir seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou le <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.Encoding.GetBytes%2A> méthode exécute le codage. Le <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un seul flux d’entrée.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin encoder le nombre de caractères d’entrée à une page de codes et de traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé. (Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu. Le <xref:System.Text.Encoder> mémorisent ce substitut afin qu’il peut être associé à un substitut faible au début d’un appel suivant. <xref:System.Text.Encoding> ne sera pas en mesure de maintenir l’état, le caractère est envoyés à la <xref:System.Text.EncoderFallback>.)  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder une chaîne ou une plage dans la chaîne, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tableau de caractères contenant le jeu de caractères à encoder.</param>
        <param name="index">Index du premier caractère à encoder.</param>
        <param name="count">Nombre de caractères à encoder.</param>
        <summary>En cas de substitution dans une classe dérivée, encode un jeu de caractères du tableau de caractères spécifié en séquence d'octets.</summary>
        <returns>Tableau d'octets contenant les résultats de l'encodage du jeu de caractères spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les données à convertir seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou le <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.Encoding.GetBytes%2A> méthode exécute le codage. Le <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un seul flux d’entrée.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin encoder le nombre de caractères d’entrée à une page de codes et de traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé. (Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu. Le <xref:System.Text.Encoder> mémorisent ce substitut afin qu’il peut être associé à un substitut faible au début d’un appel suivant. <xref:System.Text.Encoding> ne sera pas en mesure de maintenir l’état, le caractère est envoyés à la <xref:System.Text.EncoderFallback>.)  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder trois caractères d’un tableau de caractères, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Pointeur du premier caractère à encoder.</param>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <param name="bytes">Pointeur de l'emplacement où commencer l'écriture de la séquence d'octets obtenue.</param>
        <param name="byteCount">Nombre maximal d'octets à écrire.</param>
        <summary>En cas de substitution dans une classe dérivée, encode un jeu de caractères commençant au pointeur de caractère spécifié en séquence d'octets stockés à partir du pointeur d'octet spécifié.</summary>
        <returns>Nombre réel d'octets écrits à l'emplacement indiqué par le paramètre <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille de tableau exact qui <xref:System.Text.Encoding.GetBytes%2A> requiert pour stocker les octets obtenus, appelez le <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> objet fourni par le <xref:System.Text.Encoding.GetDecoder%2A> ou <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.Encoding.GetBytes%2A> méthode exécute le codage. Le <xref:System.Text.Encoding.GetBytes%2A> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un seul flux d’entrée.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin encoder le nombre de caractères d’entrée à une page de codes et de traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé. (Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu. Le <xref:System.Text.Encoder> mémorisent ce substitut afin qu’il peut être associé à un substitut faible au début d’un appel suivant. <xref:System.Text.Encoding> ne sera pas en mesure de maintenir l’état, le caractère est envoyés à la <xref:System.Text.EncoderFallback>.)  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> ou <paramref name="byteCount" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> est inférieur au nombre d'octets obtenus.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tableau de caractères contenant le jeu de caractères à encoder.</param>
        <param name="charIndex">Index du premier caractère à encoder.</param>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <param name="bytes">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</param>
        <param name="byteIndex">Index auquel commencer l'écriture de la séquence d'octets obtenue.</param>
        <summary>En cas de substitution dans une classe dérivée, encode un jeu de caractères du tableau de caractères spécifié en tableau d'octets.</summary>
        <returns>Nombre réel d'octets écrits dans <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetBytes%2A> pour stocker les octets obtenus, vous devez appeler la <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Si les données à convertir seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou le <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.Encoding.GetBytes%2A> méthode exécute le codage. Le <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un seul flux d’entrée.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin encoder le nombre de caractères d’entrée à une page de codes et de traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé. (Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu. Le <xref:System.Text.Encoder> mémorisent ce substitut afin qu’il peut être associé à un substitut faible au début d’un appel suivant. <xref:System.Text.Encoding> ne sera pas en mesure de maintenir l’état, le caractère est envoyés à la <xref:System.Text.EncoderFallback>.)  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder trois caractères d’un tableau de caractères, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="charIndex" /> et <paramref name="charCount" /> ne désignent pas une plage valide dans <paramref name="chars" />.  
  
- ou - 
 <paramref name="byteIndex" /> n'est pas un index valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> ne possède pas une capacité suffisante entre <paramref name="byteIndex" /> et la fin du tableau pour prendre en charge les octets obtenus.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Chaîne contenant le jeu de caractères à encoder.</param>
        <param name="charIndex">Index du premier caractère à encoder.</param>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <param name="bytes">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</param>
        <param name="byteIndex">Index auquel commencer l'écriture de la séquence d'octets obtenue.</param>
        <summary>En cas de substitution dans une classe dérivée, encode un jeu de caractères de la chaîne spécifiée en tableau d'octets spécifié.</summary>
        <returns>Nombre réel d'octets écrits dans <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetBytes%2A> pour stocker les octets obtenus, vous devez appeler la <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Si les données à convertir seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou le <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et le <xref:System.Text.Encoding.GetBytes%2A> méthode exécute le codage. Le <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un seul flux d’entrée.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin encoder le nombre de caractères d’entrée à une page de codes et de traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé. (Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu. Le <xref:System.Text.Encoder> mémorisent ce substitut afin qu’il peut être associé à un substitut faible au début d’un appel suivant. <xref:System.Text.Encoding> ne sera pas en mesure de maintenir l’état, le caractère est envoyés à la <xref:System.Text.EncoderFallback>.)  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder une chaîne ou une plage dans la chaîne, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="charIndex" /> et <paramref name="charCount" /> ne désignent pas une plage valide dans <paramref name="chars" />.  
  
- ou - 
 <paramref name="byteIndex" /> n'est pas un index valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> ne possède pas une capacité suffisante entre <paramref name="byteIndex" /> et la fin du tableau pour prendre en charge les octets obtenus.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, calcule le nombre de caractères produits par le décodage d'une séquence d'octets.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <summary>En cas de substitution dans une classe dérivée, calcule le nombre de caractères produits par le décodage de tous les octets du tableau d'octets spécifié.</summary>
        <returns>Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> pour stocker les caractères obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> (méthode). Pour calculer la taille maximale du tableau, vous devez utiliser le <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> (méthode). Le <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et le <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin décoder plusieurs octets d’entrée à partir d’une page de codes et de traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels.  
  
-   Si votre application gère les sorties de chaîne, vous devez utiliser le <xref:System.Text.Encoding.GetString%2A> (méthode). Dans la mesure où cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lent, mais le résultat <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne dans un tableau d’octets, puis décode les octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Pointeur du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>En cas de substitution dans une classe dérivée, calcule le nombre de caractères produits par le décodage d'une séquence d'octets commençant au pointeur d'octet spécifié.</summary>
        <returns>Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille de tableau exact qui <xref:System.Text.Encoding.GetChars%2A> requiert pour stocker les caractères obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, utilisez le <xref:System.Text.Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.Encoding.GetCharCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et le <xref:System.Text.Encoding.GetChars%2A> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin décoder plusieurs octets d’entrée à partir d’une page de codes et de traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels.  
  
-   Si votre application gère les sorties de chaîne, il est recommandé d’utiliser le <xref:System.Text.Encoding.GetString%2A> (méthode). Dans la mesure où cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lent, mais le résultat <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est inférieur à zéro.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="index">Index du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>En cas de substitution dans une classe dérivée, calcule le nombre de caractères produits par le décodage d'une séquence d'octets du tableau d'octets spécifié.</summary>
        <returns>Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetChars%2A> pour stocker les caractères obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, utilisez le <xref:System.Text.Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.Encoding.GetCharCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et le <xref:System.Text.Encoding.GetChars%2A> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin décoder plusieurs octets d’entrée à partir d’une page de codes et de traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels.  
  
-   Si votre application gère les sorties de chaîne, il est recommandé d’utiliser le <xref:System.Text.Encoding.GetString%2A> (méthode). Dans la mesure où cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lent, mais le résultat <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant convertit une chaîne d’un encodage à un autre.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 L’exemple suivant encode une chaîne dans un tableau d’octets, puis décode une plage d’octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, décode une séquence d'octets en jeu de caractères.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <summary>En cas de substitution dans une classe dérivée, décode tous les octets du tableau d'octets spécifié en jeu de caractères.</summary>
        <returns>Tableau de caractères contenant les résultats du décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtient les caractères à partir d’une séquence d’octets d’entrée. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> est différent de celui <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> car <xref:System.Text.Encoding> attend des conversions discrètes, tandis que <xref:System.Text.Decoder> est conçu pour plusieurs passes sur un seul flux d’entrée.  
  
 Si les données à convertir seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou le <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 **Remarque** cette méthode est destinée à opérer sur des caractères Unicode, pas sur des données binaires arbitraires, tels que des tableaux d’octets. Si vous avez besoin d’encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Text.Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et le <xref:System.Text.Encoding.GetChars%2A> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin décoder plusieurs octets d’entrée à partir d’une page de codes et de traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, étant donné que les séquences d’octets peuvent être interrompues lors du traitement par lots. (Par exemple, dans une séquence de MAJ ISO-2022 peut mettre fin à une <xref:System.Text.Encoding.GetChars%2A> appeler et continuer au début de la prochaine <xref:System.Text.Encoding.GetChars%2A> appeler. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> appelle la procédure de secours pour ces séquences incomplètes, mais <xref:System.Text.Decoder> mémorise ces séquences pour l’appel suivant.)  
  
-   Si votre application gère les sorties de chaîne, il est recommandé d’utiliser le <xref:System.Text.Encoding.GetString%2A> (méthode). Dans la mesure où cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lent, mais le résultat <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne dans un tableau d’octets, puis décode les octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="index">Index du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>En cas de substitution dans une classe dérivée, décode une séquence d'octets du tableau d'octets spécifié en jeu de caractères.</summary>
        <returns>Tableau de caractères contenant les résultats du décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtient les caractères à partir d’une séquence d’octets d’entrée. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> est différent de celui <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> car <xref:System.Text.Encoding> attend des conversions discrètes, tandis que <xref:System.Text.Decoder> est conçu pour plusieurs passes sur un seul flux d’entrée.  
  
 Si les données à convertir seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou le <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 **Remarque** cette méthode est destinée à opérer sur des caractères Unicode, pas sur des données binaires arbitraires, tels que des tableaux d’octets. Si vous avez besoin d’encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Text.Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et le <xref:System.Text.Encoding.GetChars%2A> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin décoder plusieurs octets d’entrée à partir d’une page de codes et de traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, étant donné que les séquences d’octets peuvent être interrompues lors du traitement par lots. (Par exemple, dans une séquence de MAJ ISO-2022 peut mettre fin à une <xref:System.Text.Encoding.GetChars%2A> appeler et continuer au début de la prochaine <xref:System.Text.Encoding.GetChars%2A> appeler. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> appelle la procédure de secours pour ces séquences incomplètes, mais <xref:System.Text.Decoder> mémorise ces séquences pour l’appel suivant.)  
  
-   Si votre application gère les sorties de chaîne, il est recommandé d’utiliser le <xref:System.Text.Encoding.GetString%2A> (méthode). Dans la mesure où cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lent, mais le résultat <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne dans un tableau d’octets, puis décode une plage d’octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Pointeur du premier octet à décoder.</param>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <param name="chars">Pointeur de l'emplacement où commencer l'écriture du jeu de caractères obtenu.</param>
        <param name="charCount">Nombre maximal de caractères à écrire.</param>
        <summary>En cas de substitution dans une classe dérivée, décode une séquence d'octets commençant au pointeur d'octet spécifié en jeu de caractères stockés à partir du pointeur de caractère spécifié.</summary>
        <returns>Nombre réel de caractères écrits à l'emplacement indiqué par le paramètre <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille de tableau exact qui <xref:System.Text.Encoding.GetChars%2A> requiert pour stocker les caractères obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, utilisez le <xref:System.Text.Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.Encoding.GetCharCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtient les caractères à partir d’une séquence d’octets d’entrée. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> est différent de celui <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> car <xref:System.Text.Encoding> attend des conversions discrètes, tandis que <xref:System.Text.Decoder> est conçu pour plusieurs passes sur un seul flux d’entrée.  
  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> objet fourni par le <xref:System.Text.Encoding.GetDecoder%2A> ou <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 **Remarque** cette méthode est destinée à opérer sur des caractères Unicode, pas sur des données binaires arbitraires, tels que des tableaux d’octets. Si vous avez besoin d’encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Text.Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et le <xref:System.Text.Encoding.GetChars%2A> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin décoder plusieurs octets d’entrée à partir d’une page de codes et de traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, étant donné que les séquences d’octets peuvent être interrompues lors du traitement par lots. (Par exemple, dans une séquence de MAJ ISO-2022 peut mettre fin à une <xref:System.Text.Encoding.GetChars%2A> appeler et continuer au début de la prochaine <xref:System.Text.Encoding.GetChars%2A> appeler. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> appelle la procédure de secours pour ces séquences incomplètes, mais <xref:System.Text.Decoder> mémorise ces séquences pour l’appel suivant.)  
  
-   Si votre application gère les sorties de chaîne, le <xref:System.Text.Encoding.GetString%2A> méthode est recommandée. Dans la mesure où cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lent, mais le résultat <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="chars" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> ou <paramref name="charCount" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> est inférieur au nombre de caractères obtenus.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="byteIndex">Index du premier octet à décoder.</param>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <param name="chars">Tableau de caractères destiné à contenir le jeu de caractères obtenu.</param>
        <param name="charIndex">Index auquel commencer l'écriture du jeu de caractères obtenu.</param>
        <summary>En cas de substitution dans une classe dérivée, décode une séquence d'octets du tableau d'octets spécifié en tableau de caractères spécifié.</summary>
        <returns>Nombre réel de caractères écrits dans <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetChars%2A> pour stocker les caractères obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, utilisez le <xref:System.Text.Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.Encoding.GetCharCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > Obtient des caractères d’une séquence d’octets d’entrée. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > est différente de celle <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> car <xref:System.Text.Encoding> attend des conversions discrètes, tandis que <xref:System.Text.Decoder> est conçu pour plusieurs passes sur un flux d’entrée unique.  
  
 Si les données à convertir seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou le <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 **Remarque** cette méthode est destinée à opérer sur des caractères Unicode, pas sur des données binaires arbitraires, tels que des tableaux d’octets. Si vous avez besoin d’encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Text.Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et le <xref:System.Text.Encoding.GetChars%2A> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, contrairement à la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Certaines considérations sur la programmation pour une utilisation de ces méthodes sont les suivantes :  
  
-   Votre application peut avoir besoin décoder plusieurs octets d’entrée à partir d’une page de codes et de traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, étant donné que les séquences d’octets peuvent être interrompues lors du traitement par lots. (Par exemple, dans une séquence de MAJ ISO-2022 peut mettre fin à un [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > appeler et continuer au début de la prochaine [\], Int32, Int32, Char\<xref : System.Text.Encoding.GetChars%2A > appeler. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > appelle la procédure de secours pour ces séquences incomplètes, mais <xref:System.Text.Decoder> mémorise ces séquences pour l’appel suivant.)  
  
-   Si votre application gère les sorties de chaîne, le <xref:System.Text.Encoding.GetString%2A> méthode est recommandée. Dans la mesure où cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lent, mais le résultat <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant convertit une chaîne d’un encodage à un autre.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 L’exemple suivant encode une chaîne dans un tableau d’octets, puis décode une plage d’octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="chars" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />, <paramref name="byteCount" /> ou <paramref name="charIndex" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="byteindex" /> et <paramref name="byteCount" /> ne désignent pas une plage valide dans <paramref name="bytes" />.  
  
- ou - 
 <paramref name="charIndex" /> n'est pas un index valide dans <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> ne possède pas une capacité suffisante entre <paramref name="charIndex" /> et la fin du tableau pour prendre en charge les caractères obtenus.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient un décodeur qui convertit une séquence d'octets encodée en séquence de caractères.</summary>
        <returns>
          <see cref="T:System.Text.Decoder" /> qui convertit une séquence d'octets encodée en une séquence de caractères.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> méthode convertit des blocs d’octets séquentiels en blocs de caractères, d’une manière similaire à la <xref:System.Text.Encoding.GetChars%2A> méthode de cette classe. Toutefois, un <xref:System.Text.Decoder> conserve les informations d’état entre les appels, de sorte qu’il peut décoder les séquences d’octets qui s’étendent sur des blocs. Le <xref:System.Text.Decoder> également conserve les octets de fin à la fin des blocs de données et utilise les octets de fin dans la prochaine opération de décodage. Par conséquent, <xref:System.Text.Encoding.GetDecoder%2A> et <xref:System.Text.Encoding.GetEncoder%2A> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L’implémentation par défaut retourne un <see cref="T:System.Text.Decoder" /> qui appelle le <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> et <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> méthodes d’actuel <see cref="T:System.Text.Encoding" />. Vous devez substituer cette méthode pour retourner un <see cref="T:System.Text.Decoder" /> qui conserve son état entre les appels.</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient un encodeur qui convertit une séquence de caractères Unicode en séquence d'octets encodée.</summary>
        <returns>
          <see cref="T:System.Text.Encoder" /> qui convertit une séquence de caractères Unicode en une séquence d'octets encodée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> méthode convertit des blocs de caractères séquentiels en blocs d’octets, d’une manière similaire à la <xref:System.Text.Encoding.GetBytes%2A> méthode de cette classe. Toutefois, un <xref:System.Text.Encoder> conserve les informations d’état entre les appels et il encode correctement les séquences de caractères qui s’étendent sur des blocs. Le <xref:System.Text.Encoder> également conserve fin caractères à la fin des blocs de données et utilise les caractères de fin de la prochaine opération de codage. Par exemple, un bloc de données peut se terminer par un substitut étendu non apparié, et le substitut faible correspondant peut se trouver dans le bloc de données suivant. Par conséquent, <xref:System.Text.Encoding.GetDecoder%2A> et <xref:System.Text.Encoding.GetEncoder%2A> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L’implémentation par défaut retourne un <see cref="T:System.Text.Encoder" /> qui appelle le <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> et <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> méthodes d’actuel <see cref="T:System.Text.Encoding" />. Vous devez substituer cette méthode pour retourner un <see cref="T:System.Text.Encoder" /> qui conserve son état entre les appels.</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un encodage pour la page de codes spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">Identificateur de la page de codes de l'encodage préféré. Les valeurs possibles apparaissent dans la colonne Page de codes de la table qui s'affiche dans la rubrique de la classe <see cref="T:System.Text.Encoding" />.  
  
- ou - 
0 (zéro) pour utiliser l'encodage par défaut.</param>
        <summary>Retourne l'encodage associé à l'identificateur de page de codes spécifié.</summary>
        <returns>Encodage associé à la page de codes spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le Gestionnaire de secours varie selon le type de codage `codepage`. Si `codepage` est un code page ou sur deux octets jeu de caractères d’encodage (DBCS), un gestionnaire de secours ajusté est utilisé. Sinon, un gestionnaire de secours de remplacement est utilisé. Ces gestionnaires de secours n’est peut-être pas appropriées pour votre application. Pour spécifier le Gestionnaire de secours utilisé par l’encodage spécifié par `codepage`, vous pouvez appeler la <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> de surcharge.  
  
 Dans le .NET Framework, le <xref:System.Text.Encoding.GetEncoding%2A> méthode s’appuie sur la plateforme sous-jacente pour prendre en charge la plupart des pages de codes. Toutefois, le .NET Framework prend en charge certains encodages en mode natif. Pour obtenir la liste des pages de codes, consultez le <xref:System.Text.Encoding> rubrique de la classe. Dans .NET Core, le <xref:System.Text.Encoding.GetEncoding%2A> méthode retourne les encodages de prise en charge par .NET Core. Sur les deux implémentations de .NET, vous pouvez appeler la <xref:System.Text.Encoding.GetEncodings%2A> méthode pour obtenir un tableau de <xref:System.Text.EncodingInfo> objets qui contient des informations sur tous les encodages disponibles. 

 Outre les encodages qui sont disponibles en mode natif sur .NET Core ou qui sont pris en charge intrinsèquement sur une version de plateforme spécifique du .NET Framework, le <xref:System.Text.Encoding.GetEncoding%2A> méthode retourne les autres encodages sont rendus disponibles en inscrivant un <xref:System.Text.EncodingProvider> objet. Si le même encodage a été inscrit par plusieurs <xref:System.Text.EncodingProvider> objets, cette méthode retourne la dernière inscrit.  

Vous pouvez également fournir une valeur de 0 pour le `codepage` argument. Son comportement précis dépend si les encodages mis à la disposition en inscrivant un <xref:System.Text.EncodingProvider> objet :

- Si un ou plusieurs fournisseurs d’encodage ont été inscrites, il retourne l’encodage du dernier fournisseur inscrit qui a choisi de retourner d’encodage lorsque le <xref:System.Text.Encoding.GetEncoding%2A> est transmis à la méthode un `codepage` argument de 0.     

- Sur le .NET Framework, si aucun encodage fournisseur a été enregistré, si le <xref:System.Text.CodePagesEncodingProvider> est le fournisseur d’encodage enregistré, ou si aucun fournisseur d’encodage inscrit ne gère un `codepage` valeur égale à 0, elle retourne la page de codes active du système d’exploitation. Pour déterminer la page de codes active sur les systèmes Windows, appelez le Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) fonction à partir de .NET Framework sur le bureau Windows.

- Sur .NET Core, si aucun fournisseur d’encodage n’a pas été inscrit ou si aucun fournisseur d’encodage inscrit ne gère un `codepage` valeur égale à 0, elle retourne le <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Du code non pris en charge des pages cause un <xref:System.ArgumentException> levée, tandis que d’autres génèrent un <xref:System.NotSupportedException>. Par conséquent, votre code doit intercepter toutes les exceptions répertoriées dans la section Exceptions.  
  
> [!NOTE]
>  Les pages de codes ANSI peuvent être différents sur des ordinateurs différents et peuvent modifier sur un seul ordinateur, ce qui conduit à une altération des données. Pour cette raison, si la page de codes active est une page de codes ANSI, codage et décodage des données à l’aide de la page de codes par défaut retourné par `Encoding.GetEncoding(0)` n’est pas recommandée. Pour obtenir des résultats plus cohérents, vous devez utiliser un encodage Unicode, tel que UTF-8 (page de codes 65001) ou UTF-16, au lieu d’une page de codes spécifique.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Retourne une instance mise en cache avec les paramètres par défaut. Vous devez utiliser les constructeurs de classes dérivées pour obtenir une instance avec des paramètres différents. Par exemple, le <xref:System.Text.UTF32Encoding> classe fournit un constructeur qui vous permet d’activer la détection d’erreurs.  

   
  
## Examples  
 L’exemple suivant obtient deux instances du même encodage (une par page de codes) et une autre par nom et vérifie leur égalité.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> est inférieur à 0 ou supérieur à 65535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> n'est pas pris en charge par la plateforme sous-jacente.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> n'est pas pris en charge par la plateforme sous-jacente.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la page de codes de l'encodage préféré. Toute valeur retournée par la propriété <see cref="P:System.Text.Encoding.WebName" /> est valide. Les valeurs possibles apparaissent dans la colonne Nom de la table qui s'affiche dans la rubrique de la classe <see cref="T:System.Text.Encoding" />.</param>
        <summary>Retourne l'encodage associé au nom de la page de codes spécifiée.</summary>
        <returns>Encodage associé à la page de codes spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le Gestionnaire de secours varie selon le type de codage `name`. Si `name` est un code page ou sur deux octets jeu de caractères d’encodage (DBCS), un gestionnaire de secours ajusté est utilisé. Sinon, un gestionnaire de secours de remplacement est utilisé. Ces gestionnaires de secours n’est peut-être pas appropriées pour votre application. Pour spécifier le Gestionnaire de secours utilisé par l’encodage spécifié par `name`, vous pouvez appeler la <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> de surcharge.  

Dans le .NET Framework, le <xref:System.Text.Encoding.GetEncoding%2A> méthode s’appuie sur la plateforme sous-jacente pour prendre en charge la plupart des pages de codes. Toutefois, le .NET Framework prend en charge certains encodages en mode natif. Pour obtenir la liste des pages de codes, consultez le <xref:System.Text.Encoding> rubrique de la classe. Dans .NET Core, le <xref:System.Text.Encoding.GetEncoding%2A> méthode retourne les encodages de prise en charge par .NET Core. Sur les deux implémentations de .NET, vous pouvez appeler la <xref:System.Text.Encoding.GetEncodings%2A> méthode pour obtenir un tableau de <xref:System.Text.EncodingInfo> objets qui contient des informations sur tous les encodages disponibles. 

 Outre les encodages qui sont disponibles en mode natif sur .NET Core ou qui sont pris en charge intrinsèquement sur une version de plateforme spécifique du .NET Framework, le <xref:System.Text.Encoding.GetEncoding%2A> méthode retourne les autres encodages sont rendus disponibles en inscrivant un <xref:System.Text.EncodingProvider> objet. Si le même encodage a été inscrit par plusieurs <xref:System.Text.EncodingProvider> objets, cette méthode retourne la dernière inscrit.  
   
> [!NOTE]
>  Les pages de codes ANSI peuvent être différents sur des ordinateurs différents, ou peuvent être modifiés pour un seul ordinateur, ce qui conduit à une altération des données. Pour obtenir des résultats plus cohérents, vous devez utiliser Unicode, tel que UTF-8 (page de codes 65001) ou UTF-16, au lieu d’une page de codes spécifique.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> Retourne une instance mise en cache avec les paramètres par défaut. Vous devez utiliser les constructeurs de classes dérivées pour obtenir une instance avec des paramètres différents. Par exemple, le <xref:System.Text.UTF32Encoding> classe fournit un constructeur qui vous permet d’activer la détection d’erreurs.  
  
## Examples  
 L’exemple suivant obtient deux instances du même encodage (une par page de codes) et une autre par nom et vérifie leur égalité.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> n'est pas un nom de page de codes valide.  
  
- ou - 
La page de codes indiquée par <paramref name="name" /> n'est pas prise en charge par la plateforme sous-jacente.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">Identificateur de la page de codes de l'encodage préféré. Les valeurs possibles apparaissent dans la colonne Page de codes de la table qui s'affiche dans la rubrique de la classe <see cref="T:System.Text.Encoding" />.  
  
- ou - 
0 (zéro) pour utiliser l'encodage par défaut.</param>
        <param name="encoderFallback">Objet qui fournit une procédure de gestion d'erreurs quand un caractère ne peut pas être encodé avec l'encodage actuel.</param>
        <param name="decoderFallback">Objet qui fournit une procédure de gestion d'erreurs quand une séquence d'octets ne peut pas être décodée avec l'encodage actuel.</param>
        <summary>Retourne l'encodage associé à l'identificateur de page de codes spécifié. Les paramètres spécifient un gestionnaire d'erreurs pour les caractères qui ne peuvent pas être encodés et pour les séquences d'octets qui ne peuvent pas être décodées.</summary>
        <returns>Encodage associé à la page de codes spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Certaines pages de codes non prise en charge de provoquer l’exception <xref:System.ArgumentException> levée, tandis que d’autres génèrent <xref:System.NotSupportedException>. Par conséquent, votre code doit intercepter toutes les exceptions répertoriées dans la section Exceptions.  

Dans le .NET Framework, le <xref:System.Text.Encoding.GetEncoding%2A> méthode s’appuie sur la plateforme sous-jacente pour prendre en charge la plupart des pages de codes. Toutefois, le .NET Framework prend en charge certains encodages en mode natif. Pour obtenir la liste des pages de codes, consultez le <xref:System.Text.Encoding> rubrique de la classe. Dans .NET Core, le <xref:System.Text.Encoding.GetEncoding%2A> méthode retourne les encodages de prise en charge par .NET Core. Sur les deux implémentations de .NET, vous pouvez appeler la <xref:System.Text.Encoding.GetEncodings%2A> méthode pour obtenir un tableau de <xref:System.Text.EncodingInfo> objets qui contient des informations sur tous les encodages disponibles. 

 Outre les encodages qui sont disponibles en mode natif sur .NET Core ou qui sont pris en charge intrinsèquement sur une version de plateforme spécifique du .NET Framework, le <xref:System.Text.Encoding.GetEncoding%2A> méthode retourne les autres encodages sont rendus disponibles en inscrivant un <xref:System.Text.EncodingProvider> objet. Si le même encodage a été inscrit par plusieurs <xref:System.Text.EncodingProvider> objets, cette méthode retourne la dernière inscrit.  

Vous pouvez également fournir une valeur de 0 pour le `codepage` argument. Son comportement précis dépend si les encodages mis à la disposition en inscrivant un <xref:System.Text.EncodingProvider> objet :

- Si un ou plusieurs fournisseurs d’encodage ont été inscrites, il retourne l’encodage du dernier fournisseur inscrit qui a choisi de retourner d’encodage lorsque le <xref:System.Text.Encoding.GetEncoding%2A> est transmis à la méthode un `codepage` argument de 0.     

- Sur le .NET Framework, si aucun encodage fournisseur a été enregistré, si le <xref:System.Text.CodePagesEncodingProvider> est le fournisseur d’encodage enregistré, ou si aucun fournisseur d’encodage inscrit ne gère un `codepage` valeur égale à 0, elle retourne la page de codes active.

- Sur .NET Core, si aucun fournisseur d’encodage n’a pas été inscrit ou si aucun fournisseur d’encodage inscrit ne gère un `codepage` valeur égale à 0, elle retourne le <xref:System.Text.UTF8Encoding> encodage.

> [!NOTE]
>  Les pages de codes ANSI peuvent être différents sur des ordinateurs différents et peuvent modifier sur un seul ordinateur, ce qui conduit à une altération des données. Pour cette raison, si la page de codes active est une page de codes ANSI, codage et décodage des données à l’aide de la page de codes par défaut retourné par `Encoding.GetEncoding(0)` n’est pas recommandée. Pour obtenir des résultats plus cohérents, vous devez utiliser Unicode, tel que UTF-8 (page de codes 65001) ou UTF-16, au lieu d’une page de codes spécifique. 
  
 Pour obtenir l’encodage associé à la page de codes active, vous pouvez soit fournir une valeur de 0 pour le `codepage` argument ou, si votre code s’exécute sur le .NET Framework sur le bureau Windows, récupérez la valeur de la <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> propriété. Pour déterminer la page de codes active actuelle, appelez le Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) fonction à partir de .NET Framework sur le bureau Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Retourne une instance mise en cache avec les paramètres par défaut. Vous devez utiliser les constructeurs de classes dérivées pour obtenir une instance avec des paramètres différents. Par exemple, le <xref:System.Text.UTF32Encoding> classe fournit un constructeur qui vous permet d’activer la détection d’erreurs.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> (méthode).  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> est inférieur à 0 ou supérieur à 65535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> n'est pas pris en charge par la plateforme sous-jacente.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> n'est pas pris en charge par la plateforme sous-jacente.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la page de codes de l'encodage préféré. Toute valeur retournée par la propriété <see cref="P:System.Text.Encoding.WebName" /> est valide. Les valeurs possibles apparaissent dans la colonne Nom de la table qui s'affiche dans la rubrique de la classe <see cref="T:System.Text.Encoding" />.</param>
        <param name="encoderFallback">Objet qui fournit une procédure de gestion d'erreurs quand un caractère ne peut pas être encodé avec l'encodage actuel.</param>
        <param name="decoderFallback">Objet qui fournit une procédure de gestion d'erreurs quand une séquence d'octets ne peut pas être décodée avec l'encodage actuel.</param>
        <summary>Retourne l'encodage associé au nom de la page de codes spécifiée. Les paramètres spécifient un gestionnaire d'erreurs pour les caractères qui ne peuvent pas être encodés et pour les séquences d'octets qui ne peuvent pas être décodées.</summary>
        <returns>Encodage associé à la page de codes spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Dans le .NET Framework, le <xref:System.Text.Encoding.GetEncoding%2A> méthode s’appuie sur la plateforme sous-jacente pour prendre en charge la plupart des pages de codes. Toutefois, le .NET Framework prend en charge certains encodages en mode natif. Pour obtenir la liste des pages de codes, consultez le <xref:System.Text.Encoding> rubrique de la classe. Dans .NET Core, le <xref:System.Text.Encoding.GetEncoding%2A> méthode retourne les encodages de prise en charge par .NET Core. Sur les deux implémentations de .NET, vous pouvez appeler la <xref:System.Text.Encoding.GetEncodings%2A> méthode pour obtenir un tableau de <xref:System.Text.EncodingInfo> objets qui contient des informations sur tous les encodages disponibles. 

 Outre les encodages qui sont disponibles en mode natif sur .NET Core ou qui sont pris en charge intrinsèquement sur une version de plateforme spécifique du .NET Framework, le <xref:System.Text.Encoding.GetEncoding%2A> méthode retourne les autres encodages sont rendus disponibles en inscrivant un <xref:System.Text.EncodingProvider> objet. Si le même encodage a été inscrit par plusieurs <xref:System.Text.EncodingProvider> objets, cette méthode retourne la dernière inscrit.  
  
> [!NOTE]
>  Les pages de codes ANSI peuvent être différents sur des ordinateurs différents et peuvent modifier sur un seul ordinateur, ce qui conduit à une altération des données. Pour obtenir des résultats plus cohérents, vous devez utiliser un encodage Unicode, tel que UTF-8 (page de codes 65001) ou UTF-16, au lieu d’une page de codes spécifique.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Retourne une instance mise en cache avec les paramètres par défaut. Vous devez utiliser les constructeurs de classes dérivées pour obtenir une instance avec des paramètres différents. Par exemple, le <xref:System.Text.UTF32Encoding> classe fournit un constructeur qui vous permet d’activer la détection d’erreurs.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> (méthode).  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> n'est pas un nom de page de codes valide.  
  
- ou - 
La page de codes indiquée par <paramref name="name" /> n'est pas prise en charge par la plateforme sous-jacente.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un tableau qui contient tous les encodages.</summary>
        <returns>Tableau qui contient tous les encodages.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne une liste des encodages pris en charge, que se différenciés uniquement par la page de codes. Pour une table qui répertorie les encodages pris en charge, consultez le <xref:System.Text.Encoding> rubrique de la classe.  
  
> [!NOTE]
>  La liste des encodages pris en charge retournés par la <xref:System.Text.Encoding.GetEncodings%2A> méthode n’inclut pas les autres encodages mis à disposition par les <xref:System.Text.EncodingProvider> implémentations qui ont été enregistrées par des appels à la <xref:System.Text.Encoding.RegisterProvider%2A> (méthode).  
  
 Sur le .NET Framework, les encodages 50220 et 50222 sont associés le nom « iso-2022-jp », mais ils ne sont pas identiques. Encodage 50220 convertit les caractères Katakana à demi-chasse en caractères Katakana à pleine chasse, tandis que l’encodage 50222 utilise une séquence Maj/Maj sorti pour encoder les caractères Katakana à demi-chasse. Le nom d’affichage pour l’encodage 50222 est « japonais (JIS-Autoriser 1 octet Kana - donc / SI) » pour le distinguer de l’encodage 50220 dont l’affichage nommer « japonais (JIS) ».  
  
 Si vous demandez l’encodage nom « iso-2022-jp », le .NET Framework retourne l’encodage 50220. Toutefois, l’encodage est appropriée pour votre application dépend du traitement préféré des caractères Katakana à demi-chasse.  
  
 Pour obtenir un encodage spécifique, vous devez utiliser le <xref:System.Text.Encoding.GetEncoding%2A> (méthode).  
  
 <xref:System.Text.Encoding.GetEncodings%2A> est parfois utilisé pour présenter à l’utilisateur avec une liste des encodages dans un fichier **enregistrer en tant que** boîte de dialogue. Toutefois, nombreux encodages non-Unicode sont incomplets et traduire le nombre de caractères à « ? », ou avoir un comportement légèrement différent sur différentes plateformes. Envisagez d’utiliser UTF-8 ou UTF-16 en tant que la valeur par défaut.  
  
   
  
## Examples  
 L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage pour l'instance actuelle.</summary>
        <returns>Code de hachage de l'instance actuelle.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Nombre de caractères à encoder.</param>
        <summary>En cas de substitution dans une classe dérivée, calcule le nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</summary>
        <returns>Nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `charCount` paramètre spécifie le nombre de <xref:System.Char> objets qui représentent les caractères Unicode à encoder, étant donné que .NET utilise en interne UTF-16 pour représenter les caractères Unicode. Par conséquent, la plupart des caractères Unicode peuvent être représentés par un <xref:System.Char> objet, mais un caractère Unicode représenté par une paire de substitution, par exemple, nécessite deux <xref:System.Char> objets.  
  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetBytes%2A> pour stocker les octets obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, utilisez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> Récupère un nombre le plus défavorable, y compris le pire des cas correspondant à votre actuellement <xref:System.Text.EncoderFallback>. Si une procédure de secours est choisi avec une chaîne potentiellement grande, <xref:System.Text.Encoding.GetMaxByteCount%2A> récupère des valeurs élevées, en particulier dans les cas où le pire des cas pour l’encodage implique des modes de commutation pour chaque caractère. Par exemple, cela peut se produire pour ISO-2022-JP. Pour plus d’informations, consultez le billet de blog «[What ' s avec Encoding.GetMaxByteCount et Encoding.GetMaxCharCount () ?](http://go.microsoft.com/fwlink/?LinkId=153702)» (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 Dans la plupart des cas, cette méthode récupère des valeurs raisonnables pour les petites chaînes. Pour les chaînes de grande taille, vous devrez peut-être choisir entre l’utilisation de mémoires tampons de grande et interception des erreurs dans les rares cas quand une mémoire tampon plus raisonnable est trop petite. Vous pourriez également envisager une approche différente à l’aide <xref:System.Text.Encoding.GetByteCount%2A> ou <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 Lorsque vous utilisez <xref:System.Text.Encoding.GetMaxByteCount%2A>, vous devez allouer le tampon de sortie selon la taille maximale de la mémoire tampon d’entrée. Si la mémoire tampon de sortie est limité en taille, vous pouvez utiliser le <xref:System.Text.Encoding.Convert%2A> (méthode).  
  
 Notez que <xref:System.Text.Encoding.GetMaxByteCount%2A> prend en compte les substituts potentiels restants d’une opération de décodeur précédente. En raison du décodeur, en passant une valeur de 1 à la méthode extrait 2 pour un encodage sur un octet, par exemple ASCII. Vous devez utiliser le <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> propriété si cette information est nécessaire.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` n’est pas nécessairement la même valeur que `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> est inférieur à zéro.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> a la valeur <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Tous les <see cref="T:System.Text.Encoding" /> implémentations doivent garantir qu’aucune exception de dépassement de capacité de mémoire tampon se produit si les mémoires tampons sont dimensionnés en fonction des résultats des calculs de cette méthode.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <summary>En cas de substitution dans une classe dérivée, calcule le nombre maximal de caractères produits par le décodage du nombre de caractères spécifié.</summary>
        <returns>Nombre maximal de caractères produits par le décodage du nombre d'octets spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetChars%2A> pour stocker les caractères obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, utilisez le <xref:System.Text.Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.Encoding.GetCharCount%2A> méthode permet généralement d’allocation de moins de mémoire, tandis que le <xref:System.Text.Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> Récupère un nombre le plus défavorable, y compris le pire des cas correspondant à votre actuellement <xref:System.Text.DecoderFallback>. Si une procédure de secours est choisi avec une chaîne potentiellement grande, <xref:System.Text.Encoding.GetMaxCharCount%2A> récupère des valeurs élevées.  
  
 Dans la plupart des cas, cette méthode récupère un nombre raisonnable pour les petites chaînes. Pour les chaînes de grande taille, vous devrez peut-être choisir entre l’utilisation de mémoires tampons de grande et interception des erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est trop petite. Vous pourriez également envisager une approche différente à l’aide <xref:System.Text.Encoding.GetCharCount%2A> ou <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> n’a aucun lien avec <xref:System.Text.Encoding.GetBytes%2A>. Si vous avez besoin d’une fonction similaire à utiliser avec <xref:System.Text.Encoding.GetBytes%2A>, vous devez utiliser <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 Lorsque vous utilisez <xref:System.Text.Encoding.GetMaxCharCount%2A>, vous devez allouer le tampon de sortie selon la taille maximale de la mémoire tampon d’entrée. Si la mémoire tampon de sortie est limité en taille, vous pouvez utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> (méthode).  
  
 Notez que <xref:System.Text.Encoding.GetMaxCharCount%2A> considère que le pire des cas pour les octets restants à partir d’une opération d’encodeur précédent. Pour la plupart des pages de codes, en passant une valeur de 0 à cette méthode récupère les valeurs supérieures ou égales à 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` n’est pas nécessairement la même valeur que `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne dans un tableau d’octets, puis décode les octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> est inférieur à zéro.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Tous les <see cref="T:System.Text.Encoding" /> implémentations doivent garantir qu’aucune exception de dépassement de capacité de mémoire tampon se produit si les mémoires tampons sont dimensionnés en fonction des résultats des calculs de cette méthode.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, retourne une séquence d'octets qui spécifie l'encodage utilisé.</summary>
        <returns>Tableau d'octets contenant une séquence d'octets qui spécifie l'encodage utilisé.  
  
- ou - 
Tableau d'octets de longueur nulle si aucun préambule n'est requis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous le souhaitez, le <xref:System.Text.Encoding> objet fournit un préambule qui est un tableau d’octets qui peut porter comme préfixe à la séquence d’octets résultant du processus de codage. Si le préambule contient une marque d’ordre d’octet (au format Unicode, le point de code U + FEFF), il aide le décodeur à déterminer l’ordre d’octet et que le format de transformation ou UTF.  
  
 La marque d’ordre octet Unicode (BOM) est sérialisée comme suit (hexadécimal) :  
  
-   UTF-8 : EF BB BF  
  
-   UTF-16 primauté des octets : FE FF  
  
-   Ordre de primauté des octets UTF-16 little : FF FE  
  
-   UTF-32 primauté des octets : 00 00 FE FF  
  
-   Ordre de primauté des octets UTF-32 little : FF FE 00 00  
  
 Vous devez utiliser la marque BOM, car il fournit une certaine identification d’un encodage pour fichiers qui autres ont perdu la référence à la <xref:System.Text.Encoding> objet, par exemple, sans balise ou incorrectement référencées données web ou des fichiers texte aléatoires stockés lorsqu’une entreprise n’ont pas avoir des intérêts internationaux ou autres données. Souvent les problèmes d’utilisateur peuvent être évités si les données sont correctement et régulièrement référencées, de préférence dans UTF-8 ou UTF-16.  
  
 Des normes qui fournissent un type de codage, un BOM est quelque peu redondant. Toutefois, il peut être utilisé pour aider à un serveur d’envoyer l’en-tête de codage correct. Ou bien, il peut être utilisé comme solution de secours si l’encodage est perdu.  
  
 Il existe certains inconvénients à l’utilisation d’une nomenclature. Par exemple, savoir comment limiter les champs de base de données qui utilisent un BOM peut être difficile. Concaténation de fichiers peut être un problème également, par exemple, lorsque les fichiers sont fusionnés de telle façon un caractère inutile peut se retrouver au milieu des données. Malgré le peu d’inconvénients, cependant, l’utilisation d’une nomenclature est hautement recommandée.  
  
 Pour plus d’informations sur l’ordre d’octet et la marque d’ordre d’octet, consultez la norme Unicode dans le [page d’accueil Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Pour vous assurer que les octets encodés sont décodés correctement, vous devez précéder les octets encodés avec un préambule. Toutefois, la plupart des encodages ne fournissent pas de préambule. Pour garantir que les octets encodés sont décodés correctement, vous devez utiliser un encodage Unicode, autrement dit, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, ou <xref:System.Text.UTF32Encoding>, avec un préambule.  
  
   
  
## Examples  
 L’exemple suivant détermine l’ordre d’octet de l’encodage selon le préambule.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, décode une séquence d'octets en chaîne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <summary>En cas de substitution dans une classe dérivée, décode tous les octets du tableau d'octets spécifié en chaîne.</summary>
        <returns>Chaîne contenant les résultats du décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les données à convertir seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> objet retourné par la <xref:System.Text.Encoding.GetDecoder%2A> d’un a (méthode) classe de VED.  
  
 Consultez la section Notes de la <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> rubrique de référence pour une description des techniques et les considérations de décodage.  
  
 Notez que le comportement précis de la <xref:System.Text.Encoding.GetString%2A> méthode pour un particulier <xref:System.Text.Encoding> implémentation dépend de la stratégie de secours définie pour cette <xref:System.Text.Encoding> objet. Pour plus d’informations, consultez la section « Choix d’une stratégie de secours » de la [encodage de caractères dans .NET](~/docs/standard/base-types/character-encoding.md) rubrique.  
  
   
  
## Examples  
 L’exemple suivant lit une chaîne encodée en UTF-8 à partir d’un fichier binaire est représenté par un <xref:System.IO.FileStream> objet. Pour les fichiers qui sont inférieures à 2 048 octets, il lit le contenu du fichier entier dans un tableau d’octets et appelle le <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> méthode pour effectuer le décodage. Pour les fichiers plus volumineux, il lit 2 048 octets à la fois dans un tableau d’octets, appelle le <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour déterminer le nombre de caractères contenus dans le tableau, puis appelle la <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour effectuer le décodage.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 L’exemple utilise le texte suivant, qui doit être enregistré dans un fichier encodé en UTF-8 nommé Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le tableau d'octets contient des points de code Unicode non valides.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Pointeur vers un tableau d'octets.</param>
        <param name="byteCount">Nombre d'octets à décoder.</param>
        <summary>En cas de substitution dans une classe dérivée, décode un nombre d'octets spécifié en commençant à une adresse spécifiée dans une chaîne.</summary>
        <returns>Chaîne contenant les résultats du décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoding.GetString%2A> méthode est conçue pour optimiser les performances lorsque vous avez un pointeur natif vers un tableau d’octets. Au lieu de la création d’un tableau d’octets gérés et ensuite le décodage, vous pouvez à la place appeler cette méthode sans avoir à créer tous les objets intermédiaires.  
  
 Si les données à convertir seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> objet retourné par la <xref:System.Text.Encoding.GetDecoder%2A> d’un a (méthode) classe de VED.  
  
 Consultez la section Notes de la <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> rubrique de référence pour une description des techniques et les considérations de décodage.  
  
 Notez que le comportement précis de la <xref:System.Text.Encoding.GetString%2A> méthode pour un particulier <xref:System.Text.Encoding> implémentation dépend de la stratégie de secours définie pour cette <xref:System.Text.Encoding> objet. Pour plus d’informations, consultez la section « Choix d’une stratégie de secours » de la [encodage de caractères dans .NET](~/docs/standard/base-types/character-encoding.md) rubrique.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> est un pointeur Null</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> est inférieur à zéro.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tableau d'octets contenant la séquence d'octets à décoder.</param>
        <param name="index">Index du premier octet à décoder.</param>
        <param name="count">Nombre d'octets à décoder.</param>
        <summary>En cas de substitution dans une classe dérivée, décode une séquence d'octets du tableau d'octets spécifié en chaîne.</summary>
        <returns>Chaîne contenant les résultats du décodage de la séquence d'octets spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les données à convertir seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou le <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Consultez la section Notes de la <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> rubrique de référence pour une description des techniques et les considérations de décodage.  
  
   
  
## Examples  
 L’exemple suivant lit une chaîne encodée en UTF-8 à partir d’un fichier binaire qui est représenté par un <xref:System.IO.FileStream> objet. Pour les fichiers qui sont inférieures à 2 048 octets, il lit le contenu du fichier entier dans un tableau d’octets et appelle le <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> méthode pour effectuer le décodage. Pour les fichiers plus volumineux, il lit 2 048 octets à la fois dans un tableau d’octets, appelle le <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour déterminer le nombre de caractères contenus dans le tableau, puis appelle la <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour effectuer le décodage.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 L’exemple utilise le texte suivant, qui doit être enregistré dans un fichier encodé en UTF-8 nommé Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le tableau d'octets contient des points de code Unicode non valides.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="index" /> et <paramref name="count" /> ne désignent pas une plage valide dans <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Une procédure de secours a eu lieu (consultez [Encodage de caractères au format .NET ](~/docs/standard/base-types/character-encoding.md) pour obtenir une explication complète) 
-et- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> a la valeur <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient un nom pour l’encodage actuel qui peut être utilisé avec les étiquettes d’en-tête de l’agent de messagerie.</summary>
        <value>Nom du <see cref="T:System.Text.Encoding" /> actuel à utiliser avec les balises d'en-tête de l'agent de messagerie.  
  
- ou - 
Une chaîne vide (""), si le <see cref="T:System.Text.Encoding" /> actuel ne peut pas être utilisé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous avez besoin d’un encodage pour un nom d’en-tête, vous devez appeler la <xref:System.Text.Encoding.GetEncoding%2A> méthode avec le <xref:System.Text.Encoding.HeaderName%2A> propriété. La méthode extrait souvent un encodage différent à partir de l’encodage de test fourni dans l’appel. En général uniquement les applications de messagerie doivent extraire un tel encodage.  
  
 Dans certains cas, la valeur de la <xref:System.Text.Encoding.BodyName%2A> propriété correspond à la norme internationale qui définit cet encodage. Cela ne signifie pas que l’implémentation est conforme à l’intégralité de cette norme.  
  
 Notez que <xref:System.Text.Encoding.WebName%2A> retourne le nom à utiliser pour décrire un encodage. Le <xref:System.Text.Encoding.HeaderName%2A> propriété définit un encodage différent qui peut fonctionner mieux pour une application de messagerie, par exemple. Toutefois, l’utilisation de la propriété pour définir l’encodage n’est pas recommandée.  
  
   
  
## Examples  
 L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms qui diffèrent des <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Il affiche <xref:System.Text.Encoding.EncodingName%2A> mais n’est pas considéré contre lui.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une valeur indiquant si l'encodage actuel est toujours normalisé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une valeur indiquant si l'encodage actuel est toujours normalisé en utilisant le formulaire de normalisation par défaut.</summary>
        <returns>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> en cours est toujours normalisé ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le formulaire de normalisation par défaut est <xref:System.Text.NormalizationForm.FormC>, qui utilise la décomposition canonique complète, suivie du remplacement des séquences par leurs composites principaux, si possible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">Une des valeurs de <see cref="T:System.Text.NormalizationForm" />.</param>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel est toujours normalisé en utilisant le formulaire de normalisation spécifié.</summary>
        <returns>
          <see langword="true" /> si l'objet <see cref="T:System.Text.Encoding" /> actuel est toujours normalisé en utilisant la valeur <see cref="T:System.Text.NormalizationForm" /> spécifiée ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le formulaire de normalisation par défaut est <xref:System.Text.NormalizationForm.FormC>, qui utilise la décomposition canonique complète, suivie du remplacement des séquences par leurs composites principaux, si possible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel peut être utilisé par les clients de navigation pour afficher le contenu.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> en cours peut être utilisé par les clients de navigateur pour afficher le contenu ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel peut être utilisé par les clients de navigation pour enregistrer du contenu.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> en cours peut être utilisé par les clients de navigateur pour enregistrer le contenu ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel peut être utilisé par les clients de messagerie et de news pour afficher du contenu.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> en cours peut être utilisé par les clients de messagerie et de news pour afficher le contenu ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel peut être utilisé par les clients de messagerie et de news pour enregistrer du contenu.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> actuel peut être utilisé par les clients de messagerie et de news pour enregistrer du contenu ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel est en lecture seule.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> actuel est en lecture seule ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel utilise des points de code codés sur un octet.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> actuel utilise des points de code codés sur un octet ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sur un octet d’encodage, par exemple, <xref:System.Text.ASCIIEncoding>, cette propriété récupère `true`.  
  
> [!CAUTION]
>  Vous devez être prudent dans ce que fait votre application avec la valeur de <xref:System.Text.Encoding.IsSingleByte%2A>. Une hypothèse de la façon dont un encodage continuera peut toujours être incorrecte. Par exemple, Windows-1252 a une valeur de `true` pour <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, mais Encoding.GetMaxByteCount (1) renvoie 2. Il s’agit, car la méthode prend en compte les substituts potentiels restants d’une opération de décodeur précédente.  
  
   
  
## Examples  
 L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Sous-classe de <see cref="T:System.Text.EncodingProvider" /> qui fournit l'accès à des encodages de caractères supplémentaires.</param>
        <summary>Enregistre un fournisseur d'encodage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoding.RegisterProvider%2A> méthode vous permet d’enregistrer une classe dérivée de <xref:System.Text.EncodingProvider> qui rend caractères encodages disponibles sur une plateforme qui ne les gère pas dans le cas contraire. Une fois que le fournisseur d’encodage est inscrit, les encodages pris en charge peuvent être récupérées en appelant une <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> de surcharge. S’il existe plusieurs fournisseurs d’encodage, le <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> méthode tente de récupérer un encodage spécifié à partir de chaque fournisseur en commençant par la plus récemment enregistré.

L’inscription d’un fournisseur d’encodage à l’aide de la <xref:System.Text.Encoding.RegisterProvider%2A> méthode modifie également le comportement de la [Encoding.GetEncoding (Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) et [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) méthodes quand il est passé un argument de `0`:

- Si le fournisseur inscrit est le <xref:System.Text.CodePagesEncodingProvider>, la méthode retourne l’encodage qui correspond à la page de code active du système lors de l’exécution sur le système d’exploitation Windows.

- Un fournisseur d’encodage personnalisé peut choisir le codage à retourner lorsque une de ces <xref:System.Text.Encoding.GetEncoding%2A> surcharges de méthode est passé un argument de `0`. Le fournisseur peut également choisir de ne renvoyer un encodage en ayant la <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> retour de la méthode `null`. 
  
À compter de .NET Framework 4.6, le .NET Framework inclut un fournisseur d’encodage, <xref:System.Text.CodePagesEncodingProvider>, qui rend les encodages disponibles qui sont présents dans le .NET Framework complet, mais ne sont pas disponibles dans la plateforme Windows universelle. Par défaut, la plateforme Windows universelle ne prend en charge les encodages Unicode, ASCII et la page de codes 28591.  
  
 Si le même fournisseur d’encodage est utilisé dans plusieurs appels à la <xref:System.Text.Encoding.RegisterProvider%2A> méthode, seul le premier appel de méthode inscrit le fournisseur. Les appels suivants sont ignorés.  
  
 Si le <xref:System.Text.Encoding.RegisterProvider%2A> méthode est appelée pour inscrire plusieurs fournisseurs qui gèrent le même encodage, le dernier fournisseur inscrit est utilisée pour tous les de codage et d’opérations de décodage. Les fournisseurs inscrits précédemment sont ignorés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un encodage pour le format UTF-16 avec primauté des octets de poids faible (little-endian).</summary>
        <value>Encodage pour le format UTF-16 en utilisant l'ordre d'octet avec primauté des octets de poids faible (Little Endian).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur les encodages pris en charge par .NET et une description de codage Unicode à utiliser, consultez [encodage de caractères dans .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Le <xref:System.Text.UnicodeEncoding> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application. Il utilise le secours de remplacement pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par un point d’interrogation (« ? ») caractères. Au lieu de cela, vous pouvez appeler la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructeur pour instancier un petit endian <xref:System.Text.UnicodeEncoding> objet dont exception de secours est un <xref:System.Text.EncoderFallbackException> ou un <xref:System.Text.DecoderFallbackException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un encodage pour le format UTF-32 avec primauté des octets de poids faible (little-endian).</summary>
        <value>Objet d'encodage pour le format UTF-32 utilisant l'ordre d'octet avec primauté des octets de poids faible (little-endian).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.UTF32Encoding> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application. Il utilise le secours de remplacement pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par le caractère de remplacement Unicode (U + FFFE). Au lieu de cela, vous pouvez appeler la <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructeur pour instancier un <xref:System.Text.UTF32Encoding> objet dont exception de secours est un <xref:System.Text.EncoderFallbackException> ou un <xref:System.Text.DecoderFallbackException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Pour une présentation de primauté des octets, consultez la <xref:System.Text.Encoding> rubrique de la classe.  
  
 Pour plus d’informations sur les encodages pris en charge par .NET et une description de codage Unicode à utiliser, consultez [encodage de caractères dans .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un encodage pour le format UTF-7.</summary>
        <value>Encodage pour le format UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Encodage UTF-7 est utilisé principalement dans les environnements qui historiquement ont été limités à 7 bits, tels que NNTP et certaines applications de messagerie. En raison de problèmes avec la sécurité et de robustesse, vous ne devez pas utiliser UTF7 codage dans les environnements de 8 bits où encodage UTF-8 peut être utilisé à la place.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche les octets obtenus.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un encodage pour le format UTF-8.</summary>
        <value>Encodage pour le format UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne un <xref:System.Text.UTF8Encoding> objet qui encode les caractères Unicode (UTF-16-encodée) en une séquence d’un à quatre octets par caractère, et qui décode un tableau d’octets encodée en UTF-8 pour les caractères Unicode (UTF-16-encodée). Pour plus d’informations sur les encodages de caractères pris en charge par .NET et une description de codage Unicode à utiliser, consultez [encodage de caractères dans .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Le <xref:System.Text.UTF8Encoding> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application.  
  
-   Elle retourne un <xref:System.Text.UTF8Encoding> objet qui fournit une marque d’ordre octet Unicode (BOM). Pour instancier un encodage UTF-8 qui ne fournit pas une nomenclature, appeler toute surcharge de la <xref:System.Text.UTF8Encoding.%23ctor%2A> constructeur.  
  
-   Elle retourne un <xref:System.Text.UTF8Encoding> objet qui utilise le remplacement de secours pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par un point d’interrogation (« ? ») caractères. Au lieu de cela, vous pouvez appeler la <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructeur pour instancier un <xref:System.Text.UTF8Encoding> objet dont exception de secours est un <xref:System.Text.EncoderFallbackException> ou un <xref:System.Text.DecoderFallbackException>, comme l’illustre l’exemple suivant.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant définit un tableau qui se compose des caractères suivants :  
  
-   LETTRE MINUSCULE LATINE Z (U + 007 A)  
  
-   LATIN LETTRE MINUSCULE (U + 0061)  
  
-   COMBINAISON BRÈVE (U + 0306)  
  
-   LETTRE MINUSCULE LATINE AE AVEC AIGUS (U + 01FD)  
  
-   LETTRE MINUSCULE GRECQUE BÊTA (U + 03B2)  
  
-   Une paire de substitution (U + D800 U + DD54) qui forme grecque ACROPHONIC ATTIC un milliers STATERS (U + 10154).  
  
 Il affiche les unités de code UTF-16 de chaque caractère et détermine le nombre d’octets requis par un encodeur UTF-8 pour encoder le tableau de caractères. Il encode les caractères, puis affiche les octets obtenus encodée en UTF-8.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le nom inscrit auprès de l'IANA (Internet Assigned Numbers Authority) pour l'encodage actuel.</summary>
        <value>Nom IANA pour le <see cref="T:System.Text.Encoding" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoding.WebName%2A> propriété est le même que le <xref:System.Text.EncodingInfo.Name%2A> propriété.  
  
 Notez que <xref:System.Text.Encoding.WebName%2A> retourne un nom enregistré IANA pour le codage. Lorsque sa valeur est le nom de la norme, l’implémentation de l’encodage n’est peut-être pas conforme dans sa totalité de cette norme. Le <xref:System.Text.Encoding.HeaderName%2A> propriété définit un encodage différent qui peut fonctionner mieux pour les en-têtes de courrier électronique. Toutefois, la plupart des applications doivent utiliser <xref:System.Text.Encoding.WebName%2A> à la place.  
  
 Pour plus d’informations sur l’IANA, accédez à [www.iana.org](https://www.iana.org/).  
  
 Le <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> est identique à la <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> retourné par <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Certains noms web sont des doublons ; consultez les notes relatives à <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> pour plus d’informations.  
  
   
  
## Examples  
 L’exemple suivant inclut le <xref:System.Text.Encoding.WebName%2A> dans un en-tête HTML.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms qui diffèrent des <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Il affiche <xref:System.Text.Encoding.EncodingName%2A> mais n’est pas considéré contre lui.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient la page de codes du système d'exploitation Windows la plus proche de l'encodage actuel.</summary>
        <value>Page de codes du système d'exploitation Windows la plus proche du <see cref="T:System.Text.Encoding" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est fournie pour la compatibilité avec le Windows API multilingue (MLang), par exemple, dans la détermination des familles de polices. Pour la globalisation, il est recommandé d’à la place l’un des encodages Unicode. Il est également recommandé d’utiliser <xref:System.Text.Encoding.WebName%2A> au lieu de <xref:System.Text.Encoding.WindowsCodePage%2A> pour identifier la page de codes.  
  
   
  
## Examples  
 L’exemple suivant détermine la page de codes Windows la plus proche de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>