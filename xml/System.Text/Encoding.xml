<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2ca10b7aefa232ce0aefa8a54a8677a253349c54" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36409155" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a character encoding.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'encodage est le processus de transformation d'un jeu de caractères Unicode en une séquence d'octets. En revanche, le décodage est le processus de transformation d’une séquence d’octets codés en un jeu de caractères Unicode. Pour plus d’informations sur les Formats (formats UTF) et d’autres encodages pris en charge par <xref:System.Text.Encoding>, consultez [l’encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Notez que <xref:System.Text.Encoding> est destiné à opérer sur des caractères Unicode à la place des données binaires arbitraires, tels que des tableaux d’octets. Si vous devez encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Le .NET Framework fournit les implémentations suivantes de la <xref:System.Text.Encoding> classe pour prendre en charge les encodages Unicode et autres :  
  
-   <xref:System.Text.ASCIIEncoding> encode les caractères Unicode comme des caractères ASCII 7 bits uniques. Cet encodage ne prend en charge que les valeurs de caractère comprises entre U + 0000 et U + 007F. Page de codes 20127. Également disponible via le <xref:System.Text.Encoding.ASCII%2A> propriété.  
  
-   <xref:System.Text.UTF7Encoding> encode les caractères Unicode à l’aide de l’encodage UTF-7. Cet encodage prend en charge toutes les valeurs de caractères Unicode. Page de codes 65000. Également disponible via le <xref:System.Text.Encoding.UTF7%2A> propriété.  
  
-   <xref:System.Text.UTF8Encoding> encode les caractères Unicode à l’aide de l’encodage UTF-8. Cet encodage prend en charge toutes les valeurs de caractères Unicode. Page de codes 65001. Également disponible via le <xref:System.Text.Encoding.UTF8%2A> propriété.  
  
-   <xref:System.Text.UnicodeEncoding> encode les caractères Unicode à l’aide de l’encodage UTF-16. Les ordres des octets little endian et big endian sont pris en charge. Également disponible via le <xref:System.Text.Encoding.Unicode%2A> propriété et le <xref:System.Text.Encoding.BigEndianUnicode%2A> propriété.  
  
-   <xref:System.Text.UTF32Encoding> encode les caractères Unicode à l’aide de l’encodage UTF-32. À la fois little endian (page de codes 12000) et octet big endian (page de codes 12001) orders sont pris en charge. Également disponible via le <xref:System.Text.Encoding.UTF32%2A> propriété.  
  
 La <xref:System.Text.Encoding> classe est principalement destinée à effectuer une conversion entre différents encodages et Unicode. Une des classes Unicode dérivées est souvent le bon choix pour votre application.  
  
 Utilisez le <xref:System.Text.Encoding.GetEncoding%2A> méthode pour obtenir d’autres encodages et appelez le <xref:System.Text.Encoding.GetEncodings%2A> méthode pour obtenir une liste de tous les encodages.  
  
 Le tableau suivant répertorie les encodages pris en charge par le .NET Framework. Il répertorie le numéro de page de codes de chaque codage et les valeurs du codage <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> et <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> propriétés. Un astérisque dans la dernière colonne indique que la page de codes est prise en charge par le .NET Framework, quel que soit la plateforme sous-jacente. Notez que le code pages dont <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> propriété correspond à une norme internationale ne sont pas nécessairement conformes à l’intégralité de cette norme.  
  
|Page de codes|Name|Nom affiché|Prise en charge de .NET framework|  
|---------------|----------|------------------|----------------------------|  
|37|IBM037|IBM EBCDIC (États-Unis-Canada)||  
|437|IBM437|OEM États-Unis||  
|500|IBM500|IBM EBCDIC (International)||  
|708|ASMO-708|Arabe (ASMO 708)||  
|720|DOS-720|Arabe (DOS)||  
|737|ibm737|Grec (DOS)||  
|775|ibm775|Baltique (DOS)||  
|850|ibm850|Europe occidentale (DOS)||  
|852|ibm852|Europe centrale (DOS)||  
|855|IBM855|OEM cyrillique||  
|857|ibm857|Turc (DOS)||  
|858|IBM00858|OEM multilingue Latin I||  
|860|IBM860|Portugais (DOS)||  
|861|ibm861|Islandais (DOS)||  
|862|DOS-862|Hébreu (DOS)||  
|863|IBM863|Français canadien (DOS)||  
|864|IBM864|Arabe (864)||  
|865|IBM865|Langues scandinaves (DOS)||  
|866|cp866|Cyrillique (DOS)||  
|869|ibm869|Grec moderne (DOS)||  
|870|IBM870|IBM EBCDIC (multilingue Latin-2)||  
|874|Windows-874|Thaï (Windows)||  
|875|cp875|IBM EBCDIC (grec moderne)||  
|932|Shift_JIS|Japonais (Shift-JIS)||  
|936|gb2312|Chinois simplifié (GB2312)|✓|  
|949|ks_c_5601-1987|Coréen||  
|950|Big5|Chinois traditionnel (Big5)||  
|1026|IBM1026|IBM EBCDIC (turc Latin-5)||  
|1047|IBM01047|IBM Latin-1||  
|1140|IBM01140|IBM EBCDIC (États-Unis-Canada-Europe)||  
|1141|IBM01141|IBM EBCDIC (Allemagne-Euro)||  
|1142|IBM01142|IBM EBCDIC (Danemark-Norvège-Euro)||  
|1143|IBM01143|IBM EBCDIC (Finlande-Suède-Euro)||  
|1144|IBM01144|IBM EBCDIC (Italie-Euro)||  
|1145|IBM01145|IBM EBCDIC (Espagne-Euro)||  
|1146|IBM01146|IBM EBCDIC (Royaume Uni-Europe)||  
|1147|IBM01147|IBM EBCDIC (France-Europe)||  
|1148|IBM01148|IBM EBCDIC (International-Euro)||  
|1149|IBM01149|IBM EBCDIC (islandais-Euro)||  
|1200|UTF-16|Unicode|✓|  
|1201|unicodeFFFE|Unicode (Big endian)|✓|  
|1250|Windows-1250|Europe centrale (Windows)||  
|1251|Windows-1251|Cyrillique (Windows)||  
|1252|Windows-1252|Europe occidentale (Windows)|✓|  
|1253|windows-1253|Grec (Windows)||  
|1254|Windows-1254|Turc (Windows)||  
|1255|Windows-1255|Hébreu (Windows)||  
|1256|Windows-1256|Arabe (Windows)||  
|1257|Windows-1257|Baltique (Windows)||  
|1258|windows-1258|Vietnamien (Windows)||  
|1361|Johab|Coréen (Johab)||  
|10000|Macintosh|Europe occidentale (Mac)||  
|10001|x-mac-japonais|Japonais (Mac)||  
|10002|x-mac-chinesetrad|Chinois traditionnel (Mac)||  
|10003|x-mac-coréen|Coréen (Mac)|✓|  
|10004|x-mac-arabe|Arabe (Mac)||  
|10005|x-mac-hébreu|Hébreu (Mac)||  
|10006|Grec-x-mac|Grec (Mac)||  
|10007|x-mac-cyrillique|Cyrillique (Mac)||  
|10008|x-mac-chinesesimp|Chinois simplifié (Mac)|✓|  
|10010|x-mac-roumain|Roumain (Mac)||  
|10017|x-mac-ukrainien|Ukrainien (Mac)||  
|10021|x-mac-thaï|Thaï (Mac)||  
|10029|x-mac-ce|Europe centrale (Mac)||  
|10079|x-mac-islandais|Islandais (Mac)||  
|10081|x-mac-turc|Turc (Mac)||  
|10082|x-mac-croate|Croate (Mac)||  
|12000|UTF-32|Unicode (UTF-32)|✓|  
|12001|UTF-32be ne|Unicode (UTF-32 Big endian)|✓|  
|20000|x-chinois-SNC|Chinois traditionnel (RC)||  
|20001|x-cp20001|ACT Taïwan||  
|20002|Chinois-x-Eten|Chinois traditionnel (Eten)||  
|20003|x-cp20003|IBM5550 Taïwan||  
|20004|x-cp20004|Télétexte Taïwan||  
|20005|x-cp20005|Wang Taïwan||  
|20105|x-IA5|Europe occidentale (IA5)||  
|20106|x-IA5-allemand|Allemand (IA5)||  
|20107|x-IA5-suédois|Suédois (IA5)||  
|20108|x-IA5-norvégien|Norvégien (IA5)||  
|20127|us-ascii|US-ASCII|✓|  
|20261|x-cp20261|T.61||  
|20269|x-cp20269|ISO-6937||  
|20273|IBM273|IBM EBCDIC (Allemagne)||  
|20277|IBM277|IBM EBCDIC (Danemark-Norvège)||  
|20278|IBM278|IBM EBCDIC (Finlande-Suède)||  
|20280|IBM280|IBM EBCDIC (Italie)||  
|20284|IBM284|IBM EBCDIC (Espagne)||  
|20285|IBM285|IBM EBCDIC (ROYAUME-UNI)||  
|20290|IBM290|IBM EBCDIC (japonais katakana)||  
|20297|IBM297|IBM EBCDIC (France)||  
|20420|IBM420|IBM EBCDIC (arabe)||  
|20423|IBM423|IBM EBCDIC (grec)||  
|20424|IBM424|IBM EBCDIC (hébreu)||  
|20833|EBCDIC-x-KoreanExtended|IBM EBCDIC (coréen étendu)||  
|20838|IBM-thaï|IBM EBCDIC (thaï)||  
|20866|koi8-r|Cyrillique (KOI8-R)||  
|20871|IBM871|IBM EBCDIC (Islande)||  
|20880|IBM880|IBM EBCDIC (Russe cyrillique)||  
|20905|IBM905|IBM EBCDIC (turc)||  
|20924|IBM00924|IBM Latin-1||  
|20932|EUC-JP|Japonais (JIS 0208-1990 et 0212-1990)||  
|20936|x-cp20936|Chinois simplifié (GB2312-80)|✓|  
|20949|x-cp20949|Coréen Wansung|✓|  
|21025|cp1025|IBM EBCDIC (serbe cyrillique-bulgare)||  
|21866|koi8-u|Cyrillique (KOI8-U)||  
|28591|ISO-8859-1.|Europe occidentale (ISO)|✓|  
|28592|ISO-8859-2|Europe centrale (ISO)||  
|28593|ISO-8859-3|3 latin (ISO)||  
|28594|ISO-8859-4|Baltique (ISO)||  
|28595|ISO-8859-5|Cyrillique (ISO)||  
|28596|ISO-8859-6|Arabe (ISO)||  
|28597|ISO-8859-7|Grec (ISO)||  
|28598|ISO-8859-8|Hébreu (ISO-Visual)|✓|  
|28599|ISO-8859-9|Turc (ISO)||  
|28603|ISO-8859-13.|Estonien (ISO)||  
|28605|ISO-8859-15|Latin 9 (ISO)||  
|29001|x-Europa|Europa||  
|38598|ISO-8859-8-i|Hébreu (ISO-logique)|✓|  
|50220|ISO-2022-jp|Japonais (JIS)|✓|  
|50221|csISO2022JP|Japonais (JIS-autorise Kana 1 octet)|✓|  
|50222|ISO-2022-jp|Japonais (JIS-1 octet Kana - donc / SI)|✓|  
|50225|ISO-2022-kr|Coréen (ISO)|✓|  
|50227|x-cp50227|Chinois simplifié (ISO-2022)|✓|  
|51932|euc-jp|Japonais (EUC)|✓|  
|51936|EUC-CN|Chinois simplifié (EUC)|✓|  
|51949|euc-kr|Coréen (EUC)|✓|  
|52936|Hz-Go-2312|Chinois simplifié (HZ)|✓|  
|54936|GB18030|Chinois simplifié (GB18030)|✓|  
|57002|x-iscii-fr|ISCII DÉVANÂGARÎ|✓|  
|57003|x iscii être|ISCII Bengali|✓|  
|57004|x-iscii-ta|Tamoul ISCII|✓|  
|57005|x-iscii-te|ISCII TÉLOUGOU|✓|  
|57006|x-iscii-en tant que|ISCII Assamais|✓|  
|57007|iscii x ou|ISCII Oriya|✓|  
|57008|x-iscii-ka|ISCII Kannada|✓|  
|57009|x-iscii-ma|ISCII Malayalam|✓|  
|57010|x-iscii-gu|ISCII Goudjrati|✓|  
|57011|x-iscii-pa|ISCII pendjabi|✓|  
|65000|utf-7|Unicode (UTF-7)|✓|  
|65001|utf-8|Unicode (UTF-8)|✓|  
  
 L’exemple suivant appelle la <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> et <xref:System.Text.Encoding.GetEncoding%28System.String%29> l’encodage de page de code de méthodes pour obtenir le grec (Windows). Il compare la <xref:System.Text.Encoding> objets retournés par les appels de méthode pour montrer qu’ils sont égaux, et cartes affiche ensuite le point de code Unicode et la valeur de page de code correspondante pour chaque caractère dans l’alphabet grec.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou la <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le format UTF-16 et les encodeurs UTF-32 peuvent utiliser l’ordre de primauté des octets (octet le plus significatif premier) ou l’ordre d’octet avec primauté (octet le moins significatif premier). Par exemple, la lettre majuscule latine A (U + 0041) est sérialisée comme suit (en hexadécimal) :  
  
-   UTF-16 primauté des octets : 00 41  
  
-   Ordre de primauté des octets little UTF-16 : 41 00  
  
-   UTF-32 primauté des octets : 00 00 00 41  
  
-   Ordre de primauté des octets little UTF-32 : 41 00 00 00  
  
 Il est généralement plus efficace de stocker des caractères Unicode à l’aide de l’ordre d’octet natif. Par exemple, il est préférable d’utiliser l’ordre d’octet avec primauté sur les plateformes little-endian, tels que des ordinateurs Intel.  
  
 Le <xref:System.Text.Encoding.GetPreamble%2A> méthode récupère un tableau d’octets contenant la marque d’ordre octet (BOM). Si ce tableau d’octets est préfixé à un flux encodé, il aide le décodeur à identifier le format d’encodage utilisé.  
  
 Pour plus d’informations sur l’ordre d’octet et la marque d’ordre, consultez la norme Unicode sur le [page d’accueil Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Notez que les classes d’encodage autorisent des erreurs :  
  
-   Modifier en mode silencieux à un « ? » caractères.  
  
-   Utilisez un caractère « ajustement optimal ».  
  
-   Passez à un comportement spécifique à l’application via l’utilisation de la <xref:System.Text.EncoderFallback> et <xref:System.Text.DecoderFallback> classes avec le caractère de remplacement Unicode U + FFFD.  
  
 Vous devez lever une exception en cas d’erreur de flux de données. Une application utilise un indicateur « throwonerror » le cas échéant ou le <xref:System.Text.EncoderExceptionFallback> et <xref:System.Text.DecoderExceptionFallback> classes. Secours le mieux adapté est généralement pas recommandé, car elle peut entraîner une perte de données ou toute confusion et est plus lente que les remplacements de caractères simples. Pour les encodages ANSI, le comportement le mieux adapté est la valeur par défaut.  
  
   
  
## Examples  
 L’exemple suivant convertit une chaîne d’un encodage à un autre.  
  
> [!NOTE]
>  Le tableau de byte [] est le seul type dans cet exemple qui contient les données encodées. Les types .NET Char et String sont eux-mêmes Unicode, donc la <xref:System.Text.Encoding.GetChars%2A> appel décode les données en Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes dérivées de substituent ce constructeur.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">The code page identifier of the preferred encoding.  -or-  0, to use the default encoding.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes dérivées de substituent ce constructeur.  
  
 Créent des appels à ce constructeur à partir d’une classe dérivée un <xref:System.Text.Encoding> objet qui utilise de secours la mieux adaptée pour l’encodage et les opérations de décodage. À la fois le <xref:System.Text.Encoding.DecoderFallback%2A> et <xref:System.Text.Encoding.EncoderFallback%2A> propriétés sont en lecture seule et ne peut pas être modifiées. Pour contrôler la stratégie de secours pour une classe dérivée de <xref:System.Text.Encoding>, appelez le <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> is less than zero.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">The encoding code page identifier.</param>
        <param name="encoderFallback">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</param>
        <param name="decoderFallback">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est `protected`; dérivées les classes substituent.  
  
 Vous appelez ce constructeur d’une classe dérivée pour contrôler l’encodage et décodage des stratégies de secours. Le <xref:System.Text.Encoding> constructeurs de classe de créent des objets de codage en lecture seule qui n’autorisent pas encodeur ou un décodeur de secours à définir une fois que l’objet est créé.  
  
 Si le paramètre `encoderFallback` ou `decoderFallback` est null, de secours la mieux adaptée est utilisé en tant que la stratégie de secours correspondante.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> is less than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the ASCII (7-bit) character set.</summary>
        <value>Encodage pour le jeu de caractères ASCII (7 bits).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caractères ASCII sont limités aux 128 caractères Unicode plus bas, à partir de U + 0000 et U + 007F.  
  
 Lorsque vous sélectionnez l’encodage ASCII pour votre application, procédez comme suit :  
  
-   L’encodage ASCII est habituellement approprié pour les protocoles qui requièrent ASCII.  
  
-   Si vous requiert le codage 8 bits (qui est parfois appelé « ASCII »), l’encodage UTF-8 est recommandé du code ASCII de codage. Pour les caractères 0-7F, les résultats sont identiques, mais utiliser UTF-8 évite la perte de données en permettant la représentation sous forme de tous les caractères Unicode qui peuvent être représentées. Notez que l’encodage ASCII a une 8 bits ambiguïté qui peut permettre une utilisation malveillante, mais l’encodage UTF-8 supprime toute ambiguïté sur les 8 bits.  
  
-   Avant la version 2.0 du .NET Framework, le .NET Framework autorisées l’usurpation d’identité en ignorant les 8 bits. À compter de .NET Framework 2.0, les points de code non-ASCII revient lors du décodage.  
  
 Le <xref:System.Text.ASCIIEncoding> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application. Il utilise le remplacement de secours pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par un point d’interrogation (« ? ») caractères. Au lieu de cela, vous pouvez appeler la <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> méthode pour instancier un <xref:System.Text.ASCIIEncoding> objet dont exception de secours est un <xref:System.Text.EncoderFallbackException> ou <xref:System.Text.DecoderFallbackException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant montre l’effet de l’encodage ASCII sur les caractères situés en dehors de la plage ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-16 format that uses the big endian byte order.</summary>
        <value>Objet d'encodage pour le format UTF-16 avec primauté des octets de poids fort (big-endian).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.UnicodeEncoding> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application. Il utilise le remplacement de secours pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par un point d’interrogation (« ? ») caractères. Au lieu de cela, vous pouvez appeler la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructeur pour instancier un big endian <xref:System.Text.UnicodeEncoding> objet dont exception de secours est un <xref:System.Text.EncoderFallbackException> ou <xref:System.Text.DecoderFallbackException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Retourné <xref:System.Text.UnicodeEncoding> objet a <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, et <xref:System.Text.Encoding.WebName%2A> propriétés, qui génère le nom « unicodeFFFE ». Bien que la marque d’ordre de primauté des octets UTF-16 est hexadécimale FEFF, le nom « unicodeFFFE » a été choisi parce que la marque d’ordre apparaît en tant que valeur hexadécimale FFFE sur les ordinateurs Windows endian peu.  
  
   
  
## Examples  
 L’exemple suivant lit un fichier texte avec un encodage UTF-16 à l’aide de l’ordre de primauté des octets.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</summary>
        <value>Nom du <see cref="T:System.Text.Encoding" /> actuel qui peut être utilisé avec les balises de corps de texte de l'agent de messagerie.  - ou - une chaîne vide (" »), si actuel <see cref="T:System.Text.Encoding" /> ne peut pas être utilisé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous avez besoin d’un encodage pour un nom de corps, vous devez appeler <xref:System.Text.Encoding.GetEncoding%2A> avec la <xref:System.Text.Encoding.BodyName%2A> propriété. La méthode extrait souvent un encodage différent de l’encodage de test fourni dans l’appel. Seules les applications de messagerie doivent généralement extraire un tel encodage ; la plupart des autres applications qui doivent décrire un encodage doivent utiliser son <xref:System.Text.Encoding.WebName%2A>.  
  
 Dans certains cas, la valeur de la <xref:System.Text.Encoding.BodyName%2A> propriété correspond à la norme internationale qui définit cet encodage. Cela ne signifie pas que l’implémentation est conforme à l’intégralité de cette norme.  
  
   
  
## Examples  
 L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms différents de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Il affiche <xref:System.Text.Encoding.EncodingName%2A> mais ne compare pas par rapport à elle.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, creates a shallow copy of the current <see cref="T:System.Text.Encoding" /> object.</summary>
        <returns>A copy of the current <see cref="T:System.Text.Encoding" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le clone est accessible en écriture même si la version d’origine <xref:System.Text.Encoding> objet est en lecture seule. Par conséquent, les propriétés du clone peuvent être modifiées.  
  
 Une copie superficielle d’un objet est une copie de l’objet uniquement. Si l’objet contient des références à d’autres objets, la copie superficielle ne crée pas de copies des objets auxquels. Il fait référence aux objets d’origine à la place. En revanche, une copie complète d’un objet crée une copie de l’objet et une copie de tous les éléments fait référence directement ou indirectement par l’objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the code page identifier of the current <see cref="T:System.Text.Encoding" />.</summary>
        <value>Identificateur de la page de codes du <see cref="T:System.Text.Encoding" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms différents de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Il affiche <xref:System.Text.Encoding.EncodingName%2A> mais ne compare pas par rapport à elle.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts a byte array from one encoding to another.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">The encoding format of <c>bytes</c>.</param>
        <param name="dstEncoding">The target encoding format.</param>
        <param name="bytes">The bytes to convert.</param>
        <summary>Converts an entire byte array from one encoding to another.</summary>
        <returns>An array of type <see cref="T:System.Byte" /> containing the results of converting <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant convertit une chaîne codée au format Unicode en une chaîne codée au format ASCII. Étant donné que l’objet d’encodage ASCII retourné par la <xref:System.Text.Encoding.ASCII%2A> propriété utilise le remplacement de secours et le caractère Pi ne fait pas partie du jeu de caractères ASCII, le caractère Pi est remplacé par un point d’interrogation, comme la sortie de l’exemple.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> is <see langword="null" />.  -or-  <paramref name="dstEncoding" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">The encoding of the source array, <c>bytes</c>.</param>
        <param name="dstEncoding">The encoding of the output array.</param>
        <param name="bytes">The array of bytes to convert.</param>
        <param name="index">The index of the first element of <c>bytes</c> to convert.</param>
        <param name="count">The number of bytes to convert.</param>
        <summary>Converts a range of bytes in a byte array from one encoding to another.</summary>
        <returns>An array of type <see cref="T:System.Byte" /> containing the result of converting a range of bytes in <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> is <see langword="null" />.  -or-  <paramref name="dstEncoding" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> and <paramref name="count" /> do not specify a valid range in the byte array.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Text.DecoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</summary>
        <value>Objet de secours de décodeur pour l'objet <see cref="T:System.Text.Encoding" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.DecoderFallback> objet représente un gestionnaire d’erreurs qui est appelé lorsqu’une séquence d’octets encodée ne peut pas être décodée en un caractère. L’un des types de gestionnaires suivants est prise en charge :  
  
-   Gestionnaire de secours la mieux adapté, qui remplace les octets qui ne peut pas être décodé par un caractère de remplacement approprié.  
  
-   Un gestionnaire de remplacement de secours, qui remplace les octets qui ne peut pas être décodé par un caractère de remplacement arbitraire. Le .NET Framework inclut un gestionnaire de secours de remplacement, <xref:System.Text.DecoderFallback>, qui par défaut remplace les octets qui ne peut pas être décodées avec un point d’interrogation (« ? ») caractères.  
  
-   Un gestionnaire d’exceptions de secours, qui lève une exception lorsque les octets ne peut pas être décodés. Le .NET Framework inclut un gestionnaire d’exceptions de secours, <xref:System.Text.DecoderExceptionFallback>, qui lève une <xref:System.Text.DecoderFallbackException> quand les octets ne peut pas être décodés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value in a set operation is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default encoding for this .NET implementation.</summary>
        <value>L’encodage par défaut pour cette implémentation .NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Des ordinateurs différents peuvent utiliser différents codages en tant que la valeur par défaut, et l’encodage par défaut peut modifier sur un seul ordinateur. Si vous utilisez la <xref:System.Text.Encoding.Default%2A> encodage pour encoder et décoder des données en continu entre ordinateurs ou récupérées à des moments différents sur le même ordinateur, il peut incorrectement traduire ces données. En outre, l’encodage retourné par la <xref:System.Text.Encoding.Default%2A> propriété utilise de secours la mieux adaptée pour mapper les caractères non pris en charge pour les caractères pris en charge par la page de codes. Pour ces raisons, à l’aide de l’encodage par défaut n’est pas recommandée. Pour garantir que les octets encodés sont décodés correctement, vous devez utiliser un encodage Unicode, tel que <xref:System.Text.UTF8Encoding> ou <xref:System.Text.UnicodeEncoding>. Vous pouvez également utiliser un protocole de niveau supérieur pour garantir que le même format est utilisé pour encoder et décoder.  

### <a name="the-default-property-in-the-net-framework"></a>La propriété par défaut dans le .NET Framework

Dans le .NET Framework sur le bureau Windows, les <xref:System.Text.Encoding.Default%2A> propriété obtient la page de codes active du système et crée toujours un <xref:System.Text.Encoding> objet qui correspond à ce dernier. La page de codes active peut être une page de codes ANSI, qui inclut le jeu, ainsi que des caractères supplémentaires qui varient par page de codes de caractères ASCII. Étant donné que tous les <xref:System.Text.Encoding.Default%2A> encodages basés sur les pages de codes ANSI de perdre des données, envisagez d’utiliser le <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> encodage à la place. UTF-8 est souvent identique U + 00 à U + 7F plage, mais peut encoder des caractères en dehors de la plage ASCII sans perte.

## <a name="the-default-property-on-net-core"></a>La propriété par défaut sur .NET Core

Sur .NET Core, la <xref:System.Text.Encoding.Default%2A> propriété retourne toujours la <xref:System.Text.UTF8Encoding>. UTF-8 est pris en charge sur tous les systèmes d’exploitation (Windows, Linux et Max OS X) sur les applications .NET Core exécuter.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Text.EncoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</summary>
        <value>Objet de secours d'encodeur pour l'objet <see cref="T:System.Text.Encoding" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.EncoderFallback> objet représente un gestionnaire d’erreurs qui est appelé lorsqu’un caractère ne peut pas être converti en séquence d’octets encodée. L’un des types de gestionnaires suivants est prise en charge :  
  
-   Gestionnaire de secours la mieux adapté, qui remplace les caractères qui ne peuvent pas être encodés avec un caractère de remplacement approprié.  
  
-   Un gestionnaire de remplacement de secours, qui remplace les caractères qui ne peuvent pas être encodés avec un caractère de remplacement arbitraire. Le .NET Framework inclut un gestionnaire de secours de remplacement, <xref:System.Text.EncoderFallback>, qui par défaut remplace les caractères qui ne peuvent pas être encodés avec un point d’interrogation (« ? ») caractères.  
  
-   Un gestionnaire d’exceptions de secours, qui lève une exception lorsque les caractères ne peut pas être encodés. Le .NET Framework inclut un gestionnaire d’exceptions de secours, <xref:System.Text.EncoderExceptionFallback>, qui lève une <xref:System.Text.EncoderFallbackException> quand les caractères ne peut pas être décodés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value in a set operation is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the human-readable description of the current encoding.</summary>
        <value>Description explicite du <see cref="T:System.Text.Encoding" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoding.EncodingName%2A> propriété est conçue pour l’affichage. Pour rechercher un nom qui peut être passé à la <xref:System.Text.Encoding.GetEncoding%2A> (méthode), utilisez le <xref:System.Text.Encoding.WebName%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms différents de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Il affiche <xref:System.Text.Encoding.EncodingName%2A> mais ne compare pas par rapport à elle.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The <see cref="T:System.Object" /> to compare with the current instance.</param>
        <summary>Determines whether the specified <see cref="T:System.Object" /> is equal to the current instance.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.Encoding" /> and is equal to the current instance; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deux instances de <xref:System.Text.Encoding> sont considérées comme égales si elles correspondent à la même page de codes et leurs `EncoderFallback` et `DecoderFallback` objets sont égaux. En particulier, toutes les pages de codes dérivé ont une page de codes de 0 et leurs secours sont normalement `null` (`Nothing` dans Visual Basic .NET). Par conséquent, ils sont tous considérés comme égales à un autre. Une conséquence est que lorsque <xref:System.Text.Encoding.Equals%2A> est utilisé pour remplir une table de hachage, tous les encodages dérivés sont égaux et se situent dans le même emplacement de table de hachage.  
  
   
  
## Examples  
 L’exemple suivant obtient deux instances du même encodage (une par page de codes) et une autre par nom et vérifie leur égalité.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the characters to encode.</param>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</summary>
        <returns>The number of bytes produced by encoding all the characters in the specified character array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetBytes%2A> pour stocker les octets obtenus, appelez le <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille de tableau maximale, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <xref:System.Text.Encoding.GetBytes%2A> méthode exécute l’encodage réel. Le <xref:System.Text.Encoding.GetBytes%2A> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé.  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser les versions de la chaîne de la <xref:System.Text.Encoding.GetBytes%2A> (méthode).  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, vous devez le réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The string containing the set of characters to encode.</param>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetBytes%2A> pour stocker les octets obtenus, appelez le <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille de tableau maximale, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <xref:System.Text.Encoding.GetBytes%2A> méthode exécute l’encodage réel. Le <xref:System.Text.Encoding.GetBytes%2A> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé.  
  
-   Si votre application gère des entrées de chaîne, la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A> est recommandé.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder une chaîne ou une plage de la chaîne, encode les caractères et affiche le nombre d’octets obtenue.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille de tableau exact qui <xref:System.Text.Encoding.GetBytes%2A> requiert pour stocker les octets obtenus, vous devez appeler la <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille de tableau maximale, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> méthode exécute l’encodage réel. Le <xref:System.Text.Encoding.GetBytes%2A> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Voici quelques considérations sur l’utilisation de ces méthodes :  
  
-   Votre application peut nécessiter à encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé.  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de la <xref:System.Text.Encoding.GetBytes%2A> (méthode).  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%2A> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="index">The index of the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</summary>
        <returns>The number of bytes produced by encoding the specified characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetBytes%2A> pour stocker les octets obtenus, appelez le <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille de tableau maximale, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <xref:System.Text.Encoding.GetBytes%2A> méthode exécute l’encodage réel. Le <xref:System.Text.Encoding.GetBytes%2A> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé.  
  
-   Si votre application gère des entrées de chaîne, la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A> est recommandé.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder trois caractères d’un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, encodes a set of characters into a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the characters to encode.</param>
        <summary>When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</summary>
        <returns>A byte array containing the results of encoding the specified set of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou la <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <xref:System.Text.Encoding.GetBytes%2A> méthode exécute l’encodage réel. Le <xref:System.Text.Encoding.GetBytes%2A> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé. (Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu. Le <xref:System.Text.Encoder> conserverons ce substitut afin qu’il peut être combiné avec un substitut faible au début d’un appel suivant. <xref:System.Text.Encoding> ne pourra plus être en mesure de maintenir l’état, le caractère est envoyés à le <xref:System.Text.EncoderFallback>.)  
  
-   Si votre application gère des entrées de chaîne, vous devez appeler la version de chaîne de la <xref:System.Text.Encoding.GetBytes%2A> (méthode).  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The string containing the characters to encode.</param>
        <summary>When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</summary>
        <returns>A byte array containing the results of encoding the specified set of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou la <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <xref:System.Text.Encoding.GetBytes%2A> méthode exécute l’encodage réel. Le <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé. (Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu. Le <xref:System.Text.Encoder> conserverons ce substitut afin qu’il peut être combiné avec un substitut faible au début d’un appel suivant. <xref:System.Text.Encoding> ne pourra plus être en mesure de maintenir l’état, le caractère est envoyés à le <xref:System.Text.EncoderFallback>.)  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder une chaîne ou une plage de la chaîne, encode les caractères et affiche le nombre d’octets obtenue.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="index">The index of the first character to encode.</param>
        <param name="count">The number of characters to encode.</param>
        <summary>When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</summary>
        <returns>A byte array containing the results of encoding the specified set of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou la <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <xref:System.Text.Encoding.GetBytes%2A> méthode exécute l’encodage réel. Le <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé. (Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu. Le <xref:System.Text.Encoder> conserverons ce substitut afin qu’il peut être combiné avec un substitut faible au début d’un appel suivant. <xref:System.Text.Encoding> ne pourra plus être en mesure de maintenir l’état, le caractère est envoyés à le <xref:System.Text.EncoderFallback>.)  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder trois caractères d’un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A pointer to the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">A pointer to the location at which to start writing the resulting sequence of bytes.</param>
        <param name="byteCount">The maximum number of bytes to write.</param>
        <summary>When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</summary>
        <returns>The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille de tableau exact qui <xref:System.Text.Encoding.GetBytes%2A> requiert pour stocker les octets obtenus, appelez le <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille de tableau maximale, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> objet fourni par le <xref:System.Text.Encoding.GetDecoder%2A> ou <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <xref:System.Text.Encoding.GetBytes%2A> méthode exécute l’encodage réel. Le <xref:System.Text.Encoding.GetBytes%2A> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé. (Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu. Le <xref:System.Text.Encoder> conserverons ce substitut afin qu’il peut être combiné avec un substitut faible au début d’un appel suivant. <xref:System.Text.Encoding> ne pourra plus être en mesure de maintenir l’état, le caractère est envoyés à le <xref:System.Text.EncoderFallback>.)  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> is less than the resulting number of bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">The character array containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetBytes%2A> pour stocker les octets obtenus, vous devez appeler la <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille de tableau maximale, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou la <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <xref:System.Text.Encoding.GetBytes%2A> méthode exécute l’encodage réel. Le <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé. (Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu. Le <xref:System.Text.Encoder> conserverons ce substitut afin qu’il peut être combiné avec un substitut faible au début d’un appel suivant. <xref:System.Text.Encoding> ne pourra plus être en mesure de maintenir l’état, le caractère est envoyés à le <xref:System.Text.EncoderFallback>.)  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder trois caractères d’un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  -or-  <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  -or-  <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">The string containing the set of characters to encode.</param>
        <param name="charIndex">The index of the first character to encode.</param>
        <param name="charCount">The number of characters to encode.</param>
        <param name="bytes">The byte array to contain the resulting sequence of bytes.</param>
        <param name="byteIndex">The index at which to start writing the resulting sequence of bytes.</param>
        <summary>When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</summary>
        <returns>The actual number of bytes written into <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetBytes%2A> pour stocker les octets obtenus, vous devez appeler la <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille de tableau maximale, appelez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou la <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Le <xref:System.Text.Encoding.GetByteCount%2A> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <xref:System.Text.Encoding.GetBytes%2A> méthode exécute l’encodage réel. Le <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetByteCount%2A> et <xref:System.Text.Encoding.GetBytes%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <xref:System.Text.Encoder> de l’objet qui est utilisé. (Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu. Le <xref:System.Text.Encoder> conserverons ce substitut afin qu’il peut être combiné avec un substitut faible au début d’un appel suivant. <xref:System.Text.Encoding> ne pourra plus être en mesure de maintenir l’état, le caractère est envoyés à le <xref:System.Text.EncoderFallback>.)  
  
-   Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La version de mémoire tampon de caractères Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <xref:System.Text.Encoder> objet ou insérer dans des mémoires tampon existantes. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le <xref:System.Text.Encoding.GetBytes%2A> version qui prend en charge les tableaux d’octets est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetByteCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder une chaîne ou une plage de la chaîne, encode les caractères et affiche le nombre d’octets obtenue.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.  -or-  <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.  -or-  <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.  -or-  <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <summary>When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> pour stocker les caractères obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> (méthode). Pour calculer la taille maximale du tableau, vous devez utiliser le <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> (méthode). Le <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels.  
  
-   Si votre application gère les sorties de chaîne, vous devez utiliser le <xref:System.Text.Encoding.GetString%2A> (méthode). Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne en un tableau d’octets, puis décode les octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille de tableau exact qui <xref:System.Text.Encoding.GetChars%2A> requiert pour stocker les caractères obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, utilisez le <xref:System.Text.Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.Encoding.GetCharCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <xref:System.Text.Encoding.GetChars%2A> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels.  
  
-   Si votre application gère les sorties de chaîne, il est recommandé d’utiliser le <xref:System.Text.Encoding.GetString%2A> (méthode). Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</summary>
        <returns>The number of characters produced by decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetChars%2A> pour stocker les caractères obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, utilisez le <xref:System.Text.Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.Encoding.GetCharCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 Le <xref:System.Text.Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <xref:System.Text.Encoding.GetChars%2A> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels.  
  
-   Si votre application gère les sorties de chaîne, il est recommandé d’utiliser le <xref:System.Text.Encoding.GetString%2A> (méthode). Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant convertit une chaîne d’un encodage à un autre.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 L’exemple suivant encode une chaîne en un tableau d’octets, puis décode une plage d’octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, decodes a sequence of bytes into a set of characters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</summary>
        <returns>A character array containing the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtient les caractères à partir d’une séquence d’octets d’entrée. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> est différent de celui <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> car <xref:System.Text.Encoding> attend des conversions discrètes, tandis que <xref:System.Text.Decoder> est conçu pour plusieurs passes sur un flux d’entrée unique.  
  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou la <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 **Remarque** cette méthode est destinée à opérer sur des caractères Unicode, pas sur des données binaires arbitraires, tels que des tableaux d’octets. Si vous avez besoin d’encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Text.Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <xref:System.Text.Encoding.GetChars%2A> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, étant donné que les séquences d’octets peuvent être interrompues lors du traitement par lots. (Par exemple, partie d’une séquence de déplacement ISO-2022 peut terminer un <xref:System.Text.Encoding.GetChars%2A> appeler et continuer au début de la prochaine <xref:System.Text.Encoding.GetChars%2A> appeler. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> appellera le secours pour ces séquences incomplètes, mais <xref:System.Text.Decoder> mémorise ces séquences pour l’appel suivant.)  
  
-   Si votre application gère les sorties de chaîne, il est recommandé d’utiliser le <xref:System.Text.Encoding.GetString%2A> (méthode). Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne en un tableau d’octets, puis décode les octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</summary>
        <returns>A character array containing the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtient les caractères à partir d’une séquence d’octets d’entrée. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> est différent de celui <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> car <xref:System.Text.Encoding> attend des conversions discrètes, tandis que <xref:System.Text.Decoder> est conçu pour plusieurs passes sur un flux d’entrée unique.  
  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou la <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 **Remarque** cette méthode est destinée à opérer sur des caractères Unicode, pas sur des données binaires arbitraires, tels que des tableaux d’octets. Si vous avez besoin d’encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Text.Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <xref:System.Text.Encoding.GetChars%2A> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, étant donné que les séquences d’octets peuvent être interrompues lors du traitement par lots. (Par exemple, partie d’une séquence de déplacement ISO-2022 peut terminer un <xref:System.Text.Encoding.GetChars%2A> appeler et continuer au début de la prochaine <xref:System.Text.Encoding.GetChars%2A> appeler. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> appellera le secours pour ces séquences incomplètes, mais <xref:System.Text.Decoder> mémorise ces séquences pour l’appel suivant.)  
  
-   Si votre application gère les sorties de chaîne, il est recommandé d’utiliser le <xref:System.Text.Encoding.GetString%2A> (méthode). Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne en un tableau d’octets, puis décode une plage d’octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">A pointer to the location at which to start writing the resulting set of characters.</param>
        <param name="charCount">The maximum number of characters to write.</param>
        <summary>When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</summary>
        <returns>The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille de tableau exact qui <xref:System.Text.Encoding.GetChars%2A> requiert pour stocker les caractères obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, utilisez le <xref:System.Text.Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.Encoding.GetCharCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtient les caractères à partir d’une séquence d’octets d’entrée. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> est différent de celui <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> car <xref:System.Text.Encoding> attend des conversions discrètes, tandis que <xref:System.Text.Decoder> est conçu pour plusieurs passes sur un flux d’entrée unique.  
  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> objet fourni par le <xref:System.Text.Encoding.GetDecoder%2A> ou <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 **Remarque** cette méthode est destinée à opérer sur des caractères Unicode, pas sur des données binaires arbitraires, tels que des tableaux d’octets. Si vous avez besoin d’encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Text.Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <xref:System.Text.Encoding.GetChars%2A> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, étant donné que les séquences d’octets peuvent être interrompues lors du traitement par lots. (Par exemple, partie d’une séquence de déplacement ISO-2022 peut terminer un <xref:System.Text.Encoding.GetChars%2A> appeler et continuer au début de la prochaine <xref:System.Text.Encoding.GetChars%2A> appeler. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> appellera le secours pour ces séquences incomplètes, mais <xref:System.Text.Decoder> mémorise ces séquences pour l’appel suivant.)  
  
-   Si votre application gère les sorties de chaîne, la <xref:System.Text.Encoding.GetString%2A> méthode est recommandée. Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.  -or-  <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> is less than the resulting number of characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="byteIndex">The index of the first byte to decode.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <param name="chars">The character array to contain the resulting set of characters.</param>
        <param name="charIndex">The index at which to start writing the resulting set of characters.</param>
        <summary>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</summary>
        <returns>The actual number of characters written into <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetChars%2A> pour stocker les caractères obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, utilisez le <xref:System.Text.Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.Encoding.GetCharCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > Obtient des caractères d’une séquence d’octets d’entrée. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > est différente de celle <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> car <xref:System.Text.Encoding> attend des conversions discrètes, tandis que <xref:System.Text.Decoder> est conçu pour plusieurs passes sur un flux d’entrée unique.  
  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou la <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 **Remarque** cette méthode est destinée à opérer sur des caractères Unicode, pas sur des données binaires arbitraires, tels que des tableaux d’octets. Si vous avez besoin d’encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Le <xref:System.Text.Encoding.GetCharCount%2A> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <xref:System.Text.Encoding.GetChars%2A> méthode effectue le décodage réel. Le <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> méthode attend des conversions discrètes, par contraste avec le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.  
  
 Plusieurs versions de <xref:System.Text.Encoding.GetCharCount%2A> et <xref:System.Text.Encoding.GetChars%2A> sont pris en charge. Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :  
  
-   Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels. Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, étant donné que les séquences d’octets peuvent être interrompues lors du traitement par lots. (Par exemple, partie d’une séquence de déplacement ISO-2022 peut terminer une [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > appelez et continuer au début de la prochaine [\], Int32, Int32, Char\<référence croisée : System.Text.Encoding.GetChars%2A > appeler. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > appellera le secours pour ces séquences incomplètes, mais <xref:System.Text.Decoder> mémorise ces séquences pour l’appel suivant.)  
  
-   Si votre application gère les sorties de chaîne, la <xref:System.Text.Encoding.GetString%2A> méthode est recommandée. Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <xref:System.String> type est recommandée.  
  
-   La version d’octet de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille. N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.  
  
-   Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie. Dans ce cas, le [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.  
  
-   Envisagez d’utiliser le <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> méthode à la place de <xref:System.Text.Encoding.GetCharCount%2A>. La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit. Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.  
  
   
  
## Examples  
 L’exemple suivant convertit une chaîne d’un encodage à un autre.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 L’exemple suivant encode une chaîne en un tableau d’octets, puis décode une plage d’octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.  -or-  <paramref name="chars" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.  -or-  <paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.  -or-  <paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> that converts an encoded sequence of bytes into a sequence of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> méthode convertit des blocs d’octets en blocs séquentiels de caractères, d’une manière similaire à la <xref:System.Text.Encoding.GetChars%2A> méthode de cette classe. Toutefois, un <xref:System.Text.Decoder> conserve les informations d’état entre les appels, de sorte qu’il peut décoder les séquences d’octets qui s’étendent sur des blocs. Le <xref:System.Text.Decoder> également conserve les octets de fin à la fin des blocs de données et les octets de fin dans la prochaine opération de décodage. Par conséquent, <xref:System.Text.Encoding.GetDecoder%2A> et <xref:System.Text.Encoding.GetEncoder%2A> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L’implémentation par défaut retourne un <see cref="T:System.Text.Decoder" /> qui appelle le <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> et <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> méthodes actuelles <see cref="T:System.Text.Encoding" />. Vous devez substituer cette méthode pour retourner un <see cref="T:System.Text.Decoder" /> qui conserve son état entre les appels.</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into an encoded sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> méthode convertit des blocs de caractères en blocs séquentiels d’octets, d’une manière similaire à la <xref:System.Text.Encoding.GetBytes%2A> méthode de cette classe. Toutefois, un <xref:System.Text.Encoder> conserve les informations d’état entre les appels et il encode correctement les séquences de caractères qui s’étendent sur des blocs. Le <xref:System.Text.Encoder> également conserve à la fin des caractères à la fin des blocs de données et utilise les caractères de fin dans la prochaine opération de codage. Par exemple, un bloc de données peut se terminer par un substitut étendu non apparié, et le substitut faible correspondant peut être dans le bloc de données suivant. Par conséquent, <xref:System.Text.Encoding.GetDecoder%2A> et <xref:System.Text.Encoding.GetEncoder%2A> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>L’implémentation par défaut retourne un <see cref="T:System.Text.Encoder" /> qui appelle le <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> et <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> méthodes actuelles <see cref="T:System.Text.Encoding" />. Vous devez substituer cette méthode pour retourner un <see cref="T:System.Text.Encoder" /> qui conserve son état entre les appels.</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns an encoding for the specified code page.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.  -or-  0 (zero), to use the default encoding.</param>
        <summary>Returns the encoding associated with the specified code page identifier.</summary>
        <returns>The encoding that is associated with the specified code page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le Gestionnaire de secours varie selon le type de codage `codepage`. Si `codepage` est le jeu de caractères code page ou sur deux octets (DBCS) encodage, un gestionnaire de secours la mieux adapté est utilisé. Sinon, un gestionnaire de secours de remplacement est utilisé. Ces gestionnaires de secours n’est peut-être pas appropriés pour votre application. Pour spécifier le Gestionnaire de secours utilisé par l’encodage spécifié par `codepage`, vous pouvez appeler la <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> de surcharge.  
  
 Le <xref:System.Text.Encoding.GetEncoding%2A> méthode s’appuie sur la plateforme sous-jacente pour prendre en charge la plupart des pages de codes. Toutefois, le .NET Framework prend en charge certains encodages en mode natif. Pour obtenir la liste des pages de codes, consultez la <xref:System.Text.Encoding> rubrique de la classe. Vous pouvez également appeler le <xref:System.Text.Encoding.GetEncodings%2A> méthode pour obtenir un tableau de <xref:System.Text.EncodingInfo> objets qui contient des informations sur tous les encodages.  
  
 Outre les encodages pris en charge intrinsèquement sur une version de plateforme spécifique du .NET Framework, le <xref:System.Text.Encoding.GetEncoding%2A> méthode retourne les encodages supplémentaires qui sont rendues disponibles par l’inscription d’un <xref:System.Text.EncodingProvider> objet. Si le même que celui qui a été enregistré par plusieurs <xref:System.Text.EncodingProvider> des objets, cette méthode retourne la dernière inscrit.  

Vous pouvez également fournir une valeur de 0 pour le `codepage` argument. Son comportement précis dépend si les encodages rendues disponibles en inscrivant un <xref:System.Text.EncodingProvider> objet :

- Si un ou plusieurs fournisseurs de codage ont été inscrite, elle retourne l’encodage du dernier fournisseur inscrit a choisi de retourner d’encodage lorsque le <xref:System.Text.Encoding.GetEncoding%2A> méthode est passée un `codepage` l’argument 0.     

- Sur le .NET Framework, si aucun encodage fournisseur a été enregistré, si le <xref:System.Text.CodePagesEncodingProvider> est le fournisseur d’encodage enregistré, ou si aucun fournisseur d’encodage inscrit ne gère un `codepage` valeur égale à 0, elle retourne la page de codes active le système d’exploitation. Pour déterminer la page de codes active sur les systèmes Windows, appelez Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) (fonction) du .NET Framework sur le bureau Windows.

- Sur .NET Core, si aucun fournisseur d’encodage n’a pas été inscrit ou si aucun fournisseur d’encodage inscrit ne gère un `codepage` valeur égale à 0, elle retourne le <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Du code non pris en charge des pages cause une <xref:System.ArgumentException> levée, alors que d’autres provoquent un <xref:System.NotSupportedException>. Par conséquent, votre code doit intercepter toutes les exceptions répertoriées dans la section Exceptions.  
  
> [!NOTE]
>  Les pages de codes ANSI peuvent être différents sur des ordinateurs différents et peuvent changer à un seul ordinateur, entraînant une altération des données. Pour cette raison, si la page de codes active est une page de codes ANSI, codage et décodage des données à l’aide de la page de codes par défaut retournée par `Encoding.GetEncoding(0)` n’est pas recommandée. Pour obtenir des résultats plus cohérents, vous devez utiliser un encodage Unicode, tel que UTF-8 (page de codes 65001) ou UTF-16, au lieu d’une page de codes spécifique.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Retourne une instance mise en cache avec les paramètres par défaut. Vous devez utiliser les constructeurs de classes dérivées pour obtenir une instance avec des paramètres différents. Par exemple, la <xref:System.Text.UTF32Encoding> classe fournit un constructeur qui vous permet d’activer la détection d’erreurs.  

   
  
## Examples  
 L’exemple suivant obtient deux instances du même encodage (une par page de codes) et une autre par nom et vérifie leur égalité.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> is less than zero or greater than 65535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> is not supported by the underlying platform.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> is not supported by the underlying platform.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The code page name of the preferred encoding. Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid. Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</param>
        <summary>Returns the encoding associated with the specified code page name.</summary>
        <returns>The encoding  associated with the specified code page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le Gestionnaire de secours varie selon le type de codage `name`. Si `name` est le jeu de caractères code page ou sur deux octets (DBCS) encodage, un gestionnaire de secours la mieux adapté est utilisé. Sinon, un gestionnaire de secours de remplacement est utilisé. Ces gestionnaires de secours n’est peut-être pas appropriés pour votre application. Pour spécifier le Gestionnaire de secours utilisé par l’encodage spécifié par `name`, vous pouvez appeler la <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> de surcharge.  
  
 Le <xref:System.Text.Encoding.GetEncoding%2A> méthode s’appuie sur la plateforme sous-jacente pour prendre en charge la plupart des pages de codes. Toutefois, le .NET Framework prend en charge certains encodages en mode natif. Pour obtenir la liste des pages de codes, consultez la <xref:System.Text.Encoding> rubrique de la classe. Vous pouvez également appeler le <xref:System.Text.Encoding.GetEncodings%2A> méthode pour obtenir un tableau de <xref:System.Text.EncodingInfo> objets qui contient des informations sur tous les encodages. 
  
 Outre les encodages pris en charge intrinsèquement sur une version de plateforme spécifique du .NET Framework, le <xref:System.Text.Encoding.GetEncoding%2A> méthode retourne les encodages supplémentaires qui sont rendues disponibles par l’inscription d’un <xref:System.Text.EncodingProvider> objet. Si le même que celui qui a été enregistré par plusieurs <xref:System.Text.EncodingProvider> des objets, cette méthode retourne la dernière inscrit.  
   
> [!NOTE]
>  Les pages de codes ANSI peuvent être différentes sur des ordinateurs différents, ou peuvent être modifiées pour un seul ordinateur, entraînant une altération des données. Pour obtenir des résultats plus cohérents, vous devez utiliser Unicode, tel que UTF-8 (page de codes 65001) ou UTF-16, au lieu d’une page de codes spécifique.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> Retourne une instance mise en cache avec les paramètres par défaut. Vous devez utiliser les constructeurs de classes dérivées pour obtenir une instance avec des paramètres différents. Par exemple, la <xref:System.Text.UTF32Encoding> classe fournit un constructeur qui vous permet d’activer la détection d’erreurs.  
  
## Examples  
 L’exemple suivant obtient deux instances du même encodage (une par page de codes) et une autre par nom et vérifie leur égalité.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is not a valid code page name.  -or-  The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.  -or-  0 (zero), to use the default encoding.</param>
        <param name="encoderFallback">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</param>
        <param name="decoderFallback">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</param>
        <summary>Returns the encoding associated with the specified code page identifier. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</summary>
        <returns>The encoding that is associated with the specified code page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Certaines pages de codes non prise en charge de provoquer l’exception <xref:System.ArgumentException> levée, alors que d’autres provoquent <xref:System.NotSupportedException>. Par conséquent, votre code doit intercepter toutes les exceptions répertoriées dans la section Exceptions.  
  
 Le <xref:System.Text.Encoding.GetEncoding%2A> méthode s’appuie sur la plateforme sous-jacente pour prendre en charge la plupart des pages de codes. Toutefois, le .NET Framework prend en charge certains encodages en mode natif. Pour obtenir la liste des pages de codes, consultez la <xref:System.Text.Encoding> rubrique de la classe. Vous pouvez appeler la <xref:System.Text.Encoding.GetEncodings%2A> méthode dans le .NET Framework complet sur le bureau Windows pour obtenir une liste de tous les encodages.   
  
 Outre les encodages pris en charge intrinsèquement sur une version de plateforme spécifique du .NET Framework, le <xref:System.Text.Encoding.GetEncoding%2A> méthode retourne les encodages supplémentaires qui sont rendues disponibles par l’inscription d’un <xref:System.Text.EncodingProvider> objet.  Si le même que celui qui a été enregistré par plusieurs <xref:System.Text.EncodingProvider> des objets, cette méthode retourne la dernière inscrit.  

Vous pouvez également fournir une valeur de 0 pour le `codepage` argument. Son comportement précis dépend si les encodages rendues disponibles en inscrivant un <xref:System.Text.EncodingProvider> objet :

- Si un ou plusieurs fournisseurs de codage ont été inscrite, elle retourne l’encodage du dernier fournisseur inscrit a choisi de retourner d’encodage lorsque le <xref:System.Text.Encoding.GetEncoding%2A> méthode est passée un `codepage` l’argument 0.     

- Sur le .NET Framework, si aucun encodage fournisseur a été enregistré, si le <xref:System.Text.CodePagesEncodingProvider> est le fournisseur d’encodage enregistré, ou si aucun fournisseur d’encodage inscrit ne gère un `codepage` valeur égale à 0, elle retourne la page de codes active.

- Sur .NET Core, si aucun fournisseur d’encodage n’a pas été inscrit ou si aucun fournisseur d’encodage inscrit ne gère un `codepage` valeur égale à 0, elle retourne le <xref:System.Text.UTF8Encoding> encodage.

> [!NOTE]
>  Les pages de codes ANSI peuvent être différents sur des ordinateurs différents et peuvent changer à un seul ordinateur, entraînant une altération des données. Pour cette raison, si la page de codes active est une page de codes ANSI, codage et décodage des données à l’aide de la page de codes par défaut retournée par `Encoding.GetEncoding(0)` n’est pas recommandée. Pour obtenir des résultats plus cohérents, vous devez utiliser Unicode, tel que UTF-8 (page de codes 65001) ou UTF-16, au lieu d’une page de codes spécifique. 
  
 Pour obtenir l’encodage associé à la page de codes active, vous pouvez soit fournir une valeur de 0 pour le `codepage` argument ou, si votre code s’exécute sur le .NET Framework complet sur le bureau Windows, récupérer la valeur de la <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> propriété. Pour déterminer la page de codes active en cours, appelez Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) (fonction) du .NET Framework sur le bureau Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Retourne une instance mise en cache avec les paramètres par défaut. Vous devez utiliser les constructeurs de classes dérivées pour obtenir une instance avec des paramètres différents. Par exemple, la <xref:System.Text.UTF32Encoding> classe fournit un constructeur qui vous permet d’activer la détection d’erreurs.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> (méthode).  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> is less than zero or greater than 65535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> is not supported by the underlying platform.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> is not supported by the underlying platform.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">The code page name of the preferred encoding. Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid. Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</param>
        <param name="encoderFallback">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</param>
        <param name="decoderFallback">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</param>
        <summary>Returns the encoding associated with the specified code page name. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</summary>
        <returns>The encoding that is associated with the specified code page.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoding.GetEncoding%2A> méthode s’appuie sur la plateforme sous-jacente pour prendre en charge la plupart des pages de codes. Toutefois, le .NET Framework prend en charge certains encodages en mode natif.  
  
 Outre les encodages pris en charge intrinsèquement sur une version de plateforme spécifique du .NET Framework, le <xref:System.Text.Encoding.GetEncoding%2A> méthode retourne les encodages supplémentaires qui sont rendues disponibles par l’inscription d’un <xref:System.Text.EncodingProvider> objet. Si le même que celui qui a été enregistré par plusieurs <xref:System.Text.EncodingProvider> des objets, cette méthode retourne la dernière inscrit. 
  
> [!NOTE]
>  Les pages de codes ANSI peuvent être différents sur des ordinateurs différents et peuvent changer à un seul ordinateur, entraînant une altération des données. Pour obtenir des résultats plus cohérents, vous devez utiliser un encodage Unicode, tel que UTF-8 (page de codes 65001) ou UTF-16, au lieu d’une page de codes spécifique.  
  
 Pour obtenir la liste des pages de codes, consultez la <xref:System.Text.Encoding> rubrique de la classe. Vous pouvez appeler la <xref:System.Text.Encoding.GetEncodings%2A> méthode sur le .NET Framework complet sur le bureau Windows pour obtenir une liste de tous les encodages.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Retourne une instance mise en cache avec les paramètres par défaut. Vous devez utiliser les constructeurs de classes dérivées pour obtenir une instance avec des paramètres différents. Par exemple, la <xref:System.Text.UTF32Encoding> classe fournit un constructeur qui vous permet d’activer la détection d’erreurs.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> (méthode).  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is not a valid code page name.  -or-  The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array that contains all encodings.</summary>
        <returns>An array that contains all encodings.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne une liste de codages pris en charge, que se différencient uniquement par la page de codes. Pour une table qui répertorie les encodages pris en charge, consultez le <xref:System.Text.Encoding> rubrique de la classe.  
  
> [!NOTE]
>  La liste de codages pris en charge retournée par le <xref:System.Text.Encoding.GetEncodings%2A> méthode n’inclut pas les encodages supplémentaires mises à disposition par les <xref:System.Text.EncodingProvider> implémentations qui ont été enregistrées par les appels à la <xref:System.Text.Encoding.RegisterProvider%2A> (méthode).  
  
 Les encodages 50220 et 50222 sont associés le nom « iso-2022-jp », mais ils ne sont pas identiques. Encodage 50220 convertit les caractères Katakana en caractères demi-chasse en caractères Katakana en caractères pleine chasse, tandis que l’encodage 50222 utilise une séquence de shift-in/shift-out pour encoder les caractères Katakana en caractères demi-chasse. Le nom d’affichage pour l’encodage 50222 est « japonais (JIS-autorise Kana 1 octet - donc / SI) » pour le distinguer de l’encodage 50220 dont l’affichage de la nommer « japonais (JIS) ».  
  
 Si vous demandez le codage nom « iso-2022-jp », le .NET Framework retourne l’encodage 50220. Toutefois, l’encodage est appropriée pour votre application dépend du traitement préféré des caractères Katakana à demi-chasse.  
  
 Pour obtenir un encodage spécifique, vous devez utiliser le <xref:System.Text.Encoding.GetEncoding%2A> (méthode).  
  
 <xref:System.Text.Encoding.GetEncodings%2A> est parfois utilisé pour présenter une liste d’encodages dans un fichier de l’utilisateur **enregistrer en tant que** boîte de dialogue. Cependant, plusieurs encodages non-Unicode sont incomplets et traduire le nombre de caractères à « ? », ou ont un comportement légèrement différent sur différentes plateformes. Envisagez d’utiliser UTF-8 ou UTF-16 en tant que la valeur par défaut.  
  
   
  
## Examples  
 L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for the current instance.</summary>
        <returns>The hash code for the current instance.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">The number of characters to encode.</param>
        <summary>When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</summary>
        <returns>The maximum number of bytes produced by encoding the specified number of characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `charCount` paramètre spécifie le nombre de <xref:System.Char> objets qui représentent les caractères Unicode à encoder, car le .NET Framework utilise en interne UTF-16 pour représenter les caractères Unicode. Par conséquent, la plupart des caractères Unicode peuvent être représentées par un <xref:System.Char> objet, mais un caractère Unicode représenté par une paire de substitution, par exemple, nécessite deux <xref:System.Char> objets.  
  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetBytes%2A> pour stocker les octets obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetByteCount%2A> (méthode). Pour calculer la taille maximale du tableau, utilisez le <xref:System.Text.Encoding.GetMaxByteCount%2A> (méthode). Le <xref:System.Text.Encoding.GetByteCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxByteCount%2A> méthode s’exécute plus rapidement.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> Récupère un nombre le plus défavorable, y compris le pire des cas actuellement sélectionné <xref:System.Text.EncoderFallback>. Si une stratégie de secours est choisi avec une chaîne potentiellement grande, <xref:System.Text.Encoding.GetMaxByteCount%2A> récupère les valeurs élevées, en particulier dans les cas où le pire des cas pour l’encodage implique des modes de commutation pour chaque caractère. Par exemple, cela peut se produire pour ISO-2022-JP. Pour plus d’informations, consultez le billet de blog «[Nouveautés avec Encoding.GetMaxByteCount et Encoding.GetMaxCharCount () ?](http://go.microsoft.com/fwlink/?LinkId=153702)» (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 Dans la plupart des cas, cette méthode récupère des valeurs raisonnables pour les petites chaînes. Pour les chaînes de grande taille, vous devrez choisir entre l’utilisation de mémoires tampons de grande et d’intercepter les erreurs dans les rares cas lorsqu’une mémoire tampon plus raisonnable est trop petite. Vous pouvez également envisager une approche différente à l’aide de <xref:System.Text.Encoding.GetByteCount%2A> ou <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 Lorsque vous utilisez <xref:System.Text.Encoding.GetMaxByteCount%2A>, vous devez allouer la mémoire tampon de sortie selon la taille maximale de la mémoire tampon d’entrée. Si la mémoire tampon de sortie est contraint de taille, vous pouvez utiliser la <xref:System.Text.Encoding.Convert%2A> (méthode).  
  
 Notez que <xref:System.Text.Encoding.GetMaxByteCount%2A> prend en compte les substituts potentiels restants d’une opération de décodeur précédente. En raison du décodeur, en passant une valeur de 1 à la méthode extrait 2 pour un encodage sur un octet, par exemple ASCII. Vous devez utiliser le <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> propriété si ces informations sont nécessaires.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` n’est pas nécessairement la même valeur que `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> is less than zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Tous les <see cref="T:System.Text.Encoding" /> implémentations doivent garantir qu’aucune exception de dépassement de capacité de mémoire tampon se produire si les mémoires tampons sont dimensionnés en fonction des résultats des calculs de cette méthode.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</summary>
        <returns>The maximum number of characters produced by decoding the specified number of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour calculer la taille exacte de tableau requise par <xref:System.Text.Encoding.GetChars%2A> pour stocker les caractères obtenus, vous devez utiliser le <xref:System.Text.Encoding.GetCharCount%2A> (méthode). Pour calculer la taille maximale du tableau, utilisez le <xref:System.Text.Encoding.GetMaxCharCount%2A> (méthode). Le <xref:System.Text.Encoding.GetCharCount%2A> méthode permet généralement d’allocation de moins de mémoire, alors que le <xref:System.Text.Encoding.GetMaxCharCount%2A> méthode s’exécute plus rapidement.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> Récupère un nombre le plus défavorable, y compris le pire des cas actuellement sélectionné <xref:System.Text.DecoderFallback>. Si une stratégie de secours est choisi avec une chaîne potentiellement grande, <xref:System.Text.Encoding.GetMaxCharCount%2A> extrait de grandes valeurs.  
  
 Dans la plupart des cas, cette méthode récupère un nombre raisonnable pour les petites chaînes. Pour les chaînes de grande taille, vous devrez peut-être choisir entre l’utilisation de mémoires tampons de grande et d’intercepter les erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est trop petite. Vous pouvez également envisager une approche différente à l’aide de <xref:System.Text.Encoding.GetCharCount%2A> ou <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> n’a aucune relation avec <xref:System.Text.Encoding.GetBytes%2A>. Si vous avez besoin d’une fonction semblable à utiliser avec <xref:System.Text.Encoding.GetBytes%2A>, vous devez utiliser <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 Lorsque vous utilisez <xref:System.Text.Encoding.GetMaxCharCount%2A>, vous devez allouer la mémoire tampon de sortie selon la taille maximale de la mémoire tampon d’entrée. Si la mémoire tampon de sortie est contraint de taille, vous pouvez utiliser la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> (méthode).  
  
 Notez que <xref:System.Text.Encoding.GetMaxCharCount%2A> considère que le pire des cas pour les octets restants à partir d’une précédente opération de l’encodeur. Pour la plupart des pages de codes, en passant une valeur de 0 à cette méthode récupère des valeurs supérieures ou égales à 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` n’est pas nécessairement la même valeur que `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 L’exemple suivant encode une chaîne en un tableau d’octets, puis décode les octets en un tableau de caractères.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Tous les <see cref="T:System.Text.Encoding" /> implémentations doivent garantir qu’aucune exception de dépassement de capacité de mémoire tampon se produire si les mémoires tampons sont dimensionnés en fonction des résultats des calculs de cette méthode.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</summary>
        <returns>A byte array containing a sequence of bytes that specifies the encoding used.  -or-  A byte array of length zero, if a preamble is not required.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous le souhaitez, le <xref:System.Text.Encoding> objet fournit un préambule est un tableau d’octets qui peuvent être un préfixe à la séquence d’octets résultant du processus de codage. Si le préambule contient une marque d’ordre (au format Unicode, le point de code U + FEFF), il aide le décodeur à déterminer l’ordre d’octet et que le format de transformation ou UTF.  
  
 La marque d’ordre octet Unicode (BOM) est sérialisée comme suit (en hexadécimal) :  
  
-   UTF-8 : EF BB BF  
  
-   UTF-16 primauté des octets : FE FF  
  
-   Ordre de primauté des octets little UTF-16 : FF FE  
  
-   UTF-32 primauté des octets : 00 00 FE FF  
  
-   Ordre de primauté des octets little UTF-32 : FF FE 00 00  
  
 Vous devez utiliser le BOM, car il fournit une certaine identification d’un encodage pour fichiers qui autres ont perdu la référence à la <xref:System.Text.Encoding> objet, par exemple, sans balise ou incorrectement référencées données web ou des fichiers texte aléatoires stockés lorsqu’une entreprise n’ont pas ont des intérêts internationaux ou autres données. Souvent des problèmes d’utilisateur peuvent être évités si les données sont correctement et régulièrement référencées, de préférence dans UTF-8 ou UTF-16.  
  
 Des normes qui fournissent un type de codage, un BOM est quelque peu redondant. Toutefois, il peut être utilisé pour aider un serveur à envoyer l’en-tête de codage correct. Sinon, il peut être utilisé comme un secours au cas où l’encodage est perdu.  
  
 Il existe certains inconvénients à l’aide d’une nomenclature. Par exemple, le fait de savoir comment limiter les champs de base de données qui utilisent un BOM peut être difficile. Concaténation de fichiers peut poser un problème également, par exemple, lors de la fusion des fichiers de telle façon un caractère inutile peut finir au milieu des données. En dépit de quelques inconvénients, toutefois, l’utilisation d’une nomenclature est hautement recommandée.  
  
 Pour plus d’informations sur l’ordre d’octet et la marque d’ordre, consultez la norme Unicode sur le [page d’accueil Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Pour vous assurer que les octets encodés sont décodés correctement, vous devez préfixe octets encodés avec un préambule. Toutefois, la plupart des encodages ne fournissent pas de préambule. Pour garantir que les octets encodés sont décodés correctement, vous devez utiliser un encodage Unicode, autrement dit, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, ou <xref:System.Text.UTF32Encoding>, avec un préambule.  
  
   
  
## Examples  
 L’exemple suivant détermine l’ordre d’octet de l’encodage selon le préambule.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>When overridden in a derived class, decodes a sequence of bytes into a string.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</summary>
        <returns>A string that contains the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> objet retourné par la <xref:System.Text.Encoding.GetDecoder%2A> d’un deri (méthode) Autoriser le classe.  
  
 Consultez la section Notes de la <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> rubrique de référence pour une présentation des techniques et les considérations de décodage.  
  
 Notez que le comportement précis de la <xref:System.Text.Encoding.GetString%2A> méthode en tant <xref:System.Text.Encoding> implémentation dépend de la stratégie de secours définie pour cette <xref:System.Text.Encoding> objet. Pour plus d’informations, consultez la section « Choix d’une stratégie de secours » de la [l’encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) rubrique.  
  
   
  
## Examples  
 L’exemple suivant lit une chaîne encodée en UTF-8 à partir d’un fichier binaire est représenté par un <xref:System.IO.FileStream> objet. Pour les fichiers qui sont inférieures à 2 048 octets, il lit le contenu du fichier entier dans un tableau d’octets et appelle le <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> méthode pour effectuer le décodage. Pour les fichiers plus volumineux, il lit 2 048 octets à la fois dans un tableau d’octets, appelle le <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour déterminer le nombre de caractères contenus dans le tableau, puis appelle la <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour effectuer le décodage.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 L’exemple utilise le texte suivant, qui doit être enregistré dans un fichier encodé en UTF-8 nommé Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The byte array contains invalid Unicode code points.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A pointer to a byte array.</param>
        <param name="byteCount">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.</summary>
        <returns>A string that contains the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoding.GetString%2A> méthode est conçue pour optimiser les performances lorsque vous avez un pointeur natif vers un tableau d’octets. Au lieu de la création d’un tableau d’octets géré et puis de le décodage, vous pouvez à la place appeler cette méthode sans avoir à créer des objets intermédiaires.  
  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> objet retourné par la <xref:System.Text.Encoding.GetDecoder%2A> d’un deri (méthode) Autoriser le classe.  
  
 Consultez la section Notes de la <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> rubrique de référence pour une présentation des techniques et les considérations de décodage.  
  
 Notez que le comportement précis de la <xref:System.Text.Encoding.GetString%2A> méthode en tant <xref:System.Text.Encoding> implémentation dépend de la stratégie de secours définie pour cette <xref:System.Text.Encoding> objet. Pour plus d’informations, consultez la section « Choix d’une stratégie de secours » de la [l’encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md) rubrique.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is a null pointer.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> is less than zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A   fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">The byte array containing the sequence of bytes to decode.</param>
        <param name="index">The index of the first byte to decode.</param>
        <param name="count">The number of bytes to decode.</param>
        <summary>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</summary>
        <returns>A string that contains the results of decoding the specified sequence of bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fournie par le <xref:System.Text.Encoding.GetDecoder%2A> méthode ou la <xref:System.Text.Encoding.GetEncoder%2A> (méthode), respectivement, d’une classe dérivée.  
  
 Consultez la section Notes de la <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> rubrique de référence pour une présentation des techniques et les considérations de décodage.  
  
   
  
## Examples  
 L’exemple suivant lit une chaîne encodée en UTF-8 à partir d’un fichier binaire qui est représenté par un <xref:System.IO.FileStream> objet. Pour les fichiers qui sont inférieures à 2 048 octets, il lit le contenu du fichier entier dans un tableau d’octets et appelle le <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> méthode pour effectuer le décodage. Pour les fichiers plus volumineux, il lit 2 048 octets à la fois dans un tableau d’octets, appelle le <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour déterminer le nombre de caractères contenus dans le tableau, puis appelle la <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour effectuer le décodage.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 L’exemple utilise le texte suivant, qui doit être enregistré dans un fichier encodé en UTF-8 nommé Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The byte array contains invalid Unicode code points.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> or <paramref name="count" /> is less than zero.  -or-  <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  -and-  <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</summary>
        <value>Nom du <see cref="T:System.Text.Encoding" /> actuel à utiliser avec les balises d'en-tête de l'agent de messagerie.  - ou - une chaîne vide (" »), si actuel <see cref="T:System.Text.Encoding" /> ne peut pas être utilisé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous avez besoin d’un encodage pour un nom d’en-tête, vous devez appeler la <xref:System.Text.Encoding.GetEncoding%2A> méthode avec le <xref:System.Text.Encoding.HeaderName%2A> propriété. La méthode extrait souvent un encodage différent de l’encodage de test fourni dans l’appel. En général uniquement les applications de messagerie doivent extraire un tel encodage.  
  
 Dans certains cas, la valeur de la <xref:System.Text.Encoding.BodyName%2A> propriété correspond à la norme internationale qui définit cet encodage. Cela ne signifie pas que l’implémentation est conforme à l’intégralité de cette norme.  
  
 Notez que <xref:System.Text.Encoding.WebName%2A> retourne le nom à utiliser pour décrire un encodage. Le <xref:System.Text.Encoding.HeaderName%2A> propriété définit un encodage différent qui peut fonctionner mieux pour une application de messagerie, par exemple. Toutefois, l’utilisation de la propriété pour définir l’encodage n’est pas recommandée.  
  
   
  
## Examples  
 L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms différents de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Il affiche <xref:System.Text.Encoding.EncodingName%2A> mais ne compare pas par rapport à elle.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a value indicating whether the current encoding is always normalized.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</summary>
        <returns>
          <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is always normalized; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le formulaire de normalisation par défaut est <xref:System.Text.NormalizationForm.FormC>, qui utilise la décomposition canonique complète, suivie du remplacement des séquences par leurs composites principaux, si possible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">One of the <see cref="T:System.Text.NormalizationForm" /> values.</param>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</summary>
        <returns>
          <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> object is always normalized using the specified <see cref="T:System.Text.NormalizationForm" /> value; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le formulaire de normalisation par défaut est <xref:System.Text.NormalizationForm.FormC>, qui utilise la décomposition canonique complète, suivie du remplacement des séquences par leurs composites principaux, si possible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> actuel peut être utilisé par les clients de navigation pour afficher le contenu ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> actuel peut être utilisé par les clients de navigation pour enregistrer du contenu ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> actuel peut être utilisé par les clients de messagerie et de news pour afficher du contenu ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> actuel peut être utilisé par les clients de messagerie et de news pour enregistrer du contenu ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> actuel est en lecture seule ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Text.Encoding" /> actuel utilise des points de code codés sur un octet ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sur un octet d’encodage, par exemple, <xref:System.Text.ASCIIEncoding>, cette propriété récupère `true`.  
  
> [!CAUTION]
>  Vous devez être prudent dans ce que votre application fait avec la valeur de <xref:System.Text.Encoding.IsSingleByte%2A>. Une hypothèse de la façon dont un encodage continuera peut toujours être incorrecte. Par exemple, Windows-1252 a une valeur de `true` pour <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, mais Encoding.GetMaxByteCount (1) renvoie 2. Il s’agit, car la méthode prend en compte les substituts potentiels restants d’une opération de décodeur précédente.  
  
   
  
## Examples  
 L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">A subclass of <see cref="T:System.Text.EncodingProvider" /> that provides access to additional character encodings.</param>
        <summary>Registers an encoding provider.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoding.RegisterProvider%2A> méthode vous permet d’enregistrer une classe dérivée de <xref:System.Text.EncodingProvider> qui rend caractères encodages disponibles sur une plateforme qui ne les gère pas dans le cas contraire. Une fois que le fournisseur d’encodage est enregistré, les encodages pris en charge peuvent être récupérés en appelant une <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> de surcharge. S’il existe plusieurs fournisseurs de codage, le <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> méthode tente de récupérer un encodage spécifié à partir de chaque fournisseur commençant par la plus récemment enregistrés.

L’inscription d’un fournisseur d’encodage à l’aide de la <xref:System.Text.Encoding.RegisterProvider%2A> méthode modifie également le comportement de la [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) et [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) méthodes quand il est passé un argument de `0`:

- Si le fournisseur inscrit est le <xref:System.Text.CodePagesEncodingProvider>, la méthode retourne l’encodage qui correspond à la page de code active du système lors de l’exécution sur le système d’exploitation Windows.

- Un fournisseur d’encodage personnalisé peut choisir le codage à retourner lorsque une de ces <xref:System.Text.Encoding.GetEncoding%2A> surcharges de méthode est passé un argument de `0`. Le fournisseur peut choisir également à ne pas retourner un encodage en ayant la <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> retour de la méthode `null`. 
  
 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] inclut un fournisseur d’encodage, <xref:System.Text.CodePagesEncodingProvider>, qui rend les encodages disponibles qui sont présents dans le .NET Framework, mais ne sont pas disponibles dans [!INCLUDE[net_v46](~/includes/net-v46-md.md)]. Par défaut, [!INCLUDE[net_v46](~/includes/net-v46-md.md)] prend uniquement en charge les encodages Unicode, ASCII et page de codes 28591.  
  
 Si le même fournisseur d’encodage est utilisé dans plusieurs appels à la <xref:System.Text.Encoding.RegisterProvider%2A> méthode, seul le premier appel de méthode inscrit le fournisseur. Les appels suivants sont ignorés.  
  
 Si la <xref:System.Text.Encoding.RegisterProvider%2A> est appelée pour inscrire plusieurs fournisseurs qui gèrent le même encodage, le dernier fournisseur enregistré est utilisée pour tous les encodage et les opérations de décodage. Tous les fournisseurs inscrits précédemment sont ignorés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-16 format using the little endian byte order.</summary>
        <value>Encodage pour le format UTF-16 en utilisant l'ordre d'octet avec primauté des octets de poids faible (Little Endian).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur les encodages pris en charge par le .NET Framework et en savoir plus sur le codage Unicode à utiliser, consultez [l’encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Le <xref:System.Text.UnicodeEncoding> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application. Il utilise le remplacement de secours pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par un point d’interrogation (« ? ») caractères. Au lieu de cela, vous pouvez appeler la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructeur pour instancier un little endian <xref:System.Text.UnicodeEncoding> objet dont exception de secours est un <xref:System.Text.EncoderFallbackException> ou <xref:System.Text.DecoderFallbackException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-32 format using the little endian byte order.</summary>
        <value>Objet d'encodage pour le format UTF-32 utilisant l'ordre d'octet avec primauté des octets de poids faible (little-endian).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.UTF32Encoding> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application. Il utilise le remplacement de secours pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par le caractère de remplacement Unicode (U + FFFE). Au lieu de cela, vous pouvez appeler la <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructeur pour instancier un <xref:System.Text.UTF32Encoding> objet dont exception de secours est un <xref:System.Text.EncoderFallbackException> ou <xref:System.Text.DecoderFallbackException>, comme l’illustre l’exemple suivant.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Pour une présentation de primauté des octets, consultez la <xref:System.Text.Encoding> rubrique de la classe.  
  
 Pour plus d’informations sur les encodages pris en charge par le .NET Framework et en savoir plus sur le codage Unicode à utiliser, consultez [l’encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-7 format.</summary>
        <value>Encodage pour le format UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage UTF-7 est utilisé principalement dans les environnements historiquement restreintes à 7 bits, tels que NNTP et certaines applications de messagerie. En raison de problèmes avec la robustesse et la sécurité, vous ne devez pas utiliser UTF7 encodage dans des environnements de 8 bits où le codage UTF-8 peut être utilisé à la place.  
  
   
  
## Examples  
 L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an encoding for the UTF-8 format.</summary>
        <value>Encodage pour le format UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne un <xref:System.Text.UTF8Encoding> objet qui encode les caractères Unicode (UTF-16-encodées) en une séquence d’un à quatre octets par caractère, et cela décode un tableau d’octets d’encodée en UTF-8 pour les caractères Unicode (UTF-16-encodées). Pour plus d’informations sur les codages de caractères pris en charge par le .NET Framework et en savoir plus sur le codage Unicode à utiliser, consultez [l’encodage de caractères dans le .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Le <xref:System.Text.UTF8Encoding> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application.  
  
-   Elle retourne un <xref:System.Text.UTF8Encoding> objet qui fournit une marque d’ordre octet (BOM) Unicode. Pour instancier un encodage UTF-8 qui ne fournit pas une nomenclature, appelez aucune surcharge de la <xref:System.Text.UTF8Encoding.%23ctor%2A> constructeur.  
  
-   Elle retourne un <xref:System.Text.UTF8Encoding> objet qui utilise le remplacement de secours pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par un point d’interrogation (« ? ») caractères. Au lieu de cela, vous pouvez appeler la <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructeur pour instancier un <xref:System.Text.UTF8Encoding> objet dont exception de secours est un <xref:System.Text.EncoderFallbackException> ou <xref:System.Text.DecoderFallbackException>, comme l’illustre l’exemple suivant.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant définit un tableau qui se compose des caractères suivants :  
  
-   LETTRE MINUSCULE LATINE Z (U + 007 A)  
  
-   LATIN LETTRE MINUSCULE (U + 0061)  
  
-   COMBINAISON BRÈVE (U + 0306)  
  
-   LETTRE MINUSCULE LATINE AE AVEC AIGUS (U + 01FD)  
  
-   LETTRE MINUSCULE GRECQUE BÊTA (U + 03B2)  
  
-   Une paire de substitution (U + D800 U + DD54) qui forme le grec ACROPHONIC ATTIC un milliers STATERS (U + 10154).  
  
 Il affiche les unités de code UTF-16 de chaque caractère et détermine le nombre d’octets requis par un encodeur UTF-8 pour encoder le tableau de caractères. Il encode les caractères et affiche les octets encodée en UTF-8 qui en résulte.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</summary>
        <value>Nom IANA pour le <see cref="T:System.Text.Encoding" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Text.Encoding.WebName%2A> propriété est le même que le <xref:System.Text.EncodingInfo.Name%2A> propriété.  
  
 Notez que <xref:System.Text.Encoding.WebName%2A> retourne un nom enregistré IANA pour le codage. Lorsque sa valeur est le nom de la norme, l’implémentation de l’encodage n’est peut-être pas conforme dans sa totalité de cette norme. Le <xref:System.Text.Encoding.HeaderName%2A> propriété définit un encodage différent qui peut fonctionner mieux pour les en-têtes de courrier électronique. Toutefois, la plupart des applications doivent utiliser <xref:System.Text.Encoding.WebName%2A> à la place.  
  
 Pour plus d’informations sur l’IANA, accédez à [www.iana.org](https://www.iana.org/).  
  
 Le <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> est le même que le <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> retourné par <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Certains noms web sont des doublons ; consultez la section Notes pour <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> pour plus d’informations.  
  
   
  
## Examples  
 L’exemple suivant inclut le <xref:System.Text.Encoding.WebName%2A> dans un en-tête HTML.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms différents de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Il affiche <xref:System.Text.Encoding.EncodingName%2A> mais ne compare pas par rapport à elle.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</summary>
        <value>Page de codes du système d'exploitation Windows la plus proche du <see cref="T:System.Text.Encoding" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est fournie pour la compatibilité avec les API Windows multilingue (MLang), par exemple, pour déterminer les familles de polices. Pour la globalisation, il est recommandé d’à la place l’un des encodages Unicode. Il est également recommandé d’utiliser <xref:System.Text.Encoding.WebName%2A> au lieu de <xref:System.Text.Encoding.WindowsCodePage%2A> pour identifier la page de codes.  
  
   
  
## Examples  
 L’exemple suivant détermine la page de codes Windows la plus proche de chaque encodage.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>