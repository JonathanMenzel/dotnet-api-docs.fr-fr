<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Encoding.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe07adda8f83141f6520fcaefa264a4ae9446935542e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">adda8f83141f6520fcaefa264a4ae9446935542e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>Represents a character encoding.</source>
          <target state="translated">Représente un encodage de caractères.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</source>
          <target state="translated">L'encodage est le processus de transformation d'un jeu de caractères Unicode en une séquence d'octets.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</source>
          <target state="translated">En revanche, le décodage est le processus de transformation d’une séquence d’octets codés en un jeu de caractères Unicode.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les Formats (formats UTF) et d’autres encodages pris en charge par <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>, consultez <bpt id="p1">[</bpt>l’encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays.</source>
          <target state="translated">Notez que <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> est destiné à opérer sur des caractères Unicode à la place des données binaires arbitraires, tels que des tableaux d’octets.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous devez encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The .NET Framework provides the following implementations of the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class to support current Unicode encodings and other encodings:</source>
          <target state="translated">Le .NET Framework fournit les implémentations suivantes de la <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> classe pour prendre en charge les encodages Unicode et autres :</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> encodes Unicode characters as single 7-bit ASCII characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> encode les caractères Unicode comme des caractères ASCII 7 bits uniques.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>This encoding only supports character values between U+0000 and U+007F.</source>
          <target state="translated">Cet encodage ne prend en charge que les valeurs de caractère comprises entre U + 0000 et U + 007F.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Code page 20127.</source>
          <target state="translated">Page de codes 20127.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.ASCII%2A&gt;</ph> property.</source>
          <target state="translated">Également disponible via le <ph id="ph1">&lt;xref:System.Text.Encoding.ASCII%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.UTF7Encoding&gt;</ph> encodes Unicode characters using the UTF-7 encoding.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF7Encoding&gt;</ph> encode les caractères Unicode à l’aide de l’encodage UTF-7.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>This encoding supports all Unicode character values.</source>
          <target state="translated">Cet encodage prend en charge toutes les valeurs de caractères Unicode.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Code page 65000.</source>
          <target state="translated">Page de codes 65000.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.UTF7%2A&gt;</ph> property.</source>
          <target state="translated">Également disponible via le <ph id="ph1">&lt;xref:System.Text.Encoding.UTF7%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> encodes Unicode characters using the UTF-8 encoding.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> encode les caractères Unicode à l’aide de l’encodage UTF-8.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>This encoding supports all Unicode character values.</source>
          <target state="translated">Cet encodage prend en charge toutes les valeurs de caractères Unicode.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Code page 65001.</source>
          <target state="translated">Page de codes 65001.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.UTF8%2A&gt;</ph> property.</source>
          <target state="translated">Également disponible via le <ph id="ph1">&lt;xref:System.Text.Encoding.UTF8%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> encodes Unicode characters using the UTF-16 encoding.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> encode les caractères Unicode à l’aide de l’encodage UTF-16.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Both little endian and big endian byte orders are supported.</source>
          <target state="translated">Les ordres des octets little endian et big endian sont pris en charge.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.Unicode%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Text.Encoding.BigEndianUnicode%2A&gt;</ph> property.</source>
          <target state="translated">Également disponible via le <ph id="ph1">&lt;xref:System.Text.Encoding.Unicode%2A&gt;</ph> propriété et le <ph id="ph2">&lt;xref:System.Text.Encoding.BigEndianUnicode%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> encodes Unicode characters using the UTF-32 encoding.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> encode les caractères Unicode à l’aide de l’encodage UTF-32.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported.</source>
          <target state="translated">À la fois little endian (page de codes 12000) et octet big endian (page de codes 12001) orders sont pris en charge.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Also available through the <ph id="ph1">&lt;xref:System.Text.Encoding.UTF32%2A&gt;</ph> property.</source>
          <target state="translated">Également disponible via le <ph id="ph1">&lt;xref:System.Text.Encoding.UTF32%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class is primarily intended to convert between different encodings and Unicode.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> classe est principalement destinée à effectuer une conversion entre différents encodages et Unicode.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Often one of the derived Unicode classes is the correct choice for your app.</source>
          <target state="translated">Une des classes Unicode dérivées est souvent le bon choix pour votre application.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method to obtain other encodings, and call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method to get a list of all encodings.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> méthode pour obtenir d’autres encodages et appelez le <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> méthode pour obtenir une liste de tous les encodages.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The following table lists the encodings supported by the .NET Framework.</source>
          <target state="translated">Le tableau suivant répertorie les encodages pris en charge par le .NET Framework.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>It lists each encoding's code page number and the values of the encoding's <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Il répertorie le numéro de page de codes de chaque codage et les valeurs du codage <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType&gt;</ph> propriétés.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>An asterisk in the last column indicates that the code page is natively supported by the .NET Framework, regardless of the underlying platform.</source>
          <target state="translated">Un astérisque dans la dernière colonne indique que la page de codes est prise en charge par le .NET Framework, quel que soit la plateforme sous-jacente.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Note that code pages whose <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph> property corresponds to an international standard do not necessarily comply in full with that standard.</source>
          <target state="translated">Notez que le code pages dont <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph> propriété correspond à une norme internationale ne sont pas nécessairement conformes à l’intégralité de cette norme.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Code page</source>
          <target state="translated">Page de codes</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Name</source>
          <target state="translated">Name</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Display name</source>
          <target state="translated">Nom affiché</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>.NET Framework support</source>
          <target state="translated">Prise en charge de .NET framework</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>37</source>
          <target state="translated">37</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM037</source>
          <target state="translated">IBM037</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (US-Canada)</source>
          <target state="translated">IBM EBCDIC (États-Unis-Canada)</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>437</source>
          <target state="translated">437</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM437</source>
          <target state="translated">IBM437</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>OEM United States</source>
          <target state="translated">OEM États-Unis</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>500</source>
          <target state="translated">500</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM500</source>
          <target state="translated">IBM500</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (International)</source>
          <target state="translated">IBM EBCDIC (International)</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>708</source>
          <target state="translated">708</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ASMO-708</source>
          <target state="translated">ASMO-708</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Arabic (ASMO 708)</source>
          <target state="translated">Arabe (ASMO 708)</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>720</source>
          <target state="translated">720</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>DOS-720</source>
          <target state="translated">DOS-720</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Arabic (DOS)</source>
          <target state="translated">Arabe (DOS)</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>737</source>
          <target state="translated">737</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm737</source>
          <target state="translated">ibm737</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Greek (DOS)</source>
          <target state="translated">Grec (DOS)</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>775</source>
          <target state="translated">775</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm775</source>
          <target state="translated">ibm775</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Baltic (DOS)</source>
          <target state="translated">Baltique (DOS)</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>850</source>
          <target state="translated">850</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm850</source>
          <target state="translated">ibm850</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Western European (DOS)</source>
          <target state="translated">Europe occidentale (DOS)</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>852</source>
          <target state="translated">852</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm852</source>
          <target state="translated">ibm852</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Central European (DOS)</source>
          <target state="translated">Europe centrale (DOS)</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>855</source>
          <target state="translated">855</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM855</source>
          <target state="translated">IBM855</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>OEM Cyrillic</source>
          <target state="translated">OEM cyrillique</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>857</source>
          <target state="translated">857</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm857</source>
          <target state="translated">ibm857</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Turkish (DOS)</source>
          <target state="translated">Turc (DOS)</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>858</source>
          <target state="translated">858</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM00858</source>
          <target state="translated">IBM00858</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>OEM Multilingual Latin I</source>
          <target state="translated">OEM multilingue Latin I</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>860</source>
          <target state="translated">860</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM860</source>
          <target state="translated">IBM860</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Portuguese (DOS)</source>
          <target state="translated">Portugais (DOS)</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>861</source>
          <target state="translated">861</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm861</source>
          <target state="translated">ibm861</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Icelandic (DOS)</source>
          <target state="translated">Islandais (DOS)</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>862</source>
          <target state="translated">862</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>DOS-862</source>
          <target state="translated">DOS-862</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Hebrew (DOS)</source>
          <target state="translated">Hébreu (DOS)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>863</source>
          <target state="translated">863</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM863</source>
          <target state="translated">IBM863</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>French Canadian (DOS)</source>
          <target state="translated">Français canadien (DOS)</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>864</source>
          <target state="translated">864</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM864</source>
          <target state="translated">IBM864</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Arabic (864)</source>
          <target state="translated">Arabe (864)</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>865</source>
          <target state="translated">865</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM865</source>
          <target state="translated">IBM865</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Nordic (DOS)</source>
          <target state="translated">Langues scandinaves (DOS)</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>866</source>
          <target state="translated">866</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>cp866</source>
          <target state="translated">cp866</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Cyrillic (DOS)</source>
          <target state="translated">Cyrillique (DOS)</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>869</source>
          <target state="translated">869</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ibm869</source>
          <target state="translated">ibm869</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Greek, Modern (DOS)</source>
          <target state="translated">Grec moderne (DOS)</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>870</source>
          <target state="translated">870</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM870</source>
          <target state="translated">IBM870</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Multilingual Latin-2)</source>
          <target state="translated">IBM EBCDIC (multilingue Latin-2)</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>874</source>
          <target state="translated">874</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-874</source>
          <target state="translated">Windows-874</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Thai (Windows)</source>
          <target state="translated">Thaï (Windows)</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>875</source>
          <target state="translated">875</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>cp875</source>
          <target state="translated">cp875</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Greek Modern)</source>
          <target state="translated">IBM EBCDIC (grec moderne)</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>932</source>
          <target state="translated">932</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>shift_jis</source>
          <target state="translated">Shift_JIS</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (Shift-JIS)</source>
          <target state="translated">Japonais (Shift-JIS)</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>936</source>
          <target state="translated">936</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>gb2312</source>
          <target state="translated">gb2312</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (GB2312)</source>
          <target state="translated">Chinois simplifié (GB2312)</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>949</source>
          <target state="translated">949</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ks_c_5601-1987</source>
          <target state="translated">ks_c_5601-1987</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Korean</source>
          <target state="translated">Coréen</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>950</source>
          <target state="translated">950</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>big5</source>
          <target state="translated">Big5</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Traditional (Big5)</source>
          <target state="translated">Chinois traditionnel (Big5)</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1026</source>
          <target state="translated">1026</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM1026</source>
          <target state="translated">IBM1026</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Turkish Latin-5)</source>
          <target state="translated">IBM EBCDIC (turc Latin-5)</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1047</source>
          <target state="translated">1047</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01047</source>
          <target state="translated">IBM01047</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM Latin-1</source>
          <target state="translated">IBM Latin-1</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1140</source>
          <target state="translated">1140</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01140</source>
          <target state="translated">IBM01140</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (US-Canada-Euro)</source>
          <target state="translated">IBM EBCDIC (États-Unis-Canada-Europe)</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1141</source>
          <target state="translated">1141</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01141</source>
          <target state="translated">IBM01141</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Germany-Euro)</source>
          <target state="translated">IBM EBCDIC (Allemagne-Euro)</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1142</source>
          <target state="translated">1142</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01142</source>
          <target state="translated">IBM01142</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Denmark-Norway-Euro)</source>
          <target state="translated">IBM EBCDIC (Danemark-Norvège-Euro)</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1143</source>
          <target state="translated">1143</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01143</source>
          <target state="translated">IBM01143</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Finland-Sweden-Euro)</source>
          <target state="translated">IBM EBCDIC (Finlande-Suède-Euro)</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1144</source>
          <target state="translated">1144</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01144</source>
          <target state="translated">IBM01144</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Italy-Euro)</source>
          <target state="translated">IBM EBCDIC (Italie-Euro)</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1145</source>
          <target state="translated">1145</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01145</source>
          <target state="translated">IBM01145</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Spain-Euro)</source>
          <target state="translated">IBM EBCDIC (Espagne-Euro)</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1146</source>
          <target state="translated">1146</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01146</source>
          <target state="translated">IBM01146</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (UK-Euro)</source>
          <target state="translated">IBM EBCDIC (Royaume Uni-Europe)</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1147</source>
          <target state="translated">1147</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01147</source>
          <target state="translated">IBM01147</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (France-Euro)</source>
          <target state="translated">IBM EBCDIC (France-Europe)</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1148</source>
          <target state="translated">1148</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01148</source>
          <target state="translated">IBM01148</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (International-Euro)</source>
          <target state="translated">IBM EBCDIC (International-Euro)</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1149</source>
          <target state="translated">1149</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM01149</source>
          <target state="translated">IBM01149</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Icelandic-Euro)</source>
          <target state="translated">IBM EBCDIC (islandais-Euro)</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1200</source>
          <target state="translated">1200</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>utf-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Unicode</source>
          <target state="translated">Unicode</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1201</source>
          <target state="translated">1201</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>unicodeFFFE</source>
          <target state="translated">unicodeFFFE</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Unicode (Big endian)</source>
          <target state="translated">Unicode (Big endian)</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1250</source>
          <target state="translated">1250</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1250</source>
          <target state="translated">Windows-1250</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Central European (Windows)</source>
          <target state="translated">Europe centrale (Windows)</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1251</source>
          <target state="translated">1251</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1251</source>
          <target state="translated">Windows-1251</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Cyrillic (Windows)</source>
          <target state="translated">Cyrillique (Windows)</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1252</source>
          <target state="translated">1252</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Windows-1252</source>
          <target state="translated">Windows-1252</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Western European (Windows)</source>
          <target state="translated">Europe occidentale (Windows)</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1253</source>
          <target state="translated">1253</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1253</source>
          <target state="translated">windows-1253</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Greek (Windows)</source>
          <target state="translated">Grec (Windows)</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1254</source>
          <target state="translated">1254</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1254</source>
          <target state="translated">Windows-1254</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Turkish (Windows)</source>
          <target state="translated">Turc (Windows)</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1255</source>
          <target state="translated">1255</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1255</source>
          <target state="translated">Windows-1255</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Hebrew (Windows)</source>
          <target state="translated">Hébreu (Windows)</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1256</source>
          <target state="translated">1256</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1256</source>
          <target state="translated">Windows-1256</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Arabic (Windows)</source>
          <target state="translated">Arabe (Windows)</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1257</source>
          <target state="translated">1257</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1257</source>
          <target state="translated">Windows-1257</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Baltic (Windows)</source>
          <target state="translated">Baltique (Windows)</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1258</source>
          <target state="translated">1258</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>windows-1258</source>
          <target state="translated">windows-1258</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Vietnamese (Windows)</source>
          <target state="translated">Vietnamien (Windows)</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>1361</source>
          <target state="translated">1361</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Johab</source>
          <target state="translated">Johab</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Korean (Johab)</source>
          <target state="translated">Coréen (Johab)</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10000</source>
          <target state="translated">10000</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>macintosh</source>
          <target state="translated">Macintosh</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Western European (Mac)</source>
          <target state="translated">Europe occidentale (Mac)</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10001</source>
          <target state="translated">10001</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-japanese</source>
          <target state="translated">x-mac-japonais</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (Mac)</source>
          <target state="translated">Japonais (Mac)</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10002</source>
          <target state="translated">10002</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-chinesetrad</source>
          <target state="translated">x-mac-chinesetrad</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Traditional (Mac)</source>
          <target state="translated">Chinois traditionnel (Mac)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10003</source>
          <target state="translated">10003</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-korean</source>
          <target state="translated">x-mac-coréen</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Korean (Mac)</source>
          <target state="translated">Coréen (Mac)</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10004</source>
          <target state="translated">10004</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-arabic</source>
          <target state="translated">x-mac-arabe</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Arabic (Mac)</source>
          <target state="translated">Arabe (Mac)</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10005</source>
          <target state="translated">10005</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-hebrew</source>
          <target state="translated">x-mac-hébreu</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Hebrew (Mac)</source>
          <target state="translated">Hébreu (Mac)</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10006</source>
          <target state="translated">10006</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-greek</source>
          <target state="translated">Grec-x-mac</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Greek (Mac)</source>
          <target state="translated">Grec (Mac)</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10007</source>
          <target state="translated">10007</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-cyrillic</source>
          <target state="translated">x-mac-cyrillique</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Cyrillic (Mac)</source>
          <target state="translated">Cyrillique (Mac)</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10008</source>
          <target state="translated">10008</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-chinesesimp</source>
          <target state="translated">x-mac-chinesesimp</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (Mac)</source>
          <target state="translated">Chinois simplifié (Mac)</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10010</source>
          <target state="translated">10010</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-romanian</source>
          <target state="translated">x-mac-roumain</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Romanian (Mac)</source>
          <target state="translated">Roumain (Mac)</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10017</source>
          <target state="translated">10017</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-ukrainian</source>
          <target state="translated">x-mac-ukrainien</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Ukrainian (Mac)</source>
          <target state="translated">Ukrainien (Mac)</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10021</source>
          <target state="translated">10021</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-thai</source>
          <target state="translated">x-mac-thaï</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Thai (Mac)</source>
          <target state="translated">Thaï (Mac)</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10029</source>
          <target state="translated">10029</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-ce</source>
          <target state="translated">x-mac-ce</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Central European (Mac)</source>
          <target state="translated">Europe centrale (Mac)</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10079</source>
          <target state="translated">10079</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-icelandic</source>
          <target state="translated">x-mac-islandais</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Icelandic (Mac)</source>
          <target state="translated">Islandais (Mac)</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10081</source>
          <target state="translated">10081</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-turkish</source>
          <target state="translated">x-mac-turc</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Turkish (Mac)</source>
          <target state="translated">Turc (Mac)</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>10082</source>
          <target state="translated">10082</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-mac-croatian</source>
          <target state="translated">x-mac-croate</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Croatian (Mac)</source>
          <target state="translated">Croate (Mac)</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>12000</source>
          <target state="translated">12000</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>utf-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Unicode (UTF-32)</source>
          <target state="translated">Unicode (UTF-32)</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>12001</source>
          <target state="translated">12001</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>utf-32BE</source>
          <target state="translated">UTF-32be ne</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Unicode (UTF-32 Big endian)</source>
          <target state="translated">Unicode (UTF-32 Big endian)</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20000</source>
          <target state="translated">20000</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-Chinese-CNS</source>
          <target state="translated">x-chinois-SNC</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Traditional (CNS)</source>
          <target state="translated">Chinois traditionnel (RC)</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20001</source>
          <target state="translated">20001</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20001</source>
          <target state="translated">x-cp20001</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>TCA Taiwan</source>
          <target state="translated">ACT Taïwan</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20002</source>
          <target state="translated">20002</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-Chinese-Eten</source>
          <target state="translated">Chinois-x-Eten</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Traditional (Eten)</source>
          <target state="translated">Chinois traditionnel (Eten)</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20003</source>
          <target state="translated">20003</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20003</source>
          <target state="translated">x-cp20003</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM5550 Taiwan</source>
          <target state="translated">IBM5550 Taïwan</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20004</source>
          <target state="translated">20004</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20004</source>
          <target state="translated">x-cp20004</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>TeleText Taiwan</source>
          <target state="translated">Télétexte Taïwan</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20005</source>
          <target state="translated">20005</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20005</source>
          <target state="translated">x-cp20005</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Wang Taiwan</source>
          <target state="translated">Wang Taïwan</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20105</source>
          <target state="translated">20105</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-IA5</source>
          <target state="translated">x-IA5</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Western European (IA5)</source>
          <target state="translated">Europe occidentale (IA5)</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20106</source>
          <target state="translated">20106</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-IA5-German</source>
          <target state="translated">x-IA5-allemand</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>German (IA5)</source>
          <target state="translated">Allemand (IA5)</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20107</source>
          <target state="translated">20107</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-IA5-Swedish</source>
          <target state="translated">x-IA5-suédois</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Swedish (IA5)</source>
          <target state="translated">Suédois (IA5)</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20108</source>
          <target state="translated">20108</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-IA5-Norwegian</source>
          <target state="translated">x-IA5-norvégien</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Norwegian (IA5)</source>
          <target state="translated">Norvégien (IA5)</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20127</source>
          <target state="translated">20127</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>us-ascii</source>
          <target state="translated">us-ascii</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>US-ASCII</source>
          <target state="translated">US-ASCII</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20261</source>
          <target state="translated">20261</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20261</source>
          <target state="translated">x-cp20261</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>T.61</source>
          <target state="translated">T.61</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20269</source>
          <target state="translated">20269</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20269</source>
          <target state="translated">x-cp20269</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISO-6937</source>
          <target state="translated">ISO-6937</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20273</source>
          <target state="translated">20273</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM273</source>
          <target state="translated">IBM273</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Germany)</source>
          <target state="translated">IBM EBCDIC (Allemagne)</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20277</source>
          <target state="translated">20277</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM277</source>
          <target state="translated">IBM277</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Denmark-Norway)</source>
          <target state="translated">IBM EBCDIC (Danemark-Norvège)</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20278</source>
          <target state="translated">20278</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM278</source>
          <target state="translated">IBM278</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Finland-Sweden)</source>
          <target state="translated">IBM EBCDIC (Finlande-Suède)</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20280</source>
          <target state="translated">20280</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM280</source>
          <target state="translated">IBM280</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Italy)</source>
          <target state="translated">IBM EBCDIC (Italie)</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20284</source>
          <target state="translated">20284</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM284</source>
          <target state="translated">IBM284</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Spain)</source>
          <target state="translated">IBM EBCDIC (Espagne)</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20285</source>
          <target state="translated">20285</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM285</source>
          <target state="translated">IBM285</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (UK)</source>
          <target state="translated">IBM EBCDIC (ROYAUME-UNI)</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20290</source>
          <target state="translated">20290</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM290</source>
          <target state="translated">IBM290</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Japanese katakana)</source>
          <target state="translated">IBM EBCDIC (japonais katakana)</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20297</source>
          <target state="translated">20297</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM297</source>
          <target state="translated">IBM297</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (France)</source>
          <target state="translated">IBM EBCDIC (France)</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20420</source>
          <target state="translated">20420</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM420</source>
          <target state="translated">IBM420</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Arabic)</source>
          <target state="translated">IBM EBCDIC (arabe)</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20423</source>
          <target state="translated">20423</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM423</source>
          <target state="translated">IBM423</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Greek)</source>
          <target state="translated">IBM EBCDIC (grec)</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20424</source>
          <target state="translated">20424</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM424</source>
          <target state="translated">IBM424</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Hebrew)</source>
          <target state="translated">IBM EBCDIC (hébreu)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20833</source>
          <target state="translated">20833</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-EBCDIC-KoreanExtended</source>
          <target state="translated">EBCDIC-x-KoreanExtended</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Korean Extended)</source>
          <target state="translated">IBM EBCDIC (coréen étendu)</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20838</source>
          <target state="translated">20838</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM-Thai</source>
          <target state="translated">IBM-thaï</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Thai)</source>
          <target state="translated">IBM EBCDIC (thaï)</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20866</source>
          <target state="translated">20866</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>koi8-r</source>
          <target state="translated">koi8-r</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Cyrillic (KOI8-R)</source>
          <target state="translated">Cyrillique (KOI8-R)</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20871</source>
          <target state="translated">20871</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM871</source>
          <target state="translated">IBM871</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Icelandic)</source>
          <target state="translated">IBM EBCDIC (Islande)</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20880</source>
          <target state="translated">20880</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM880</source>
          <target state="translated">IBM880</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Cyrillic Russian)</source>
          <target state="translated">IBM EBCDIC (Russe cyrillique)</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20905</source>
          <target state="translated">20905</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM905</source>
          <target state="translated">IBM905</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Turkish)</source>
          <target state="translated">IBM EBCDIC (turc)</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20924</source>
          <target state="translated">20924</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM00924</source>
          <target state="translated">IBM00924</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM Latin-1</source>
          <target state="translated">IBM Latin-1</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20932</source>
          <target state="translated">20932</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>EUC-JP</source>
          <target state="translated">EUC-JP</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (JIS 0208-1990 and 0212-1990)</source>
          <target state="translated">Japonais (JIS 0208-1990 et 0212-1990)</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20936</source>
          <target state="translated">20936</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20936</source>
          <target state="translated">x-cp20936</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (GB2312-80)</source>
          <target state="translated">Chinois simplifié (GB2312-80)</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>20949</source>
          <target state="translated">20949</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp20949</source>
          <target state="translated">x-cp20949</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Korean Wansung</source>
          <target state="translated">Coréen Wansung</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>21025</source>
          <target state="translated">21025</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>cp1025</source>
          <target state="translated">cp1025</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>IBM EBCDIC (Cyrillic Serbian-Bulgarian)</source>
          <target state="translated">IBM EBCDIC (serbe cyrillique-bulgare)</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>21866</source>
          <target state="translated">21866</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>koi8-u</source>
          <target state="translated">koi8-u</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Cyrillic (KOI8-U)</source>
          <target state="translated">Cyrillique (KOI8-U)</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28591</source>
          <target state="translated">28591</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-1</source>
          <target state="translated">ISO-8859-1.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Western European (ISO)</source>
          <target state="translated">Europe occidentale (ISO)</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28592</source>
          <target state="translated">28592</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-2</source>
          <target state="translated">ISO-8859-2</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Central European (ISO)</source>
          <target state="translated">Europe centrale (ISO)</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28593</source>
          <target state="translated">28593</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-3</source>
          <target state="translated">ISO-8859-3</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Latin 3 (ISO)</source>
          <target state="translated">3 latin (ISO)</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28594</source>
          <target state="translated">28594</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-4</source>
          <target state="translated">ISO-8859-4</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Baltic (ISO)</source>
          <target state="translated">Baltique (ISO)</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28595</source>
          <target state="translated">28595</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-5</source>
          <target state="translated">ISO-8859-5</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Cyrillic (ISO)</source>
          <target state="translated">Cyrillique (ISO)</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28596</source>
          <target state="translated">28596</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-6</source>
          <target state="translated">ISO-8859-6</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Arabic (ISO)</source>
          <target state="translated">Arabe (ISO)</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28597</source>
          <target state="translated">28597</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-7</source>
          <target state="translated">ISO-8859-7</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Greek (ISO)</source>
          <target state="translated">Grec (ISO)</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28598</source>
          <target state="translated">28598</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-8</source>
          <target state="translated">ISO-8859-8</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Hebrew (ISO-Visual)</source>
          <target state="translated">Hébreu (ISO-Visual)</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28599</source>
          <target state="translated">28599</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-9</source>
          <target state="translated">ISO-8859-9</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Turkish (ISO)</source>
          <target state="translated">Turc (ISO)</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28603</source>
          <target state="translated">28603</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-13</source>
          <target state="translated">ISO-8859-13.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Estonian (ISO)</source>
          <target state="translated">Estonien (ISO)</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>28605</source>
          <target state="translated">28605</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-15</source>
          <target state="translated">ISO-8859-15</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Latin 9 (ISO)</source>
          <target state="translated">Latin 9 (ISO)</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>29001</source>
          <target state="translated">29001</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-Europa</source>
          <target state="translated">x-Europa</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Europa</source>
          <target state="translated">Europa</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>38598</source>
          <target state="translated">38598</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-8859-8-i</source>
          <target state="translated">ISO-8859-8-i</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Hebrew (ISO-Logical)</source>
          <target state="translated">Hébreu (ISO-logique)</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>50220</source>
          <target state="translated">50220</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-2022-jp</source>
          <target state="translated">ISO-2022-jp</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (JIS)</source>
          <target state="translated">Japonais (JIS)</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>50221</source>
          <target state="translated">50221</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>csISO2022JP</source>
          <target state="translated">csISO2022JP</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (JIS-Allow 1 byte Kana)</source>
          <target state="translated">Japonais (JIS-autorise Kana 1 octet)</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>50222</source>
          <target state="translated">50222</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-2022-jp</source>
          <target state="translated">ISO-2022-jp</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (JIS-Allow 1 byte Kana - SO/SI)</source>
          <target state="translated">Japonais (JIS-1 octet Kana - donc / SI)</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>50225</source>
          <target state="translated">50225</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>iso-2022-kr</source>
          <target state="translated">ISO-2022-kr</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Korean (ISO)</source>
          <target state="translated">Coréen (ISO)</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>50227</source>
          <target state="translated">50227</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-cp50227</source>
          <target state="translated">x-cp50227</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (ISO-2022)</source>
          <target state="translated">Chinois simplifié (ISO-2022)</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>51932</source>
          <target state="translated">51932</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>euc-jp</source>
          <target state="translated">euc-jp</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Japanese (EUC)</source>
          <target state="translated">Japonais (EUC)</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>51936</source>
          <target state="translated">51936</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>EUC-CN</source>
          <target state="translated">EUC-CN</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (EUC)</source>
          <target state="translated">Chinois simplifié (EUC)</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>51949</source>
          <target state="translated">51949</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>euc-kr</source>
          <target state="translated">euc-kr</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Korean (EUC)</source>
          <target state="translated">Coréen (EUC)</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>52936</source>
          <target state="translated">52936</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>hz-gb-2312</source>
          <target state="translated">Hz-Go-2312</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (HZ)</source>
          <target state="translated">Chinois simplifié (HZ)</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>54936</source>
          <target state="translated">54936</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>GB18030</source>
          <target state="translated">GB18030</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Chinese Simplified (GB18030)</source>
          <target state="translated">Chinois simplifié (GB18030)</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57002</source>
          <target state="translated">57002</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-de</source>
          <target state="translated">x-iscii-fr</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Devanagari</source>
          <target state="translated">ISCII DÉVANÂGARÎ</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57003</source>
          <target state="translated">57003</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-be</source>
          <target state="translated">x iscii être</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Bengali</source>
          <target state="translated">ISCII Bengali</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57004</source>
          <target state="translated">57004</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-ta</source>
          <target state="translated">x-iscii-ta</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Tamil</source>
          <target state="translated">Tamoul ISCII</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57005</source>
          <target state="translated">57005</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-te</source>
          <target state="translated">x-iscii-te</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Telugu</source>
          <target state="translated">ISCII TÉLOUGOU</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57006</source>
          <target state="translated">57006</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-as</source>
          <target state="translated">x-iscii-en tant que</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Assamese</source>
          <target state="translated">ISCII Assamais</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57007</source>
          <target state="translated">57007</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-or</source>
          <target state="translated">iscii x ou</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Oriya</source>
          <target state="translated">ISCII Oriya</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57008</source>
          <target state="translated">57008</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-ka</source>
          <target state="translated">x-iscii-ka</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Kannada</source>
          <target state="translated">ISCII Kannada</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57009</source>
          <target state="translated">57009</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-ma</source>
          <target state="translated">x-iscii-ma</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Malayalam</source>
          <target state="translated">ISCII Malayalam</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57010</source>
          <target state="translated">57010</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-gu</source>
          <target state="translated">x-iscii-gu</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Gujarati</source>
          <target state="translated">ISCII Goudjrati</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>57011</source>
          <target state="translated">57011</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>x-iscii-pa</source>
          <target state="translated">x-iscii-pa</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>ISCII Punjabi</source>
          <target state="translated">ISCII pendjabi</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>65000</source>
          <target state="translated">65000</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>utf-7</source>
          <target state="translated">utf-7</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Unicode (UTF-7)</source>
          <target state="translated">Unicode (UTF-7)</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>65001</source>
          <target state="translated">65001</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>utf-8</source>
          <target state="translated">utf-8</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Unicode (UTF-8)</source>
          <target state="translated">Unicode (UTF-8)</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>✓</source>
          <target state="translated">✓</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%29&gt;</ph> methods to get the Greek (Windows) code page encoding.</source>
          <target state="translated">L’exemple suivant appelle la <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%29&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%29&gt;</ph> l’encodage de page de code de méthodes pour obtenir le grec (Windows).</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>It compares the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.</source>
          <target state="translated">Il compare la <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objets retournés par les appels de méthode pour montrer qu’ils sont égaux, et cartes affiche ensuite le point de code Unicode et la valeur de page de code correspondante pour chaque caractère dans l’alphabet grec.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> méthode ou la <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement, d’une classe dérivée.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first).</source>
          <target state="translated">Le format UTF-16 et les encodeurs UTF-32 peuvent utiliser l’ordre de primauté des octets (octet le plus significatif premier) ou l’ordre d’octet avec primauté (octet le moins significatif premier).</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):</source>
          <target state="translated">Par exemple, la lettre majuscule latine A (U + 0041) est sérialisée comme suit (en hexadécimal) :</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>UTF-16 big endian byte order: 00 41</source>
          <target state="translated">UTF-16 primauté des octets : 00 41</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>UTF-16 little endian byte order: 41 00</source>
          <target state="translated">Ordre de primauté des octets little UTF-16 : 41 00</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>UTF-32 big endian byte order: 00 00 00 41</source>
          <target state="translated">UTF-32 primauté des octets : 00 00 00 41</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>UTF-32 little endian byte order: 41 00 00 00</source>
          <target state="translated">Ordre de primauté des octets little UTF-32 : 41 00 00 00</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>It is generally more efficient to store Unicode characters using the native byte order.</source>
          <target state="translated">Il est généralement plus efficace de stocker des caractères Unicode à l’aide de l’ordre d’octet natif.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</source>
          <target state="translated">Par exemple, il est préférable d’utiliser l’ordre d’octet avec primauté sur les plateformes little-endian, tels que des ordinateurs Intel.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetPreamble%2A&gt;</ph> method retrieves an array of bytes that includes the byte order mark (BOM).</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetPreamble%2A&gt;</ph> méthode récupère un tableau d’octets contenant la marque d’ordre octet (BOM).</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.</source>
          <target state="translated">Si ce tableau d’octets est préfixé à un flux encodé, il aide le décodeur à identifier le format d’encodage utilisé.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’ordre d’octet et la marque d’ordre, consultez la norme Unicode sur le <bpt id="p1">[</bpt>page d’accueil Unicode<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Note that the encoding classes allow errors to:</source>
          <target state="translated">Notez que les classes d’encodage autorisent des erreurs :</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Silently change to a "?" character.</source>
          <target state="translated">Modifier en mode silencieux à un « ? » caractères.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Use a "best fit" character.</source>
          <target state="translated">Utilisez un caractère « ajustement optimal ».</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Change to an application-specific behavior through use of the <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph> classes with the U+FFFD Unicode replacement character.</source>
          <target state="translated">Passez à un comportement spécifique à l’application via l’utilisation de la <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph> classes avec le caractère de remplacement Unicode U + FFFD.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>You should throw an exception on any data stream error.</source>
          <target state="translated">Vous devez lever une exception en cas d’erreur de flux de données.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>An app either uses a "throwonerror" flag when applicable or uses the <ph id="ph1">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph> classes.</source>
          <target state="translated">Une application utilise un indicateur « throwonerror » le cas échéant ou le <ph id="ph1">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph> classes.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements.</source>
          <target state="translated">Secours le mieux adapté est généralement pas recommandé, car elle peut entraîner une perte de données ou toute confusion et est plus lente que les remplacements de caractères simples.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>For ANSI encodings, the best fit behavior is the default.</source>
          <target state="translated">Pour les encodages ANSI, le comportement le mieux adapté est la valeur par défaut.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The following example converts a string from one encoding to another.</source>
          <target state="translated">L’exemple suivant convertit une chaîne d’un encodage à un autre.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The byte[] array is the only type in this example that contains the encoded data.</source>
          <target state="translated">Le tableau de byte [] est le seul type dans cet exemple qui contient les données encodées.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.Encoding">
          <source>The .NET Char and String types are themselves Unicode, so the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call decodes the data back to Unicode.</source>
          <target state="translated">Les types .NET Char et String sont eux-mêmes Unicode, donc la <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> appel décode les données en Unicode.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor">
          <source>Derived classes override this constructor.</source>
          <target state="translated">Classes dérivées de substituent ce constructeur.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>The code page identifier of the preferred encoding.</source>
          <target state="translated">Identificateur de la page de codes de l'encodage préféré.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>0, to use the default encoding.</source>
          <target state="translated">0, pour utiliser l'encodage par défaut.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class that corresponds to the specified code page.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> qui correspond à la page de codes spécifiée.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>Derived classes override this constructor.</source>
          <target state="translated">Classes dérivées de substituent ce constructeur.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>Calls to this constructor from a derived class create an <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object that uses best-fit fallback for both encoding and decoding operations.</source>
          <target state="translated">Créent des appels à ce constructeur à partir d’une classe dérivée un <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objet qui utilise de secours la mieux adaptée pour l’encodage et les opérations de décodage.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>Both the <ph id="ph1">&lt;xref:System.Text.Encoding.DecoderFallback%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.EncoderFallback%2A&gt;</ph> properties are read-only and cannot be modified.</source>
          <target state="translated">À la fois le <ph id="ph1">&lt;xref:System.Text.Encoding.DecoderFallback%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.EncoderFallback%2A&gt;</ph> propriétés sont en lecture seule et ne peut pas être modifiées.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source>To control the fallback strategy for a class derived from <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> constructor.</source>
          <target state="translated">Pour contrôler la stratégie de secours pour une classe dérivée de <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph>, appelez le <ph id="ph2">&lt;xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="codePage" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="codePage" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The encoding code page identifier.</source>
          <target state="translated">Identificateur de la page de code d'encodage.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</source>
          <target state="translated">Objet qui fournit une procédure de gestion d'erreurs quand un caractère ne peut pas être encodé avec l'encodage actuel.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</source>
          <target state="translated">Objet qui fournit une procédure de gestion d'erreurs quand une séquence d'octets ne peut pas être décodée avec l'encodage actuel.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> qui correspond à la page de code spécifiée avec les stratégies de secours d'encodeur et de décodeur spécifiées.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>This constructor is <ph id="ph1">`protected`</ph>; derived classes override it.</source>
          <target state="translated">Ce constructeur est <ph id="ph1">`protected`</ph>; dérivées les classes substituent.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>You call this constructor from a derived class to control the fallback encoding and decoding strategies.</source>
          <target state="translated">Vous appelez ce constructeur d’une classe dérivée pour contrôler l’encodage et décodage des stratégies de secours.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> constructeurs de classe de créent des objets de codage en lecture seule qui n’autorisent pas encodeur ou un décodeur de secours à définir une fois que l’objet est créé.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>If either <ph id="ph1">`encoderFallback`</ph> or <ph id="ph2">`decoderFallback`</ph> is null, best-fit fallback is used as the corresponding fallback strategy.</source>
          <target state="translated">Si le paramètre <ph id="ph1">`encoderFallback`</ph> ou <ph id="ph2">`decoderFallback`</ph> est null, de secours la mieux adaptée est utilisé en tant que la stratégie de secours correspondante.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;paramref name="codePage" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="codePage" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.ASCII">
          <source>Gets an encoding for the ASCII (7-bit) character set.</source>
          <target state="translated">Obtient un encodage pour le jeu de caractères ASCII (7 bits).</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>An  encoding for the ASCII (7-bit) character set.</source>
          <target state="translated">Encodage pour le jeu de caractères ASCII (7 bits).</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.</source>
          <target state="translated">Caractères ASCII sont limités aux 128 caractères Unicode plus bas, à partir de U + 0000 et U + 007F.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>When selecting the ASCII encoding for your app, consider the following:</source>
          <target state="translated">Lorsque vous sélectionnez l’encodage ASCII pour votre application, procédez comme suit :</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>The ASCII encoding is usually appropriate for protocols that require ASCII.</source>
          <target state="translated">L’encodage ASCII est habituellement approprié pour les protocoles qui requièrent ASCII.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>If you requires 8-bit encoding (which is sometimes incorrectly referred to as "ASCII"), the UTF-8 encoding is recommended over the ASCII encoding.</source>
          <target state="translated">Si vous requiert le codage 8 bits (qui est parfois appelé « ASCII »), l’encodage UTF-8 est recommandé du code ASCII de codage.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable.</source>
          <target state="translated">Pour les caractères 0-7F, les résultats sont identiques, mais utiliser UTF-8 évite la perte de données en permettant la représentation sous forme de tous les caractères Unicode qui peuvent être représentées.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.</source>
          <target state="translated">Notez que l’encodage ASCII a une 8 bits ambiguïté qui peut permettre une utilisation malveillante, mais l’encodage UTF-8 supprime toute ambiguïté sur les 8 bits.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit.</source>
          <target state="translated">Avant la version 2.0 du .NET Framework, le .NET Framework autorisées l’usurpation d’identité en ignorant les 8 bits.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.</source>
          <target state="translated">À compter de .NET Framework 2.0, les points de code non-ASCII revient lors du décodage.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>The <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> object that is returned by this property might not have the appropriate behavior for your app.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</source>
          <target state="translated">Il utilise le remplacement de secours pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par un point d’interrogation (« ? ») caractères.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> method to instantiate an <ph id="ph2">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
          <target state="translated">Au lieu de cela, vous pouvez appeler la <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> méthode pour instancier un <ph id="ph2">&lt;xref:System.Text.ASCIIEncoding&gt;</ph> objet dont exception de secours est un <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, comme l’illustre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.ASCII">
          <source>The following example demonstrates the effect of the ASCII encoding on characters that are outside the ASCII range.</source>
          <target state="translated">L’exemple suivant montre l’effet de l’encodage ASCII sur les caractères situés en dehors de la plage ASCII.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>Gets an encoding for the UTF-16 format that uses the big endian byte order.</source>
          <target state="translated">Obtient un encodage pour le format UTF-16 qui utilise l'ordre d'octet avec primauté des octets de poids fort (big-endian).</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>An encoding object for the UTF-16 format that uses the big endian byte order.</source>
          <target state="translated">Objet d'encodage pour le format UTF-16 avec primauté des octets de poids fort (big-endian).</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object that is returned by this property may not have the appropriate behavior for your app.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</source>
          <target state="translated">Il utilise le remplacement de secours pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par un point d’interrogation (« ? ») caractères.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> constructor to instantiate a big endian <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
          <target state="translated">Au lieu de cela, vous pouvez appeler la <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> constructeur pour instancier un big endian <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objet dont exception de secours est un <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, comme l’illustre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>The returned <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object has <ph id="ph2">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> properties, which yield the name "unicodeFFFE".</source>
          <target state="translated">Retourné <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objet a <ph id="ph2">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph>, et <ph id="ph4">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> propriétés, qui génère le nom « unicodeFFFE ».</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name "unicodeFFFE" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.</source>
          <target state="translated">Bien que la marque d’ordre de primauté des octets UTF-16 est hexadécimale FEFF, le nom « unicodeFFFE » a été choisi parce que la marque d’ordre apparaît en tant que valeur hexadécimale FFFE sur les ordinateurs Windows endian peu.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>The following example reads a text file with a UTF-16 encoding using the big endian byte order.</source>
          <target state="translated">L’exemple suivant lit un fichier texte avec un encodage UTF-16 à l’aide de l’ordre de primauté des octets.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BigEndianUnicode">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.BodyName">
          <source>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient un nom pour l’encodage actuel qui peut être utilisé avec les étiquettes de corps de texte de l’agent de messagerie.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>A name for the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> that can be used with mail agent body tags.</source>
          <target state="translated">Nom du <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel qui peut être utilisé avec les balises de corps de texte de l'agent de messagerie.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>An empty string (""), if the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> cannot be used.</source>
          <target state="translated">Une chaîne vide (""), si le <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel ne peut pas être utilisé.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>If you need an encoding for a body name, you should call <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> with the <ph id="ph2">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> property.</source>
          <target state="translated">Si vous avez besoin d’un encodage pour un nom de corps, vous devez appeler <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> avec la <ph id="ph2">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>Often the method retrieves a different encoding from the test encoding furnished in the call.</source>
          <target state="translated">La méthode extrait souvent un encodage différent de l’encodage de test fourni dans l’appel.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>Generally only email applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph>.</source>
          <target state="translated">Seules les applications de messagerie doivent généralement extraire un tel encodage ; la plupart des autres applications qui doivent décrire un encodage doivent utiliser son <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>In some cases, the value of the <ph id="ph1">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> property corresponds to the international standard that defines that encoding.</source>
          <target state="translated">Dans certains cas, la valeur de la <ph id="ph1">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> propriété correspond à la norme internationale qui définit cet encodage.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>This doesn't mean that the implementation complies in full with that standard.</source>
          <target state="translated">Cela ne signifie pas que l’implémentation est conforme à l’intégralité de cette norme.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms différents de <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.BodyName">
          <source>It displays <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> but does not compare against it.</source>
          <target state="translated">Il affiche <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> mais ne compare pas par rapport à elle.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Clone">
          <source>When overridden in a derived class, creates a shallow copy of the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, crée une copie superficielle de l'objet <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Clone">
          <source>A copy of the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">Copie de l'objet <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Clone">
          <source>The clone is writable even if the original <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object is read-only.</source>
          <target state="translated">Le clone est accessible en écriture même si la version d’origine <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objet est en lecture seule.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Clone">
          <source>Therefore, the properties of the clone can be modified.</source>
          <target state="translated">Par conséquent, les propriétés du clone peuvent être modifiées.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Clone">
          <source>A shallow copy of an object is a copy of the object only.</source>
          <target state="translated">Une copie superficielle d’un objet est une copie de l’objet uniquement.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Clone">
          <source>If the object contains references to other objects, the shallow copy does not create copies of the referred objects.</source>
          <target state="translated">Si l’objet contient des références à d’autres objets, la copie superficielle ne crée pas de copies des objets auxquels.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Clone">
          <source>It refers to the original objects instead.</source>
          <target state="translated">Il fait référence aux objets d’origine à la place.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Clone">
          <source>In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.</source>
          <target state="translated">En revanche, une copie complète d’un objet crée une copie de l’objet et une copie de tous les éléments fait référence directement ou indirectement par l’objet.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.CodePage">
          <source>When overridden in a derived class, gets the code page identifier of the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient l'identificateur de la page de codes du <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.CodePage">
          <source>The code page identifier of the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">Identificateur de la page de codes du <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.CodePage">
          <source>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms différents de <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.CodePage">
          <source>It displays <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> but does not compare against it.</source>
          <target state="translated">Il affiche <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> mais ne compare pas par rapport à elle.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>Converts a byte array from one encoding to another.</source>
          <target state="translated">Convertit un tableau d'octets d'un encodage à un autre.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>The encoding format of <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Format d’encodage de <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>The target encoding format.</source>
          <target state="translated">Format d'encodage cible.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>The bytes to convert.</source>
          <target state="translated">Octets à convertir.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>Converts an entire byte array from one encoding to another.</source>
          <target state="translated">Convertit un tableau d'octets entier d'un encodage à un autre.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> containing the results of converting <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph> from <ph id="ph3">&lt;paramref name="srcEncoding" /&gt;</ph> to <ph id="ph4">&lt;paramref name="dstEncoding" /&gt;</ph>.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> contenant le résultat de la conversion de <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph> de <ph id="ph3">&lt;paramref name="srcEncoding" /&gt;</ph> en <ph id="ph4">&lt;paramref name="dstEncoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>The following example converts a Unicode-encoded string to an ASCII-encoded string.</source>
          <target state="translated">L’exemple suivant convertit une chaîne codée au format Unicode en une chaîne codée au format ASCII.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>Because the ASCII encoding object returned by the <ph id="ph1">&lt;xref:System.Text.Encoding.ASCII%2A&gt;</ph> property uses replacement fallback and the Pi character is not part of the ASCII character set, the Pi character is replaced with a question mark, as the output from the example shows.</source>
          <target state="translated">Étant donné que l’objet d’encodage ASCII retourné par la <ph id="ph1">&lt;xref:System.Text.Encoding.ASCII%2A&gt;</ph> propriété utilise le remplacement de secours et le caractère Pi ne fait pas partie du jeu de caractères ASCII, le caractère Pi est remplacé par un point d’interrogation, comme la sortie de l’exemple.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="srcEncoding" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="srcEncoding" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="dstEncoding" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dstEncoding" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><bpt id="p1">**</bpt>srcEncoding.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>srcEncoding.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><bpt id="p1">**</bpt>dstEncoding.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>dstEncoding.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>The encoding of the source array, <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Encodage du tableau source, <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>The encoding of the output array.</source>
          <target state="translated">Encodage du tableau de sortie.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>The array of bytes to convert.</source>
          <target state="translated">Tableau d'octets à convertir.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first element of <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept> to convert.</source>
          <target state="translated">Index du premier élément de <bpt id="p1">&lt;c&gt;</bpt>bytes<ept id="p1">&lt;/c&gt;</ept> à convertir.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to convert.</source>
          <target state="translated">Nombre d'octets à convertir.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>Converts a range of bytes in a byte array from one encoding to another.</source>
          <target state="translated">Convertit une plage d'octets d'un encodage à un autre dans un tableau d'octets.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> containing the result of converting a range of bytes in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph> from <ph id="ph3">&lt;paramref name="srcEncoding" /&gt;</ph> to <ph id="ph4">&lt;paramref name="dstEncoding" /&gt;</ph>.</source>
          <target state="translated">Tableau de type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> contenant le résultat de la conversion d'une plage d'octets de <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph> de <ph id="ph3">&lt;paramref name="srcEncoding" /&gt;</ph> en <ph id="ph4">&lt;paramref name="dstEncoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="srcEncoding" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="srcEncoding" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dstEncoding" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dstEncoding" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid range in the byte array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne spécifient pas une plage valide du tableau d'octets.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><bpt id="p1">**</bpt>srcEncoding.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>srcEncoding.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><bpt id="p1">**</bpt>dstEncoding.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>dstEncoding.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.DecoderFallback">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Text.DecoderFallback" /&gt;</ph> object for the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">Obtient ou définit l'objet <ph id="ph1">&lt;see cref="T:System.Text.DecoderFallback" /&gt;</ph> actuel de l'objet <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>The decoder fallback object for the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">Objet de secours de décodeur pour l'objet <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>The <ph id="ph1">&lt;xref:System.Text.DecoderFallback&gt;</ph> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.DecoderFallback&gt;</ph> objet représente un gestionnaire d’erreurs qui est appelé lorsqu’une séquence d’octets encodée ne peut pas être décodée en un caractère.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>Any one of the following handler types is supported:</source>
          <target state="translated">L’un des types de gestionnaires suivants est prise en charge :</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.</source>
          <target state="translated">Gestionnaire de secours la mieux adapté, qui remplace les octets qui ne peut pas être décodé par un caractère de remplacement approprié.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character.</source>
          <target state="translated">Un gestionnaire de remplacement de secours, qui remplace les octets qui ne peut pas être décodé par un caractère de remplacement arbitraire.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>The .NET Framework includes one replacement fallback handler, <ph id="ph1">&lt;xref:System.Text.DecoderFallback&gt;</ph>, which by default replaces bytes that cannot be decoded with a question mark ("?") character.</source>
          <target state="translated">Le .NET Framework inclut un gestionnaire de secours de remplacement, <ph id="ph1">&lt;xref:System.Text.DecoderFallback&gt;</ph>, qui par défaut remplace les octets qui ne peut pas être décodées avec un point d’interrogation (« ? ») caractères.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>An exception fallback handler, which throws an exception when bytes cannot be decoded.</source>
          <target state="translated">Un gestionnaire d’exceptions de secours, qui lève une exception lorsque les octets ne peut pas être décodés.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.DecoderFallback">
          <source>The .NET Framework includes one exception fallback handler, <ph id="ph1">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph>, which throws a <ph id="ph2">&lt;xref:System.Text.DecoderFallbackException&gt;</ph> when bytes cannot be decoded.</source>
          <target state="translated">Le .NET Framework inclut un gestionnaire d’exceptions de secours, <ph id="ph1">&lt;xref:System.Text.DecoderExceptionFallback&gt;</ph>, qui lève une <ph id="ph2">&lt;xref:System.Text.DecoderFallbackException&gt;</ph> quand les octets ne peut pas être décodés.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.DecoderFallback">
          <source>The value in a set operation is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dans une opération ensembliste, la valeur est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.DecoderFallback">
          <source>A value cannot be assigned in a set operation because the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object is read-only.</source>
          <target state="translated">Une valeur ne peut pas être attribuée dans une opération ensembliste parce que l'objet <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> en cours est en lecture seule.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.Default">
          <source>Gets the default encoding for this .NET implementation.</source>
          <target state="translated">Obtient l’encodage par défaut pour cette implémentation .NET.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>The default encoding for this .NET implementation.</source>
          <target state="translated">L’encodage par défaut pour cette implémentation .NET.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>Different computers can use different encodings as the default, and the default encoding can change on a single computer.</source>
          <target state="translated">Des ordinateurs différents peuvent utiliser différents codages en tant que la valeur par défaut, et l’encodage par défaut peut modifier sur un seul ordinateur.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>If you use the <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> encoding to encode and decode data streamed between computers or retrieved at different times on the same computer, it may translate that data incorrectly.</source>
          <target state="translated">Si vous utilisez la <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> encodage pour encoder et décoder des données en continu entre ordinateurs ou récupérées à des moments différents sur le même ordinateur, il peut incorrectement traduire ces données.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>In addition, the encoding returned by the <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> property uses best-fit fallback to map unsupported characters to characters supported by the code page.</source>
          <target state="translated">En outre, l’encodage retourné par la <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> propriété utilise de secours la mieux adaptée pour mapper les caractères non pris en charge pour les caractères pris en charge par la page de codes.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>For these reasons, using the default encoding is not recommended.</source>
          <target state="translated">Pour ces raisons, à l’aide de l’encodage par défaut n’est pas recommandée.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</source>
          <target state="translated">Pour garantir que les octets encodés sont décodés correctement, vous devez utiliser un encodage Unicode, tel que <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>You could also use a higher-level protocol to ensure that the same format is used for encoding and decoding.</source>
          <target state="translated">Vous pouvez également utiliser un protocole de niveau supérieur pour garantir que le même format est utilisé pour encoder et décoder.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>The Default property in the .NET Framework</source>
          <target state="translated">La propriété par défaut dans le .NET Framework</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>In the .NET Framework on the Windows desktop, the <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> property always gets the system's active code page and creates a <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> object that corresponds to it.</source>
          <target state="translated">Dans le .NET Framework sur le bureau Windows, les <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> propriété obtient la page de codes active du système et crée toujours un <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> objet qui correspond à ce dernier.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>The active code page may be an ANSI code page, which includes the ASCII character set along with additional characters that vary by code page.</source>
          <target state="translated">La page de codes active peut être une page de codes ANSI, qui inclut le jeu, ainsi que des caractères supplémentaires qui varient par page de codes de caractères ASCII.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>Because all <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> encodings based on ANSI code pages lose data, consider using the <ph id="ph2">&lt;xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType&gt;</ph> encoding instead.</source>
          <target state="translated">Étant donné que tous les <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> encodages basés sur les pages de codes ANSI de perdre des données, envisagez d’utiliser le <ph id="ph2">&lt;xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType&gt;</ph> encodage à la place.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>UTF-8 is often identical in the U+00 to U+7F range, but can encode characters outside the ASCII range without loss.</source>
          <target state="translated">UTF-8 est souvent identique U + 00 à U + 7F plage, mais peut encoder des caractères en dehors de la plage ASCII sans perte.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>The Default property on .NET Core</source>
          <target state="translated">La propriété par défaut sur .NET Core</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>On .NET Core, the <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> property always returns the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph>.</source>
          <target state="translated">Sur .NET Core, la <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A&gt;</ph> propriété retourne toujours la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Default">
          <source>UTF-8 is supported on all the operating systems (Windows, Linux, and Max OS X) on which .NET Core applications run.</source>
          <target state="translated">UTF-8 est pris en charge sur tous les systèmes d’exploitation (Windows, Linux et Max OS X) sur les applications .NET Core exécuter.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.EncoderFallback">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallback" /&gt;</ph> object for the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">Obtient ou définit l'objet <ph id="ph1">&lt;see cref="T:System.Text.EncoderFallback" /&gt;</ph> actuel de l'objet <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>The encoder fallback object for the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">Objet de secours d'encodeur pour l'objet <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>The <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph> objet représente un gestionnaire d’erreurs qui est appelé lorsqu’un caractère ne peut pas être converti en séquence d’octets encodée.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>Any one of the following handler types is supported:</source>
          <target state="translated">L’un des types de gestionnaires suivants est prise en charge :</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.</source>
          <target state="translated">Gestionnaire de secours la mieux adapté, qui remplace les caractères qui ne peuvent pas être encodés avec un caractère de remplacement approprié.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character.</source>
          <target state="translated">Un gestionnaire de remplacement de secours, qui remplace les caractères qui ne peuvent pas être encodés avec un caractère de remplacement arbitraire.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>The .NET Framework includes one replacement fallback handler, <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph>, which by default replaces characters that cannot be encoded with a question mark ("?") character.</source>
          <target state="translated">Le .NET Framework inclut un gestionnaire de secours de remplacement, <ph id="ph1">&lt;xref:System.Text.EncoderFallback&gt;</ph>, qui par défaut remplace les caractères qui ne peuvent pas être encodés avec un point d’interrogation (« ? ») caractères.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>An exception fallback handler, which throws an exception when characters cannot be encoded.</source>
          <target state="translated">Un gestionnaire d’exceptions de secours, qui lève une exception lorsque les caractères ne peut pas être encodés.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncoderFallback">
          <source>The .NET Framework includes one exception fallback handler, <ph id="ph1">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph>, which throws an <ph id="ph2">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> when characters cannot be decoded.</source>
          <target state="translated">Le .NET Framework inclut un gestionnaire d’exceptions de secours, <ph id="ph1">&lt;xref:System.Text.EncoderExceptionFallback&gt;</ph>, qui lève une <ph id="ph2">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> quand les caractères ne peut pas être décodés.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.EncoderFallback">
          <source>The value in a set operation is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dans une opération ensembliste, la valeur est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.EncoderFallback">
          <source>A value cannot be assigned in a set operation because the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object is read-only.</source>
          <target state="translated">Une valeur ne peut pas être attribuée dans une opération ensembliste parce que l'objet <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> en cours est en lecture seule.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.EncodingName">
          <source>When overridden in a derived class, gets the human-readable description of the current encoding.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient la description explicite de l'encodage actuel.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncodingName">
          <source>The human-readable description of the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">Description explicite du <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncodingName">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> property is intended for display.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> propriété est conçue pour l’affichage.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncodingName">
          <source>To find a name that can be passed to the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> property.</source>
          <target state="translated">Pour rechercher un nom qui peut être passé à la <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> (méthode), utilisez le <ph id="ph2">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncodingName">
          <source>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms différents de <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.EncodingName">
          <source>It displays <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> but does not compare against it.</source>
          <target state="translated">Il affiche <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> mais ne compare pas par rapport à elle.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to compare with the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> à comparer à l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> is equal to the current instance.</source>
          <target state="translated">Détermine si le <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> spécifié est égal à l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is an instance of <ph id="ph3">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> and is equal to the current instance; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> est une instance de <ph id="ph3">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> et s'il est égal à l'instance actuelle ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>Two instances of <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> are considered equal if they correspond to the same code page and their <ph id="ph2">`EncoderFallback`</ph> and <ph id="ph3">`DecoderFallback`</ph> objects are equal.</source>
          <target state="translated">Deux instances de <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> sont considérées comme égales si elles correspondent à la même page de codes et leurs <ph id="ph2">`EncoderFallback`</ph> et <ph id="ph3">`DecoderFallback`</ph> objets sont égaux.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>In particular, derived code pages all have a code page of 0 and their fallbacks are normally <ph id="ph1">`null`</ph> (<ph id="ph2">`Nothing`</ph> in Visual Basic .NET).</source>
          <target state="translated">En particulier, toutes les pages de codes dérivé ont une page de codes de 0 et leurs secours sont normalement <ph id="ph1">`null`</ph> (<ph id="ph2">`Nothing`</ph> dans Visual Basic .NET).</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>Thus they are all considered equal to one another.</source>
          <target state="translated">Par conséquent, ils sont tous considérés comme égales à un autre.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>One consequence is that when <ph id="ph1">&lt;xref:System.Text.Encoding.Equals%2A&gt;</ph> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.</source>
          <target state="translated">Une conséquence est que lorsque <ph id="ph1">&lt;xref:System.Text.Encoding.Equals%2A&gt;</ph> est utilisé pour remplir une table de hachage, tous les encodages dérivés sont égaux et se situent dans le même emplacement de table de hachage.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.Equals(System.Object)">
          <source>The following example gets two instances of the same encoding (one by codepage and another by name), and checks their equality.</source>
          <target state="translated">L’exemple suivant obtient deux instances du même encodage (une par page de codes) et une autre par nom et vérifie leur égalité.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage d'un jeu de caractères.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The character array containing the characters to encode.</source>
          <target state="translated">Tableau de caractères contenant les caractères à encoder.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage de tous les caractères du tableau de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The number of bytes produced by encoding all the characters in the specified character array.</source>
          <target state="translated">Nombre d'octets produits par l'encodage de tous les caractères du tableau de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> pour stocker les octets obtenus, appelez le <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau maximale, appelez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode exécute l’encodage réel.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> de l’objet qui est utilisé.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>If your app handles string inputs, you should use the string versions of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated">Si votre application gère des entrées de chaîne, vous devez utiliser les versions de la chaîne de la <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">La version de mémoire tampon de caractères Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet ou insérer dans des mémoires tampon existantes.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>If your app must convert a large amount of data, you should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, vous devez le réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version qui prend en charge les tableaux d’octets est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The string containing the set of characters to encode.</source>
          <target state="translated">Chaîne contenant le jeu de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage des caractères de la chaîne spécifiée.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">Nombre d'octets produits par l'encodage des caractères spécifiés.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> pour stocker les octets obtenus, appelez le <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau maximale, appelez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode exécute l’encodage réel.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> de l’objet qui est utilisé.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>If your app handles string inputs, the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> is recommended.</source>
          <target state="translated">Si votre application gère des entrées de chaîne, la version de chaîne de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> est recommandé.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">La version de mémoire tampon de caractères Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet ou insérer dans des mémoires tampon existantes.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version qui prend en charge les tableaux d’octets est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder une chaîne ou une plage de la chaîne, encode les caractères et affiche le nombre d’octets obtenue.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Pointeur du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage d'un jeu de caractères commençant au pointeur de caractère spécifié.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">Nombre d'octets produits par l'encodage des caractères spécifiés.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> requires to store the resulting bytes, you should call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau exact qui <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> requiert pour stocker les octets obtenus, vous devez appeler la <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau maximale, appelez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29&gt;</ph> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> méthode exécute l’encodage réel.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The following are some considerations for using these methods:</source>
          <target state="translated">Voici quelques considérations sur l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Your app may need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Votre application peut nécessiter à encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> de l’objet qui est utilisé.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>If your app handles string inputs, you should use the string version of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated">Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de la <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">La version de mémoire tampon de caractères Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet ou insérer dans des mémoires tampon existantes.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version qui prend en charge les tableaux d’octets est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">Tableau de caractères contenant le jeu de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Index du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre d'octets produits par l'encodage d'un jeu de caractères du tableau de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">Nombre d'octets produits par l'encodage des caractères spécifiés.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> pour stocker les octets obtenus, appelez le <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau maximale, appelez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode exécute l’encodage réel.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> de l’objet qui est utilisé.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>If your app handles string inputs, the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> is recommended.</source>
          <target state="translated">Si votre application gère des entrées de chaîne, la version de chaîne de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> est recommandé.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">La version de mémoire tampon de caractères Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet ou insérer dans des mémoires tampon existantes.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version qui prend en charge les tableaux d’octets est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder trois caractères d’un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>When overridden in a derived class, encodes a set of characters into a sequence of bytes.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, encode un jeu de caractères en séquence d'octets.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The character array containing the characters to encode.</source>
          <target state="translated">Tableau de caractères contenant les caractères à encoder.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, encode tous les caractères du tableau de caractères spécifié en séquence d'octets.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>A byte array containing the results of encoding the specified set of characters.</source>
          <target state="translated">Tableau d'octets contenant les résultats de l'encodage du jeu de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> méthode ou la <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement, d’une classe dérivée.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode exécute l’encodage réel.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> de l’objet qui est utilisé.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
          <target state="translated">(Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> conserverons ce substitut afin qu’il peut être combiné avec un substitut faible au début d’un appel suivant.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> ne pourra plus être en mesure de maintenir l’état, le caractère est envoyés à le <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>If your app handles string inputs, you should call the string version of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated">Si votre application gère des entrées de chaîne, vous devez appeler la version de chaîne de la <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">La version de mémoire tampon de caractères Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet ou insérer dans des mémoires tampon existantes.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version qui prend en charge les tableaux d’octets est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The string containing the characters to encode.</source>
          <target state="translated">Chaîne contenant les caractères à encoder.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, encode tous les caractères de la chaîne spécifiée en séquence d'octets.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>A byte array containing the results of encoding the specified set of characters.</source>
          <target state="translated">Tableau d'octets contenant les résultats de l'encodage du jeu de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> méthode ou la <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement, d’une classe dérivée.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode exécute l’encodage réel.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> de l’objet qui est utilisé.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
          <target state="translated">(Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> conserverons ce substitut afin qu’il peut être combiné avec un substitut faible au début d’un appel suivant.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> ne pourra plus être en mesure de maintenir l’état, le caractère est envoyés à le <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">La version de mémoire tampon de caractères Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet ou insérer dans des mémoires tampon existantes.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version qui prend en charge les tableaux d’octets est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder une chaîne ou une plage de la chaîne, encode les caractères et affiche le nombre d’octets obtenue.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">Tableau de caractères contenant le jeu de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Index du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, encode un jeu de caractères du tableau de caractères spécifié en séquence d'octets.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>A byte array containing the results of encoding the specified set of characters.</source>
          <target state="translated">Tableau d'octets contenant les résultats de l'encodage du jeu de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> méthode ou la <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement, d’une classe dérivée.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode exécute l’encodage réel.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> de l’objet qui est utilisé.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
          <target state="translated">(Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> conserverons ce substitut afin qu’il peut être combiné avec un substitut faible au début d’un appel suivant.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> ne pourra plus être en mesure de maintenir l’état, le caractère est envoyés à le <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">La version de mémoire tampon de caractères Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet ou insérer dans des mémoires tampon existantes.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version qui prend en charge les tableaux d’octets est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder trois caractères d’un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Pointeur du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Pointeur de l'emplacement où commencer l'écriture de la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Nombre maximal d'octets à écrire.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, encode un jeu de caractères commençant au pointeur de caractère spécifié en séquence d'octets stockés à partir du pointeur d'octet spécifié.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The actual number of bytes written at the location indicated by the <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> parameter.</source>
          <target state="translated">Nombre réel d'octets écrits à l'emplacement indiqué par le paramètre <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> requires to store the resulting bytes, call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau exact qui <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> requiert pour stocker les octets obtenus, appelez le <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau maximale, appelez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet fourni par le <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement, d’une classe dérivée.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode exécute l’encodage réel.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> de l’objet qui est utilisé.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
          <target state="translated">(Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> conserverons ce substitut afin qu’il peut être combiné avec un substitut faible au début d’un appel suivant.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> ne pourra plus être en mesure de maintenir l’état, le caractère est envoyés à le <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">La version de mémoire tampon de caractères Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet ou insérer dans des mémoires tampon existantes.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version qui prend en charge les tableaux d’octets est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than the resulting number of bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> est inférieur au nombre d'octets obtenus.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">Tableau de caractères contenant le jeu de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Index du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Index auquel commencer l'écriture de la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, encode un jeu de caractères du tableau de caractères spécifié en tableau d'octets.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">Nombre réel d'octets écrits dans <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you should call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> pour stocker les octets obtenus, vous devez appeler la <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau maximale, appelez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> méthode ou la <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement, d’une classe dérivée.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode exécute l’encodage réel.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> de l’objet qui est utilisé.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
          <target state="translated">(Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> conserverons ce substitut afin qu’il peut être combiné avec un substitut faible au début d’un appel suivant.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> ne pourra plus être en mesure de maintenir l’état, le caractère est envoyés à le <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">La version de mémoire tampon de caractères Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet ou insérer dans des mémoires tampon existantes.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version qui prend en charge les tableaux d’octets est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder trois caractères d’un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> n'est pas un index valide dans <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ne possède pas une capacité suffisante entre <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> et la fin du tableau pour prendre en charge les octets obtenus.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The string containing the set of characters to encode.</source>
          <target state="translated">Chaîne contenant le jeu de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Index du premier caractère à encoder.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">Tableau d'octets destiné à contenir la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Index auquel commencer l'écriture de la séquence d'octets obtenue.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, encode un jeu de caractères de la chaîne spécifiée en tableau d'octets spécifié.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">Nombre réel d'octets écrits dans <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you should call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> pour stocker les octets obtenus, vous devez appeler la <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau maximale, appelez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> méthode ou la <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement, d’une classe dérivée.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode détermine le nombre d’octets entraînant le codage d’un jeu de caractères Unicode et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode exécute l’encodage réel.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple conversions on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs conversions sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Your app might need to encode many input characters to a code page and process the characters using multiple calls.</source>
          <target state="translated">Votre application devrez encoder le nombre de caractères d’entrée à une page de codes et traiter les caractères à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> object being used.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, compte tenu de l’état est conservé par le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> de l’objet qui est utilisé.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</source>
          <target state="translated">(Par exemple, une séquence de caractères qui inclut des paires de substitution peut se terminer par un caractère de substitution étendu.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> conserverons ce substitut afin qu’il peut être combiné avec un substitut faible au début d’un appel suivant.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> won't be able to maintain the state, so the character will be sent to the <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> ne pourra plus être en mesure de maintenir l’état, le caractère est envoyés à le <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>If your app handles string inputs, you should use the string version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated">Si votre application gère des entrées de chaîne, vous devez utiliser la version de chaîne de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The Unicode character buffer version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls using the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object or inserting into existing buffers.</source>
          <target state="translated">La version de mémoire tampon de caractères Unicode de <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec les appels multiples à l’aide de la <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet ou insérer dans des mémoires tampon existantes.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version that supports byte arrays is the best choice.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> version qui prend en charge les tableaux d’octets est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>For continuous encoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour l’encodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder une chaîne ou une plage de la chaîne, encode les caractères et affiche le nombre d’octets obtenue.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> n'est pas un index valide dans <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> ne possède pas une capacité suffisante entre <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> et la fin du tableau pour prendre en charge les octets obtenus.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre de caractères produits par le décodage d'une séquence d'octets.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Tableau d'octets contenant la séquence d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre de caractères produits par le décodage de tous les octets du tableau d'octets spécifié.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29&gt;</ph> to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29&gt;</ph> pour stocker les caractères obtenus, vous devez utiliser le <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>To calculate the maximum array size, you should use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the  <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29&gt;</ph> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29&gt;</ph> méthode effectue le décodage réel.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>In this case, you probably need to maintain state between calls.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>If your app handles string outputs, you should use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
          <target state="translated">Si votre application gère les sorties de chaîne, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <ph id="ph1">&lt;xref:System.String&gt;</ph> type est recommandée.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">La version d’octet de <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Dans ce cas, le [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</source>
          <target state="translated">L’exemple suivant encode une chaîne en un tableau d’octets, puis décode les octets en un tableau de caractères.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Pointeur du premier octet à décoder.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre de caractères produits par le décodage d'une séquence d'octets commençant au pointeur d'octet spécifié.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> requires to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau exact qui <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> requiert pour stocker les caractères obtenus, vous devez utiliser le <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, utilisez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> méthode effectue le décodage réel.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>In this case, you probably need to maintain state between calls.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>If your app handles string outputs, it is recommended to use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
          <target state="translated">Si votre application gère les sorties de chaîne, il est recommandé d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <ph id="ph1">&lt;xref:System.String&gt;</ph> type est recommandée.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">La version d’octet de <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Dans ce cas, le [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Tableau d'octets contenant la séquence d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Index du premier octet à décoder.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre de caractères produits par le décodage d'une séquence d'octets du tableau d'octets spécifié.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">Nombre de caractères produits par le décodage de la séquence d'octets spécifiée.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> pour stocker les caractères obtenus, vous devez utiliser le <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, utilisez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> méthode effectue le décodage réel.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, you probably need to maintain state between calls.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>If your app handles string outputs, it is recommended to use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
          <target state="translated">Si votre application gère les sorties de chaîne, il est recommandé d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <ph id="ph1">&lt;xref:System.String&gt;</ph> type est recommandée.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">La version d’octet de <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Dans ce cas, le [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The following example converts a string from one encoding to another.</source>
          <target state="translated">L’exemple suivant convertit une chaîne d’un encodage à un autre.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</source>
          <target state="translated">L’exemple suivant encode une chaîne en un tableau d’octets, puis décode une plage d’octets en un tableau de caractères.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>When overridden in a derived class, decodes a sequence of bytes into a set of characters.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, décode une séquence d'octets en jeu de caractères.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Tableau d'octets contenant la séquence d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, décode tous les octets du tableau d'octets spécifié en jeu de caractères.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>A character array containing the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Tableau de caractères contenant les résultats du décodage de la séquence d'octets spécifiée.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> gets characters from an input byte sequence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> Obtient les caractères à partir d’une séquence d’octets d’entrée.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> is different than <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> because <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> est différent de celui <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> car <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> attend des conversions discrètes, tandis que <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> est conçu pour plusieurs passes sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> méthode ou la <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement, d’une classe dérivée.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>Remarque<ept id="p1">**</ept> cette méthode est destinée à opérer sur des caractères Unicode, pas sur des données binaires arbitraires, tels que des tableaux d’octets.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous avez besoin d’encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> méthode effectue le décodage réel.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, étant donné que les séquences d’octets peuvent être interrompues lors du traitement par lots.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>(For example, part of an ISO-2022 shift sequence may end one <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call and continue at the beginning of the next <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call.</source>
          <target state="translated">(Par exemple, partie d’une séquence de déplacement ISO-2022 peut terminer un <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> appeler et continuer au début de la prochaine <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> appeler.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> will call the fallback for those incomplete sequences, but <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> appellera le secours pour ces séquences incomplètes, mais <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> mémorise ces séquences pour l’appel suivant.)</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>If your app handles string outputs, it is recommended to use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
          <target state="translated">Si votre application gère les sorties de chaîne, il est recommandé d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <ph id="ph1">&lt;xref:System.String&gt;</ph> type est recommandée.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">La version d’octet de <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Dans ce cas, le [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</source>
          <target state="translated">L’exemple suivant encode une chaîne en un tableau d’octets, puis décode les octets en un tableau de caractères.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Tableau d'octets contenant la séquence d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Index du premier octet à décoder.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, décode une séquence d'octets du tableau d'octets spécifié en jeu de caractères.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>A character array containing the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Tableau de caractères contenant les résultats du décodage de la séquence d'octets spécifiée.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> gets characters from an input byte sequence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> Obtient les caractères à partir d’une séquence d’octets d’entrée.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> is different than <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> because <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> est différent de celui <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> car <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> attend des conversions discrètes, tandis que <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> est conçu pour plusieurs passes sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> méthode ou la <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement, d’une classe dérivée.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>Remarque<ept id="p1">**</ept> cette méthode est destinée à opérer sur des caractères Unicode, pas sur des données binaires arbitraires, tels que des tableaux d’octets.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous avez besoin d’encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> méthode effectue le décodage réel.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, étant donné que les séquences d’octets peuvent être interrompues lors du traitement par lots.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>(For example, part of an ISO-2022 shift sequence may end one <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call and continue at the beginning of the next <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call.</source>
          <target state="translated">(Par exemple, partie d’une séquence de déplacement ISO-2022 peut terminer un <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> appeler et continuer au début de la prochaine <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> appeler.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> will call the fallback for those incomplete sequences, but <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> appellera le secours pour ces séquences incomplètes, mais <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> mémorise ces séquences pour l’appel suivant.)</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>If your app handles string outputs, it is recommended to use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method.</source>
          <target state="translated">Si votre application gère les sorties de chaîne, il est recommandé d’utiliser le <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <ph id="ph1">&lt;xref:System.String&gt;</ph> type est recommandée.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">La version d’octet de <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Dans ce cas, le [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</source>
          <target state="translated">L’exemple suivant encode une chaîne en un tableau d’octets, puis décode une plage d’octets en un tableau de caractères.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Pointeur du premier octet à décoder.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting set of characters.</source>
          <target state="translated">Pointeur de l'emplacement où commencer l'écriture du jeu de caractères obtenu.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The maximum number of characters to write.</source>
          <target state="translated">Nombre maximal de caractères à écrire.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, décode une séquence d'octets commençant au pointeur d'octet spécifié en jeu de caractères stockés à partir du pointeur de caractère spécifié.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The actual number of characters written at the location indicated by the <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> parameter.</source>
          <target state="translated">Nombre réel de caractères écrits à l'emplacement indiqué par le paramètre <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the exact array size that <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> requires to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille de tableau exact qui <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> requiert pour stocker les caractères obtenus, vous devez utiliser le <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, utilisez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> gets characters from an input byte sequence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> Obtient les caractères à partir d’une séquence d’octets d’entrée.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> is different than <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> because <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> est différent de celui <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> car <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> attend des conversions discrètes, tandis que <ph id="ph4">&lt;xref:System.Text.Decoder&gt;</ph> est conçu pour plusieurs passes sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objet fourni par le <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement, d’une classe dérivée.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>Remarque<ept id="p1">**</ept> cette méthode est destinée à opérer sur des caractères Unicode, pas sur des données binaires arbitraires, tels que des tableaux d’octets.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous avez besoin d’encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> méthode effectue le décodage réel.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, étant donné que les séquences d’octets peuvent être interrompues lors du traitement par lots.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>(For example, part of an ISO-2022 shift sequence may end one <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call and continue at the beginning of the next <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> call.</source>
          <target state="translated">(Par exemple, partie d’une séquence de déplacement ISO-2022 peut terminer un <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> appeler et continuer au début de la prochaine <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> appeler.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> will call the fallback for those incomplete sequences, but <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> appellera le secours pour ces séquences incomplètes, mais <ph id="ph2">&lt;xref:System.Text.Decoder&gt;</ph> mémorise ces séquences pour l’appel suivant.)</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If your app handles string outputs, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method is recommended.</source>
          <target state="translated">Si votre application gère les sorties de chaîne, la <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> méthode est recommandée.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <ph id="ph1">&lt;xref:System.String&gt;</ph> type est recommandée.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">La version d’octet de <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Dans ce cas, le [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than the resulting number of characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> est inférieur au nombre de caractères obtenus.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiert une confiance totale pour l’appelant immédiat.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Tableau d'octets contenant la séquence d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Index du premier octet à décoder.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The character array to contain the resulting set of characters.</source>
          <target state="translated">Tableau de caractères destiné à contenir le jeu de caractères obtenu.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index at which to start writing the resulting set of characters.</source>
          <target state="translated">Index auquel commencer l'écriture du jeu de caractères obtenu.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, décode une séquence d'octets du tableau d'octets spécifié en tableau de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The actual number of characters written into <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated">Nombre réel de caractères écrits dans <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> pour stocker les caractères obtenus, vous devez utiliser le <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, utilisez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt; gets characters from an input byte sequence.</source>
          <target state="translated">[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType &gt; Obtient des caractères d’une séquence d’octets d’entrée.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt; is different than <ph id="ph3">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> because <ph id="ph4">&lt;xref:System.Text.Encoding&gt;</ph> expects discrete conversions, while <ph id="ph5">&lt;xref:System.Text.Decoder&gt;</ph> is designed for multiple passes on a single input stream.</source>
          <target state="translated">[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType &gt; est différente de celle <ph id="ph3">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> car <ph id="ph4">&lt;xref:System.Text.Encoding&gt;</ph> attend des conversions discrètes, tandis que <ph id="ph5">&lt;xref:System.Text.Decoder&gt;</ph> est conçu pour plusieurs passes sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> méthode ou la <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement, d’une classe dérivée.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>Remarque<ept id="p1">**</ept> cette méthode est destinée à opérer sur des caractères Unicode, pas sur des données binaires arbitraires, tels que des tableaux d’octets.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si vous avez besoin d’encoder des données arbitraires en texte, vous devez utiliser un protocole tel qu’uuencode, qui est implémentée par les méthodes telles que <ph id="ph1">&lt;xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method performs the actual decoding.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> méthode détermine le nombre de caractères entraînant le décodage d’une séquence d’octets et la <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> méthode effectue le décodage réel.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> method expects discrete conversions, in contrast to the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method, which handles multiple passes on a single input stream.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> méthode attend des conversions discrètes, par contraste avec le <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui gère plusieurs passes sur un flux d’entrée unique.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Several versions of <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> are supported.</source>
          <target state="translated">Plusieurs versions de <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> sont pris en charge.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The following are some programming considerations for use of these methods:</source>
          <target state="translated">Voici quelques considérations sur la programmation pour l’utilisation de ces méthodes :</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</source>
          <target state="translated">Votre application deviez décoder plusieurs octets d’entrée à partir d’une page de codes et traiter les octets à l’aide de plusieurs appels.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</source>
          <target state="translated">Dans ce cas, vous devrez probablement mettre à jour d’état entre les appels, étant donné que les séquences d’octets peuvent être interrompues lors du traitement par lots.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>(For example, part of an ISO-2022 shift sequence may end one [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A&gt; call and continue at the beginning of the next [<ph id="ph3">\]</ph>, Int32, Int32, Char<ph id="ph4">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A&gt; call.</source>
          <target state="translated">(Par exemple, partie d’une séquence de déplacement ISO-2022 peut terminer une [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A &gt; appelez et continuer au début de la prochaine [<ph id="ph3">\]</ph>, Int32, Int32, Char<ph id="ph4">\&lt;</ph>référence croisée : System.Text.Encoding.GetChars%2A &gt; appeler.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt; will call the fallback for those incomplete sequences, but <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> will remember those sequences for the next call.)</source>
          <target state="translated">[<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType &gt; appellera le secours pour ces séquences incomplètes, mais <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> mémorise ces séquences pour l’appel suivant.)</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If your app handles string outputs, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method is recommended.</source>
          <target state="translated">Si votre application gère les sorties de chaîne, la <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> méthode est recommandée.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <ph id="ph1">&lt;xref:System.String&gt;</ph> type is to be preferred.</source>
          <target state="translated">Étant donné que cette méthode doit vérifier la longueur de chaîne et allouer une mémoire tampon, il est légèrement plus lente, mais résultant <ph id="ph1">&lt;xref:System.String&gt;</ph> type est recommandée.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The byte version of <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> allows some fast techniques, particularly with multiple calls to large buffers.</source>
          <target state="translated">La version d’octet de <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29&gt;</ph> autorise certaines techniques rapides, en particulier avec plusieurs appels à des tampons de grande taille.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</source>
          <target state="translated">N’oubliez pas, toutefois, que cette version de la méthode est parfois dangereuse, étant donné que les pointeurs sont nécessaires.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If your app must convert a large amount of data, it should reuse the output buffer.</source>
          <target state="translated">Si votre application doit convertir une grande quantité de données, elle doit réutiliser la mémoire tampon de sortie.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>In this case, the [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29&gt; version that supports output character buffers is the best choice.</source>
          <target state="translated">Dans ce cas, le [<ph id="ph1">\]</ph>, Int32, Int32, Char<ph id="ph2">\&lt;</ph>xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 &gt; version qui prend en charge les caractères de sortie mémoires tampons est le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Consider using the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method instead of <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</source>
          <target state="translated">Envisagez d’utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> méthode à la place de <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</source>
          <target state="translated">La méthode de conversion convertit autant de données que possible et lève une exception si la mémoire tampon de sortie est trop petit.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>For continuous decoding of a stream, this method is often the best choice.</source>
          <target state="translated">Pour le décodage d’un flux continu, cette méthode est souvent le meilleur choix.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The following example converts a string from one encoding to another.</source>
          <target state="translated">L’exemple suivant convertit une chaîne d’un encodage à un autre.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</source>
          <target state="translated">L’exemple suivant encode une chaîne en un tableau d’octets, puis décode une plage d’octets en un tableau de caractères.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> ou <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> et <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> n'est pas un index valide dans <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> to the end of the array to accommodate the resulting characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> ne possède pas une capacité suffisante entre <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> et la fin du tableau pour prendre en charge les caractères obtenus.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetDecoder">
          <source>When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient un décodeur qui convertit une séquence d'octets encodée en séquence de caractères.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetDecoder">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> that converts an encoded sequence of bytes into a sequence of characters.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> qui convertit une séquence d'octets encodée en une séquence de caractères.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> method of this class.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> méthode convertit des blocs d’octets en blocs séquentiels de caractères, d’une manière similaire à la <ph id="ph2">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> méthode de cette classe.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetDecoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> maintains state information between calls so it correctly decodes byte sequences that span blocks.</source>
          <target state="translated">Toutefois, un <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> conserve les informations d’état entre les appels, de sorte qu’il peut décoder les séquences d’octets qui s’étendent sur des blocs.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> également conserve les octets de fin à la fin des blocs de données et les octets de fin dans la prochaine opération de décodage.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetDecoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Par conséquent, <ph id="ph1">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetDecoder">
          <source>The default implementation returns a <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> that calls the <ph id="ph2">&lt;see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /&gt;</ph> and <ph id="ph3">&lt;see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /&gt;</ph> methods of the current <ph id="ph4">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">L’implémentation par défaut retourne un <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> qui appelle le <ph id="ph2">&lt;see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /&gt;</ph> et <ph id="ph3">&lt;see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /&gt;</ph> méthodes actuelles <ph id="ph4">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetDecoder">
          <source>You must override this method to return a <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> that maintains its state between calls.</source>
          <target state="translated">Vous devez substituer cette méthode pour retourner un <ph id="ph1">&lt;see cref="T:System.Text.Decoder" /&gt;</ph> qui conserve son état entre les appels.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoder">
          <source>When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient un encodeur qui convertit une séquence de caractères Unicode en séquence d'octets encodée.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoder">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> that converts a sequence of Unicode characters into an encoded sequence of bytes.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> qui convertit une séquence de caractères Unicode en une séquence d'octets encodée.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> method of this class.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> méthode convertit des blocs de caractères en blocs séquentiels d’octets, d’une manière similaire à la <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> méthode de cette classe.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> maintains state information between calls so it correctly encodes character sequences that span blocks.</source>
          <target state="translated">Toutefois, un <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> conserve les informations d’état entre les appels et il encode correctement les séquences de caractères qui s’étendent sur des blocs.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> également conserve à la fin des caractères à la fin des blocs de données et utilise les caractères de fin dans la prochaine opération de codage.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</source>
          <target state="translated">Par exemple, un bloc de données peut se terminer par un substitut étendu non apparié, et le substitut faible correspondant peut être dans le bloc de données suivant.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Par conséquent, <ph id="ph1">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> sont utiles pour la transmission réseau et les opérations de fichiers, car celles-ci traitent souvent des blocs de données au lieu d’un flux de données complète.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>The default implementation returns a <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> that calls the <ph id="ph2">&lt;see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /&gt;</ph> and <ph id="ph3">&lt;see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /&gt;</ph> methods of the current <ph id="ph4">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">L’implémentation par défaut retourne un <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> qui appelle le <ph id="ph2">&lt;see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /&gt;</ph> et <ph id="ph3">&lt;see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /&gt;</ph> méthodes actuelles <ph id="ph4">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoder">
          <source>You must override this method to return a <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> that maintains its state between calls.</source>
          <target state="translated">Vous devez substituer cette méthode pour retourner un <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> qui conserve son état entre les appels.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>Returns an encoding for the specified code page.</source>
          <target state="translated">Retourne un encodage pour la page de codes spécifiée.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>The code page identifier of the preferred encoding.</source>
          <target state="translated">Identificateur de la page de codes de l'encodage préféré.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Possible values are listed in the Code Page column of the table that appears in the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class topic.</source>
          <target state="translated">Les valeurs possibles apparaissent dans la colonne Page de codes de la table qui s'affiche dans la rubrique de la classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>0 (zero), to use the default encoding.</source>
          <target state="translated">0 (zéro) pour utiliser l'encodage par défaut.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Returns the encoding associated with the specified code page identifier.</source>
          <target state="translated">Retourne l'encodage associé à l'identificateur de page de codes spécifié.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>The encoding that is associated with the specified code page.</source>
          <target state="translated">Encodage associé à la page de codes spécifiée.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>The fallback handler depends on the encoding type of <ph id="ph1">`codepage`</ph>.</source>
          <target state="translated">Le Gestionnaire de secours varie selon le type de codage <ph id="ph1">`codepage`</ph>.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>If <ph id="ph1">`codepage`</ph> is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</source>
          <target state="translated">Si <ph id="ph1">`codepage`</ph> est le jeu de caractères code page ou sur deux octets (DBCS) encodage, un gestionnaire de secours la mieux adapté est utilisé.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Otherwise, a replacement fallback handler is used.</source>
          <target state="translated">Sinon, un gestionnaire de secours de remplacement est utilisé.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>These fallback handlers may not be appropriate for your app.</source>
          <target state="translated">Ces gestionnaires de secours n’est peut-être pas appropriés pour votre application.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>To specify the fallback handler used by the encoding specified by <ph id="ph1">`codepage`</ph>, you can call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> overload.</source>
          <target state="translated">Pour spécifier le Gestionnaire de secours utilisé par l’encodage spécifié par <ph id="ph1">`codepage`</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> de surcharge.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method relies on the underlying platform to support most code pages.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> méthode s’appuie sur la plateforme sous-jacente pour prendre en charge la plupart des pages de codes.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>However, the .NET Framework natively supports some encodings.</source>
          <target state="translated">Toutefois, le .NET Framework prend en charge certains encodages en mode natif.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>For a list of code pages, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
          <target state="translated">Pour obtenir la liste des pages de codes, consultez la <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> rubrique de la classe.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Alternatively, you can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method to get an array of <ph id="ph2">&lt;xref:System.Text.EncodingInfo&gt;</ph> objects that contains information about all encodings.</source>
          <target state="translated">Vous pouvez également appeler le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> méthode pour obtenir un tableau de <ph id="ph2">&lt;xref:System.Text.EncodingInfo&gt;</ph> objets qui contient des informations sur tous les encodages.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method returns any additional encodings that are made available by registering an <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.</source>
          <target state="translated">Outre les encodages pris en charge intrinsèquement sur une version de plateforme spécifique du .NET Framework, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> méthode retourne les encodages supplémentaires qui sont rendues disponibles par l’inscription d’un <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>If the same encoding has been registered by multiple <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objects, this method returns the last one registered.</source>
          <target state="translated">Si le même que celui qui a été enregistré par plusieurs <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> des objets, cette méthode retourne la dernière inscrit.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>You can also supply a value of 0 for the <ph id="ph1">`codepage`</ph> argument.</source>
          <target state="translated">Vous pouvez également fournir une valeur de 0 pour le <ph id="ph1">`codepage`</ph> argument.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Its precise behavior depends on whether any encodings have been made available by registering an <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> object:</source>
          <target state="translated">Son comportement précis dépend si les encodages rendues disponibles en inscrivant un <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objet :</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method is passed a <ph id="ph2">`codepage`</ph> argument of 0.</source>
          <target state="translated">Si un ou plusieurs fournisseurs de codage ont été inscrite, elle retourne l’encodage du dernier fournisseur inscrit a choisi de retourner d’encodage lorsque le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> méthode est passée un <ph id="ph2">`codepage`</ph> l’argument 0.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>On the .NET Framework, if no encoding provider has been registered, if the <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph> is the registered encoding provider, or if no registered encoding provider handles a <ph id="ph2">`codepage`</ph> value of 0, it returns the operating system's active code page.</source>
          <target state="translated">Sur le .NET Framework, si aucun encodage fournisseur a été enregistré, si le <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph> est le fournisseur d’encodage enregistré, ou si aucun fournisseur d’encodage inscrit ne gère un <ph id="ph2">`codepage`</ph> valeur égale à 0, elle retourne la page de codes active le système d’exploitation.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>To determine the active code page on Windows systems, call the Windows <bpt id="p1">[</bpt>GetACP<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)</ept> function from the .NET Framework on the Windows desktop.</source>
          <target state="translated">Pour déterminer la page de codes active sur les systèmes Windows, appelez Windows <bpt id="p1">[</bpt>GetACP<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)</ept> (fonction) du .NET Framework sur le bureau Windows.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a <ph id="ph1">`codepage`</ph> value of 0, it returns the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph>.</source>
          <target state="translated">Sur .NET Core, si aucun fournisseur d’encodage n’a pas été inscrit ou si aucun fournisseur d’encodage inscrit ne gère un <ph id="ph1">`codepage`</ph> valeur égale à 0, elle retourne le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Some unsupported code pages cause an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> to be thrown, whereas others cause a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Du code non pris en charge des pages cause une <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> levée, alors que d’autres provoquent un <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>Therefore, your code must catch all exceptions indicated in the Exceptions section.</source>
          <target state="translated">Par conséquent, votre code doit intercepter toutes les exceptions répertoriées dans la section Exceptions.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</source>
          <target state="translated">Les pages de codes ANSI peuvent être différents sur des ordinateurs différents et peuvent changer à un seul ordinateur, entraînant une altération des données.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by <ph id="ph1">`Encoding.GetEncoding(0)`</ph> is not recommended.</source>
          <target state="translated">Pour cette raison, si la page de codes active est une page de codes ANSI, codage et décodage des données à l’aide de la page de codes par défaut retournée par <ph id="ph1">`Encoding.GetEncoding(0)`</ph> n’est pas recommandée.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</source>
          <target state="translated">Pour obtenir des résultats plus cohérents, vous devez utiliser un encodage Unicode, tel que UTF-8 (page de codes 65001) ou UTF-16, au lieu d’une page de codes spécifique.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> Retourne une instance mise en cache avec les paramètres par défaut.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>You should use the constructors of derived classes to get an instance with different settings.</source>
          <target state="translated">Vous devez utiliser les constructeurs de classes dérivées pour obtenir une instance avec des paramètres différents.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.</source>
          <target state="translated">Par exemple, la <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> classe fournit un constructeur qui vous permet d’activer la détection d’erreurs.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source>The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</source>
          <target state="translated">L’exemple suivant obtient deux instances du même encodage (une par page de codes) et une autre par nom et vérifie leur égalité.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> is less than zero or greater than 65535.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> est inférieur à 0 ou supérieur à 65535.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> is not supported by the underlying platform.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> n'est pas pris en charge par la plateforme sous-jacente.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> is not supported by the underlying platform.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> n'est pas pris en charge par la plateforme sous-jacente.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The code page name of the preferred encoding.</source>
          <target state="translated">Nom de la page de codes de l'encodage préféré.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>Any value returned by the <ph id="ph1">&lt;see cref="P:System.Text.Encoding.WebName" /&gt;</ph> property is valid.</source>
          <target state="translated">Toute valeur retournée par la propriété <ph id="ph1">&lt;see cref="P:System.Text.Encoding.WebName" /&gt;</ph> est valide.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>Possible values are listed in the Name column of the table that appears in the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class topic.</source>
          <target state="translated">Les valeurs possibles apparaissent dans la colonne Nom de la table qui s'affiche dans la rubrique de la classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>Returns the encoding associated with the specified code page name.</source>
          <target state="translated">Retourne l'encodage associé au nom de la page de codes spécifiée.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The encoding  associated with the specified code page.</source>
          <target state="translated">Encodage associé à la page de codes spécifiée.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The fallback handler depends on the encoding type of <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Le Gestionnaire de secours varie selon le type de codage <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>If <ph id="ph1">`name`</ph> is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</source>
          <target state="translated">Si <ph id="ph1">`name`</ph> est le jeu de caractères code page ou sur deux octets (DBCS) encodage, un gestionnaire de secours la mieux adapté est utilisé.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>Otherwise, a replacement fallback handler is used.</source>
          <target state="translated">Sinon, un gestionnaire de secours de remplacement est utilisé.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>These fallback handlers may not be appropriate for your app.</source>
          <target state="translated">Ces gestionnaires de secours n’est peut-être pas appropriés pour votre application.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>To specify the fallback handler used by the encoding specified by <ph id="ph1">`name`</ph>, you can call the <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> overload.</source>
          <target state="translated">Pour spécifier le Gestionnaire de secours utilisé par l’encodage spécifié par <ph id="ph1">`name`</ph>, vous pouvez appeler la <ph id="ph2">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29&gt;</ph> de surcharge.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method relies on the underlying platform to support most code pages.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> méthode s’appuie sur la plateforme sous-jacente pour prendre en charge la plupart des pages de codes.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>However, the .NET Framework natively supports some encodings.</source>
          <target state="translated">Toutefois, le .NET Framework prend en charge certains encodages en mode natif.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>For a list of code pages, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
          <target state="translated">Pour obtenir la liste des pages de codes, consultez la <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> rubrique de la classe.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>Alternatively, you can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method to get an array of <ph id="ph2">&lt;xref:System.Text.EncodingInfo&gt;</ph> objects that contains information about all encodings.</source>
          <target state="translated">Vous pouvez également appeler le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> méthode pour obtenir un tableau de <ph id="ph2">&lt;xref:System.Text.EncodingInfo&gt;</ph> objets qui contient des informations sur tous les encodages.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method returns any additional encodings that are made available by registering an <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.</source>
          <target state="translated">Outre les encodages pris en charge intrinsèquement sur une version de plateforme spécifique du .NET Framework, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> méthode retourne les encodages supplémentaires qui sont rendues disponibles par l’inscription d’un <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>If the same encoding has been registered by multiple <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objects, this method returns the last one registered.</source>
          <target state="translated">Si le même que celui qui a été enregistré par plusieurs <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> des objets, cette méthode retourne la dernière inscrit.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.</source>
          <target state="translated">Les pages de codes ANSI peuvent être différentes sur des ordinateurs différents, ou peuvent être modifiées pour un seul ordinateur, entraînant une altération des données.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</source>
          <target state="translated">Pour obtenir des résultats plus cohérents, vous devez utiliser Unicode, tel que UTF-8 (page de codes 65001) ou UTF-16, au lieu d’une page de codes spécifique.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> Retourne une instance mise en cache avec les paramètres par défaut.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>You should use the constructors of derived classes to get an instance with different settings.</source>
          <target state="translated">Vous devez utiliser les constructeurs de classes dérivées pour obtenir une instance avec des paramètres différents.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.</source>
          <target state="translated">Par exemple, la <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> classe fournit un constructeur qui vous permet d’activer la détection d’erreurs.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</source>
          <target state="translated">L’exemple suivant obtient deux instances du même encodage (une par page de codes) et une autre par nom et vérifie leur égalité.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid code page name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> n'est pas un nom de page de codes valide.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String)">
          <source>The code page indicated by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not supported by the underlying platform.</source>
          <target state="translated">La page de codes indiquée par <ph id="ph1">&lt;paramref name="name" /&gt;</ph> n'est pas prise en charge par la plateforme sous-jacente.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The code page identifier of the preferred encoding.</source>
          <target state="translated">Identificateur de la page de codes de l'encodage préféré.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Possible values are listed in the Code Page column of the table that appears in the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class topic.</source>
          <target state="translated">Les valeurs possibles apparaissent dans la colonne Page de codes de la table qui s'affiche dans la rubrique de la classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>0 (zero), to use the default encoding.</source>
          <target state="translated">0 (zéro) pour utiliser l'encodage par défaut.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</source>
          <target state="translated">Objet qui fournit une procédure de gestion d'erreurs quand un caractère ne peut pas être encodé avec l'encodage actuel.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</source>
          <target state="translated">Objet qui fournit une procédure de gestion d'erreurs quand une séquence d'octets ne peut pas être décodée avec l'encodage actuel.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Returns the encoding associated with the specified code page identifier.</source>
          <target state="translated">Retourne l'encodage associé à l'identificateur de page de codes spécifié.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</source>
          <target state="translated">Les paramètres spécifient un gestionnaire d'erreurs pour les caractères qui ne peuvent pas être encodés et pour les séquences d'octets qui ne peuvent pas être décodées.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The encoding that is associated with the specified code page.</source>
          <target state="translated">Encodage associé à la page de codes spécifiée.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Some unsupported code pages cause the exception <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> to be thrown, whereas others cause <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Certaines pages de codes non prise en charge de provoquer l’exception <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> levée, alors que d’autres provoquent <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Therefore, your code must catch all exceptions indicated in the Exceptions section.</source>
          <target state="translated">Par conséquent, votre code doit intercepter toutes les exceptions répertoriées dans la section Exceptions.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method relies on the underlying platform to support most code pages.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> méthode s’appuie sur la plateforme sous-jacente pour prendre en charge la plupart des pages de codes.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>However, the .NET Framework natively supports some encodings.</source>
          <target state="translated">Toutefois, le .NET Framework prend en charge certains encodages en mode natif.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For a list of code pages, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
          <target state="translated">Pour obtenir la liste des pages de codes, consultez la <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> rubrique de la classe.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method in the full .NET Framework on the Windows desktop to get a list of all encodings.</source>
          <target state="translated">Vous pouvez appeler la <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> méthode dans le .NET Framework complet sur le bureau Windows pour obtenir une liste de tous les encodages.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method returns any additional encodings that are made available by registering an <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.</source>
          <target state="translated">Outre les encodages pris en charge intrinsèquement sur une version de plateforme spécifique du .NET Framework, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> méthode retourne les encodages supplémentaires qui sont rendues disponibles par l’inscription d’un <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>If the same encoding has been registered by multiple <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objects, this method returns the last one registered.</source>
          <target state="translated">Si le même que celui qui a été enregistré par plusieurs <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> des objets, cette méthode retourne la dernière inscrit.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>You can also supply a value of 0 for the <ph id="ph1">`codepage`</ph> argument.</source>
          <target state="translated">Vous pouvez également fournir une valeur de 0 pour le <ph id="ph1">`codepage`</ph> argument.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Its precise behavior depends on whether any encodings have been made available by registering an <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> object:</source>
          <target state="translated">Son comportement précis dépend si les encodages rendues disponibles en inscrivant un <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objet :</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method is passed a <ph id="ph2">`codepage`</ph> argument of 0.</source>
          <target state="translated">Si un ou plusieurs fournisseurs de codage ont été inscrite, elle retourne l’encodage du dernier fournisseur inscrit a choisi de retourner d’encodage lorsque le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> méthode est passée un <ph id="ph2">`codepage`</ph> l’argument 0.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>On the .NET Framework, if no encoding provider has been registered, if the <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph> is the registered encoding provider, or if no registered encoding provider handles a <ph id="ph2">`codepage`</ph> value of 0, it returns the active code page.</source>
          <target state="translated">Sur le .NET Framework, si aucun encodage fournisseur a été enregistré, si le <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph> est le fournisseur d’encodage enregistré, ou si aucun fournisseur d’encodage inscrit ne gère un <ph id="ph2">`codepage`</ph> valeur égale à 0, elle retourne la page de codes active.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a <ph id="ph1">`codepage`</ph> value of 0, it returns the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> encoding.</source>
          <target state="translated">Sur .NET Core, si aucun fournisseur d’encodage n’a pas été inscrit ou si aucun fournisseur d’encodage inscrit ne gère un <ph id="ph1">`codepage`</ph> valeur égale à 0, elle retourne le <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> encodage.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</source>
          <target state="translated">Les pages de codes ANSI peuvent être différents sur des ordinateurs différents et peuvent changer à un seul ordinateur, entraînant une altération des données.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by <ph id="ph1">`Encoding.GetEncoding(0)`</ph> is not recommended.</source>
          <target state="translated">Pour cette raison, si la page de codes active est une page de codes ANSI, codage et décodage des données à l’aide de la page de codes par défaut retournée par <ph id="ph1">`Encoding.GetEncoding(0)`</ph> n’est pas recommandée.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</source>
          <target state="translated">Pour obtenir des résultats plus cohérents, vous devez utiliser Unicode, tel que UTF-8 (page de codes 65001) ou UTF-16, au lieu d’une page de codes spécifique.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>To get the encoding associated with the active code page, you can either supply a value of 0 for the <ph id="ph1">`codepage`</ph> argument or, if your code is running on the full .NET Framework on the Windows desktop, retrieve the value of the <ph id="ph2">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Pour obtenir l’encodage associé à la page de codes active, vous pouvez soit fournir une valeur de 0 pour le <ph id="ph1">`codepage`</ph> argument ou, si votre code s’exécute sur le .NET Framework complet sur le bureau Windows, récupérer la valeur de la <ph id="ph2">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>To determine the current active code page, call the Windows <bpt id="p1">[</bpt>GetACP<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)</ept> function from the .NET Framework on the Windows desktop.</source>
          <target state="translated">Pour déterminer la page de codes active en cours, appelez Windows <bpt id="p1">[</bpt>GetACP<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)</ept> (fonction) du .NET Framework sur le bureau Windows.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> Retourne une instance mise en cache avec les paramètres par défaut.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>You should use the constructors of derived classes to get an instance with different settings.</source>
          <target state="translated">Vous devez utiliser les constructeurs de classes dérivées pour obtenir une instance avec des paramètres différents.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.</source>
          <target state="translated">Par exemple, la <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> classe fournit un constructeur qui vous permet d’activer la détection d’erreurs.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant illustre la <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> is less than zero or greater than 65535.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> est inférieur à 0 ou supérieur à 65535.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> is not supported by the underlying platform.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> n'est pas pris en charge par la plateforme sous-jacente.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> is not supported by the underlying platform.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="codepage" /&gt;</ph> n'est pas pris en charge par la plateforme sous-jacente.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The code page name of the preferred encoding.</source>
          <target state="translated">Nom de la page de codes de l'encodage préféré.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Any value returned by the <ph id="ph1">&lt;see cref="P:System.Text.Encoding.WebName" /&gt;</ph> property is valid.</source>
          <target state="translated">Toute valeur retournée par la propriété <ph id="ph1">&lt;see cref="P:System.Text.Encoding.WebName" /&gt;</ph> est valide.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Possible values are listed in the Name column of the table that appears in the <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> class topic.</source>
          <target state="translated">Les valeurs possibles apparaissent dans la colonne Nom de la table qui s'affiche dans la rubrique de la classe <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</source>
          <target state="translated">Objet qui fournit une procédure de gestion d'erreurs quand un caractère ne peut pas être encodé avec l'encodage actuel.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</source>
          <target state="translated">Objet qui fournit une procédure de gestion d'erreurs quand une séquence d'octets ne peut pas être décodée avec l'encodage actuel.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Returns the encoding associated with the specified code page name.</source>
          <target state="translated">Retourne l'encodage associé au nom de la page de codes spécifiée.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</source>
          <target state="translated">Les paramètres spécifient un gestionnaire d'erreurs pour les caractères qui ne peuvent pas être encodés et pour les séquences d'octets qui ne peuvent pas être décodées.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The encoding that is associated with the specified code page.</source>
          <target state="translated">Encodage associé à la page de codes spécifiée.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method relies on the underlying platform to support most code pages.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> méthode s’appuie sur la plateforme sous-jacente pour prendre en charge la plupart des pages de codes.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>However, the .NET Framework natively supports some encodings.</source>
          <target state="translated">Toutefois, le .NET Framework prend en charge certains encodages en mode natif.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method returns any additional encodings that are made available by registering an <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> object.</source>
          <target state="translated">Outre les encodages pris en charge intrinsèquement sur une version de plateforme spécifique du .NET Framework, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> méthode retourne les encodages supplémentaires qui sont rendues disponibles par l’inscription d’un <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>If the same encoding has been registered by multiple <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> objects, this method returns the last one registered.</source>
          <target state="translated">Si le même que celui qui a été enregistré par plusieurs <ph id="ph1">&lt;xref:System.Text.EncodingProvider&gt;</ph> des objets, cette méthode retourne la dernière inscrit.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</source>
          <target state="translated">Les pages de codes ANSI peuvent être différents sur des ordinateurs différents et peuvent changer à un seul ordinateur, entraînant une altération des données.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</source>
          <target state="translated">Pour obtenir des résultats plus cohérents, vous devez utiliser un encodage Unicode, tel que UTF-8 (page de codes 65001) ou UTF-16, au lieu d’une page de codes spécifique.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For a list of code pages, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
          <target state="translated">Pour obtenir la liste des pages de codes, consultez la <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> rubrique de la classe.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method on the full .NET Framework on the Windows desktop to get a list of all encodings.</source>
          <target state="translated">Vous pouvez appeler la <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> méthode sur le .NET Framework complet sur le bureau Windows pour obtenir une liste de tous les encodages.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> returns a cached instance with default settings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> Retourne une instance mise en cache avec les paramètres par défaut.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>You should use the constructors of derived classes to get an instance with different settings.</source>
          <target state="translated">Vous devez utiliser les constructeurs de classes dérivées pour obtenir une instance avec des paramètres différents.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>For example, the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class provides a constructor that lets you enable error detection.</source>
          <target state="translated">Par exemple, la <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> classe fournit un constructeur qui vous permet d’activer la détection d’erreurs.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant illustre la <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not a valid code page name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> n'est pas un nom de page de codes valide.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
          <source>The code page indicated by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is not supported by the underlying platform.</source>
          <target state="translated">La page de codes indiquée par <ph id="ph1">&lt;paramref name="name" /&gt;</ph> n'est pas prise en charge par la plateforme sous-jacente.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncodings">
          <source>Returns an array that contains all encodings.</source>
          <target state="translated">Retourne un tableau qui contient tous les encodages.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetEncodings">
          <source>An array that contains all encodings.</source>
          <target state="translated">Tableau qui contient tous les encodages.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>This method returns a list of supported encodings, uniquely distinguished by code page.</source>
          <target state="translated">Cette méthode retourne une liste de codages pris en charge, que se différencient uniquement par la page de codes.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>For a table that lists the supported encodings, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
          <target state="translated">Pour une table qui répertorie les encodages pris en charge, consultez le <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> rubrique de la classe.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>The list of supported encodings returned by the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> method does not include any additional encodings made available by any <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> implementations that were registered by calls to the <ph id="ph3">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method.</source>
          <target state="translated">La liste de codages pris en charge retournée par le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> méthode n’inclut pas les encodages supplémentaires mises à disposition par les <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> implémentations qui ont été enregistrées par les appels à la <ph id="ph3">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>Encodings 50220 and 50222 are both associated with the name "iso-2022-jp", but they are not identical.</source>
          <target state="translated">Les encodages 50220 et 50222 sont associés le nom « iso-2022-jp », mais ils ne sont pas identiques.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters.</source>
          <target state="translated">Encodage 50220 convertit les caractères Katakana en caractères demi-chasse en caractères Katakana en caractères pleine chasse, tandis que l’encodage 50222 utilise une séquence de shift-in/shift-out pour encoder les caractères Katakana en caractères demi-chasse.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>The display name for encoding 50222 is "Japanese (JIS-Allow 1 byte Kana - SO/SI)" to distinguish it from encoding 50220, which has the display name "Japanese (JIS)".</source>
          <target state="translated">Le nom d’affichage pour l’encodage 50222 est « japonais (JIS-autorise Kana 1 octet - donc / SI) » pour le distinguer de l’encodage 50220 dont l’affichage de la nommer « japonais (JIS) ».</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>If you request the encoding name "iso-2022-jp", the .NET Framework returns encoding 50220.</source>
          <target state="translated">Si vous demandez le codage nom « iso-2022-jp », le .NET Framework retourne l’encodage 50220.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.</source>
          <target state="translated">Toutefois, l’encodage est appropriée pour votre application dépend du traitement préféré des caractères Katakana à demi-chasse.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>To get a specific encoding, you should use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method.</source>
          <target state="translated">Pour obtenir un encodage spécifique, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> is sometimes used to present the user with a list of encodings in a File <bpt id="p1">**</bpt>Save as<ept id="p1">**</ept> dialog box.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A&gt;</ph> est parfois utilisé pour présenter une liste d’encodages dans un fichier de l’utilisateur <bpt id="p1">**</bpt>enregistrer en tant que<ept id="p1">**</ept> boîte de dialogue.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>However, many non-Unicode encodings are either incomplete and translate many characters to "?", or have subtly different behavior on different platforms.</source>
          <target state="translated">Cependant, plusieurs encodages non-Unicode sont incomplets et traduire le nombre de caractères à « ? », ou ont un comportement légèrement différent sur différentes plateformes.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>Consider using UTF-8 or UTF-16 as the default.</source>
          <target state="translated">Envisagez d’utiliser UTF-8 ou UTF-16 en tant que la valeur par défaut.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetEncodings">
          <source>The following example checks the values of the Boolean properties of each encoding.</source>
          <target state="translated">L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetHashCode">
          <source>Returns the hash code for the current instance.</source>
          <target state="translated">Retourne le code de hachage pour l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetHashCode">
          <source>The hash code for the current instance.</source>
          <target state="translated">Code de hachage de l'instance actuelle.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Nombre de caractères à encoder.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>The maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">Nombre maximal d'octets produits par l'encodage du nombre de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>The <ph id="ph1">`charCount`</ph> parameter actually specifies the number of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects that represent the Unicode characters to encode, because the .NET Framework internally uses UTF-16 to represent Unicode characters.</source>
          <target state="translated">Le <ph id="ph1">`charCount`</ph> paramètre spécifie le nombre de <ph id="ph2">&lt;xref:System.Char&gt;</ph> objets qui représentent les caractères Unicode à encoder, car le .NET Framework utilise en interne UTF-16 pour représenter les caractères Unicode.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>Consequently, most Unicode characters can be represented by one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object, but a Unicode character represented by a surrogate pair, for example, requires two <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects.</source>
          <target state="translated">Par conséquent, la plupart des caractères Unicode peuvent être représentées par un <ph id="ph1">&lt;xref:System.Char&gt;</ph> objet, mais un caractère Unicode représenté par une paire de substitution, par exemple, nécessite deux <ph id="ph2">&lt;xref:System.Char&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph> pour stocker les octets obtenus, vous devez utiliser le <ph id="ph2">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, utilisez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> retrieves a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> Récupère un nombre le plus défavorable, y compris le pire des cas actuellement sélectionné <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character.</source>
          <target state="translated">Si une stratégie de secours est choisi avec une chaîne potentiellement grande, <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> récupère les valeurs élevées, en particulier dans les cas où le pire des cas pour l’encodage implique des modes de commutation pour chaque caractère.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>For example, this can happen for ISO-2022-JP.</source>
          <target state="translated">Par exemple, cela peut se produire pour ISO-2022-JP.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>For more information, see the blog entry "<bpt id="p1">[</bpt>What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=153702)</ept>"</source>
          <target state="translated">Pour plus d’informations, consultez le billet de blog «<bpt id="p1">[</bpt>Nouveautés avec Encoding.GetMaxByteCount et Encoding.GetMaxCharCount () ?<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=153702)</ept>»</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>(<ph id="ph1">http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx)</ph>.</source>
          <target state="translated">(<ph id="ph1">http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx)</ph>.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>In most cases, this method retrieves reasonable values for small strings.</source>
          <target state="translated">Dans la plupart des cas, cette méthode récupère des valeurs raisonnables pour les petites chaînes.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small.</source>
          <target state="translated">Pour les chaînes de grande taille, vous devrez choisir entre l’utilisation de mémoires tampons de grande et d’intercepter les erreurs dans les rares cas lorsqu’une mémoire tampon plus raisonnable est trop petite.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vous pouvez également envisager une approche différente à l’aide de <ph id="ph1">&lt;xref:System.Text.Encoding.GetByteCount%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>When using <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph>, you should allocate the output buffer based on the maximum size of the input buffer.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph>, vous devez allouer la mémoire tampon de sortie selon la taille maximale de la mémoire tampon d’entrée.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>If the output buffer is constrained in size, you might use the <ph id="ph1">&lt;xref:System.Text.Encoding.Convert%2A&gt;</ph> method.</source>
          <target state="translated">Si la mémoire tampon de sortie est contraint de taille, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Text.Encoding.Convert%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> considers potential leftover surrogates from a previous decoder operation.</source>
          <target state="translated">Notez que <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph> prend en compte les substituts potentiels restants d’une opération de décodeur précédente.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII.</source>
          <target state="translated">En raison du décodeur, en passant une valeur de 1 à la méthode extrait 2 pour un encodage sur un octet, par exemple ASCII.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>You should use the <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding.IsSingleByte%2A&gt;</ph> property if this information is necessary.</source>
          <target state="translated">Vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding.IsSingleByte%2A&gt;</ph> propriété si ces informations sont nécessaires.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">`GetMaxByteCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxByteCount(N)`</ph> n’est pas nécessairement la même valeur que <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxByteCount(System.Int32)">
          <source>All <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</source>
          <target state="translated">Tous les <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> implémentations doivent garantir qu’aucune exception de dépassement de capacité de mémoire tampon se produire si les mémoires tampons sont dimensionnés en fonction des résultats des calculs de cette méthode.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, calcule le nombre maximal de caractères produits par le décodage du nombre de caractères spécifié.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>The maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">Nombre maximal de caractères produits par le décodage du nombre d'octets spécifié.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you should use the <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille exacte de tableau requise par <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A&gt;</ph> pour stocker les caractères obtenus, vous devez utiliser le <ph id="ph2">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the maximum array size, use the <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Pour calculer la taille maximale du tableau, utilisez le <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> method generally allows allocation of less memory, while the <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> méthode permet généralement d’allocation de moins de mémoire, alors que le <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> méthode s’exécute plus rapidement.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> retrieves a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> Récupère un nombre le plus défavorable, y compris le pire des cas actuellement sélectionné <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> retrieves large values.</source>
          <target state="translated">Si une stratégie de secours est choisi avec une chaîne potentiellement grande, <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> extrait de grandes valeurs.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>In most cases, this method retrieves reasonable numbers for small strings.</source>
          <target state="translated">Dans la plupart des cas, cette méthode récupère un nombre raisonnable pour les petites chaînes.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small.</source>
          <target state="translated">Pour les chaînes de grande taille, vous devrez peut-être choisir entre l’utilisation de mémoires tampons de grande et d’intercepter les erreurs dans les rares cas qu’une mémoire tampon plus raisonnable est trop petite.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Vous pouvez également envisager une approche différente à l’aide de <ph id="ph1">&lt;xref:System.Text.Encoding.GetCharCount%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> n’a aucune relation avec <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>If you needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>, you should use <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph>.</source>
          <target state="translated">Si vous avez besoin d’une fonction semblable à utiliser avec <ph id="ph1">&lt;xref:System.Text.Encoding.GetBytes%2A&gt;</ph>, vous devez utiliser <ph id="ph2">&lt;xref:System.Text.Encoding.GetMaxByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>When using <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph>, you should allocate the output buffer based on the maximum size of the input buffer.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph>, vous devez allouer la mémoire tampon de sortie selon la taille maximale de la mémoire tampon d’entrée.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>If the output buffer is constrained in size, you might use the <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si la mémoire tampon de sortie est contraint de taille, vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> considers the worst case for leftover bytes from a previous encoder operation.</source>
          <target state="translated">Notez que <ph id="ph1">&lt;xref:System.Text.Encoding.GetMaxCharCount%2A&gt;</ph> considère que le pire des cas pour les octets restants à partir d’une précédente opération de l’encodeur.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.</source>
          <target state="translated">Pour la plupart des pages de codes, en passant une valeur de 0 à cette méthode récupère des valeurs supérieures ou égales à 1.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">`GetMaxCharCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxCharCount(N)`</ph> n’est pas nécessairement la même valeur que <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</source>
          <target state="translated">L’exemple suivant encode une chaîne en un tableau d’octets, puis décode les octets en un tableau de caractères.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetMaxCharCount(System.Int32)">
          <source>All <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</source>
          <target state="translated">Tous les <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> implémentations doivent garantir qu’aucune exception de dépassement de capacité de mémoire tampon se produire si les mémoires tampons sont dimensionnés en fonction des résultats des calculs de cette méthode.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetPreamble">
          <source>When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, retourne une séquence d'octets qui spécifie l'encodage utilisé.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetPreamble">
          <source>A byte array containing a sequence of bytes that specifies the encoding used.</source>
          <target state="translated">Tableau d'octets contenant une séquence d'octets qui spécifie l'encodage utilisé.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetPreamble">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetPreamble">
          <source>A byte array of length zero, if a preamble is not required.</source>
          <target state="translated">Tableau d'octets de longueur nulle si aucun préambule n'est requis.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>Optionally, the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</source>
          <target state="translated">Si vous le souhaitez, le <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objet fournit un préambule est un tableau d’octets qui peuvent être un préfixe à la séquence d’octets résultant du processus de codage.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.</source>
          <target state="translated">Si le préambule contient une marque d’ordre (au format Unicode, le point de code U + FEFF), il aide le décodeur à déterminer l’ordre d’octet et que le format de transformation ou UTF.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</source>
          <target state="translated">La marque d’ordre octet Unicode (BOM) est sérialisée comme suit (en hexadécimal) :</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>UTF-8: EF BB BF</source>
          <target state="translated">UTF-8 : EF BB BF</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>UTF-16 big endian byte order: FE FF</source>
          <target state="translated">UTF-16 primauté des octets : FE FF</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>UTF-16 little endian byte order: FF FE</source>
          <target state="translated">Ordre de primauté des octets little UTF-16 : FF FE</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>UTF-32 big endian byte order: 00 00 FE FF</source>
          <target state="translated">UTF-32 primauté des octets : 00 00 FE FF</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>UTF-32 little endian byte order: FF FE 00 00</source>
          <target state="translated">Ordre de primauté des octets little UTF-32 : FF FE 00 00</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.</source>
          <target state="translated">Vous devez utiliser le BOM, car il fournit une certaine identification d’un encodage pour fichiers qui autres ont perdu la référence à la <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> objet, par exemple, sans balise ou incorrectement référencées données web ou des fichiers texte aléatoires stockés lorsqu’une entreprise n’ont pas ont des intérêts internationaux ou autres données.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.</source>
          <target state="translated">Souvent des problèmes d’utilisateur peuvent être évités si les données sont correctement et régulièrement référencées, de préférence dans UTF-8 ou UTF-16.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>For standards that provide an encoding type, a BOM is somewhat redundant.</source>
          <target state="translated">Des normes qui fournissent un type de codage, un BOM est quelque peu redondant.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>However, it can be used to help a server send the correct encoding header.</source>
          <target state="translated">Toutefois, il peut être utilisé pour aider un serveur à envoyer l’en-tête de codage correct.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</source>
          <target state="translated">Sinon, il peut être utilisé comme un secours au cas où l’encodage est perdu.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>There are some disadvantages to using a BOM.</source>
          <target state="translated">Il existe certains inconvénients à l’aide d’une nomenclature.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>For example, knowing how to limit the database fields that use a BOM can be difficult.</source>
          <target state="translated">Par exemple, le fait de savoir comment limiter les champs de base de données qui utilisent un BOM peut être difficile.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</source>
          <target state="translated">Concaténation de fichiers peut poser un problème également, par exemple, lors de la fusion des fichiers de telle façon un caractère inutile peut finir au milieu des données.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>In spite of the few disadvantages, however, the use of a BOM is highly recommended.</source>
          <target state="translated">En dépit de quelques inconvénients, toutefois, l’utilisation d’une nomenclature est hautement recommandée.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’ordre d’octet et la marque d’ordre, consultez la norme Unicode sur le <bpt id="p1">[</bpt>page d’accueil Unicode<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.</source>
          <target state="translated">Pour vous assurer que les octets encodés sont décodés correctement, vous devez préfixe octets encodés avec un préambule.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>However, most encodings do not provide a preamble.</source>
          <target state="translated">Toutefois, la plupart des encodages ne fournissent pas de préambule.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph>, <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, or <ph id="ph3">&lt;xref:System.Text.UTF32Encoding&gt;</ph>, with a preamble.</source>
          <target state="translated">Pour garantir que les octets encodés sont décodés correctement, vous devez utiliser un encodage Unicode, autrement dit, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph>, <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph>, ou <ph id="ph3">&lt;xref:System.Text.UTF32Encoding&gt;</ph>, avec un préambule.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetPreamble">
          <source>The following example determines the byte order of the encoding based on the preamble.</source>
          <target state="translated">L’exemple suivant détermine l’ordre d’octet de l’encodage selon le préambule.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>When overridden in a derived class, decodes a sequence of bytes into a string.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, décode une séquence d'octets en chaîne.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Tableau d'octets contenant la séquence d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, décode tous les octets du tableau d'octets spécifié en chaîne.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>A string that contains the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Chaîne contenant les résultats du décodage de la séquence d'octets spécifiée.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> objet retourné par la <ph id="ph2">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> d’un deri (méthode) Autoriser le classe.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> reference topic for a discussion of decoding techniques and considerations.</source>
          <target state="translated">Consultez la section Notes de la <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> rubrique de référence pour une présentation des techniques et les considérations de décodage.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>Note that the precise behavior of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method for a particular <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> implementation depends on the fallback strategy defined for that <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> object.</source>
          <target state="translated">Notez que le comportement précis de la <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> méthode en tant <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> implémentation dépend de la stratégie de secours définie pour cette <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>For more information, see the "Choosing a Fallback Strategy" section of the <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> topic.</source>
          <target state="translated">Pour plus d’informations, consultez la section « Choix d’une stratégie de secours » de la <bpt id="p1">[</bpt>l’encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>The following example reads a UTF-8 encoded string from a binary file represented by a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">L’exemple suivant lit une chaîne encodée en UTF-8 à partir d’un fichier binaire est représenté par un <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29&gt;</ph> method to perform the decoding.</source>
          <target state="translated">Pour les fichiers qui sont inférieures à 2 048 octets, il lit le contenu du fichier entier dans un tableau d’octets et appelle le <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29&gt;</ph> méthode pour effectuer le décodage.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>For larger files, it reads 2,048 bytes at a time into a byte array, calls the <ph id="ph1">&lt;xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to determine how many characters are contained in the array, and then calls the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to perform the decoding.</source>
          <target state="translated">Pour les fichiers plus volumineux, il lit 2 048 octets à la fois dans un tableau d’octets, appelle le <ph id="ph1">&lt;xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> méthode pour déterminer le nombre de caractères contenus dans le tableau, puis appelle la <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> méthode pour effectuer le décodage.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</source>
          <target state="translated">L’exemple utilise le texte suivant, qui doit être enregistré dans un fichier encodé en UTF-8 nommé Utf8Example.txt.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>The byte array contains invalid Unicode code points.</source>
          <target state="translated">Le tableau d'octets contient des points de code Unicode non valides.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[])">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>A pointer to a byte array.</source>
          <target state="translated">Pointeur vers un tableau d'octets.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, décode un nombre d'octets spécifié en commençant à une adresse spécifiée dans une chaîne.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>A string that contains the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Chaîne contenant les résultats du décodage de la séquence d'octets spécifiée.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method is designed to optimize performance when you have a native pointer to a byte array.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> méthode est conçue pour optimiser les performances lorsque vous avez un pointeur natif vers un tableau d’octets.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.</source>
          <target state="translated">Au lieu de la création d’un tableau d’octets géré et puis de le décodage, vous pouvez à la place appeler cette méthode sans avoir à créer des objets intermédiaires.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> objet retourné par la <ph id="ph2">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> d’un deri (méthode) Autoriser le classe.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> reference topic for a discussion of decoding techniques and considerations.</source>
          <target state="translated">Consultez la section Notes de la <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> rubrique de référence pour une présentation des techniques et les considérations de décodage.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>Note that the precise behavior of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> method for a particular <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> implementation depends on the fallback strategy defined for that <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> object.</source>
          <target state="translated">Notez que le comportement précis de la <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%2A&gt;</ph> méthode en tant <ph id="ph2">&lt;xref:System.Text.Encoding&gt;</ph> implémentation dépend de la stratégie de secours définie pour cette <ph id="ph3">&lt;xref:System.Text.Encoding&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>For more information, see the "Choosing a Fallback Strategy" section of the <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> topic.</source>
          <target state="translated">Pour plus d’informations, consultez la section « Choix d’une stratégie de secours » de la <bpt id="p1">[</bpt>l’encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> rubrique.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is a null pointer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est un pointeur Null</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>A   fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for a complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Tableau d'octets contenant la séquence d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Index du premier octet à décoder.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Nombre d'octets à décoder.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, décode une séquence d'octets du tableau d'octets spécifié en chaîne.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A string that contains the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Chaîne contenant les résultats du décodage de la séquence d'octets spécifiée.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> method, respectively, of a derived class.</source>
          <target state="translated">Si les conversion des données seront disponibles uniquement dans les blocs séquentiels (par exemple, les données lues à partir d’un flux de données) ou si la quantité de données est tellement importante qu’elle doit être divisée en blocs plus petits, vous devez utiliser le <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> ou <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> fournie par le <ph id="ph3">&lt;xref:System.Text.Encoding.GetDecoder%2A&gt;</ph> méthode ou la <ph id="ph4">&lt;xref:System.Text.Encoding.GetEncoder%2A&gt;</ph> (méthode), respectivement, d’une classe dérivée.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>See the Remarks section of the <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> reference topic for a discussion of decoding techniques and considerations.</source>
          <target state="translated">Consultez la section Notes de la <ph id="ph1">&lt;xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType&gt;</ph> rubrique de référence pour une présentation des techniques et les considérations de décodage.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The following example reads a UTF-8 encoded string from a binary file that is represented by a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">L’exemple suivant lit une chaîne encodée en UTF-8 à partir d’un fichier binaire qui est représenté par un <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method to perform the decoding.</source>
          <target state="translated">Pour les fichiers qui sont inférieures à 2 048 octets, il lit le contenu du fichier entier dans un tableau d’octets et appelle le <ph id="ph1">&lt;xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> méthode pour effectuer le décodage.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>For larger files, it reads 2,048 bytes at a time into a byte array, calls the <ph id="ph1">&lt;xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to determine how many characters are contained in the array, and then calls the <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to perform the decoding.</source>
          <target state="translated">Pour les fichiers plus volumineux, il lit 2 048 octets à la fois dans un tableau d’octets, appelle le <ph id="ph1">&lt;xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> méthode pour déterminer le nombre de caractères contenus dans le tableau, puis appelle la <ph id="ph2">&lt;xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> méthode pour effectuer le décodage.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</source>
          <target state="translated">L’exemple utilise le texte suivant, qui doit être enregistré dans un fichier encodé en UTF-8 nommé Utf8Example.txt.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array contains invalid Unicode code points.</source>
          <target state="translated">Le tableau d'octets contient des points de code Unicode non valides.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="count" /&gt;</ph> est inférieur à zéro.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> et <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ne désignent pas une plage valide dans <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Une procédure de secours a eu lieu (consultez <bpt id="p1">[</bpt>Encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> pour obtenir une explication complète)</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">-et-</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.HeaderName">
          <source>When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient un nom pour l’encodage actuel qui peut être utilisé avec les étiquettes d’en-tête de l’agent de messagerie.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>A name for the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> to use with mail agent header tags.</source>
          <target state="translated">Nom du <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel à utiliser avec les balises d'en-tête de l'agent de messagerie.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>An empty string (""), if the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> cannot be used.</source>
          <target state="translated">Une chaîne vide (""), si le <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel ne peut pas être utilisé.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>If you need an encoding for a header name, you should call the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> property.</source>
          <target state="translated">Si vous avez besoin d’un encodage pour un nom d’en-tête, vous devez appeler la <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> méthode avec le <ph id="ph2">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>Often the method retrieves a different encoding from the test encoding furnished in the call.</source>
          <target state="translated">La méthode extrait souvent un encodage différent de l’encodage de test fourni dans l’appel.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>Generally only email applications need to retrieve such an encoding.</source>
          <target state="translated">En général uniquement les applications de messagerie doivent extraire un tel encodage.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>In some cases, the value of the <ph id="ph1">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> property corresponds to the international standard that defines that encoding.</source>
          <target state="translated">Dans certains cas, la valeur de la <ph id="ph1">&lt;xref:System.Text.Encoding.BodyName%2A&gt;</ph> propriété correspond à la norme internationale qui définit cet encodage.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>This doesn't mean that the implementation complies in full with that standard.</source>
          <target state="translated">Cela ne signifie pas que l’implémentation est conforme à l’intégralité de cette norme.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> returns the name to use to describe an encoding.</source>
          <target state="translated">Notez que <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> retourne le nom à utiliser pour décrire un encodage.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> property defines a different encoding that might work better for an email application, for example.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> propriété définit un encodage différent qui peut fonctionner mieux pour une application de messagerie, par exemple.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>However, use of the property to define the encoding is not recommended.</source>
          <target state="translated">Toutefois, l’utilisation de la propriété pour définir l’encodage n’est pas recommandée.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms différents de <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.HeaderName">
          <source>It displays <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> but does not compare against it.</source>
          <target state="translated">Il affiche <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> mais ne compare pas par rapport à elle.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" uid="T:System.Text.Encoding">
          <source>Gets a value indicating whether the current encoding is always normalized.</source>
          <target state="translated">Obtient une valeur indiquant si l'encodage actuel est toujours normalisé.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized">
          <source>Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</source>
          <target state="translated">Obtient une valeur indiquant si l'encodage actuel est toujours normalisé en utilisant le formulaire de normalisation par défaut.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> is always normalized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> en cours est toujours normalisé ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.IsAlwaysNormalized">
          <source>The default normalization form is <ph id="ph1">&lt;xref:System.Text.NormalizationForm.FormC&gt;</ph>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</source>
          <target state="translated">Le formulaire de normalisation par défaut est <ph id="ph1">&lt;xref:System.Text.NormalizationForm.FormC&gt;</ph>, qui utilise la décomposition canonique complète, suivie du remplacement des séquences par leurs composites principaux, si possible.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Text.NormalizationForm" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Text.NormalizationForm" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel est toujours normalisé en utilisant le formulaire de normalisation spécifié.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object is always normalized using the specified <ph id="ph3">&lt;see cref="T:System.Text.NormalizationForm" /&gt;</ph> value; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'objet <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel est toujours normalisé en utilisant la valeur <ph id="ph3">&lt;see cref="T:System.Text.NormalizationForm" /&gt;</ph> spécifiée ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)">
          <source>The default normalization form is <ph id="ph1">&lt;xref:System.Text.NormalizationForm.FormC&gt;</ph>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</source>
          <target state="translated">Le formulaire de normalisation par défaut est <ph id="ph1">&lt;xref:System.Text.NormalizationForm.FormC&gt;</ph>, qui utilise la décomposition canonique complète, suivie du remplacement des séquences par leurs composites principaux, si possible.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.IsBrowserDisplay">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel peut être utilisé par les clients de navigation pour afficher le contenu.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsBrowserDisplay">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> can be used by browser clients for displaying content; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> en cours peut être utilisé par les clients de navigateur pour afficher le contenu ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsBrowserDisplay">
          <source>The following example checks the values of the Boolean properties of each encoding.</source>
          <target state="translated">L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.IsBrowserSave">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel peut être utilisé par les clients de navigation pour enregistrer du contenu.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsBrowserSave">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> can be used by browser clients for saving content; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> en cours peut être utilisé par les clients de navigateur pour enregistrer le contenu ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsBrowserSave">
          <source>The following example checks the values of the Boolean properties of each encoding.</source>
          <target state="translated">L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.IsMailNewsDisplay">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel peut être utilisé par les clients de messagerie et de news pour afficher du contenu.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsMailNewsDisplay">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> can be used by mail and news clients for displaying content; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> en cours peut être utilisé par les clients de messagerie et de news pour afficher le contenu ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsMailNewsDisplay">
          <source>The following example checks the values of the Boolean properties of each encoding.</source>
          <target state="translated">L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.IsMailNewsSave">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel peut être utilisé par les clients de messagerie et de news pour enregistrer du contenu.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsMailNewsSave">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> can be used by mail and news clients for saving content; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel peut être utilisé par les clients de messagerie et de news pour enregistrer du contenu ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsMailNewsSave">
          <source>The following example checks the values of the Boolean properties of each encoding.</source>
          <target state="translated">L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.IsReadOnly">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel est en lecture seule.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel est en lecture seule ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsReadOnly">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.IsSingleByte">
          <source>When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient une valeur indiquant si l'encodage actuel utilise des points de code codés sur un octet.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> uses single-byte code points; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel utilise des points de code codés sur un octet ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source>For a single-byte encoding, for example, <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph>, this property retrieves <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Sur un octet d’encodage, par exemple, <ph id="ph1">&lt;xref:System.Text.ASCIIEncoding&gt;</ph>, cette propriété récupère <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source>You should be careful in what your application does with the value for <ph id="ph1">&lt;xref:System.Text.Encoding.IsSingleByte%2A&gt;</ph>.</source>
          <target state="translated">Vous devez être prudent dans ce que votre application fait avec la valeur de <ph id="ph1">&lt;xref:System.Text.Encoding.IsSingleByte%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source>An assumption of how an Encoding will proceed may still be wrong.</source>
          <target state="translated">Une hypothèse de la façon dont un encodage continuera peut toujours être incorrecte.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source>For example, Windows-1252 has a value of <ph id="ph1">`true`</ph> for <ph id="ph2">&lt;xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType&gt;</ph>, but Encoding.GetMaxByteCount(1) returns 2.</source>
          <target state="translated">Par exemple, Windows-1252 a une valeur de <ph id="ph1">`true`</ph> pour <ph id="ph2">&lt;xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType&gt;</ph>, mais Encoding.GetMaxByteCount (1) renvoie 2.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source>This is because the method considers potential leftover surrogates from a previous decoder operation.</source>
          <target state="translated">Il s’agit, car la méthode prend en compte les substituts potentiels restants d’une opération de décodeur précédente.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.IsSingleByte">
          <source>The following example checks the values of the Boolean properties of each encoding.</source>
          <target state="translated">L’exemple suivant vérifie les valeurs des propriétés booléennes de chaque encodage.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>A subclass of <ph id="ph1">&lt;see cref="T:System.Text.EncodingProvider" /&gt;</ph> that provides access to additional character encodings.</source>
          <target state="translated">Sous-classe de <ph id="ph1">&lt;see cref="T:System.Text.EncodingProvider" /&gt;</ph> qui fournit l'accès à des encodages de caractères supplémentaires.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>Registers an encoding provider.</source>
          <target state="translated">Enregistre un fournisseur d'encodage.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method allows you to register a class derived from <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> that makes character encodings available on a platform that does not otherwise support them.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> méthode vous permet d’enregistrer une classe dérivée de <ph id="ph2">&lt;xref:System.Text.EncodingProvider&gt;</ph> qui rend caractères encodages disponibles sur une plateforme qui ne les gère pas dans le cas contraire.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> overload.</source>
          <target state="translated">Une fois que le fournisseur d’encodage est enregistré, les encodages pris en charge peuvent être récupérés en appelant une <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> de surcharge.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>If there are multiple encoding providers, the <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> method attempts to retrieve a specified encoding from each provider starting with the one most recently registered.</source>
          <target state="translated">S’il existe plusieurs fournisseurs de codage, le <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> méthode tente de récupérer un encodage spécifié à partir de chaque fournisseur commençant par la plus récemment enregistrés.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>Registering an encoding provider by using the <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method also modifies the behavior of the <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](&lt;xref:System.Text.Encoding.GetEncoding(System.Int32)&gt;)</ept> and <bpt id="p2">[</bpt>EncodingProvider.GetEncoding(Int32, EncoderFallback, DecoderFallback)<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> methods when passed an argument of <ph id="ph2">`0`</ph>:</source>
          <target state="translated">L’inscription d’un fournisseur d’encodage à l’aide de la <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> méthode modifie également le comportement de la <bpt id="p1">[</bpt>Encoding.GetEncoding(Int32)<ept id="p1">](&lt;xref:System.Text.Encoding.GetEncoding(System.Int32)&gt;)</ept> et <bpt id="p2">[</bpt>EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )<ept id="p2">](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))</ept> méthodes quand il est passé un argument de <ph id="ph2">`0`</ph>:</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>If the registered provider is the <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph>, the method returns the encoding that matches the system active code page when running on the Windows operating system.</source>
          <target state="translated">Si le fournisseur inscrit est le <ph id="ph1">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph>, la méthode retourne l’encodage qui correspond à la page de code active du système lors de l’exécution sur le système d’exploitation Windows.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>A custom encoding provider can choose which encoding to return when either of these <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> method overloads is passed an argument of <ph id="ph2">`0`</ph>.</source>
          <target state="translated">Un fournisseur d’encodage personnalisé peut choisir le codage à retourner lorsque une de ces <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncoding%2A&gt;</ph> surcharges de méthode est passé un argument de <ph id="ph2">`0`</ph>.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>The provider can also choose to not return an encoding by having the <ph id="ph1">&lt;xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> method return <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Le fournisseur peut choisir également à ne pas retourner un encodage en ayant la <ph id="ph1">&lt;xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType&gt;</ph> retour de la méthode <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source><ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> includes one encoding provider, <ph id="ph2">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph>, that makes the encodings available that are present in the full .NET Framework but are not available in <ph id="ph3">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> inclut un fournisseur d’encodage, <ph id="ph2">&lt;xref:System.Text.CodePagesEncodingProvider&gt;</ph>, qui rend les encodages disponibles qui sont présents dans le .NET Framework, mais ne sont pas disponibles dans <ph id="ph3">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>By default, <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> only supports the Unicode encodings, ASCII, and code page 28591.</source>
          <target state="translated">Par défaut, <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> prend uniquement en charge les encodages Unicode, ASCII et page de codes 28591.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>If the same encoding provider is used in multiple calls to the <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method, only the first method call registers the provider.</source>
          <target state="translated">Si le même fournisseur d’encodage est utilisé dans plusieurs appels à la <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> méthode, seul le premier appel de méthode inscrit le fournisseur.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>Subsequent calls are ignored.</source>
          <target state="translated">Les appels suivants sont ignorés.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>If the <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations.</source>
          <target state="translated">Si la <ph id="ph1">&lt;xref:System.Text.Encoding.RegisterProvider%2A&gt;</ph> est appelée pour inscrire plusieurs fournisseurs qui gèrent le même encodage, le dernier fournisseur enregistré est utilisée pour tous les encodage et les opérations de décodage.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source>Any previously registered providers are ignored.</source>
          <target state="translated">Tous les fournisseurs inscrits précédemment sont ignorés.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)">
          <source><ph id="ph1">&lt;paramref name="provider" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="provider" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.Unicode">
          <source>Gets an encoding for the UTF-16 format using the little endian byte order.</source>
          <target state="translated">Obtient un encodage pour le format UTF-16 avec primauté des octets de poids faible (little-endian).</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Unicode">
          <source>An encoding for the UTF-16 format using the little endian byte order.</source>
          <target state="translated">Encodage pour le format UTF-16 en utilisant l'ordre d'octet avec primauté des octets de poids faible (Little Endian).</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Unicode">
          <source>For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les encodages pris en charge par le .NET Framework et en savoir plus sur le codage Unicode à utiliser, consultez <bpt id="p1">[</bpt>l’encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Unicode">
          <source>The <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object that is returned by this property may not have the appropriate behavior for your app.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Unicode">
          <source>It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</source>
          <target state="translated">Il utilise le remplacement de secours pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par un point d’interrogation (« ? ») caractères.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Unicode">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> constructor to instantiate a little endian <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
          <target state="translated">Au lieu de cela, vous pouvez appeler la <ph id="ph1">&lt;xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> constructeur pour instancier un little endian <ph id="ph2">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> objet dont exception de secours est un <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, comme l’illustre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.Unicode">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.UTF32">
          <source>Gets an encoding for the UTF-32 format using the little endian byte order.</source>
          <target state="translated">Obtient un encodage pour le format UTF-32 avec primauté des octets de poids faible (little-endian).</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>An  encoding object for the UTF-32 format using the little endian byte order.</source>
          <target state="translated">Objet d'encodage pour le format UTF-32 utilisant l'ordre d'octet avec primauté des octets de poids faible (little-endian).</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object that is returned by this property may not have the appropriate behavior for your app.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF32Encoding&gt;</ph> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE).</source>
          <target state="translated">Il utilise le remplacement de secours pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par le caractère de remplacement Unicode (U + FFFE).</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
          <target state="translated">Au lieu de cela, vous pouvez appeler la <ph id="ph1">&lt;xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> constructeur pour instancier un <ph id="ph2">&lt;xref:System.Text.UTF32Encoding&gt;</ph> objet dont exception de secours est un <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, comme l’illustre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>For a discussion of little endian byte order, see the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> class topic.</source>
          <target state="translated">Pour une présentation de primauté des octets, consultez la <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> rubrique de la classe.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les encodages pris en charge par le .NET Framework et en savoir plus sur le codage Unicode à utiliser, consultez <bpt id="p1">[</bpt>l’encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF32">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.UTF7">
          <source>Gets an encoding for the UTF-7 format.</source>
          <target state="translated">Obtient un encodage pour le format UTF-7.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF7">
          <source>An encoding for the UTF-7 format.</source>
          <target state="translated">Encodage pour le format UTF-7.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF7">
          <source>UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications.</source>
          <target state="translated">L’encodage UTF-7 est utilisé principalement dans les environnements historiquement restreintes à 7 bits, tels que NNTP et certaines applications de messagerie.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF7">
          <source>Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.</source>
          <target state="translated">En raison de problèmes avec la robustesse et la sécurité, vous ne devez pas utiliser UTF7 encodage dans des environnements de 8 bits où le codage UTF-8 peut être utilisé à la place.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF7">
          <source>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</source>
          <target state="translated">L’exemple suivant détermine le nombre d’octets requis pour encoder un tableau de caractères, encode les caractères et affiche le nombre d’octets résultant.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.UTF8">
          <source>Gets an encoding for the UTF-8 format.</source>
          <target state="translated">Obtient un encodage pour le format UTF-8.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>An encoding for the UTF-8 format.</source>
          <target state="translated">Encodage pour le format UTF-8.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>This property returns a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters.</source>
          <target state="translated">Cette propriété retourne un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet qui encode les caractères Unicode (UTF-16-encodées) en une séquence d’un à quatre octets par caractère, et cela décode un tableau d’octets d’encodée en UTF-8 pour les caractères Unicode (UTF-16-encodées).</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>For information about the character encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les codages de caractères pris en charge par le .NET Framework et en savoir plus sur le codage Unicode à utiliser, consultez <bpt id="p1">[</bpt>l’encodage de caractères dans le .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that is returned by this property might not have the appropriate behavior for your app.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet qui est retourné par cette propriété ne peut pas avoir le comportement approprié pour votre application.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>It returns a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that provides a Unicode byte order mark (BOM).</source>
          <target state="translated">Elle retourne un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet qui fournit une marque d’ordre octet (BOM) Unicode.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">Pour instancier un encodage UTF-8 qui ne fournit pas une nomenclature, appelez aucune surcharge de la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%2A&gt;</ph> constructeur.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>It returns a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark ("?") character.</source>
          <target state="translated">Elle retourne un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet qui utilise le remplacement de secours pour remplacer chaque chaîne qu’il ne peut pas encoder et chaque octet qu’il ne peut pas décoder par un point d’interrogation (« ? ») caractères.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>Instead, you can call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> constructor to instantiate a <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object whose fallback is either an <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> or a <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, as the following example illustrates.</source>
          <target state="translated">Au lieu de cela, vous pouvez appeler la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> constructeur pour instancier un <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objet dont exception de secours est un <ph id="ph3">&lt;xref:System.Text.EncoderFallbackException&gt;</ph> ou <ph id="ph4">&lt;xref:System.Text.DecoderFallbackException&gt;</ph>, comme l’illustre l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>The following example defines an array that consists of the following characters:</source>
          <target state="translated">L’exemple suivant définit un tableau qui se compose des caractères suivants :</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>LATIN SMALL LETTER Z (U+007A)</source>
          <target state="translated">LETTRE MINUSCULE LATINE Z (U + 007 A)</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>LATIN SMALL LETTER A (U+0061)</source>
          <target state="translated">LATIN LETTRE MINUSCULE (U + 0061)</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>COMBINING BREVE (U+0306)</source>
          <target state="translated">COMBINAISON BRÈVE (U + 0306)</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>LATIN SMALL LETTER AE WITH ACUTE (U+01FD)</source>
          <target state="translated">LETTRE MINUSCULE LATINE AE AVEC AIGUS (U + 01FD)</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>GREEK SMALL LETTER BETA (U+03B2)</source>
          <target state="translated">LETTRE MINUSCULE GRECQUE BÊTA (U + 03B2)</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>A surrogate pair (U+D800 U+DD54) that forms GREEK ACROPHONIC ATTIC ONE THOUSAND STATERS (U+10154).</source>
          <target state="translated">Une paire de substitution (U + D800 U + DD54) qui forme le grec ACROPHONIC ATTIC un milliers STATERS (U + 10154).</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>It displays the UTF-16 code units of each character and determines the number of bytes required by a UTF-8 encoder to encode the character array.</source>
          <target state="translated">Il affiche les unités de code UTF-16 de chaque caractère et détermine le nombre d’octets requis par un encodeur UTF-8 pour encoder le tableau de caractères.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.UTF8">
          <source>It then encodes the characters and displays the resulting UTF-8-encoded bytes.</source>
          <target state="translated">Il encode les caractères et affiche les octets encodée en UTF-8 qui en résulte.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.WebName">
          <source>When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient le nom inscrit auprès de l'IANA (Internet Assigned Numbers Authority) pour l'encodage actuel.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>The IANA name for the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">Nom IANA pour le <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> property is the same as the <ph id="ph2">&lt;xref:System.Text.EncodingInfo.Name%2A&gt;</ph> property.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> propriété est le même que le <ph id="ph2">&lt;xref:System.Text.EncodingInfo.Name%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>Note that <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> returns an IANA-registered name for the encoding.</source>
          <target state="translated">Notez que <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> retourne un nom enregistré IANA pour le codage.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard.</source>
          <target state="translated">Lorsque sa valeur est le nom de la norme, l’implémentation de l’encodage n’est peut-être pas conforme dans sa totalité de cette norme.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> property defines a different encoding that might work better for email headers.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.HeaderName%2A&gt;</ph> propriété définit un encodage différent qui peut fonctionner mieux pour les en-têtes de courrier électronique.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>However, most apps should use <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> instead.</source>
          <target state="translated">Toutefois, la plupart des applications doivent utiliser <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> à la place.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>For more information on the IANA, go to <bpt id="p1">[</bpt>www.iana.org<ept id="p1">](https://www.iana.org/)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’IANA, accédez à <bpt id="p1">[</bpt>www.iana.org<ept id="p1">](https://www.iana.org/)</ept>.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType&gt;</ph> is the same as the <ph id="ph2">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph> returned by <ph id="ph3">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType&gt;</ph> est le même que le <ph id="ph2">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph> retourné par <ph id="ph3">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>Some of the web names are duplicates; see the remarks for <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Certains noms web sont des doublons ; consultez la section Notes pour <ph id="ph1">&lt;xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType&gt;</ph> pour plus d’informations.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>The following example includes the <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> in an HTML header.</source>
          <target state="translated">L’exemple suivant inclut le <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> dans un en-tête HTML.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L’exemple suivant récupère les noms de chaque codage et affiche les encodages avec un ou plusieurs noms différents de <ph id="ph1">&lt;xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WebName">
          <source>It displays <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> but does not compare against it.</source>
          <target state="translated">Il affiche <ph id="ph1">&lt;xref:System.Text.Encoding.EncodingName%2A&gt;</ph> mais ne compare pas par rapport à elle.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" uid="P:System.Text.Encoding.WindowsCodePage">
          <source>When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</source>
          <target state="translated">En cas de substitution dans une classe dérivée, obtient la page de codes du système d'exploitation Windows la plus proche de l'encodage actuel.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WindowsCodePage">
          <source>The Windows operating system code page that most closely corresponds to the current <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</source>
          <target state="translated">Page de codes du système d'exploitation Windows la plus proche du <ph id="ph1">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> actuel.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WindowsCodePage">
          <source>This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families.</source>
          <target state="translated">Cette propriété est fournie pour la compatibilité avec les API Windows multilingue (MLang), par exemple, pour déterminer les familles de polices.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WindowsCodePage">
          <source>For globalization, using one of the Unicode encodings is recommended instead.</source>
          <target state="translated">Pour la globalisation, il est recommandé d’à la place l’un des encodages Unicode.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WindowsCodePage">
          <source>It is also recommended to use <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Text.Encoding.WindowsCodePage%2A&gt;</ph> to identify the code page.</source>
          <target state="translated">Il est également recommandé d’utiliser <ph id="ph1">&lt;xref:System.Text.Encoding.WebName%2A&gt;</ph> au lieu de <ph id="ph2">&lt;xref:System.Text.Encoding.WindowsCodePage%2A&gt;</ph> pour identifier la page de codes.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.Encoding.WindowsCodePage">
          <source>The following example determines the Windows code page that most closely corresponds to each encoding.</source>
          <target state="translated">L’exemple suivant détermine la page de codes Windows la plus proche de chaque encodage.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>