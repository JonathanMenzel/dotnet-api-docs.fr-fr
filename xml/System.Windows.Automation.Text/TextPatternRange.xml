<Type Name="TextPatternRange" FullName="System.Windows.Automation.Text.TextPatternRange">
  <Metadata><Meta Name="ms.openlocfilehash" Value="04b05150fd153351bd0d4d4a5be88cb75ea6b5f8" /><Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="09/22/2018" /><Meta Name="ms.locfileid" Value="46616846" /></Metadata><TypeSignature Language="C#" Value="public class TextPatternRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPatternRange extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Text.TextPatternRange" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPatternRange" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPatternRange" />
  <TypeSignature Language="F#" Value="type TextPatternRange = class" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationClient</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente une étendue de texte continu dans un conteneur <see cref="T:System.Windows.Automation.TextPattern" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Automation.Text.TextPatternRange> peut représenter un point d’insertion, un sous-ensemble ou tout le texte dans un <xref:System.Windows.Automation.TextPattern> conteneur.  
  
 Un <xref:System.Windows.Automation.Text.TextPatternRange> devient non valide si une des actions suivantes se produit : le texte dans le <xref:System.Windows.Automation.TextPattern> conteneur change en raison d’une activité utilisateur ou le <xref:System.Windows.Automation.ValuePattern.SetValue%2A> méthode de <xref:System.Windows.Automation.ValuePattern> est utilisée pour modifier par programmation la valeur du texte dans le <xref:System.Windows.Automation.TextPattern> conteneur.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Automation.Provider.ITextRangeProvider" />
    <related type="Article" href="~/docs/framework/ui-automation/ui-automation-control-patterns-overview.md">Vue d’ensemble des modèles de contrôle UI Automation</related>
    <related type="Article" href="~/docs/framework/ui-automation/ui-automation-control-patterns-for-clients.md">Modèles de contrôle UI Automation pour les clients</related>
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToSelection();" />
      <MemberSignature Language="F#" Value="member this.AddToSelection : unit -&gt; unit" Usage="textPatternRange.AddToSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ajoute à la collection de texte mis en surbrillance dans un conteneur de texte qui prend en charge les sélections multiples et disjointes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le point d’insertion de texte se déplace vers la zone de la nouvelle sélection.  
  
 En fournissant une plage de texte dégénérée déplace le point d’insertion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si le fournisseur de texte ne prend pas en charge les sélections multiples disjointes (par exemple, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> doit avoir la valeur <see langword="Multiple" />).</exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.Select" />
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Automation.Text.TextPatternRange" Usage="textPatternRange.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une nouvelle plage <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> identique à la plage <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> d'origine et héritant de toutes les propriétés de l'original.</summary>
        <returns>Nouvelle plage de texte. Une référence null (<see langword="Nothing" /> en Visual Basic) n’est jamais retournée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez également créer un nouveau <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> à partir de la <xref:System.Windows.Automation.TextPattern> et déplacer les deux points de terminaison pour qu’elles correspondent aux points de terminaison de la plage de texte d’origine.  
  
 La nouvelle plage peut être manipulée indépendamment de l’original.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1060](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1060)]  
  
 [!code-vb[UIATextPattern_snip#2060](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2060)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <altmember cref="M:System.Windows.Automation.TextPattern.RangeFromChild(System.Windows.Automation.AutomationElement)" />
        <altmember cref="M:System.Windows.Automation.TextPattern.RangeFromPoint(System.Windows.Point)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Text.TextPatternRange range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Compare(class System.Windows.Automation.Text.TextPatternRange range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compare (range As TextPatternRange) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Compare(System::Windows::Automation::Text::TextPatternRange ^ range);" />
      <MemberSignature Language="F#" Value="member this.Compare : System.Windows.Automation.Text.TextPatternRange -&gt; bool" Usage="textPatternRange.Compare range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Text.TextPatternRange" />
      </Parameters>
      <Docs>
        <param name="range">Plage de texte à comparer.</param>
        <summary>Retourne une valeur <see cref="T:System.Boolean" /> qui indique si l'étendue (du point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> au point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />) d'une plage de texte est la même qu'une autre plage de texte.</summary>
        <returns><see langword="true" /> si l'étendue des deux plages de texte est identique ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1061](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1061)]  
  
 [!code-vb[UIATextPattern_snip#2061](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2061)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si la plage qui est comparée ne vient pas du même fournisseur de textes.</exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareEndpoints (endpoint As TextPatternRangeEndpoint, targetRange As TextPatternRange, targetEndpoint As TextPatternRangeEndpoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareEndpoints(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextPatternRange ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="member this.CompareEndpoints : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextPatternRange * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; int" Usage="textPatternRange.CompareEndpoints (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">Point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de l'appelant.</param>
        <param name="targetRange">Plage cible à comparer.</param>
        <param name="targetEndpoint">Point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de la cible.</param>
        <summary>Retourne un élément <see cref="T:System.Int32" /> qui indique si deux plages de texte ont des points de terminaison identiques.</summary>
        <returns>Retourne une valeur négative si le point de terminaison de l'appelant se situe dans le texte avant le point de terminaison cible.  
  
Retourne zéro si le point de terminaison de l'appelant est au même emplacement que le point de terminaison cible.  
  
Retourne une valeur positive si le point de terminaison de l'appelant se situe dans le texte après le point de terminaison cible.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En comparant les points de terminaison de début et de fin de la même plage de texte, vous pouvez identifier si une plage de texte est dégénérée ou si les points de terminaison sont dans l’ordre des flux de texte logique.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1062](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1062)]  
  
 [!code-vb[UIATextPattern_snip#2062](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2062)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">S la plage est une référence null (<see langword="Nothing" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentException">Si la plage est d'un autre conteneur.</exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExpandToEnclosingUnit (unit As TextUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExpandToEnclosingUnit(System::Windows::Automation::Text::TextUnit unit);" />
      <MemberSignature Language="F#" Value="member this.ExpandToEnclosingUnit : System.Windows.Automation.Text.TextUnit -&gt; unit" Usage="textPatternRange.ExpandToEnclosingUnit unit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit">Unité de texte.</param>
        <summary>Développe la plage de texte à l'élément <see cref="T:System.Windows.Automation.Text.TextUnit" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la plage est déjà une quantité exacte d’unités spécifiées, elle reste inchangée.  
  
 Dans l’ordre pour la <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> méthode s’exécute correctement, une séquence d’actions est exécutée en arrière-plan.  
  
1.  La plage de texte est normalisée ; Autrement dit, la plage de texte est réduite à une plage dégénérée au niveau du <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> point de terminaison, ce qui le <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> superflu de point de terminaison. Cette étape est nécessaire pour supprimer toute ambiguïté dans des situations où une plage de texte s’étend sur `unit` limites ; par exemple, « {l’U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) est incorporée dans le texte » où « { » et «} » est des points de terminaison de plage de texte.  
  
2.  La plage obtenue est déplacée vers l'arrière dans <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> au début de la limite `unit` demandée.  
  
3.  La plage est avancée ou reculée dans <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> du nombre demandé de limites `unit`.  
  
4.  La plage est ensuite étendue à partir d'un état de plage dégénérée en déplaçant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> d'une limite `unit` demandée.  
  
 ![Ajustements de plage par Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustements de plage par Move & ExpandToEnclosingUnit")  
Exemples de la façon dont une plage de texte est ajustée pour Move() et ExpandToEnclosingUnit()  
  
> [!NOTE]
>  Ces étapes sont nécessaires dans la mesure où il est courant pour un lecteur d’écran lire un mot complet, une phrase ou un paragraphe entier au point d’insertion ou de n’importe quelle position de curseur virtuel.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> respecte le texte à la fois visible et masqué. Le client UI Automation puisse vérifier le <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> visibilité du texte.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> s’appuie sur la prochaine plus grande <xref:System.Windows.Automation.Text.TextUnit> prise en charge si la donnée <xref:System.Windows.Automation.Text.TextUnit> n’est pas pris en charge par le contrôle.  
  
 L’ordre, à partir de la plus petite unité au plus grand, est indiquée ci-dessous.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1063](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1063)]  
  
 [!code-vb[UIATextPattern_snip#2063](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2063)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindAttribute(class System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAttribute (attribute As AutomationTextAttribute, value As Object, backward As Boolean) As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ FindAttribute(System::Windows::Automation::AutomationTextAttribute ^ attribute, System::Object ^ value, bool backward);" />
      <MemberSignature Language="F#" Value="member this.FindAttribute : System.Windows.Automation.AutomationTextAttribute * obj * bool -&gt; System.Windows.Automation.Text.TextPatternRange" Usage="textPatternRange.FindAttribute (attribute, value, backward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute">Attribut à rechercher.</param>
        <param name="value">Valeur d'attribut à rechercher. Cette valeur doit correspondre au type spécifié pour l'attribut.</param>
        <param name="backward"><see langword="true" /> si la dernière plage de texte doit être retournée à la place de la première ; sinon, <see langword="false" />.</param>
        <summary>Retourne un sous-ensemble de la plage de texte qui a la valeur d'attribut spécifiée.</summary>
        <returns>Plage de texte dont l’attribut et la valeur d’attribut correspondent ; sinon, null (<see langword="Nothing" /> en Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’existe aucune distinction entre du texte masqué et visible. Les clients UI Automation peuvent utiliser <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> pour vérifier la visibilité du texte.  
  
> [!NOTE]
>  Utilisez <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> pour rechercher la totalité du document.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1064](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1064)]  
  
 [!code-vb[UIATextPattern_snip#2064](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2064)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.TextPattern" />
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindText (text As String, backward As Boolean, ignoreCase As Boolean) As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ FindText(System::String ^ text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="member this.FindText : string * bool * bool -&gt; System.Windows.Automation.Text.TextPatternRange" Usage="textPatternRange.FindText (text, backward, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">Chaîne de texte à rechercher.</param>
        <param name="backward"><see langword="true" /> si la dernière plage de texte doit être retournée à la place de la première ; sinon, <see langword="false" />.</param>
        <param name="ignoreCase"><see langword="true" /> si la casse doit être ignorée ; sinon, <see langword="false" />.</param>
        <summary>Retourne un sous-ensemble de la plage de texte qui contient le texte spécifié.</summary>
        <returns>Plage de texte correspondant au texte spécifié ; sinon, null (<see langword="Nothing" /> en Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’existe aucune distinction entre du texte masqué et visible. Les clients UI Automation peuvent utiliser <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> pour vérifier la visibilité du texte.  
  
> [!NOTE]
>  Utilisez <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> pour rechercher la totalité du document.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1065](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1065)]  
  
 [!code-vb[UIATextPattern_snip#2065](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2065)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.TextPattern" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetAttributeValue(class System.Windows.Automation.AutomationTextAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttributeValue (attribute As AutomationTextAttribute) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetAttributeValue(System::Windows::Automation::AutomationTextAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="member this.GetAttributeValue : System.Windows.Automation.AutomationTextAttribute -&gt; obj" Usage="textPatternRange.GetAttributeValue attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Attribut de texte.</param>
        <summary>Retourne la valeur de l'attribut spécifié sur la totalité de la plage de texte.</summary>
        <returns>Retourne la valeur de l'attribut spécifié. Par exemple, GetAttributeValue (TextPattern.FontNameAttribute) retourne une chaîne qui représente le nom de la police, si elle est unique, de la plage de texte, tandis que GetAttributeValue (TextPattern.IsItalicAttribute) retourne un booléen.  
  
Retourne <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> si la valeur de l'attribut spécifié varie sur la plage de texte.  
  
Retourne <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> si l'attribut spécifié n'est pas pris en charge par le fournisseur ou par le contrôle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il n’existe aucune distinction entre du texte masqué et visible. Les clients UI Automation peuvent utiliser <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> pour vérifier la visibilité du texte.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1066](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1066)]  
  
 [!code-vb[UIATextPattern_snip#2066](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2066)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si l’attribut spécifié n’est pas valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public System.Windows.Rect[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect[] GetBoundingRectangles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoundingRectangles () As Rect()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Rect&gt; ^ GetBoundingRectangles();" />
      <MemberSignature Language="F#" Value="member this.GetBoundingRectangles : unit -&gt; System.Windows.Rect[]" Usage="textPatternRange.GetBoundingRectangles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une collection de rectangles englobants pour chaque ligne de texte complètement ou partiellement visible dans une plage de texte.</summary>
        <returns>Tableau de rectangles englobants pour chaque ligne de texte complète ou partielle dans une plage de texte.  
  
Tableau vide pour une plage de texte dégénérée.  
  
Tableau vide pour une plage de texte qui a des coordonnées d'écran qui la placent complètement hors écran, qui la font défiler en dehors de l'affichage ou qui la masquent par une fenêtre superposée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1067](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1067)]  
  
 [!code-vb[UIATextPattern_snip#2067](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2067)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement[] GetChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetChildren" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildren () As AutomationElement()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Automation::AutomationElement ^&gt; ^ GetChildren();" />
      <MemberSignature Language="F#" Value="member this.GetChildren : unit -&gt; System.Windows.Automation.AutomationElement[]" Usage="textPatternRange.GetChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une collection de tous les objets incorporés qui se trouvent dans la plage de texte.</summary>
        <returns>Une collection de tous les objets enfants qui se trouvent dans la plage. Les enfants superposés à la plage mais qui ne sont pas entièrement contenus dans la plage sont également inclus dans la collection.  
  
Retourne une collection vide s’il n’y a pas d’objets enfants.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#getembeddedobjects)]
[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#getembeddedobjects)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement GetEnclosingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnclosingElement () As AutomationElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::AutomationElement ^ GetEnclosingElement();" />
      <MemberSignature Language="F#" Value="member this.GetEnclosingElement : unit -&gt; System.Windows.Automation.AutomationElement" Usage="textPatternRange.GetEnclosingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne l'élément <see cref="T:System.Windows.Automation.AutomationElement" /> le plus profond qui encadre la plage de texte.</summary>
        <returns>L'élément le plus profond qui contient l'appelant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La forme <xref:System.Windows.Automation.AutomationElement>, en général le fournisseur de texte qui fournit la plage de texte. Cependant, si le fournisseur de texte prend en charge des éléments enfants comme des tables ou des liens hypertexte, l'élément englobant peut être un descendant du fournisseur de texte.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1069](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1069)]  
  
 [!code-vb[UIATextPattern_snip#2069](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2069)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetText(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetText (maxLength As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetText(int maxLength);" />
      <MemberSignature Language="F#" Value="member this.GetText : int -&gt; string" Usage="textPatternRange.GetText maxLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">Longueur maximale de la chaîne à retourner. Utilisez <c>-1</c> si aucune limite n'est exigée.</param>
        <summary>Retourne le texte brut de la plage de texte.</summary>
        <returns>Texte brut de la plage de texte, éventuellement tronqué à la longueur <paramref name="maxLength" /> spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A> respecte le texte à la fois visible et masqué. Le client UI Automation puisse vérifier le <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> visibilité du texte.  
  
 Si `maxLength` est supérieur à la longueur de l’étendue de texte de l’appelant, la chaîne retournée sera le texte brut de la plage de texte.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A> ne seront pas affectées par l’ordre des points de terminaison dans le flux de texte ; elle retourne toujours le texte entre les points de terminaison de début et de fin de la plage de texte dans l’ordre de flux de texte logique.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1070](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1070)]  
  
 [!code-vb[UIATextPattern_snip#2070](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2070)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si <paramref name="maxLength" /> est inférieure à -1.</exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Move (unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Move(System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="member this.Move : System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="textPatternRange.Move (unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit">Limite d'unité de texte.</param>
        <param name="count">Nombre d'unités de texte à déplacer. Une valeur positive déplace la plage de texte vers l'avant, une valeur négative déplace la plage de texte vers l'arrière. 0 n'a aucun effet.</param>
        <summary>Déplace la plage de texte du nombre spécifié d'unités de texte.</summary>
        <returns>Nombre d'unités réellement déplacées. Ce peut être moins que le nombre requis si l'un ou l'autre des nouveaux points de terminaison de plage de texte est supérieur ou inférieur aux points de terminaison de <see cref="P:System.Windows.Automation.TextPattern.DocumentRange" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand il est nécessaire de parcourir le contenu d'une plage de texte, il faut effectuer une série d'étapes en arrière-plan pour assurer la bonne exécution de la méthode <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> .  
  
1.  La plage de texte est normalisée : elle est réduite en une plage dégénérée au niveau du point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> , rendant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> superflu. Cette étape est nécessaire pour supprimer toute ambiguïté dans des situations où une plage de texte s’étend sur `unit` limites ; par exemple, « {l’U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) est incorporée dans le texte » où « { » et «} » est des points de terminaison de plage de texte.  
  
2.  La plage obtenue est déplacée vers l'arrière dans <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> au début de la limite `unit` demandée.  
  
3.  La plage est avancée ou reculée dans <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> du nombre demandé de limites `unit`.  
  
4.  La plage est ensuite étendue à partir d'un état de plage dégénérée en déplaçant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> d'une limite `unit` demandée.  
  
 ![Ajustements de plage par Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustements de plage par Move & ExpandToEnclosingUnit")  
Exemples de la façon dont une plage de texte est ajustée pour Move() et ExpandToEnclosingUnit()  
  
 Le contenu textuel (ou texte interne) d'un conteneur de texte et d'un objet incorporé, tel qu'un lien hypertexte ou une cellule de tableau, est exposé en tant que flux de texte unique et continu dans l'affichage de contrôle et l'affichage du contenu de l'arborescence [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] ; le contour des objets est ignoré. Si un client UI Automation récupère le texte à des fins de récitation, interprétation ou analyse de quelque façon que ce soit, vous devez vérifier les cas spéciaux de la plage de texte, tels qu’un tableau avec du contenu textuel ou d’autres objets incorporés. Cela peut être accompli en appelant <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> pour obtenir un <xref:System.Windows.Automation.AutomationElement> pour chaque objet incorporé, puis en appelant <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> pour obtenir une plage de texte pour chaque élément ; pour cela de manière récursive jusqu'à ce que tout le contenu textuel a été récupéré.  
  
 ![Plages de texte sur lesquelles s’étend des objets incorporés. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Les plages de texte sur lesquelles s’étend des objets incorporés.")  
Exemple de flux de texte avec des objets incorporés et leurs amplitudes  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> respecte le texte à la fois visible et masqué. Le client UI Automation puisse vérifier le <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> visibilité du texte.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> s’appuie sur la prochaine plus grande <xref:System.Windows.Automation.Text.TextUnit> prise en charge si la donnée <xref:System.Windows.Automation.Text.TextUnit> n’est pas pris en charge par le contrôle.  
  
 L’ordre, à partir de la plus petite unité au plus grand, est indiquée ci-dessous.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
> [!NOTE]
>  Le texte n’est pas modifié de quelque manière que la plage de texte couvre juste une autre partie du texte.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#MoveSelection](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#moveselection)]
[!code-vb[UIATextPattern_snip#MoveSelection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#moveselection)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveEndpointByRange (endpoint As TextPatternRangeEndpoint, targetRange As TextPatternRange, targetEndpoint As TextPatternRangeEndpoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveEndpointByRange(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextPatternRange ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="member this.MoveEndpointByRange : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextPatternRange * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; unit" Usage="textPatternRange.MoveEndpointByRange (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">Point de terminaison à déplacer.</param>
        <param name="targetRange">Une autre plage du même fournisseur de texte.</param>
        <param name="targetEndpoint">Point de terminaison sur l'autre plage.</param>
        <summary>Déplace un point de terminaison d'une plage de texte au point de terminaison spécifié d'une deuxième plage de texte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le point de terminaison en cours de déplacement traverse l’autre point de terminaison de la même plage de texte, cette autre point de terminaison est également déplacé, provoquant une plage dégénérée et assurant le classement correct des points de terminaison (autrement dit, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> est toujours inférieure ou égale à <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1072](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1072)]  
  
 [!code-vb[UIATextPattern_snip#2072](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2072)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveEndpointByUnit (endpoint As TextPatternRangeEndpoint, unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int MoveEndpointByUnit(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="member this.MoveEndpointByUnit : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="textPatternRange.MoveEndpointByUnit (endpoint, unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint">Point de terminaison à déplacer.</param>
        <param name="unit">Unité de texte à déplacer.</param>
        <param name="count">Nombre d'unités à déplacer. Un nombre positif déplace le point de terminaison vers l'avant. Un nombre négatif le déplace vers l'arrière. 0 n'a aucun effet.</param>
        <summary>Déplace un point de terminaison de la plage de texte du nombre spécifié d'éléments <see cref="T:System.Windows.Automation.Text.TextUnit" /> dans la plage du document.</summary>
        <returns>Nombre d'unités réellement déplacées, qui peut être inférieur au nombre requis si le déplacement des points de terminaison atteint le début ou la fin du document.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand il est nécessaire de parcourir le contenu d'une plage de texte, il faut effectuer une série d'étapes en arrière-plan pour assurer la bonne exécution de la méthode <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> .  
  
1.  La plage de texte est normalisée : elle est réduite en une plage dégénérée au niveau du point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> , rendant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> superflu. Cette étape est nécessaire pour supprimer toute ambiguïté dans des situations où une plage de texte s’étend sur `unit` limites ; par exemple, « {l’U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) est incorporée dans le texte » où « { » et «} » est des points de terminaison de plage de texte.  
  
2.  La plage obtenue est déplacée vers l'arrière dans <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> au début de la limite `unit` demandée.  
  
3.  La plage est ensuite étendue à partir d'un état de plage dégénérée en déplaçant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> d'une limite `unit` demandée.  
  
 ![Ajustements de plage par Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustements de plage par Move & ExpandToEnclosingUnit")  
Exemples de la façon dont une plage de texte est ajustée pour Move() et ExpandToEnclosingUnit()  
  
 Le contenu textuel (ou texte interne) d'un conteneur de texte et d'un objet incorporé, tel qu'un lien hypertexte ou une cellule de tableau, est exposé en tant que flux de texte unique et continu dans l'affichage de contrôle et l'affichage du contenu de l'arborescence [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] ; le contour des objets est ignoré. Si un client UI Automation récupère le texte à des fins de récitation, interprétation ou analyse de quelque façon que ce soit, vous devez vérifier les cas spéciaux de la plage de texte, tels qu’un tableau avec du contenu textuel ou d’autres objets incorporés. Cela peut être accompli en appelant <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> pour obtenir un <xref:System.Windows.Automation.AutomationElement> pour chaque objet incorporé, puis en appelant <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> pour obtenir une plage de texte pour chaque élément ; pour cela de manière récursive jusqu'à ce que tout le contenu textuel a été récupéré.  
  
 ![Plages de texte sur lesquelles s’étend des objets incorporés. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Les plages de texte sur lesquelles s’étend des objets incorporés.")  
Exemple de flux de texte avec des objets incorporés et leurs amplitudes  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit%2A> s’appuie sur la prochaine plus grande <xref:System.Windows.Automation.Text.TextUnit> prise en charge si la donnée <xref:System.Windows.Automation.Text.TextUnit> n’est pas pris en charge par le contrôle.  
  
 L’ordre, à partir de la plus petite unité au plus grand, est indiquée ci-dessous.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1073](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1073)]  
  
 [!code-vb[UIATextPattern_snip#2073](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2073)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFromSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFromSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFromSelection();" />
      <MemberSignature Language="F#" Value="member this.RemoveFromSelection : unit -&gt; unit" Usage="textPatternRange.RemoveFromSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime une section en surbrillance de texte, correspondant aux points de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> et <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de la plage de texte appelante, de la collection de textes mis en surbrillance dans un conteneur de texte qui prend en charge des sélections multiples et disjointes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le point d’insertion de texte se déplacera vers la zone de la mise en surbrillance supprimé.  
  
 En fournissant une plage de texte dégénérée déplacera le point d’insertion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si le fournisseur de texte ne prend pas en charge les sélections multiples disjointes (par exemple, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> doit avoir la valeur <see langword="Multiple" />).</exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.Select" />
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignToTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignToTop);" />
      <MemberSignature Language="F#" Value="member this.ScrollIntoView : bool -&gt; unit" Usage="textPatternRange.ScrollIntoView alignToTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop"><see langword="true" /> si le contrôle de texte doit défiler de façon à ce que la plage de texte soit au même niveau que le haut de la fenêtre d'affichage ; <see langword="false" /> si elle doit être au même niveau que le bas de la fenêtre d'affichage.</param>
        <summary>Provoque le défilement vertical du contrôle de texte jusqu'à ce que la plage de texte soit visible dans la fenêtre d'affichage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView%2A> respecte le texte à la fois visible et masqué. Le client UI Automation puisse vérifier le <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> visibilité du texte. Si la plage de texte est masquée, le contrôle de texte défile uniquement si le texte masqué a une ancre dans la fenêtre d’affichage.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1074](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1074)]  
  
 [!code-vb[UIATextPattern_snip#2074](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2074)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Si le défilement n’est pas pris en charge par le contrôle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; unit" Usage="textPatternRange.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Met en surbrillance le texte dans le contrôle de texte qui correspond aux points de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> et <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de la plage de texte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une plage de texte dégénérée est fournie, le point d’insertion de texte se déplace à la <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> point de terminaison de la plage de texte.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1075](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1075)]  
  
 [!code-vb[UIATextPattern_snip#2075](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2075)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se produit lorsque la sélection de texte n’est pas prise en charge par le contrôle de texte.</exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
        <altmember cref="M:System.Windows.Automation.SelectionItemPattern.RemoveFromSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="TextPattern">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.TextPattern TextPattern { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Automation.TextPattern TextPattern" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Text.TextPatternRange.TextPattern" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TextPattern As TextPattern" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Automation::TextPattern ^ TextPattern { System::Windows::Automation::TextPattern ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TextPattern : System.Windows.Automation.TextPattern" Usage="System.Windows.Automation.Text.TextPatternRange.TextPattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.TextPattern</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'élément <see cref="T:System.Windows.Automation.TextPattern" /> associé à la plage de texte.</summary>
        <value>Fournisseur de texte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1076](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1076)]  
  
 [!code-vb[UIATextPattern_snip#2076](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2076)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>