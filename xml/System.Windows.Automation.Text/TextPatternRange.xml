<Type Name="TextPatternRange" FullName="System.Windows.Automation.Text.TextPatternRange">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f1da67f9a8572d73325547cdc1627cc97baee149" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39785653" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPatternRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPatternRange extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Text.TextPatternRange" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPatternRange" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPatternRange" />
  <TypeSignature Language="F#" Value="type TextPatternRange = class" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationClient</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="0503d-101">Représente une étendue de texte continu dans un conteneur <see cref="T:System.Windows.Automation.TextPattern" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0503d-101">Represents a span of continuous text in a <see cref="T:System.Windows.Automation.TextPattern" /> container.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-102">Un <xref:System.Windows.Automation.Text.TextPatternRange> peut représenter un point d’insertion, un sous-ensemble ou tout le texte dans un <xref:System.Windows.Automation.TextPattern> conteneur.</span><span class="sxs-lookup"><span data-stu-id="0503d-102">A <xref:System.Windows.Automation.Text.TextPatternRange> can represent an insertion point, a subset, or all of the text in a <xref:System.Windows.Automation.TextPattern> container.</span></span>  
  
 <span data-ttu-id="0503d-103">Un <xref:System.Windows.Automation.Text.TextPatternRange> devient non valide si une des actions suivantes se produit : le texte dans le <xref:System.Windows.Automation.TextPattern> conteneur change en raison d’une activité utilisateur ou le <xref:System.Windows.Automation.ValuePattern.SetValue%2A> méthode de <xref:System.Windows.Automation.ValuePattern> est utilisée pour modifier par programmation la valeur du texte dans le <xref:System.Windows.Automation.TextPattern> conteneur.</span><span class="sxs-lookup"><span data-stu-id="0503d-103">A <xref:System.Windows.Automation.Text.TextPatternRange> will become invalid if one of the following occurs: the text in the <xref:System.Windows.Automation.TextPattern> container changes because of some user activity, or the <xref:System.Windows.Automation.ValuePattern.SetValue%2A> method of <xref:System.Windows.Automation.ValuePattern> is used to programmatically change the value of the text in the <xref:System.Windows.Automation.TextPattern> container.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Automation.Provider.ITextRangeProvider" />
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToSelection();" />
      <MemberSignature Language="F#" Value="member this.AddToSelection : unit -&gt; unit" Usage="textPatternRange.AddToSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0503d-104">Ajoute à la collection de texte mis en surbrillance dans un conteneur de texte qui prend en charge les sélections multiples et disjointes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-104">Adds to the collection of highlighted text in a text container that supports multiple, disjoint selections.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-105">Le point d’insertion de texte se déplace vers la zone de la nouvelle sélection.</span><span class="sxs-lookup"><span data-stu-id="0503d-105">The text insertion point moves to the area of the new selection.</span></span>  
  
 <span data-ttu-id="0503d-106">En fournissant une plage de texte dégénérée déplace le point d’insertion.</span><span class="sxs-lookup"><span data-stu-id="0503d-106">Providing a degenerate text range moves the insertion point.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0503d-107">Si le fournisseur de texte ne prend pas en charge les sélections multiples disjointes (par exemple, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> doit avoir la valeur <see langword="Multiple" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-107">If text provider does not support multiple, disjoint selections (for example, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> must have a value of <see langword="Multiple" />).</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.Select" />
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Automation.Text.TextPatternRange" Usage="textPatternRange.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0503d-108">Récupère une nouvelle plage <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> identique à la plage <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> d'origine et héritant de toutes les propriétés de l'original.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-108">Retrieves a new <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> identical to the original <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> and inheriting all properties of the original.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0503d-109">Nouvelle plage de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-109">The new text range.</span>
          </span>
          <span data-ttu-id="0503d-110">Une référence null (<see langword="Nothing" /> en Visual Basic) n’est jamais retournée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-110">A null reference (<see langword="Nothing" /> in Visual Basic) is never returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-111">Vous pouvez également créer un nouveau <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> à partir de la <xref:System.Windows.Automation.TextPattern> et déplacer les deux points de terminaison pour qu’elles correspondent aux points de terminaison de la plage de texte d’origine.</span><span class="sxs-lookup"><span data-stu-id="0503d-111">Alternatively, create a new <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> from the <xref:System.Windows.Automation.TextPattern> and move the two endpoints to correspond with the endpoints of the original text range.</span></span>  
  
 <span data-ttu-id="0503d-112">La nouvelle plage peut être manipulée indépendamment de l’original.</span><span class="sxs-lookup"><span data-stu-id="0503d-112">The new range can be manipulated independently from the original.</span></span>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1060](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1060)]  
  
 [!code-vb[UIATextPattern_snip#2060](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2060)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <altmember cref="M:System.Windows.Automation.TextPattern.RangeFromChild(System.Windows.Automation.AutomationElement)" />
        <altmember cref="M:System.Windows.Automation.TextPattern.RangeFromPoint(System.Windows.Point)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Text.TextPatternRange range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Compare(class System.Windows.Automation.Text.TextPatternRange range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compare (range As TextPatternRange) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Compare(System::Windows::Automation::Text::TextPatternRange ^ range);" />
      <MemberSignature Language="F#" Value="member this.Compare : System.Windows.Automation.Text.TextPatternRange -&gt; bool" Usage="textPatternRange.Compare range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Text.TextPatternRange" />
      </Parameters>
      <Docs>
        <param name="range">
          <span data-ttu-id="0503d-113">Plage de texte à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-113">A text range to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0503d-114">Retourne une valeur <see cref="T:System.Boolean" /> qui indique si l'étendue (du point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> au point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />) d'une plage de texte est la même qu'une autre plage de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-114">Returns a <see cref="T:System.Boolean" /> value indicating whether the span (the <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> endpoint to the <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> endpoint) of a text range is the same as another text range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0503d-115">
            <see langword="true" /> si l'étendue des deux plages de texte est identique ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-115">
              <see langword="true" /> if the span of both text ranges is identical; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1061](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1061)]  
  
 [!code-vb[UIATextPattern_snip#2061](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2061)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0503d-116">Si la plage qui est comparée ne vient pas du même fournisseur de textes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-116">If the range being compared does not come from the same text provider.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareEndpoints (endpoint As TextPatternRangeEndpoint, targetRange As TextPatternRange, targetEndpoint As TextPatternRangeEndpoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareEndpoints(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextPatternRange ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="member this.CompareEndpoints : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextPatternRange * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; int" Usage="textPatternRange.CompareEndpoints (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">
          <span data-ttu-id="0503d-117">Point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de l'appelant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-117">The <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> or <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> endpoint of the caller.</span>
          </span>
        </param>
        <param name="targetRange">
          <span data-ttu-id="0503d-118">Plage cible à comparer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-118">The target range for comparison.</span>
          </span>
        </param>
        <param name="targetEndpoint">
          <span data-ttu-id="0503d-119">Point de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de la cible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-119">The <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> or <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> endpoint of the target.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0503d-120">Retourne un élément <see cref="T:System.Int32" /> qui indique si deux plages de texte ont des points de terminaison identiques.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-120">Returns an <see cref="T:System.Int32" /> indicating whether two text ranges have identical endpoints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0503d-121">Retourne une valeur négative si le point de terminaison de l'appelant se situe dans le texte avant le point de terminaison cible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-121">Returns a negative value if the caller's endpoint occurs earlier in the text than the target endpoint.</span>
          </span>
          <span data-ttu-id="0503d-122">Retourne zéro si le point de terminaison de l'appelant est au même emplacement que le point de terminaison cible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-122">Returns zero if the caller's endpoint is at the same location as the target endpoint.</span>
          </span>
          <span data-ttu-id="0503d-123">Retourne une valeur positive si le point de terminaison de l'appelant se situe dans le texte après le point de terminaison cible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-123">Returns a positive value if the caller's endpoint occurs later in the text than the target endpoint.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-124">En comparant les points de terminaison de début et de fin de la même plage de texte, vous pouvez identifier si une plage de texte est dégénérée ou si les points de terminaison sont dans l’ordre des flux de texte logique.</span><span class="sxs-lookup"><span data-stu-id="0503d-124">By comparing the starting and ending endpoints of the same text range you can identify if a text range is degenerate or if the endpoints are in the order of logical text flow.</span></span>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1062](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1062)]  
  
 [!code-vb[UIATextPattern_snip#2062](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2062)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0503d-125">S la plage est une référence null (<see langword="Nothing" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-125">If range is a null reference (<see langword="Nothing" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0503d-126">Si la plage est d'un autre conteneur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-126">If range is from another container.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExpandToEnclosingUnit (unit As TextUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExpandToEnclosingUnit(System::Windows::Automation::Text::TextUnit unit);" />
      <MemberSignature Language="F#" Value="member this.ExpandToEnclosingUnit : System.Windows.Automation.Text.TextUnit -&gt; unit" Usage="textPatternRange.ExpandToEnclosingUnit unit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit">
          <span data-ttu-id="0503d-127">Unité de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-127">The textual unit.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0503d-128">Développe la plage de texte à l'élément <see cref="T:System.Windows.Automation.Text.TextUnit" /> spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-128">Expands the text range to the specified <see cref="T:System.Windows.Automation.Text.TextUnit" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-129">Si la plage est déjà une quantité exacte d’unités spécifiées, elle reste inchangée.</span><span class="sxs-lookup"><span data-stu-id="0503d-129">If the range is already an exact quantity of the specified units then it remains unchanged.</span></span>  
  
 <span data-ttu-id="0503d-130">Dans l’ordre pour la <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> méthode s’exécute correctement, une séquence d’actions est exécutée en arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="0503d-130">In order for the <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> method to execute successfully, a sequence of actions is performed behind the scenes.</span></span>  
  
1.  <span data-ttu-id="0503d-131">La plage de texte est normalisée ; Autrement dit, la plage de texte est réduite à une plage dégénérée au niveau du <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> point de terminaison, ce qui le <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> superflu de point de terminaison.</span><span class="sxs-lookup"><span data-stu-id="0503d-131">The text range is normalized; that is, the text range is collapsed to a degenerate range at the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> endpoint, making the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint superfluous.</span></span> <span data-ttu-id="0503d-132">Cette étape est nécessaire pour supprimer toute ambiguïté dans des situations où une plage de texte s’étend sur `unit` limites ; par exemple, « {l’U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) est incorporée dans le texte » où « { » et «} » est des points de terminaison de plage de texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-132">This step is necessary to remove ambiguity in situations where a text range spans `unit` boundaries; for example, "{The U}RL [https://www.microsoft.com/](https://www.microsoft.com/) is embedded in text" where "{" and "}" are the text range endpoints.</span></span>  
  
2.  <span data-ttu-id="0503d-133">La plage obtenue est déplacée vers l'arrière dans <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> au début de la limite `unit` demandée.</span><span class="sxs-lookup"><span data-stu-id="0503d-133">The resulting range is moved backward in the <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> to the beginning of the requested `unit` boundary.</span></span>  
  
3.  <span data-ttu-id="0503d-134">La plage est avancée ou reculée dans <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> du nombre demandé de limites `unit`.</span><span class="sxs-lookup"><span data-stu-id="0503d-134">The range is moved forward or backward in the <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> by the requested number of `unit` boundaries.</span></span>  
  
4.  <span data-ttu-id="0503d-135">La plage est ensuite étendue à partir d'un état de plage dégénérée en déplaçant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> d'une limite `unit` demandée.</span><span class="sxs-lookup"><span data-stu-id="0503d-135">The range is then expanded from a degenerate range state by moving the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint by one requested `unit` boundary.</span></span>  
  
 <span data-ttu-id="0503d-136">![Ajustements de plage par Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustements de plage par Move & ExpandToEnclosingUnit")</span><span class="sxs-lookup"><span data-stu-id="0503d-136">![Range adjustments by Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Range adjustments by Move & ExpandToEnclosingUnit")</span></span>  
<span data-ttu-id="0503d-137">Exemples de la façon dont une plage de texte est ajustée pour Move() et ExpandToEnclosingUnit()</span><span class="sxs-lookup"><span data-stu-id="0503d-137">Examples of how a text range is adjusted for Move() and ExpandToEnclosingUnit()</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0503d-138">Ces étapes sont nécessaires dans la mesure où il est courant pour un lecteur d’écran lire un mot complet, une phrase ou un paragraphe entier au point d’insertion ou de n’importe quelle position de curseur virtuel.</span><span class="sxs-lookup"><span data-stu-id="0503d-138">These steps are necessary since it is common for a screen reader to read out a full word, sentence, or entire paragraph at the insertion point or any virtual cursor position.</span></span>  
  
 <span data-ttu-id="0503d-139"><xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> respecte le texte à la fois visible et masqué.</span><span class="sxs-lookup"><span data-stu-id="0503d-139"><xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> respects both hidden and visible text.</span></span> <span data-ttu-id="0503d-140">Le client UI Automation puisse vérifier le <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> visibilité du texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-140">The UI Automation client can check the <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> for text visibility.</span></span>  
  
 <span data-ttu-id="0503d-141"><xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> s’appuie sur la prochaine plus grande <xref:System.Windows.Automation.Text.TextUnit> prise en charge si la donnée <xref:System.Windows.Automation.Text.TextUnit> n’est pas pris en charge par le contrôle.</span><span class="sxs-lookup"><span data-stu-id="0503d-141"><xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> defers to the next largest <xref:System.Windows.Automation.Text.TextUnit> supported if the given <xref:System.Windows.Automation.Text.TextUnit> is not supported by the control.</span></span>  
  
 <span data-ttu-id="0503d-142">L’ordre, à partir de la plus petite unité au plus grand, est indiquée ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="0503d-142">The order, from smallest unit to largest, is listed below.</span></span>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1063](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1063)]  
  
 [!code-vb[UIATextPattern_snip#2063](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2063)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindAttribute(class System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAttribute (attribute As AutomationTextAttribute, value As Object, backward As Boolean) As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ FindAttribute(System::Windows::Automation::AutomationTextAttribute ^ attribute, System::Object ^ value, bool backward);" />
      <MemberSignature Language="F#" Value="member this.FindAttribute : System.Windows.Automation.AutomationTextAttribute * obj * bool -&gt; System.Windows.Automation.Text.TextPatternRange" Usage="textPatternRange.FindAttribute (attribute, value, backward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute">
          <span data-ttu-id="0503d-143">Attribut à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-143">The attribute to search for.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="0503d-144">Valeur d'attribut à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-144">The attribute value to search for.</span>
          </span>
          <span data-ttu-id="0503d-145">Cette valeur doit correspondre au type spécifié pour l'attribut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-145">This value must match the type specified for the attribute.</span>
          </span>
        </param>
        <param name="backward">
          <span data-ttu-id="0503d-146">
            <see langword="true" /> si la dernière plage de texte doit être retournée à la place de la première ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-146">
              <see langword="true" /> if the last occurring text range should be returned instead of the first; otherwise <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0503d-147">Retourne un sous-ensemble de la plage de texte qui a la valeur d'attribut spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-147">Returns a text range subset that has the specified attribute value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0503d-148">Plage de texte dont l’attribut et la valeur d’attribut correspondent ; sinon, null (<see langword="Nothing" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-148">A text range having a matching attribute and attribute value; otherwise null (<see langword="Nothing" /> in Visual Basic).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-149">Il n’existe aucune distinction entre du texte masqué et visible.</span><span class="sxs-lookup"><span data-stu-id="0503d-149">There is no differentiation between hidden and visible text.</span></span> <span data-ttu-id="0503d-150">Les clients UI Automation peuvent utiliser <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> pour vérifier la visibilité du texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-150">UI Automation clients can use <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> to check text visibility.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0503d-151">Utilisez <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> pour rechercher la totalité du document.</span><span class="sxs-lookup"><span data-stu-id="0503d-151">Use <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> to search the entire document.</span></span>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1064](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1064)]  
  
 [!code-vb[UIATextPattern_snip#2064](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2064)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.TextPattern" />
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindText (text As String, backward As Boolean, ignoreCase As Boolean) As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ FindText(System::String ^ text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="member this.FindText : string * bool * bool -&gt; System.Windows.Automation.Text.TextPatternRange" Usage="textPatternRange.FindText (text, backward, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">
          <span data-ttu-id="0503d-152">Chaîne de texte à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-152">The text string to search for.</span>
          </span>
        </param>
        <param name="backward">
          <span data-ttu-id="0503d-153">
            <see langword="true" /> si la dernière plage de texte doit être retournée à la place de la première ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-153">
              <see langword="true" /> if the last occurring text range should be returned instead of the first; otherwise <see langword="false" />.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="0503d-154">
            <see langword="true" /> si la casse doit être ignorée ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-154">
              <see langword="true" /> if case should be ignored; otherwise <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0503d-155">Retourne un sous-ensemble de la plage de texte qui contient le texte spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-155">Returns a text range subset that contains the specified text.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0503d-156">Plage de texte correspondant au texte spécifié ; sinon, null (<see langword="Nothing" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-156">A text range matching the specified text; otherwise null (<see langword="Nothing" /> in Visual Basic).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-157">Il n’existe aucune distinction entre du texte masqué et visible.</span><span class="sxs-lookup"><span data-stu-id="0503d-157">There is no differentiation between hidden and visible text.</span></span> <span data-ttu-id="0503d-158">Les clients UI Automation peuvent utiliser <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> pour vérifier la visibilité du texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-158">UI Automation clients can use <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> to check text visibility.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0503d-159">Utilisez <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> pour rechercher la totalité du document.</span><span class="sxs-lookup"><span data-stu-id="0503d-159">Use <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> to search the entire document.</span></span>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1065](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1065)]  
  
 [!code-vb[UIATextPattern_snip#2065](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2065)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.TextPattern" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetAttributeValue(class System.Windows.Automation.AutomationTextAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttributeValue (attribute As AutomationTextAttribute) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetAttributeValue(System::Windows::Automation::AutomationTextAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="member this.GetAttributeValue : System.Windows.Automation.AutomationTextAttribute -&gt; obj" Usage="textPatternRange.GetAttributeValue attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">
          <span data-ttu-id="0503d-160">Attribut de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-160">The text attribute.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0503d-161">Retourne la valeur de l'attribut spécifié sur la totalité de la plage de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-161">Returns the value of the specified attribute across the entire text range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0503d-162">Retourne la valeur de l'attribut spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-162">Returns the value of the specified attribute.</span>
          </span>
          <span data-ttu-id="0503d-163">Par exemple, GetAttributeValue (TextPattern.FontNameAttribute) retourne une chaîne qui représente le nom de la police, si elle est unique, de la plage de texte, tandis que GetAttributeValue (TextPattern.IsItalicAttribute) retourne un booléen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-163">For example, GetAttributeValue(TextPattern.FontNameAttribute) would return a string that represents the font name, if unique, of the text range while GetAttributeValue(TextPattern.IsItalicAttribute) would return a boolean.</span>
          </span>
          <span data-ttu-id="0503d-164">Retourne <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> si la valeur de l'attribut spécifié varie sur la plage de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-164">Returns <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> if the value of the specified attribute varies over the text range.</span>
          </span>
          <span data-ttu-id="0503d-165">Retourne <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> si l'attribut spécifié n'est pas pris en charge par le fournisseur ou par le contrôle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-165">Returns <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> if the specified attribute is not supported by the provider or the control.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-166">Il n’existe aucune distinction entre du texte masqué et visible.</span><span class="sxs-lookup"><span data-stu-id="0503d-166">There is no differentiation between hidden and visible text.</span></span> <span data-ttu-id="0503d-167">Les clients UI Automation peuvent utiliser <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> pour vérifier la visibilité du texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-167">UI Automation clients can use <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> to check text visibility.</span></span>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1066](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1066)]  
  
 [!code-vb[UIATextPattern_snip#2066](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2066)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0503d-168">Si l’attribut spécifié n’est pas valide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-168">If the specified attribute is not valid.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public System.Windows.Rect[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect[] GetBoundingRectangles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoundingRectangles () As Rect()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Rect&gt; ^ GetBoundingRectangles();" />
      <MemberSignature Language="F#" Value="member this.GetBoundingRectangles : unit -&gt; System.Windows.Rect[]" Usage="textPatternRange.GetBoundingRectangles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0503d-169">Récupère une collection de rectangles englobants pour chaque ligne de texte complètement ou partiellement visible dans une plage de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-169">Retrieves a collection of bounding rectangles for each fully or partially visible line of text in a text range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0503d-170">Tableau de rectangles englobants pour chaque ligne de texte complète ou partielle dans une plage de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-170">An array of bounding rectangles for each full or partial line of text in a text range.</span>
          </span>
          <span data-ttu-id="0503d-171">Tableau vide pour une plage de texte dégénérée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-171">An empty array for a degenerate text range.</span>
          </span>
          <span data-ttu-id="0503d-172">Tableau vide pour une plage de texte qui a des coordonnées d'écran qui la placent complètement hors écran, qui la font défiler en dehors de l'affichage ou qui la masquent par une fenêtre superposée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-172">An empty array for a text range that has screen coordinates placing it completely off-screen, scrolled out of view, or obscured by an overlapping window.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1067](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1067)]  
  
 [!code-vb[UIATextPattern_snip#2067](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2067)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement[] GetChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetChildren" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildren () As AutomationElement()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Automation::AutomationElement ^&gt; ^ GetChildren();" />
      <MemberSignature Language="F#" Value="member this.GetChildren : unit -&gt; System.Windows.Automation.AutomationElement[]" Usage="textPatternRange.GetChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0503d-173">Récupère une collection de tous les objets incorporés qui se trouvent dans la plage de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-173">Retrieves a collection of all embedded objects that fall within the text range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0503d-174">Une collection de tous les objets enfants qui se trouvent dans la plage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-174">A collection of all child objects that fall within the range.</span>
          </span>
          <span data-ttu-id="0503d-175">Les enfants superposés à la plage mais qui ne sont pas entièrement contenus dans la plage sont également inclus dans la collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-175">Children that overlap with the range but are not entirely enclosed by it will also be included in the collection.</span>
          </span>
          <span data-ttu-id="0503d-176">Retourne une collection vide s’il n’y a pas d’objets enfants.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-176">Returns an empty collection if there are no child objects.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#getembeddedobjects)]
[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#getembeddedobjects)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement GetEnclosingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnclosingElement () As AutomationElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::AutomationElement ^ GetEnclosingElement();" />
      <MemberSignature Language="F#" Value="member this.GetEnclosingElement : unit -&gt; System.Windows.Automation.AutomationElement" Usage="textPatternRange.GetEnclosingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0503d-177">Retourne l'élément <see cref="T:System.Windows.Automation.AutomationElement" /> le plus profond qui encadre la plage de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-177">Returns the innermost <see cref="T:System.Windows.Automation.AutomationElement" /> that encloses the text range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0503d-178">L'élément le plus profond qui contient l'appelant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-178">The innermost element enclosing the caller.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-179">La forme <xref:System.Windows.Automation.AutomationElement>, en général le fournisseur de texte qui fournit la plage de texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-179">The enclosing <xref:System.Windows.Automation.AutomationElement>, typically the text provider that supplies the text range.</span></span> <span data-ttu-id="0503d-180">Cependant, si le fournisseur de texte prend en charge des éléments enfants comme des tables ou des liens hypertexte, l'élément englobant peut être un descendant du fournisseur de texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-180">However, if the text provider supports child elements such as tables or hyperlinks, then the enclosing element could be a descendant of the text provider.</span></span>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1069](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1069)]  
  
 [!code-vb[UIATextPattern_snip#2069](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2069)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetText(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetText (maxLength As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetText(int maxLength);" />
      <MemberSignature Language="F#" Value="member this.GetText : int -&gt; string" Usage="textPatternRange.GetText maxLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">
          <span data-ttu-id="0503d-181">Longueur maximale de la chaîne à retourner.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-181">The maximum length of the string to return.</span>
          </span>
          <span data-ttu-id="0503d-182">Utilisez <c>-1</c> si aucune limite n'est exigée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-182">Use <c>-1</c> if no limit is required.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0503d-183">Retourne le texte brut de la plage de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-183">Returns the plain text of the text range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0503d-184">Texte brut de la plage de texte, éventuellement tronqué à la longueur <paramref name="maxLength" /> spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-184">The plain text of the text range, possibly truncated at the specified <paramref name="maxLength" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-185"><xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A> respecte le texte à la fois visible et masqué.</span><span class="sxs-lookup"><span data-stu-id="0503d-185"><xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A> respects both hidden and visible text.</span></span> <span data-ttu-id="0503d-186">Le client UI Automation puisse vérifier le <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> visibilité du texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-186">The UI Automation client can check the <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> for text visibility.</span></span>  
  
 <span data-ttu-id="0503d-187">Si `maxLength` est supérieur à la longueur de l’étendue de texte de l’appelant, la chaîne retournée sera le texte brut de la plage de texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-187">If `maxLength` is greater than the length of the text span of the caller, the string returned will be the plain text of the text range.</span></span>  
  
 <span data-ttu-id="0503d-188"><xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A> ne seront pas affectées par l’ordre des points de terminaison dans le flux de texte ; elle retourne toujours le texte entre les points de terminaison de début et de fin de la plage de texte dans l’ordre de flux de texte logique.</span><span class="sxs-lookup"><span data-stu-id="0503d-188"><xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A> will not be affected by the order of endpoints in the text flow; it will always return the text between the Start and End endpoints of the text range in the logical text flow order.</span></span>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1070](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1070)]  
  
 [!code-vb[UIATextPattern_snip#2070](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2070)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0503d-189">Si <paramref name="maxLength" /> est inférieure à -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-189">If <paramref name="maxLength" /> is less than -1.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Move (unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Move(System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="member this.Move : System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="textPatternRange.Move (unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit">
          <span data-ttu-id="0503d-190">Limite d'unité de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-190">The text unit boundary.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="0503d-191">Nombre d'unités de texte à déplacer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-191">The number of text units to move.</span>
          </span>
          <span data-ttu-id="0503d-192">Une valeur positive déplace la plage de texte vers l'avant, une valeur négative déplace la plage de texte vers l'arrière. 0 n'a aucun effet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-192">A positive value moves the text range forward, a negative value moves the text range backward, and 0 has no effect.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0503d-193">Déplace la plage de texte du nombre spécifié d'unités de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-193">Moves the text range the specified number of text units.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0503d-194">Nombre d'unités réellement déplacées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-194">The number of units actually moved.</span>
          </span>
          <span data-ttu-id="0503d-195">Ce peut être moins que le nombre requis si l'un ou l'autre des nouveaux points de terminaison de plage de texte est supérieur ou inférieur aux points de terminaison de <see cref="P:System.Windows.Automation.TextPattern.DocumentRange" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-195">This can be less than the number requested if either of the new text range endpoints is greater than or less than the <see cref="P:System.Windows.Automation.TextPattern.DocumentRange" /> endpoints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-196">Quand il est nécessaire de parcourir le contenu d'une plage de texte, il faut effectuer une série d'étapes en arrière-plan pour assurer la bonne exécution de la méthode <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> .</span><span class="sxs-lookup"><span data-stu-id="0503d-196">When it is necessary to traverse the content of a text range, a series of steps are involved behind the scenes in order for the <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> method to execute successfully.</span></span>  
  
1.  <span data-ttu-id="0503d-197">La plage de texte est normalisée : elle est réduite en une plage dégénérée au niveau du point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> , rendant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> superflu.</span><span class="sxs-lookup"><span data-stu-id="0503d-197">The text range is normalized; that is, the text range is collapsed to a degenerate range at the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> endpoint, which makes the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint superfluous.</span></span> <span data-ttu-id="0503d-198">Cette étape est nécessaire pour supprimer toute ambiguïté dans des situations où une plage de texte s’étend sur `unit` limites ; par exemple, « {l’U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) est incorporée dans le texte » où « { » et «} » est des points de terminaison de plage de texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-198">This step is necessary to remove ambiguity in situations where a text range spans `unit` boundaries; for example, "{The U}RL [https://www.microsoft.com/](https://www.microsoft.com/) is embedded in text" where "{" and "}" are the text range endpoints.</span></span>  
  
2.  <span data-ttu-id="0503d-199">La plage obtenue est déplacée vers l'arrière dans <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> au début de la limite `unit` demandée.</span><span class="sxs-lookup"><span data-stu-id="0503d-199">The resulting range is moved backward in the <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> to the beginning of the requested `unit` boundary.</span></span>  
  
3.  <span data-ttu-id="0503d-200">La plage est avancée ou reculée dans <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> du nombre demandé de limites `unit`.</span><span class="sxs-lookup"><span data-stu-id="0503d-200">The range is moved forward or backward in the <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> by the requested number of `unit` boundaries.</span></span>  
  
4.  <span data-ttu-id="0503d-201">La plage est ensuite étendue à partir d'un état de plage dégénérée en déplaçant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> d'une limite `unit` demandée.</span><span class="sxs-lookup"><span data-stu-id="0503d-201">The range is then expanded from a degenerate range state by moving the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint by one requested `unit` boundary.</span></span>  
  
 <span data-ttu-id="0503d-202">![Ajustements de plage par Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustements de plage par Move & ExpandToEnclosingUnit")</span><span class="sxs-lookup"><span data-stu-id="0503d-202">![Range adjustments by Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Range adjustments by Move & ExpandToEnclosingUnit")</span></span>  
<span data-ttu-id="0503d-203">Exemples de la façon dont une plage de texte est ajustée pour Move() et ExpandToEnclosingUnit()</span><span class="sxs-lookup"><span data-stu-id="0503d-203">Examples of how a text range is adjusted for Move() and ExpandToEnclosingUnit()</span></span>  
  
 <span data-ttu-id="0503d-204">Le contenu textuel (ou texte interne) d'un conteneur de texte et d'un objet incorporé, tel qu'un lien hypertexte ou une cellule de tableau, est exposé en tant que flux de texte unique et continu dans l'affichage de contrôle et l'affichage du contenu de l'arborescence [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] ; le contour des objets est ignoré.</span><span class="sxs-lookup"><span data-stu-id="0503d-204">The textual content (or inner text) of a text container and an embedded object, such as a hyperlink or table cell, is exposed as a single, continuous text stream in both the control view and the content view of the [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] tree; object boundaries are ignored.</span></span> <span data-ttu-id="0503d-205">Si un client UI Automation récupère le texte à des fins de récitation, interprétation ou analyse de quelque façon que ce soit, vous devez vérifier les cas spéciaux de la plage de texte, tels qu’un tableau avec du contenu textuel ou d’autres objets incorporés.</span><span class="sxs-lookup"><span data-stu-id="0503d-205">If a UI Automation client is retrieving the text for the purpose of reciting, interpreting, or analyzing in some manner, the text range should be checked for special cases, such as a table with textual content or other embedded objects.</span></span> <span data-ttu-id="0503d-206">Cela peut être accompli en appelant <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> pour obtenir un <xref:System.Windows.Automation.AutomationElement> pour chaque objet incorporé, puis en appelant <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> pour obtenir une plage de texte pour chaque élément ; pour cela de manière récursive jusqu'à ce que tout le contenu textuel a été récupéré.</span><span class="sxs-lookup"><span data-stu-id="0503d-206">This can be accomplished by calling <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> to obtain an <xref:System.Windows.Automation.AutomationElement> for each embedded object and then calling <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> to obtain a text range for each element; this is done recursively until all textual content has been retrieved.</span></span>  
  
 <span data-ttu-id="0503d-207">![Plages de texte sur lesquelles s’étend des objets incorporés. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Les plages de texte sur lesquelles s’étend des objets incorporés.")</span><span class="sxs-lookup"><span data-stu-id="0503d-207">![Text ranges spanned by embedded objects.](~/add/media/uia-textpattern-embeddedobjecttextranges.png "Text ranges spanned by embedded objects.")</span></span>  
<span data-ttu-id="0503d-208">Exemple de flux de texte avec des objets incorporés et leurs amplitudes</span><span class="sxs-lookup"><span data-stu-id="0503d-208">Example of a text stream with embedded objects and their range spans</span></span>  
  
 <span data-ttu-id="0503d-209"><xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> respecte le texte à la fois visible et masqué.</span><span class="sxs-lookup"><span data-stu-id="0503d-209"><xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> respects both hidden and visible text.</span></span> <span data-ttu-id="0503d-210">Le client UI Automation puisse vérifier le <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> visibilité du texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-210">The UI Automation client can check the <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> for text visibility.</span></span>  
  
 <span data-ttu-id="0503d-211"><xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> s’appuie sur la prochaine plus grande <xref:System.Windows.Automation.Text.TextUnit> prise en charge si la donnée <xref:System.Windows.Automation.Text.TextUnit> n’est pas pris en charge par le contrôle.</span><span class="sxs-lookup"><span data-stu-id="0503d-211"><xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> defers to the next largest <xref:System.Windows.Automation.Text.TextUnit> supported if the given <xref:System.Windows.Automation.Text.TextUnit> is not supported by the control.</span></span>  
  
 <span data-ttu-id="0503d-212">L’ordre, à partir de la plus petite unité au plus grand, est indiquée ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="0503d-212">The order, from smallest unit to largest, is listed below.</span></span>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
> [!NOTE]
>  <span data-ttu-id="0503d-213">Le texte n’est pas modifié de quelque manière que la plage de texte couvre juste une autre partie du texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-213">The text is not altered in any way as the text range just spans a different part of the text.</span></span>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#MoveSelection](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#moveselection)]
[!code-vb[UIATextPattern_snip#MoveSelection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#moveselection)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveEndpointByRange (endpoint As TextPatternRangeEndpoint, targetRange As TextPatternRange, targetEndpoint As TextPatternRangeEndpoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveEndpointByRange(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextPatternRange ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="member this.MoveEndpointByRange : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextPatternRange * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; unit" Usage="textPatternRange.MoveEndpointByRange (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">
          <span data-ttu-id="0503d-214">Point de terminaison à déplacer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-214">The endpoint to move.</span>
          </span>
        </param>
        <param name="targetRange">
          <span data-ttu-id="0503d-215">Une autre plage du même fournisseur de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-215">Another range from the same text provider.</span>
          </span>
        </param>
        <param name="targetEndpoint">
          <span data-ttu-id="0503d-216">Point de terminaison sur l'autre plage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-216">An endpoint on the other range.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0503d-217">Déplace un point de terminaison d'une plage de texte au point de terminaison spécifié d'une deuxième plage de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-217">Moves one endpoint of a text range to the specified endpoint of a second text range.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-218">Si le point de terminaison en cours de déplacement traverse l’autre point de terminaison de la même plage de texte, cette autre point de terminaison est également déplacé, provoquant une plage dégénérée et assurant le classement correct des points de terminaison (autrement dit, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> est toujours inférieure ou égale à <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).</span><span class="sxs-lookup"><span data-stu-id="0503d-218">If the endpoint being moved crosses the other endpoint of the same text range then that other endpoint is moved also, resulting in a degenerate range and ensuring the correct ordering of the endpoints (that is, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> is always less than or equal to <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).</span></span>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1072](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1072)]  
  
 [!code-vb[UIATextPattern_snip#2072](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2072)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveEndpointByUnit (endpoint As TextPatternRangeEndpoint, unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int MoveEndpointByUnit(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="member this.MoveEndpointByUnit : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="textPatternRange.MoveEndpointByUnit (endpoint, unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint">
          <span data-ttu-id="0503d-219">Point de terminaison à déplacer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-219">The endpoint to move.</span>
          </span>
        </param>
        <param name="unit">
          <span data-ttu-id="0503d-220">Unité de texte à déplacer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-220">The textual unit for moving.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="0503d-221">Nombre d'unités à déplacer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-221">The number of units to move.</span>
          </span>
          <span data-ttu-id="0503d-222">Un nombre positif déplace le point de terminaison vers l'avant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-222">A positive count moves the endpoint forward.</span>
          </span>
          <span data-ttu-id="0503d-223">Un nombre négatif le déplace vers l'arrière.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-223">A negative count moves backward.</span>
          </span>
          <span data-ttu-id="0503d-224">0 n'a aucun effet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-224">A count of 0 has no effect.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0503d-225">Déplace un point de terminaison de la plage de texte du nombre spécifié d'éléments <see cref="T:System.Windows.Automation.Text.TextUnit" /> dans la plage du document.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-225">Moves one endpoint of the text range the specified number of <see cref="T:System.Windows.Automation.Text.TextUnit" />s within the document range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0503d-226">Nombre d'unités réellement déplacées, qui peut être inférieur au nombre requis si le déplacement des points de terminaison atteint le début ou la fin du document.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-226">The number of units actually moved, which can be less than the number requested if moving the endpoint runs into the beginning or end of the document.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-227">Quand il est nécessaire de parcourir le contenu d'une plage de texte, il faut effectuer une série d'étapes en arrière-plan pour assurer la bonne exécution de la méthode <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> .</span><span class="sxs-lookup"><span data-stu-id="0503d-227">When it is necessary to traverse the content of a text range, a series of steps are involved behind the scenes in order for the <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> method to execute successfully.</span></span>  
  
1.  <span data-ttu-id="0503d-228">La plage de texte est normalisée : elle est réduite en une plage dégénérée au niveau du point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> , rendant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> superflu.</span><span class="sxs-lookup"><span data-stu-id="0503d-228">The text range is normalized; that is, the text range is collapsed to a degenerate range at the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> endpoint, which makes the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint superfluous.</span></span> <span data-ttu-id="0503d-229">Cette étape est nécessaire pour supprimer toute ambiguïté dans des situations où une plage de texte s’étend sur `unit` limites ; par exemple, « {l’U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) est incorporée dans le texte » où « { » et «} » est des points de terminaison de plage de texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-229">This step is necessary to remove ambiguity in situations where a text range spans `unit` boundaries; for example, "{The U}RL [https://www.microsoft.com/](https://www.microsoft.com/) is embedded in text" where "{" and "}" are the text range endpoints.</span></span>  
  
2.  <span data-ttu-id="0503d-230">La plage obtenue est déplacée vers l'arrière dans <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> au début de la limite `unit` demandée.</span><span class="sxs-lookup"><span data-stu-id="0503d-230">The resulting range is moved backward in the <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> to the beginning of the requested `unit` boundary.</span></span>  
  
3.  <span data-ttu-id="0503d-231">La plage est ensuite étendue à partir d'un état de plage dégénérée en déplaçant le point de terminaison <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> d'une limite `unit` demandée.</span><span class="sxs-lookup"><span data-stu-id="0503d-231">The range is then expanded from a degenerate range state by moving the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> endpoint by one requested `unit` boundary.</span></span>  
  
 <span data-ttu-id="0503d-232">![Ajustements de plage par Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustements de plage par Move & ExpandToEnclosingUnit")</span><span class="sxs-lookup"><span data-stu-id="0503d-232">![Range adjustments by Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "Range adjustments by Move & ExpandToEnclosingUnit")</span></span>  
<span data-ttu-id="0503d-233">Exemples de la façon dont une plage de texte est ajustée pour Move() et ExpandToEnclosingUnit()</span><span class="sxs-lookup"><span data-stu-id="0503d-233">Examples of how a text range is adjusted for Move() and ExpandToEnclosingUnit()</span></span>  
  
 <span data-ttu-id="0503d-234">Le contenu textuel (ou texte interne) d'un conteneur de texte et d'un objet incorporé, tel qu'un lien hypertexte ou une cellule de tableau, est exposé en tant que flux de texte unique et continu dans l'affichage de contrôle et l'affichage du contenu de l'arborescence [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] ; le contour des objets est ignoré.</span><span class="sxs-lookup"><span data-stu-id="0503d-234">The textual content (or inner text) of a text container and an embedded object, such as a hyperlink or table cell, is exposed as a single, continuous text stream in both the control view and the content view of the [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] tree; object boundaries are ignored.</span></span> <span data-ttu-id="0503d-235">Si un client UI Automation récupère le texte à des fins de récitation, interprétation ou analyse de quelque façon que ce soit, vous devez vérifier les cas spéciaux de la plage de texte, tels qu’un tableau avec du contenu textuel ou d’autres objets incorporés.</span><span class="sxs-lookup"><span data-stu-id="0503d-235">If a UI Automation client is retrieving the text for the purpose of reciting, interpreting, or analyzing in some manner, the text range should be checked for special cases, such as a table with textual content or other embedded objects.</span></span> <span data-ttu-id="0503d-236">Cela peut être accompli en appelant <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> pour obtenir un <xref:System.Windows.Automation.AutomationElement> pour chaque objet incorporé, puis en appelant <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> pour obtenir une plage de texte pour chaque élément ; pour cela de manière récursive jusqu'à ce que tout le contenu textuel a été récupéré.</span><span class="sxs-lookup"><span data-stu-id="0503d-236">This can be accomplished by calling <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> to obtain an <xref:System.Windows.Automation.AutomationElement> for each embedded object and then calling <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> to obtain a text range for each element; this is done recursively until all textual content has been retrieved.</span></span>  
  
 <span data-ttu-id="0503d-237">![Plages de texte sur lesquelles s’étend des objets incorporés. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Les plages de texte sur lesquelles s’étend des objets incorporés.")</span><span class="sxs-lookup"><span data-stu-id="0503d-237">![Text ranges spanned by embedded objects.](~/add/media/uia-textpattern-embeddedobjecttextranges.png "Text ranges spanned by embedded objects.")</span></span>  
<span data-ttu-id="0503d-238">Exemple de flux de texte avec des objets incorporés et leurs amplitudes</span><span class="sxs-lookup"><span data-stu-id="0503d-238">Example of a text stream with embedded objects and their range spans</span></span>  
  
 <span data-ttu-id="0503d-239"><xref:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit%2A> s’appuie sur la prochaine plus grande <xref:System.Windows.Automation.Text.TextUnit> prise en charge si la donnée <xref:System.Windows.Automation.Text.TextUnit> n’est pas pris en charge par le contrôle.</span><span class="sxs-lookup"><span data-stu-id="0503d-239"><xref:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit%2A> defers to the next largest <xref:System.Windows.Automation.Text.TextUnit> supported if the given <xref:System.Windows.Automation.Text.TextUnit> is not supported by the control.</span></span>  
  
 <span data-ttu-id="0503d-240">L’ordre, à partir de la plus petite unité au plus grand, est indiquée ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="0503d-240">The order, from smallest unit to largest, is listed below.</span></span>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1073](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1073)]  
  
 [!code-vb[UIATextPattern_snip#2073](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2073)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFromSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFromSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFromSelection();" />
      <MemberSignature Language="F#" Value="member this.RemoveFromSelection : unit -&gt; unit" Usage="textPatternRange.RemoveFromSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0503d-241">Supprime une section en surbrillance de texte, correspondant aux points de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> et <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de la plage de texte appelante, de la collection de textes mis en surbrillance dans un conteneur de texte qui prend en charge des sélections multiples et disjointes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-241">Removes a highlighted section of text, corresponding to the calling text range <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> and <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> endpoints, from an existing collection of highlighted text in a text container that supports multiple, disjoint selections.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-242">Le point d’insertion de texte se déplacera vers la zone de la mise en surbrillance supprimé.</span><span class="sxs-lookup"><span data-stu-id="0503d-242">The text insertion point will move to the area of the removed highlight.</span></span>  
  
 <span data-ttu-id="0503d-243">En fournissant une plage de texte dégénérée déplacera le point d’insertion.</span><span class="sxs-lookup"><span data-stu-id="0503d-243">Providing a degenerate text range will move the insertion point.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0503d-244">Si le fournisseur de texte ne prend pas en charge les sélections multiples disjointes (par exemple, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> doit avoir la valeur <see langword="Multiple" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-244">If text provider does not support multiple, disjoint selections (for example, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> must have a value of <see langword="Multiple" />).</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.Select" />
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignToTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignToTop);" />
      <MemberSignature Language="F#" Value="member this.ScrollIntoView : bool -&gt; unit" Usage="textPatternRange.ScrollIntoView alignToTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop">
          <span data-ttu-id="0503d-245">
            <see langword="true" /> si le contrôle de texte doit défiler de façon à ce que la plage de texte soit au même niveau que le haut de la fenêtre d'affichage ; <see langword="false" /> si elle doit être au même niveau que le bas de la fenêtre d'affichage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-245">
              <see langword="true" /> if the text control should be scrolled so the text range is flush with the top of the viewport; <see langword="false" /> if it should be flush with the bottom of the viewport.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0503d-246">Provoque le défilement vertical du contrôle de texte jusqu'à ce que la plage de texte soit visible dans la fenêtre d'affichage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-246">Causes the text control to scroll vertically until the text range is visible in the viewport.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-247"><xref:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView%2A> respecte le texte à la fois visible et masqué.</span><span class="sxs-lookup"><span data-stu-id="0503d-247"><xref:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView%2A> respects both hidden and visible text.</span></span> <span data-ttu-id="0503d-248">Le client UI Automation puisse vérifier le <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> visibilité du texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-248">The UI Automation client can check the <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> for text visibility.</span></span> <span data-ttu-id="0503d-249">Si la plage de texte est masquée, le contrôle de texte défile uniquement si le texte masqué a une ancre dans la fenêtre d’affichage.</span><span class="sxs-lookup"><span data-stu-id="0503d-249">If the text range is hidden, the text control will scroll only if the hidden text has an anchor in the viewport.</span></span>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1074](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1074)]  
  
 [!code-vb[UIATextPattern_snip#2074](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2074)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0503d-250">Si le défilement n’est pas pris en charge par le contrôle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-250">If scrolling is not supported by the control.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; unit" Usage="textPatternRange.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0503d-251">Met en surbrillance le texte dans le contrôle de texte qui correspond aux points de terminaison <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> et <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> de la plage de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-251">Highlights text in the text control corresponding to the text range <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> and <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> endpoints.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0503d-252">Si une plage de texte dégénérée est fournie, le point d’insertion de texte se déplace à la <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> point de terminaison de la plage de texte.</span><span class="sxs-lookup"><span data-stu-id="0503d-252">If a degenerate text range is provided, the text insertion point will move to the <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> endpoint of the text range.</span></span>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1075](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1075)]  
  
 [!code-vb[UIATextPattern_snip#2075](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2075)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0503d-253">Se produit lorsque la sélection de texte n’est pas prise en charge par le contrôle de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-253">Occurs when text selection is not supported by the text control.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
        <altmember cref="M:System.Windows.Automation.SelectionItemPattern.RemoveFromSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="TextPattern">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.TextPattern TextPattern { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Automation.TextPattern TextPattern" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Text.TextPatternRange.TextPattern" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TextPattern As TextPattern" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Automation::TextPattern ^ TextPattern { System::Windows::Automation::TextPattern ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TextPattern : System.Windows.Automation.TextPattern" Usage="System.Windows.Automation.Text.TextPatternRange.TextPattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.TextPattern</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0503d-254">Obtient l'élément <see cref="T:System.Windows.Automation.TextPattern" /> associé à la plage de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-254">Gets the <see cref="T:System.Windows.Automation.TextPattern" /> associated with the text range.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0503d-255">Fournisseur de texte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0503d-255">The text provider.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1076](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1076)]  
  
 [!code-vb[UIATextPattern_snip#2076](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2076)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>