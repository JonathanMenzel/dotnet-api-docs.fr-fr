<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="148f6e411fc3a15c775c1c4f9e4d927dbba2ae02" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53475787" /></Metadata><TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataTable = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une table de données en mémoire.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable> est un objet central dans la bibliothèque ADO.NET. Autres objets qui utilisent le <xref:System.Data.DataTable> incluent le <xref:System.Data.DataSet> et <xref:System.Data.DataView>.  
  
 Lors de l’accès <xref:System.Data.DataTable> objets, notez qu’ils sont conditionnelle respectant la casse. Par exemple, si un <xref:System.Data.DataTable> est appelé « mydatatable » et un autre nommé « Mydatatable », une chaîne utilisée pour rechercher une des tables est considérée comme respectant la casse. Cependant, si « mydatatable » existe et n’est pas le cas de « Mydatatable », la chaîne de recherche est considérée comme respectent pas la casse. Un <xref:System.Data.DataSet> peut contenir deux <xref:System.Data.DataTable> les objets qui ont le même <xref:System.Data.DataTable.TableName%2A> valeur de propriété mais différents <xref:System.Data.DataTable.Namespace%2A> valeurs de propriété. Pour plus d’informations sur l’utilisation de <xref:System.Data.DataTable> , consultez [création d’un DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Si vous créez un <xref:System.Data.DataTable> par programmation, vous devez d’abord définir son schéma en ajoutant <xref:System.Data.DataColumn> des objets sur le <xref:System.Data.DataColumnCollection> (accessibles via le <xref:System.Data.DataTable.Columns%2A> propriété). Pour plus d’informations sur l’ajout de <xref:System.Data.DataColumn> , consultez [Ajout de colonnes à un DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md).  
  
 Pour ajouter des lignes à une <xref:System.Data.DataTable>, vous devez d’abord utiliser le <xref:System.Data.DataTable.NewRow%2A> méthode pour retourner une nouvelle <xref:System.Data.DataRow> objet. Le <xref:System.Data.DataTable.NewRow%2A> méthode retourne une ligne avec le schéma de la <xref:System.Data.DataTable>, telle qu’elle est définie par la table <xref:System.Data.DataColumnCollection>. Le nombre maximal de lignes qui une <xref:System.Data.DataTable> pouvez store est 16 777 216. Pour plus d’informations, consultez [Ajout de données à un DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md).  
  
 Le <xref:System.Data.DataTable> contient également une collection de <xref:System.Data.Constraint> objets qui peuvent être utilisés pour garantir l’intégrité des données. Pour plus d’informations, consultez [contraintes de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
 Il existe de nombreux <xref:System.Data.DataTable> événements qui peuvent être utilisées pour déterminer le moment où les modifications sont apportées à une table. Il s'agit notamment de <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting> et <xref:System.Data.DataTable.RowDeleted>. Pour plus d’informations sur les événements qui peut être utilisé avec un <xref:System.Data.DataTable>, consultez [gestion des événements de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
 Lorsqu’une instance de <xref:System.Data.DataTable> est créé, certains de la lecture/écriture les propriétés sont définies sur les valeurs initiales. Pour obtenir la liste de ces valeurs, consultez le <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> rubrique du constructeur.  
  
> [!NOTE]
>  Le <xref:System.Data.DataSet> et <xref:System.Data.DataTable> objets héritent <xref:System.ComponentModel.MarshalByValueComponent>et prennent en charge la <xref:System.Runtime.Serialization.ISerializable> interface pour .NET Framework remoting. Ceux-ci sont les seuls objets ADO.NET que vous pouvez utiliser pour le .NET Framework remoting.  
  
   
  
## Examples  
 L’exemple suivant crée deux <xref:System.Data.DataTable> objets et l’autre <xref:System.Data.DataRelation> de l’objet et ajoute les nouveaux objets à un <xref:System.Data.DataSet>. Les tables sont ensuite affichées dans un <xref:System.Windows.Forms.DataGridView> contrôle.  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 Cet exemple montre comment créer un DataTable manuellement avec les définitions de schéma spécifique :  
  
-   Créer plusieurs tables de données et définir les colonnes initiales.  
  
-   Créer les contraintes de table.  
  
-   Insérez les valeurs et afficher les tables.  
  
-   Créer des colonnes d’expression et afficher les tables.  
  
 Vous trouverez des projets c# et Visual Basic avec cet exemple de code sur [exemples de Code développeur](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914).  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est sécurisé pour les opérations de lecture multithreads. Vous devez synchroniser des opérations d’écriture.</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataTable" />.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataTable" /> sans argument.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur définit les valeurs initiales pour toutes les propriétés de la <xref:System.Data.DataTable> objet. Le tableau suivant répertorie les propriétés et leurs valeurs par défaut. Lorsqu’une instance de <xref:System.Data.DataTable> est créée, les propriétés sont définies sur les valeurs initiales en lecture/écriture.  
  
|Property|Valeur par défaut|  
|--------------|-------------------|  
|**CaseSensitive**|Identique à celle du parent <xref:System.Data.DataSet>, s’il appartient à un. Sinon, `false`.|  
|**DisplayExpression**|une chaîne vide ( » »)|  
|**Paramètres régionaux**|Identique à celle du parent <xref:System.Data.DataSet> l’objet <xref:System.Globalization.CultureInfo> (retourné par la <xref:System.Data.DataSet.Locale%2A> propriété) ; si aucun parent n’existe, la valeur par défaut est le système actuel <xref:System.Globalization.CultureInfo>.|  
|**MinimumCapacity**|50 lignes.|  
  
 Vous pouvez modifier la valeur d’une de ces propriétés via un appel séparé à la propriété.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Data.DataTable> avec <xref:System.Data.DataColumn> et <xref:System.Data.DataRow>et l’affiche dans un <xref:System.Windows.Forms.DataGridView> contrôle.  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable tableName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Nom à attribuer à la table. Si <paramref name="tableName" /> est <see langword="null" /> ou une chaîne vide, un nom par défaut est attribué lors de son ajout à <see cref="T:System.Data.DataTableCollection" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataTable" /> avec le nom de table spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataTable> et l’affiche dans un <xref:System.Windows.Forms.DataGridView> contrôle.  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Données nécessaires à la sérialisation et à la désérialisation d’un objet.</param>
        <param name="context">Source et destination d’un flux sérialisé donné.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataTable" /> avec <see cref="T:System.Runtime.Serialization.SerializationInfo" /> et <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation de la <xref:System.Data.DataTable> constructeur est requis pour <xref:System.Runtime.Serialization.ISerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string * string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (tableName, tableNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Nom à attribuer à la table. Si <paramref name="tableName" /> est <see langword="null" /> ou une chaîne vide, un nom par défaut est attribué lors de son ajout à <see cref="T:System.Data.DataTableCollection" />.</param>
        <param name="tableNamespace">Espace de noms de la représentation XML des données stockées dans le <see langword="DataTable" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataTable" /> avec le nom de table et l'espace de noms spécifiés.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataTable.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Valide toutes les modifications apportées à cette table depuis le dernier appel à <see cref="M:System.Data.DataTable.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Data.DataTable.AcceptChanges%2A> est appelé, tout <xref:System.Data.DataRow> objet toujours en mode édition termine correctement ses modifications. Le <xref:System.Data.DataRowState> change également : tous les `Added` et `Modified` lignes deviennent `Unchanged`, et `Deleted` lignes sont supprimées.  
  
 Le <xref:System.Data.DataTable.AcceptChanges%2A> méthode est généralement appelée sur un <xref:System.Data.DataTable> une fois que vous tentez de mettre à jour le <xref:System.Data.DataSet> à l’aide de la <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant teste chaque table d’erreurs. Si les erreurs de la table peuvent être rapprochés (en le passant à une fonction non définie), <xref:System.Data.DataTable.AcceptChanges%2A> est appelée ; sinon, <xref:System.Data.DataTable.RejectChanges%2A> est appelée.  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataTable.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commence l'initialisation d'un <see cref="T:System.Data.DataTable" /> qui est utilisé dans un formulaire ou par un autre composant. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’environnement de conception de Visual Studio .NET utilise cette méthode pour démarrer l’initialisation d’un composant qui est utilisé sur un formulaire ou par un autre composant. Le <xref:System.Data.DataTable.EndInit%2A> méthode termine l’initialisation. À l’aide de la <xref:System.Data.DataTable.BeginInit%2A> et <xref:System.Data.DataTable.EndInit%2A> méthodes empêche le contrôle de l’utilisation avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberSignature Language="F#" Value="member this.BeginLoadData : unit -&gt; unit" Usage="dataTable.BeginLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Désactive les notifications, la gestion d'index et les contraintes lors du chargement de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Data.DataTable.BeginLoadData%2A> conjointement avec <xref:System.Data.DataTable.LoadDataRow%2A> et <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataTable.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique si les comparaisons de chaînes au sein de la table respectent la casse.</summary>
        <value><see langword="true" /> si la comparaison respecte la casse ; sinon, <see langword="false" />. La valeur par défaut est celle de la propriété <see cref="T:System.Data.DataSet" /> de l'objet <see cref="P:System.Data.DataSet.CaseSensitive" /> parent, ou <see langword="false" /> si <see cref="T:System.Data.DataTable" /> a été créé indépendamment de <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.CaseSensitive%2A> propriété affecte les comparaisons de chaînes dans le tri, la recherche et le filtrage.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Data.DataTable.Select%2A> méthode deux fois sur un <xref:System.Data.DataTable>. La première fois, le <xref:System.Data.DataTable.CaseSensitive%2A> propriété est définie sur `false`, le deuxième à `true`.  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ChildRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableChildRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection des relations enfants de ce <see cref="T:System.Data.DataTable" />.</summary>
        <value><see cref="T:System.Data.DataRelationCollection" /> qui contient les relations enfants pour la table. Une collection vide est retournée si aucun objet <see cref="T:System.Data.DataRelation" /> n'existe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Data.DataRelation> définit la relation entre deux tables. En règle générale, les deux tables sont liées via un champ unique qui contient les mêmes données. Par exemple, une table qui contient les données d’adresse peut avoir un seul champ contenant des codes qui représentent les pays/régions. Une seconde table qui contient les données de pays/région aura un champ unique qui contient le code qui identifie le pays/région, et c’est ce code qui est inséré dans le champ correspondant dans la première table. Un <xref:System.Data.DataRelation>, puis, contient au moins quatre éléments d’information : (1) le nom de la première table, (2) le nom de colonne dans la première table, (3) le nom de la deuxième table et (4) le nom de colonne dans la seconde table.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataTable.ChildRelations%2A> propriété pour retourner chaque enfant <xref:System.Data.DataRelation> dans un <xref:System.Data.DataTable>. Chaque relation est ensuite utilisée en tant qu’argument dans le <xref:System.Data.DataRow.GetChildRows%2A> méthode de la <xref:System.Data.DataRow> pour retourner un tableau de lignes. La valeur de chaque colonne dans la ligne s’affiche ensuite.  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface toutes les données de <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Toutes les lignes dans toutes les tables sont supprimées. Une exception est générée si la table a des relations enfants appliquées qui provoquent des lignes enfants orphelines.  
  
 Si le <xref:System.Data.DataSet> est lié à un <xref:System.Xml.XmlDataDocument>, l’appel <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> ou <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> déclenche le <xref:System.NotSupportedException>. Pour éviter cette situation, parcourez chaque table et supprimez les lignes une à la fois. Lorsque vous utilisez <xref:System.Data.DataTable.NewRow%2A> pour créer de nouvelles lignes, les lignes doivent être traités avant d’appeler <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 L’exemple suivant efface la table de toutes les données.  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataTable&#xA;override this.Clone : unit -&gt; System.Data.DataTable" Usage="dataTable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clone la structure de <see cref="T:System.Data.DataTable" />, y compris tous les schémas et contraintes <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Nouveau <see cref="T:System.Data.DataTable" /> possédant le même schéma que le <see cref="T:System.Data.DataTable" /> en cours.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ces classes ont été dérivées, le clone sera également les mêmes classes dérivées.  
  
 Clone crée un nouveau <xref:System.Data.DataTable> avec la même structure que l’original <xref:System.Data.DataTable>, mais ne copie ne pas toutes les données (la nouvelle <xref:System.Data.DataTable> ne contient pas `DataRows`). Pour copier la structure et les données dans un nouveau <xref:System.Data.DataTable>, utilisez <xref:System.Data.DataTable.Copy%2A>.  
  
   
  
## Examples  
 L’exemple suivant montre comment mettre à jour de la structure et les contraintes de la table de destination une fois que vous exécutez DataTable.Clone. La classe ClonedDataTable renvoie une table de destination et inclut tous les événements de mise à jour. Après le clonage, les modifications de la structure de la table source ne sont pas répercutées dans la table de destination. Plus précisément, cet exemple est :  
  
-   Mettre à jour les modifications des colonnes dans la table source.  
  
-   Mettre à jour les modifications de UniqueConstraint dans la table source.  
  
-   Mettre à jour les modifications de la classe ForeignKeyConstraint dans la table source.  
  
 Vous trouverez des projets c# et Visual Basic avec cet exemple de code sur [exemples de Code développeur](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable).  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 Cet exemple montre comment modifier des données dans un DataTable et mettre à jour de la source de données.  
  
 Tout d’abord, créez une base de données :  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 Vous pouvez maintenant compiler et exécuter l’exemple. [Comment modifier des données dans la table de données et de mise à jour de la source de données](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) a des projets Visual Basic et c# de cet exemple.  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après la modification d'une valeur du <see cref="T:System.Data.DataColumn" /> spécifié dans un <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [gestion des événements de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lors de la modification d'une valeur du <see cref="T:System.Data.DataColumn" /> spécifié dans un <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [gestion des événements de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Columns : System.Data.DataColumnCollection" Usage="System.Data.DataTable.Columns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection des colonnes qui appartiennent à cette table.</summary>
        <value><see cref="T:System.Data.DataColumnCollection" /> qui contient la collection des objets <see cref="T:System.Data.DataColumn" /> pour la table. Une collection vide est retournée si aucun objet <see cref="T:System.Data.DataColumn" /> n'existe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataColumnCollection> détermine le schéma d’une table en définissant le type de données de chaque colonne.  
  
   
  
## Examples  
 L’exemple suivant imprime chaque valeur de chaque ligne dans une table à l’aide de la <xref:System.Data.DataTable.Columns%2A> propriété.  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Compute : string * string -&gt; obj" Usage="dataTable.Compute (expression, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Expression à calculer.</param>
        <param name="filter">Filtre permettant de limiter le nombre de lignes dont le résultat de l'évaluation est contenu dans l'expression.</param>
        <summary>Calcule l'expression donnée sur les lignes en cours qui passent les critères du filtre.</summary>
        <returns><see cref="T:System.Object" /> ayant pour valeur le résultat du calcul. Si l'expression prend la valeur Null, la valeur de retour est <see cref="F:System.DBNull.Value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `expression` paramètre nécessite une fonction d’agrégation. Par exemple, ce qui suit est une expression juridique :  
  
 `Count(Quantity)`  
  
 Mais cette expression n’est pas :  
  
 `Sum (Quantity * UnitPrice)`  
  
 Si vous devez effectuer une opération sur deux ou plusieurs colonnes, vous devez créer un <xref:System.Data.DataColumn>, définissez son <xref:System.Data.DataColumn.Expression%2A> propriété à une expression appropriée et utiliser une expression d’agrégation sur la colonne résultante. Dans ce cas, étant donné un <xref:System.Data.DataColumn> avec le nom « total » et le <xref:System.Data.DataColumn.Expression%2A> affectée à cette propriété :  
  
 `"Quantity * UnitPrice"`  
  
 L’argument expression pour la <xref:System.Data.DataTable.Compute%2A> méthode serait alors cela :  
  
 `Sum(total)`  
  
 Le deuxième paramètre, `filter`, détermine les lignes qui sont utilisés dans l’expression. Par exemple, si la table contient une colonne de date nommée « colDate », vous pouvez limiter les lignes avec l’expression suivante :  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 Pour plus d’informations sur la création d’expressions pour les deux paramètres, consultez le <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> propriété.  
  
   
  
## Examples  
 L’exemple suivant additionne les valeurs d’une colonne nommée « Total », pour le vendeur dont le numéro d’identification est cinq.  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraints : System.Data.ConstraintCollection" Usage="System.Data.DataTable.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de contraintes gérée par cette table.</summary>
        <value><see cref="T:System.Data.ConstraintCollection" /> qui contient la collection des objets <see cref="T:System.Data.Constraint" /> pour la table. Une collection vide est retournée si aucun objet <see cref="T:System.Data.Constraint" /> n'existe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Data.ForeignKeyConstraint> restreint l’action effectuée lorsqu’une valeur dans une colonne (ou les colonnes) est supprimée ou mise à jour. Une telle contrainte est destinée à être utilisé avec les colonnes de clé primaire. Dans une relation parent/enfant entre deux tables, la suppression d’une valeur de la table parente peut affecter les lignes enfants de l’une des manières suivantes.  
  
-   L’enfant lignes peuvent également être supprimés (une action en cascade).  
  
-   Les valeurs dans la colonne enfant (ou les colonnes) peuvent être définies aux valeurs null.  
  
-   Les valeurs dans la colonne enfant (ou les colonnes) peuvent être définies pour les valeurs par défaut.  
  
-   Une exception peut être générée.  
  
 Un <xref:System.Data.UniqueConstraint> devient actif lorsque vous tentez de définir une valeur dans une clé primaire sur une valeur non unique.  
  
   
  
## Examples  
 L’exemple suivant ajoute un <xref:System.Data.ForeignKeyConstraint> à la collection de contraintes.  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataTable" Usage="dataTable.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie à la fois la structure et les données de ce <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Nouveau <see cref="T:System.Data.DataTable" /> possédant la même structure (schémas et contraintes de table) et les mêmes données que ce <see cref="T:System.Data.DataTable" />.  
  
Si ces classes ont été dérivées, la copie appartient également aux mêmes classes dérivées.  
  
 <see cref="M:System.Data.DataTable.Copy" /> crée un nouveau <see cref="T:System.Data.DataTable" /> avec la même structure et les mêmes données que le <see cref="T:System.Data.DataTable" />d'origine. Pour copier la structure dans un nouveau <see cref="T:System.Data.DataTable" /> sans les données, utilisez <see cref="M:System.Data.DataTable.Clone" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataTable.Copy%2A> méthode pour créer une copie de l’original <xref:System.Data.DataTable>. Le nom de l’espace de noms n’est pas conservé si elle est héritée d’un parent <xref:System.Data.DataTable> ou <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataTable.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Data.DataTableReader" /> correspondant aux données dans ce <see cref="T:System.Data.DataTable" />.</summary>
        <returns><see cref="T:System.Data.DataTableReader" /> contenant un jeu de résultats, correspondant à l'instance de <see cref="T:System.Data.DataTable" /> source.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'application console suivante crée une instance de l'objet <xref:System.Data.DataTable>. Cet exemple passe ensuite le plein <xref:System.Data.DataTable> à une procédure qui appelle le <xref:System.Data.DataTable.CreateDataReader%2A> (méthode), qui effectue une itération dans les résultats contenus dans le <xref:System.Data.DataTableReader>.  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 L'exemple affiche la sortie suivante dans la fenêtre de console :  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : unit -&gt; System.Data.DataTable&#xA;override this.CreateInstance : unit -&gt; System.Data.DataTable" Usage="dataTable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une instance de <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Nouvelle expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Data.DataTable.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDataSetDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Data.DataSet" /> auquel cette table appartient.</summary>
        <value><see cref="T:System.Data.DataSet" /> auquel cette table appartient.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un contrôle est lié aux données un <xref:System.Data.DataTable>, et que la table appartient à un <xref:System.Data.DataSet>, vous pouvez accéder à la <xref:System.Data.DataSet> via cette propriété.  
  
   
  
## Examples  
 L’exemple suivant retourne le parent <xref:System.Data.DataSet> d’une table donnée par le biais du <xref:System.Data.DataTable.DataSet%2A> propriété.  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultView : System.Data.DataView" Usage="System.Data.DataTable.DefaultView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une vue personnalisée de la table qui peut comprendre une vue filtrée ou une position de curseur.</summary>
        <value>Objet <see cref="T:System.Data.DataView" /> associé au <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.DefaultView%2A> propriété retourne un <xref:System.Data.DataView> vous pouvez utiliser pour trier, filtrer et rechercher un <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 L’exemple suivant définit une propriété de la <xref:System.Data.DataTable> l’objet <xref:System.Data.DataView> via la <xref:System.Data.DataTable.DefaultView%2A> propriété. L’exemple illustre également la liaison d’un <xref:System.Windows.Forms.DataGridView> le contrôle à un <xref:System.Data.DataTable> nommé « Fournisseurs » qui inclut une colonne nommée « CompanyName ».  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayExpression : string with get, set" Usage="System.Data.DataTable.DisplayExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDisplayExpressionDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'expression qui retourne une valeur utilisée pour représenter cette table dans l'interface utilisateur. La propriété <see langword="DisplayExpression" /> vous permet d'afficher le nom de cette table dans une interface utilisateur.</summary>
        <value>Chaîne d'affichage.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataTable.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termine l'initialisation d'un <see cref="T:System.Data.DataTable" /> qui est utilisé dans un formulaire ou par un autre composant. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’environnement de conception de Visual Studio .NET utilise cette méthode pour terminer l’initialisation d’un composant qui est utilisé sur un formulaire ou par un autre composant. Le <xref:System.Data.DataTable.BeginInit%2A> méthode démarre l’initialisation. À l’aide de la <xref:System.Data.DataTable.BeginInit%2A> et <xref:System.Data.DataTable.EndInit%2A> méthodes empêche le contrôle de l’utilisation avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberSignature Language="F#" Value="member this.EndLoadData : unit -&gt; unit" Usage="dataTable.EndLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Active les notifications, la gestion d'index et les contraintes après le chargement de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Data.DataTable.EndLoadData%2A> conjointement avec <xref:System.Data.DataTable.LoadDataRow%2A> et <xref:System.Data.DataTable.BeginLoadData%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataTable.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection d'informations utilisateur personnalisées.</summary>
        <value><see cref="T:System.Data.PropertyCollection" /> qui contient les informations utilisateur personnalisées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.ExtendedProperties%2A> pour ajouter des informations personnalisées à un <xref:System.Data.DataTable>. Ajouter des informations avec le `Add` (méthode). Récupérer des informations avec le `Item` (méthode).  
  
 Les propriétés étendues doivent être de type <xref:System.String>. Les propriétés qui ne sont pas de type String ne sont pas conservées lorsque le <xref:System.Data.DataTable> est écrit au format XML.  
  
   
  
## Examples  
 L’exemple suivant ajoute une valeur d’horodatage pour le <xref:System.Data.DataTable> via la <xref:System.Data.DataTable.ExtendedProperties%2A> propriété.  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberSignature Language="F#" Value="val mutable fInitInProgress : bool" Usage="System.Data.DataTable.fInitInProgress" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vérifie si l'initialisation est en cours. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une copie du <see cref="T:System.Data.DataTable" /> contenant l'ensemble des modifications qui lui ont été apportées depuis son dernier chargement ou depuis l'appel à <see cref="M:System.Data.DataTable.AcceptChanges" />.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataTable" Usage="dataTable.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une copie du <see cref="T:System.Data.DataTable" /> qui contient l'ensemble des modifications qui lui ont été apportées depuis son chargement ou depuis le dernier appel à <see cref="M:System.Data.DataTable.AcceptChanges" />.</summary>
        <returns>Copie des modifications de ce <see cref="T:System.Data.DataTable" /> ou <see langword="null" /> si aucune modification n'est repérée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée un <xref:System.Data.DataSet> contenant une copie de toutes les lignes dans la version d’origine <xref:System.Data.DataSet> ayant des modifications en attente. Les contraintes de relation peuvent entraîner des lignes inchangées supplémentaires à ajouter à la nouvelle <xref:System.Data.DataSet> si les lignes inchangées contiennent des clés primaires correspondant aux clés étrangères dans les lignes modifiées. La méthode retourne `null` (`Nothing` en Visual Basic) s’il en existe aucune ligne dans la version d’origine <xref:System.Data.DataSet> avec modifications en attente.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataTable" Usage="dataTable.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Une des valeurs de <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Obtient une copie du <see cref="T:System.Data.DataTable" /> contenant l'ensemble des modifications qui lui ont été apportées depuis son dernier chargement ou depuis l'appel à <see cref="M:System.Data.DataTable.AcceptChanges" />, filtrée par <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Copie filtrée du <see cref="T:System.Data.DataTable" /> sur lequel des actions peuvent être exécutées, et ensuite refusionnées dans <see cref="T:System.Data.DataTable" /> à l'aide de <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Si aucune ligne du <see cref="T:System.Data.DataRowState" /> souhaité n'est détectée, la méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.GetChanges%2A> méthode est utilisée pour générer un deuxième <xref:System.Data.DataTable> objet qui contient uniquement les modifications introduites dans la version d’origine. Utilisez le `rowStates` argument pour spécifier le type de l’objet nouveau doit inclure des modifications.  
  
 Les contraintes de relation peuvent entraîner des lignes inchangées parent à inclure.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataTableSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataTable.GetDataTableSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Instance de <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</param>
        <summary>Cette méthode retourne une instance de <see cref="T:System.Xml.Schema.XmlSchemaSet" /> contenant WSDL (Web Services Description Language), lequel décrit <see cref="T:System.Data.DataTable" /> pour les services Web.</summary>
        <returns>Instance <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberSignature Language="F#" Value="member this.GetErrors : unit -&gt; System.Data.DataRow[]" Usage="dataTable.GetErrors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un tableau d'objets <see cref="T:System.Data.DataRow" /> qui contiennent des erreurs.</summary>
        <returns>Tableau d'objets <see cref="T:System.Data.DataRow" /> qui contiennent des erreurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourne la liste des <xref:System.Data.DataRow> objets ayant <xref:System.Data.DataRow.RowError%2A> définie. Par exemple, des erreurs peuvent se produire lors de l’appel <xref:System.Data.Common.DataAdapter.Update%2A> avec <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> défini sur `true`. N’appelez pas <xref:System.Data.DataTable.AcceptChanges%2A> sur le <xref:System.Data.DataTable> jusqu'à ce que vous résolvez toutes les erreurs et soumettez à nouveau le <xref:System.Data.DataSet> pour la mise à jour.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataTable.GetErrors%2A> méthode pour retourner un tableau de <xref:System.Data.DataRow> objets présentant des erreurs.  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">DataTables (ADO.NET)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataTable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" /> qui contient les données sérialisées associées à <see cref="T:System.Data.DataTable" />.</param>
        <param name="context">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui contient la source et la destination du flux sérialisé associé à <see cref="T:System.Data.DataTable" />.</param>
        <summary>Remplit un objet d’informations de sérialisation avec les données nécessaires pour sérialiser <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="info" /> est une référence null (<see langword="Nothing" /> en Visual Basic).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberSignature Language="F#" Value="abstract member GetRowType : unit -&gt; Type&#xA;override this.GetRowType : unit -&gt; Type" Usage="dataTable.GetRowType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le type de ligne.</summary>
        <returns>Type de <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberSignature Language="F#" Value="abstract member GetSchema : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataTable.GetSchema " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns><see cref="T:System.Xml.Schema.XmlSchema" /> qui décrit la représentation XML de l’objet qui est généré par la méthode <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> et utilisé par la méthode <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataTable.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant s'il existe des erreurs dans une des lignes d'une table du <see cref="T:System.Data.DataSet" /> auquel appartient la table.</summary>
        <value><see langword="true" /> s'il existe des erreurs ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comme les utilisateurs travaillent sur un jeu de données contenues dans un <xref:System.Data.DataTable>, vous pouvez marquer chaque modification avec une erreur si elle entraîne un échec de validation. Vous pouvez marquer l’intégralité d’un <xref:System.Data.DataRow> avec un message d’erreur à l’aide du <xref:System.Data.DataRow.RowError%2A> propriété. Vous pouvez également définir des erreurs pour chaque colonne de la ligne avec la <xref:System.Data.DataRow.SetColumnError%2A> (méthode).  
  
 Avant la mise à jour une source de données avec un <xref:System.Data.DataSet>, il est recommandé d’appeler d’abord la <xref:System.Data.DataSet.GetChanges%2A> méthode sur la cible <xref:System.Data.DataSet>. La méthode entraîne un <xref:System.Data.DataSet> qui contient uniquement les modifications apportées à l’original. Avant d’envoyer le <xref:System.Data.DataSet> à la source de données pour la mise à jour, vérifiez le <xref:System.Data.DataTable.HasErrors%2A> propriété de chaque table pour voir si des erreurs ont été attachées aux lignes ou colonnes dans les lignes.  
  
 Après la réconciliation de chaque erreur, désactivez les erreurs avec le <xref:System.Data.DataRow.ClearErrors%2A> méthode de la `DataRow`.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataTable.HasErrors%2A> propriété à vérifier si une table contient des erreurs.  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberSignature Language="F#" Value="member this.ImportRow : System.Data.DataRow -&gt; unit" Usage="dataTable.ImportRow row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row"><see cref="T:System.Data.DataRow" /> à importer.</param>
        <summary>Copie <see cref="T:System.Data.DataRow" /> dans un <see cref="T:System.Data.DataTable" /> en préservant tous les paramètres de propriété, ainsi que les valeurs d'origine et actuelles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Data.DataTable.NewRow%2A> ajoute une ligne à la table en utilisant le schéma de table existant, mais avec les valeurs par défaut pour la ligne et définit le <xref:System.Data.DataRowState> à `Detached`. Appel <xref:System.Data.DataTable.ImportRow%2A> conserve existant <xref:System.Data.DataRowState> ainsi que les autres valeurs dans la ligne. Si le `DataRow` qui lui est passé comme un paramètre est dans un état détaché, il est ignoré, et aucune exception n’est levée.  
  
 La nouvelle ligne sera ajoutée à la fin de la table de données.  
  
 Si la nouvelle ligne viole une contrainte, il ne sera ajoutée à la table de données.  
  
 Vous pouvez obtenir l’index de la nouvelle ligne avec DataTable.Rows.Find et DataTable.Rows.IndexOf. Pour plus d'informations, consultez <xref:System.Data.DataRowCollection> et <xref:System.Data.DataTable.Rows%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5cb86d48-a987-4af4-80e0-8cc2c8373d62">Manipulation de données dans un DataTable (ADO.NET)</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.ISupportInitializeNotification.Initialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit une fois que le <see cref="T:System.Data.DataTable" /> est initialisé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations, consultez <xref:System.Data.DataTable.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataTable.IsInitialized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ISupportInitializeNotification.IsInitialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Data.DataTable" /> est initialisé.</summary>
        <value><see langword="true" /> pour indiquer que le composant a terminé l'initialisation ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourne l’état de la <xref:System.Data.DataTable> pendant qu’il est en cours de construction, par exemple par Visual Studio. Le <xref:System.Data.DataTable.BeginInit%2A> méthode lui affecte `false` et <xref:System.Data.DataTable.EndInit%2A> méthode lui affecte `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remplit un <see cref="T:System.Data.DataTable" /> avec des valeurs issues d'une source de données à l'aide du <see cref="T:System.Data.IDataReader" /> fourni. Si <see langword="DataTable" /> contient déjà des lignes, les données entrantes à partir de la source de données sont fusionnées avec les lignes existantes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Load` méthode peut être utilisée dans plusieurs scénarios courants, tous centrés sur l’obtention de données à partir d’une source de données spécifiée et en l’ajoutant au conteneur de données actuel (dans ce cas, un `DataTable`). Les scénarios suivants décrivent l’utilisation standard pour un `DataTable`, décrivant sa mise à jour et le comportement de la fusion.  
  
 Un `DataTable` synchronise ou met à jour avec une source de données primaire. Le `DataTable` effectue le suivi des modifications, autorisant la synchronisation avec la source de données primaire. En outre, un `DataTable` peut accepter des données incrémentielles à partir d’une ou plusieurs sources de données secondaires. Le `DataTable` n’est pas responsable du suivi des modifications afin de permettre la synchronisation avec la source de données secondaire.  
  
 Étant donné ces deux sources de données hypothétiques, un utilisateur est susceptible de demander un des comportements suivants :  
  
-   Initialiser `DataTable` à partir d’une source de données principale. Dans ce scénario, l’utilisateur souhaite initialiser vide `DataTable` avec les valeurs de la source de données primaire. Plus tard l’utilisateur envisage de propager les modifications à la source de données primaire.  
  
-   Conserver les modifications et ré-synchroniser à partir de la source de données primaire. Dans ce scénario, l’utilisateur souhaite prendre le `DataTable` rempli dans le scénario précédent et exécuter une synchronisation incrémentielle avec la source de données principale, en conservant les modifications apportées dans le `DataTable`.  
  
-   Flux de données incrémentielles à partir de sources de données secondaires. Dans ce scénario, l’utilisateur souhaite fusionner les modifications à partir d’une ou plusieurs sources de données secondaires et propager ces modifications à la source de données primaire.  
  
 Le `Load` méthode rend tous ces scénarios possibles. Alors que les autres des surcharges pour cette méthode permet de spécifier un paramètre d’option de chargement, indiquant comment les lignes déjà présentes dans un <xref:System.Data.DataTable> associées aux lignes en cours de chargement. (La surcharge qui ne vous permet de spécifier le comportement utilise l’option de chargement par défaut). Le tableau suivant décrit les trois options de chargement fournies par le <xref:System.Data.LoadOption> énumération. Dans chaque cas, la description indique le comportement lorsque la clé primaire d’une ligne dans les données entrantes correspond à la clé primaire d’une ligne existante.  
  
|Option de chargement|Description |  
|-----------------|-----------------|  
|`PreserveChanges` (par défaut)|Met à jour la version d’origine de la ligne avec la valeur de la ligne entrante.|  
|`OverwriteChanges`|Met à jour les versions actuelles et d’origine de la ligne avec la valeur de la ligne entrante.|  
|`Upsert`|Met à jour la version actuelle de la ligne avec la valeur de la ligne entrante.|  
  
 En règle générale, le `PreserveChanges` et `OverwriteChanges` options sont destinées aux scénarios dans lesquels l’utilisateur doit synchroniser le `DataSet` et ses modifications avec la source de données primaire. Le `Upsert` option facilite l’agrégation des modifications à partir d’une ou plusieurs sources de données secondaires.  
  
   
  
## Examples  
 L’exemple suivant illustre plusieurs des problèmes impliqués par l’appel le <xref:System.Data.DataTable.Load%2A> (méthode). Tout d’abord, l’exemple se concentre sur les problèmes de schéma, notamment la déduction d’un schéma à partir de la charger <xref:System.Data.IDataReader>, puis gestion de schémas incompatibles et schémas avec des colonnes manquantes ou supplémentaires. L’exemple se concentre ensuite sur les problèmes de données, notamment la gestion des différentes options de chargement.  
  
> [!NOTE]
>  Cet exemple montre comment utiliser une des versions surchargées de `Load`. Pour obtenir des exemples qui peuvent être disponibles, consultez les rubriques de surcharges individuelles.  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader -&gt; unit" Usage="dataTable.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Data.IDataReader" /> qui fournit un jeu de résultats.</param>
        <summary>Remplit un <see cref="T:System.Data.DataTable" /> avec des valeurs issues d'une source de données à l'aide du <see cref="T:System.Data.IDataReader" /> fourni. Si <see cref="T:System.Data.DataTable" /> contient déjà des lignes, les données entrantes à partir de la source de données sont fusionnées avec les lignes existantes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.Load%2A> méthode consomme le premier jeu de résultats de la charger <xref:System.Data.IDataReader>et après l’achèvement réussi, définit la position du lecteur sur le jeu de résultats suivant, le cas échéant. Lors de la conversion de données, le `Load` méthode utilise les mêmes règles de conversion que le <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> (méthode).  
  
 Le <xref:System.Data.DataTable.Load%2A> méthode doit prendre en compte trois problèmes spécifiques lors du chargement des données à partir d’un <xref:System.Data.IDataReader> instance : opérations de schéma, les données et les événements. Lorsque vous travaillez avec le schéma, le <xref:System.Data.DataTable.Load%2A> méthode peut rencontrer des conditions comme décrit dans le tableau suivant. Les opérations de schéma ont lieu pour tous les jeux de résultats importés, même ceux ne contenant aucune donnée.  
  
|Condition|Comportement|  
|---------------|--------------|  
|Le <xref:System.Data.DataTable> ne possède aucun schéma.|Le <xref:System.Data.DataTable.Load%2A> méthode déduit le schéma basé sur le jeu de résultats d’importé <xref:System.Data.IDataReader>.|  
|Le <xref:System.Data.DataTable> dispose d’un schéma, mais il n’est pas compatible avec le schéma chargé.|Le <xref:System.Data.DataTable.Load%2A> méthode lève une exception correspondant à l’erreur particulière qui se produit lorsque vous tentez de charger des données dans le schéma incompatible.|  
|Les schémas sont compatibles, mais le schéma du jeu de résultats chargé contient des colonnes qui n’existent pas dans le <xref:System.Data.DataTable>.|Le <xref:System.Data.DataTable.Load%2A> méthode ajoute les colonnes supplémentaires à `DataTable`du schéma. La méthode lève une exception si correspondant colonnes dans le <xref:System.Data.DataTable> et le jeu de résultats chargés ne sont pas compatibles de la valeur. La méthode récupère également les informations de contrainte à partir du jeu de résultats pour toutes les colonnes ajoutées. Sauf dans le cas de contrainte de clé primaire, ces informations de contrainte sont utilisées uniquement si actuel <xref:System.Data.DataTable> ne contient pas de colonnes au début de l’opération de chargement.|  
|Les schémas sont compatibles, mais le schéma du jeu de résultats chargé contient moins de colonnes que le `DataTable`.|Si une colonne manquante a une valeur par défaut définie ou type de données de la colonne est nullable, le <xref:System.Data.DataTable.Load%2A> méthode autorise les lignes à ajouter, en remplaçant la valeur par défaut ou `null` valeur pour la colonne manquante. Si aucune valeur par défaut ou `null` peut être utilisé, puis le `Load` méthode lève une exception. Si aucune valeur par défaut spécifique n’a été fourni, le `Load` méthode utilise la `null` valeur que la valeur par défaut implicite.|  
  
 Avant de considérer que le comportement de la `Load` méthode en termes d’opérations de données, considérez que chaque ligne dans un <xref:System.Data.DataTable> tient à jour la valeur actuelle et la valeur d’origine pour chaque colonne. Ces valeurs peuvent être équivalents, ou peut être différents si les données dans la ligne a été modifiées depuis le remplissage du `DataTable`.  Pour plus d’informations, consultez [États des lignes et des Versions de ligne](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Cette version de la `Load` méthode tente de conserver les valeurs actuelles dans chaque ligne, en laissant intactes les valeurs d’origine. (Si vous souhaitez mieux contrôler le comportement des données entrantes, consultez <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) Si la ligne existante et la ligne entrante contiennent des valeurs de clé primaire correspondantes, la ligne est traitée à l’aide de sa valeur d’état de ligne actuelle, sinon il est traité comme une nouvelle ligne.  
  
 En termes d’opérations de l’événement, le <xref:System.Data.DataTable.RowChanging> événement se produit avant la modification de chaque ligne et le <xref:System.Data.DataTable.RowChanged> événement se produit après chaque ligne a été modifiée. Dans chaque cas, le <xref:System.Data.DataRowChangeEventArgs.Action%2A> propriété de la <xref:System.Data.DataRowChangeEventArgs> instance passée au gestionnaire d’événements contient des informations sur l’action particulière associée à l’événement. Valeur de cette action dépend de l’état de la ligne avant l’opération de chargement. Dans chaque cas, les deux événements se produisent, et l’action est la même pour chacun. L’action peut être appliquée à la version actuelle ou d’origine de chaque ligne, ou les deux, selon l’état actuel de la ligne.  
  
 Le tableau suivant présente le comportement de la `Load` (méthode). La dernière ligne (étiquetée « (absente) ») décrit le comportement pour les lignes entrantes qui ne correspondent pas n’importe quelle ligne existante. Chaque cellule dans cette table décrit la valeur d’origine et actuelle pour un champ dans une ligne, ainsi que la <xref:System.Data.DataRowState> pour la valeur après la `Load` méthode est terminée. Dans ce cas, la méthode ne vous permet d’indiquer l’option de chargement et utilise la valeur par défaut, `PreserveChanges`.  
  
|DataRowState existant|Valeurs après `Load` (méthode) et l’action d’événement|  
|---------------------------|--------------------------------------------------|  
|Ajouté|Actuel = \<existant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<modifié ><br /><br /> RowAction = ChangeOriginal|  
|Modifiée le|Actuel = \<existant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<modifié ><br /><br /> RowAction = ChangeOriginal|  
|Supprimé|Actuel = \<non disponible ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<supprimé ><br /><br /> RowAction = ChangeOriginal|  
|Inchangé|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
|(Absent)|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Les valeurs dans un <xref:System.Data.DataColumn> peut être contraint par le biais des propriétés telles que <xref:System.Data.DataColumn.ReadOnly%2A> et <xref:System.Data.DataColumn.AutoIncrement%2A>. Le `Load` méthode gère ces colonnes de manière cohérente avec le comportement défini par les propriétés de la colonne. La contrainte en lecture seule sur un <xref:System.Data.DataColumn> s’applique uniquement aux modifications qui se produisent dans la mémoire. Le `Load` la méthode remplace les valeurs de colonne en lecture seule, si nécessaire.  
  
 Pour déterminer la version du champ clé primaire à utiliser pour comparer la ligne actuelle avec une ligne entrante, la `Load` méthode utilise la version d’origine de la valeur de clé primaire dans une ligne, si elle existe. Sinon, le `Load` méthode utilise la version actuelle du champ clé primaire.  
  
   
  
## Examples  
 L’exemple suivant illustre plusieurs des problèmes impliqués par l’appel le <xref:System.Data.DataTable.Load%2A> (méthode). Tout d’abord, l’exemple se concentre sur les problèmes de schéma, notamment la déduction d’un schéma à partir de la charger <xref:System.Data.IDataReader>, puis gestion de schémas incompatibles et schémas avec des colonnes manquantes ou supplémentaires. L’exemple appelle ensuite la `Load` méthode, affichant les données avant et après l’opération de chargement.  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption -&gt; unit" Usage="dataTable.Load (reader, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Data.IDataReader" /> qui fournit un ou plusieurs jeux de résultats.</param>
        <param name="loadOption">Valeur issue de l'énumération <see cref="T:System.Data.LoadOption" /> qui indique comment les lignes déjà présentes dans le <see cref="T:System.Data.DataTable" /> sont associées aux lignes entrantes qui partagent la même clé primaire.</param>
        <summary>Remplit un <see cref="T:System.Data.DataTable" /> avec des valeurs issues d'une source de données à l'aide du <see cref="T:System.Data.IDataReader" /> fourni. Si <see langword="DataTable" /> contient déjà des lignes, les données entrantes à partir de la source de données sont fusionnées avec les lignes existantes en fonction de la valeur du paramètre <paramref name="loadOption" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Load` méthode consomme le premier jeu de résultats de la charger <xref:System.Data.IDataReader>et après l’achèvement réussi, définit la position du lecteur sur le jeu de résultats suivant, le cas échéant. Lors de la conversion de données, le `Load` méthode utilise les mêmes règles de conversion que le <xref:System.Data.Common.DbDataAdapter.Fill%2A> (méthode).  
  
 Le `Load` méthode doit prendre en compte trois problèmes spécifiques lors du chargement des données à partir d’un <xref:System.Data.IDataReader> instance : opérations de schéma, les données et les événements. Lorsque vous travaillez avec le schéma, le `Load` méthode peut rencontrer des conditions comme décrit dans le tableau suivant. Les opérations de schéma ont lieu pour tous les jeux de résultats importés, même ceux ne contenant aucune donnée.  
  
|Condition|Comportement|  
|---------------|--------------|  
|Le <xref:System.Data.DataTable> ne possède aucun schéma.|Le `Load` méthode déduit le schéma basé sur le jeu de résultats d’importé <xref:System.Data.IDataReader>.|  
|Le <xref:System.Data.DataTable> dispose d’un schéma, mais il n’est pas compatible avec le schéma chargé.|Le `Load` méthode lève une exception correspondant à l’erreur particulière qui se produit lorsque vous tentez de charger des données dans le schéma incompatible.|  
|Les schémas sont compatibles, mais le schéma du jeu de résultats chargé contient des colonnes qui n’existent pas dans le `DataTable`.|Le `Load` méthode ajoute les colonnes supplémentaires à `DataTable`du schéma. La méthode lève une exception si correspondant colonnes dans le <xref:System.Data.DataTable> et le jeu de résultats chargés ne sont pas compatibles de la valeur. La méthode récupère également les informations de contrainte à partir du jeu de résultats pour toutes les colonnes ajoutées. Sauf dans le cas de contrainte de clé primaire, ces informations de contrainte sont utilisées uniquement si actuel <xref:System.Data.DataTable> ne contient pas de colonnes au début de l’opération de chargement.|  
|Les schémas sont compatibles, mais le schéma du jeu de résultats chargé contient moins de colonnes que le `DataTable`.|Si une colonne manquante a une valeur par défaut définie ou type de données de la colonne est nullable, le `Load` méthode autorise les lignes à ajouter, en remplaçant la valeur par défaut ou null pour la colonne manquante. Si aucune valeur par défaut ou la valeur null ne peut être utilisé, puis le `Load` méthode lève une exception. Si aucune valeur par défaut spécifique n’a été fourni, le `Load` méthode utilise la valeur null comme valeur par défaut implicite.|  
  
 Avant de considérer que le comportement de la `Load` méthode en termes d’opérations de données, considérez que chaque ligne dans un <xref:System.Data.DataTable> tient à jour la valeur actuelle et la valeur d’origine pour chaque colonne. Ces valeurs peuvent être équivalents, ou peut être différents si les données dans la ligne a été modifiées depuis le remplissage du `DataTable`. Consultez [États des lignes et des Versions de ligne](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) pour plus d’informations.  
  
 Dans cet appel de méthode spécifié <xref:System.Data.LoadOption> paramètre influence le traitement des données entrantes. Comment la méthode Load doit gérer les lignes de chargement qui ont la même clé primaire en tant que lignes existantes ? Doit elle modifie les valeurs actuelles, les valeurs d’origine ou les deux ? Ces problèmes et bien plus encore, sont contrôlées par le `loadOption` paramètre.  
  
 Si la ligne existante et la ligne entrante contiennent des valeurs de clé primaire correspondantes, la ligne est traitée à l’aide de sa valeur d’état de ligne actuelle, sinon il est traité comme une nouvelle ligne.  
  
 En termes d’opérations de l’événement, le <xref:System.Data.DataTable.RowChanging> événement se produit avant la modification de chaque ligne et le <xref:System.Data.DataTable.RowChanged> événement se produit après chaque ligne a été modifiée. Dans chaque cas, le <xref:System.Data.DataRowChangeEventArgs.Action%2A> propriété de la <xref:System.Data.DataRowChangeEventArgs> instance passée au gestionnaire d’événements contient des informations sur l’action particulière associée à l’événement. Valeur de cette action varie, selon l’état de la ligne avant l’opération de chargement. Dans chaque cas, les deux événements se produisent, et l’action est la même pour chacun. L’action peut être appliquée à la version actuelle ou d’origine de chaque ligne, ou les deux, selon l’état actuel de la ligne.  
  
 Le tableau suivant présente le comportement de la méthode Load lorsqu’elle est appelée avec chacune de la `LoadOption` de valeurs et montre également comment les valeurs interagissent avec l’état de la ligne de la ligne en cours de chargement. La dernière ligne (étiquetée « (absente) ») décrit le comportement pour les lignes entrantes qui ne correspondent pas n’importe quelle ligne existante. Chaque cellule dans cette table décrit la valeur d’origine et actuelle pour un champ dans une ligne, ainsi que la <xref:System.Data.DataRowState> pour la valeur après la `Load` méthode est terminée.  
  
|DataRowState existant|Upsert|OverwriteChanges|PreserveChanges (comportement par défaut)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Ajouté|Actuel = \<entrant ><br /><br /> D’origine = -\<non disponible ><br /><br /> État = \<ajouté ><br /><br /> RowAction = modification|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|Actuel = \<existant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<modifié ><br /><br /> RowAction = ChangeOriginal|  
|Modifiée le|Actuel = \<entrant ><br /><br /> D’origine = \<existant ><br /><br /> État = \<modifié ><br /><br /> RowAction = modification|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|Actuel = \<existant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<modifié ><br /><br /> RowAction = ChangeOriginal|  
upprimé /|(Charge ne pas les lignes affectent supprimé)<br /><br /> En cours =---<br /><br /> D’origine = \<existant ><br /><br /> État = \<supprimé ><br /><br /> (Nouvelle ligne est ajoutée avec les caractéristiques suivantes)<br /><br /> Actuel = \<entrant ><br /><br /> D’origine = \<non disponible ><br /><br /> État = \<ajouté ><br /><br /> RowAction = ajouter|Annuler la suppression et<br /><br /> Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|Actuel = \<non disponible ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<supprimé ><br /><br /> RowAction = ChangeOriginal|  
|Inchangé|Actuel = \<entrant ><br /><br /> D’origine = \<existant ><br /><br /> Si la nouvelle valeur est identique à la valeur existante puis<br /><br /> État = \<inchangé ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> État = \<modifié ><br /><br /> RowAction = modification|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Absent)|Actuel = \<entrant ><br /><br /> D’origine = \<non disponible ><br /><br /> État = \<ajouté ><br /><br /> RowAction = ajouter|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Les valeurs dans un <xref:System.Data.DataColumn> peut être contraint par le biais des propriétés telles que <xref:System.Data.DataColumn.ReadOnly%2A> et <xref:System.Data.DataColumn.AutoIncrement%2A>. Le `Load` méthode gère ces colonnes de manière cohérente avec le comportement défini par les propriétés de la colonne. La contrainte en lecture seule sur un <xref:System.Data.DataColumn> s’applique uniquement aux modifications qui se produisent dans la mémoire. Le `Load` la méthode remplace les valeurs de colonne en lecture seule, si nécessaire.  
  
 Si vous spécifiez les options OverwriteChanges ou PreserveChanges lorsque vous appelez le `Load` (méthode), puis l’hypothèse est effectuée que les données entrantes provient le `DataTable`de source de données principale et la table de données effectue le suivi des modifications et peut propager les modifications dans la source de données. Si vous sélectionnez l’option Upsert, il est supposé que les données proviennent d’une source de données secondaire, telles que les données fournies par un composant de couche intermédiaire, éventuellement modifié par un utilisateur. Dans ce cas, l’hypothèse est que l’intention est d’agréger les données à partir d’une ou plusieurs sources de données dans le `DataTable`et puis éventuellement de propager les données à la source de données primaire. Le <xref:System.Data.LoadOption> paramètre est utilisé pour déterminer la version spécifique de la ligne qui doit être utilisé pour la comparaison de clé primaire. Le tableau ci-dessous fournit les détails.  
  
|Option de chargement|Version de DataRow utilisée pour la comparaison de clé primaire|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Version d’origine, si elle existe, la version actuelle dans le cas contraire|  
|`PreserveChanges`|Version d’origine, si elle existe, la version actuelle dans le cas contraire|  
|`Upsert`|Version actuelle, si elle existe, sinon d’origine version|  
  
   
  
## Examples  
 L’exemple suivant illustre plusieurs des problèmes impliqués par l’appel le <xref:System.Data.DataTable.Load%2A> (méthode). Tout d’abord, l’exemple se concentre sur les problèmes de schéma, notamment la déduction d’un schéma à partir de la charger <xref:System.Data.IDataReader>, puis gestion de schémas incompatibles et schémas avec des colonnes manquantes ou supplémentaires. L’exemple se concentre ensuite sur les problèmes de données, notamment la gestion des différentes options de chargement.  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit" Usage="dataTable.Load (reader, loadOption, errorHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">Un <see cref="T:System.Data.IDataReader" /> qui fournit un jeu de résultats.</param>
        <param name="loadOption">Valeur issue de l'énumération <see cref="T:System.Data.LoadOption" /> qui indique comment les lignes déjà présentes dans le <see cref="T:System.Data.DataTable" /> sont associées aux lignes entrantes qui partagent la même clé primaire.</param>
        <param name="errorHandler">Un délégué <see cref="T:System.Data.FillErrorEventHandler" /> à appeler lorsqu'une erreur se produit en chargeant des données.</param>
        <summary>Remplit un <see cref="T:System.Data.DataTable" /> avec des valeurs issues d'une source de données à l'aide du <see cref="T:System.Data.IDataReader" /> fourni et d'un délégué de gestion d'erreur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Load` méthode consomme le premier jeu de résultats de la charger <xref:System.Data.IDataReader>et après l’achèvement réussi, définit la position du lecteur sur le jeu de résultats suivant, le cas échéant. Lors de la conversion de données, le `Load` méthode utilise les mêmes règles de conversion que le <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> (méthode).  
  
 Le `Load` méthode doit prendre en compte trois problèmes spécifiques lors du chargement des données à partir d’un <xref:System.Data.IDataReader> instance : opérations de schéma, les données et les événements. Lorsque vous travaillez avec le schéma, le `Load` méthode peut rencontrer des conditions comme décrit dans le tableau suivant. Les opérations de schéma ont lieu pour tous les jeux de résultats importés, même ceux ne contenant aucune donnée.  
  
|Condition|Comportement|  
|---------------|--------------|  
|Le <xref:System.Data.DataTable> ne possède aucun schéma.|Le `Load` méthode déduit le schéma basé sur le jeu de résultats d’importé <xref:System.Data.IDataReader>.|  
|Le <xref:System.Data.DataTable> dispose d’un schéma, mais il n’est pas compatible avec le schéma chargé.|Le `Load` méthode lève une exception correspondant à l’erreur particulière qui se produit lorsque vous tentez de charger des données dans le schéma incompatible.|  
|Les schémas sont compatibles, mais le schéma du jeu de résultats chargé contient des colonnes qui n’existent pas dans le `DataTable`.|Le `Load` méthode ajoute des colonnes supplémentaires à `DataTable`du schéma. La méthode lève une exception si correspondant colonnes dans le <xref:System.Data.DataTable> et le jeu de résultats chargés ne sont pas compatibles de la valeur. La méthode récupère également les informations de contrainte à partir du jeu de résultats pour toutes les colonnes ajoutées. Sauf dans le cas de contrainte de clé primaire, ces informations de contrainte sont utilisées uniquement si actuel <xref:System.Data.DataTable> ne contient pas de colonnes au début de l’opération de chargement.|  
|Les schémas sont compatibles, mais le schéma du jeu de résultats chargé contient moins de colonnes que le `DataTable`.|Si une colonne manquante a une valeur par défaut définie ou type de données de la colonne est nullable, le `Load` méthode autorise les lignes à ajouter, en remplaçant la valeur par défaut ou null pour la colonne manquante. Si aucune valeur par défaut ou la valeur null ne peut être utilisé, puis le `Load` méthode lève une exception. Si aucune valeur par défaut spécifique n’a été fourni, le `Load` méthode utilise la valeur null comme valeur par défaut implicite.|  
  
 Avant de considérer que le comportement de la `Load` méthode en termes d’opérations de données, considérez que chaque ligne dans un <xref:System.Data.DataTable> tient à jour la valeur actuelle et la valeur d’origine pour chaque colonne. Ces valeurs peuvent être équivalents, ou peut être différents si les données dans la ligne a été modifiées depuis le remplissage du `DataTable`. Consultez [États des lignes et des Versions de ligne](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) pour plus d’informations.  
  
 Dans cet appel de méthode spécifié <xref:System.Data.LoadOption> paramètre influence le traitement des données entrantes. Comment la méthode Load doit gérer les lignes de chargement qui ont la même clé primaire en tant que lignes existantes ? Doit elle modifie les valeurs actuelles, les valeurs d’origine ou les deux ? Ces problèmes et bien plus encore, sont contrôlées par le `loadOption` paramètre.  
  
 Si la ligne existante et la ligne entrante contiennent des valeurs de clé primaire correspondantes, la ligne est traitée à l’aide de sa valeur d’état de ligne actuelle, sinon il est traité comme une nouvelle ligne.  
  
 En termes d’opérations de l’événement, le <xref:System.Data.DataTable.RowChanging> événement se produit avant la modification de chaque ligne et le <xref:System.Data.DataTable.RowChanged> événement se produit après chaque ligne a été modifiée. Dans chaque cas, le <xref:System.Data.DataRowChangeEventArgs.Action%2A> propriété de la <xref:System.Data.DataRowChangeEventArgs> instance passée au gestionnaire d’événements contient des informations sur l’action particulière associée à l’événement. Valeur de cette action varie, selon l’état de la ligne avant l’opération de chargement. Dans chaque cas, les deux événements se produisent, et l’action est la même pour chacun. L’action peut être appliquée à la version actuelle ou d’origine de chaque ligne, ou les deux, selon l’état actuel de la ligne.  
  
 Le tableau suivant présente le comportement de la méthode Load lorsqu’elle est appelée avec chacune de la `LoadOption` de valeurs et montre également comment les valeurs interagissent avec l’état de la ligne de la ligne en cours de chargement. La dernière ligne (étiquetée « (absente) ») décrit le comportement pour les lignes entrantes qui ne correspondent pas n’importe quelle ligne existante. Chaque cellule dans cette table décrit la valeur d’origine et actuelle pour un champ dans une ligne, ainsi que la <xref:System.Data.DataRowState> pour la valeur après la `Load` méthode est terminée.  
  
|DataRowState existant|Upsert|OverwriteChanges|PreserveChanges (comportement par défaut)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Ajouté|Actuel = \<entrant ><br /><br /> D’origine = -\<non disponible ><br /><br /> État = \<ajouté ><br /><br /> RowAction = modification|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|Actuel = \<existant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<modifié ><br /><br /> RowAction = ChangeOriginal|  
|Modifiée le|Actuel = \<entrant ><br /><br /> D’origine = \<existant ><br /><br /> État = \<modifié ><br /><br /> RowAction = modification|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|Actuel = \<existant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<modifié ><br /><br /> RowAction = ChangeOriginal|  
upprimé /|(Charge ne pas les lignes affectent supprimé)<br /><br /> En cours =---<br /><br /> D’origine = \<existant ><br /><br /> État = \<supprimé ><br /><br /> (Nouvelle ligne est ajoutée avec les caractéristiques suivantes)<br /><br /> Actuel = \<entrant ><br /><br /> D’origine = \<non disponible ><br /><br /> État = \<ajouté ><br /><br /> RowAction = ajouter|Annuler la suppression et<br /><br /> Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|Actuel = \<non disponible ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<supprimé ><br /><br /> RowAction = ChangeOriginal|  
|Inchangé|Actuel = \<entrant ><br /><br /> D’origine = \<existant ><br /><br /> Si la nouvelle valeur est identique à la valeur existante puis<br /><br /> État = \<inchangé ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> État = \<modifié ><br /><br /> RowAction = modification|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Absent)|Actuel = \<entrant ><br /><br /> D’origine = \<non disponible ><br /><br /> État = \<ajouté ><br /><br /> RowAction = ajouter|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|Actuel = \<entrant ><br /><br /> D’origine = \<entrant ><br /><br /> État = \<inchangé ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Les valeurs dans un <xref:System.Data.DataColumn> peut être contraint par le biais des propriétés telles que <xref:System.Data.DataColumn.ReadOnly%2A> et <xref:System.Data.DataColumn.AutoIncrement%2A>. Le `Load` méthode gère ces colonnes de manière cohérente avec le comportement défini par les propriétés de la colonne. La contrainte en lecture seule sur un <xref:System.Data.DataColumn> s’applique uniquement aux modifications qui se produisent dans la mémoire. Le `Load` la méthode remplace les valeurs de colonne en lecture seule, si nécessaire.  
  
 Si vous spécifiez les options OverwriteChanges ou PreserveChanges lorsque vous appelez le `Load` (méthode), puis l’hypothèse est effectuée que les données entrantes provient le `DataTable`de source de données principale et la table de données effectue le suivi des modifications et peut propager les modifications dans la source de données. Si vous sélectionnez l’option Upsert, il est supposé que les données proviennent d’une source de données secondaire, telles que les données fournies par un composant de couche intermédiaire, éventuellement modifié par un utilisateur. Dans ce cas, l’hypothèse est que l’intention est d’agréger les données à partir d’une ou plusieurs sources de données dans le `DataTable`et puis éventuellement de propager les données à la source de données primaire. Le <xref:System.Data.LoadOption> paramètre est utilisé pour déterminer la version spécifique de la ligne qui doit être utilisé pour la comparaison de clé primaire. Le tableau ci-dessous fournit les détails.  
  
|Option de chargement|Version de DataRow utilisée pour la comparaison de clé primaire|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Version d’origine, si elle existe, la version actuelle dans le cas contraire|  
|`PreserveChanges`|Version d’origine, si elle existe, la version actuelle dans le cas contraire|  
|`Upsert`|Version actuelle, si elle existe, sinon d’origine version|  
  
 Le `errorHandler` paramètre est un <xref:System.Data.FillErrorEventHandler> délégué qui fait référence à une procédure qui est appelée lorsqu’une erreur se produit lors du chargement des données. Le <xref:System.Data.FillErrorEventArgs> paramètre transmis à la procédure fournit des propriétés qui vous permettent de récupérer des informations sur l’erreur qui s’est produite, la ligne actuelle de données, et le <xref:System.Data.DataTable> remplie. À l’aide de ce mécanisme de délégué, au lieu d’un bloc try/catch plus simple, vous permet de déterminer l’erreur, gérer la situation et continuer le traitement si vous le souhaitez. Le <xref:System.Data.FillErrorEventArgs> paramètre fournit un <xref:System.Data.FillErrorEventArgs.Continue%2A> propriété : définissez cette propriété sur `true` pour indiquer que vous avez géré l’erreur et souhaitez continuer le traitement. Affectez à la propriété `false` pour indiquer que vous souhaitez arrêter le traitement. N’oubliez pas que la définition de la propriété `false` provoque le code qui a déclenché le problème pour lever une exception.  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche et met à jour une ligne spécifique. Si aucune ligne correspondante n'est détectée, une nouvelle ligne est créée à l'aide des valeurs données.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * bool -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, fAcceptChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">Tableau des valeurs utilisées pour créer la nouvelle ligne.</param>
        <param name="fAcceptChanges"><see langword="true" /> pour accepter les modifications ; sinon, <see langword="false" />.</param>
        <summary>Recherche et met à jour une ligne spécifique. Si aucune ligne correspondante n'est détectée, une nouvelle ligne est créée à l'aide des valeurs données.</summary>
        <returns>Nouvelle <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.LoadDataRow%2A> méthode prend un tableau de valeurs et recherche les valeurs correspondantes dans les colonnes clés primaires.  
  
 Si une colonne a la valeur par défaut, passez une valeur null dans le tableau pour définir la valeur par défaut pour cette colonne. De même, si une colonne a son <xref:System.Data.DataColumn.AutoIncrement%2A> propriété définie sur true, passez une valeur null dans le tableau pour définir la valeur générée automatiquement pour la ligne.  
  
 Si le `fAcceptChanges` paramètre est `true` ou n’est ne pas spécifié, les nouvelles données sont ajoutées, puis <xref:System.Data.DataTable.AcceptChanges%2A> est appelée pour accepter toutes les modifications dans le <xref:System.Data.DataTable>; si l’argument est `false`, qui vient d’être ajouté de lignes sont marquées comme insertions et les modifications apportées à les lignes existantes sont marqués comme des modifications.  
  
 Exceptions peuvent également se produire pendant une <xref:System.Data.DataTable.ColumnChanging> ou <xref:System.Data.DataTable.RowChanging> événement. Si une exception se produit, la ligne n’est pas ajoutée à la table.  
  
 Utilisez <xref:System.Data.DataTable.LoadDataRow%2A> conjointement avec <xref:System.Data.DataTable.BeginLoadData%2A> et <xref:System.Data.DataTable.EndLoadData%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Data.DataTable.LoadDataRow%2A> méthode tente de trouver une ligne. Si aucune ligne n’est trouvée, les valeurs sont utilisées pour créer une nouvelle ligne.  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le tableau contient un nombre de colonnes supérieur à celui de la table.</exception>
        <exception cref="T:System.InvalidCastException">Une valeur ne correspond pas à son type de colonne respectif.</exception>
        <exception cref="T:System.Data.ConstraintException">L'ajout de la ligne rend une contrainte non valide.</exception>
        <exception cref="T:System.Data.NoNullAllowedException">Tentative d'insertion d'une valeur null dans une colonne dont <see cref="P:System.Data.DataColumn.AllowDBNull" /> a la valeur false.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * System.Data.LoadOption -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">Tableau des valeurs utilisées pour créer la nouvelle ligne.</param>
        <param name="loadOption">Utilisé pour déterminer comment les valeurs de tableau sont appliquées aux valeurs correspondantes dans une ligne existante.</param>
        <summary>Recherche et met à jour une ligne spécifique. Si aucune ligne correspondante n'est détectée, une nouvelle ligne est créée à l'aide des valeurs données.</summary>
        <returns>Nouvelle <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.LoadDataRow%2A> méthode prend un tableau de valeurs et recherche les valeurs correspondantes dans les colonnes clés primaires.  
  
 Si une colonne a la valeur par défaut, passez une valeur null dans le tableau pour définir la valeur par défaut pour cette colonne. De même, si une colonne a son <xref:System.Data.DataColumn.AutoIncrement%2A> propriété définie sur true, passez une valeur null dans le tableau pour définir la valeur générée automatiquement pour la ligne.  
  
 La valeur de la `loadOption` paramètre est utilisé pour déterminer comment les valeurs dans le tableau sont appliquées à une ligne existante. Par exemple, si `loadOption` a la valeur `OverwriteChanges`, le `Original` et `Current` valeurs de chaque colonne sont remplacées par les valeurs dans la ligne entrante et la `RowState` propriété est définie sur `Unchanged`.  
  
 Exceptions peuvent également se produire pendant une <xref:System.Data.DataTable.ColumnChanging> ou <xref:System.Data.DataTable.RowChanging> événement. Si une exception se produit, la ligne n’est pas ajoutée à la table.  
  
 Utilisez <xref:System.Data.DataTable.LoadDataRow%2A> conjointement avec <xref:System.Data.DataTable.BeginLoadData%2A> et <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataTable.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les paramètres régionaux utilisés pour comparer des chaînes dans la table.</summary>
        <value><see cref="T:System.Globalization.CultureInfo" /> qui contient les données relatives aux paramètres régionaux de l'ordinateur de l'utilisateur. La valeur par défaut est le <see cref="T:System.Data.DataSet" /> de l'objet <see cref="T:System.Globalization.CultureInfo" /> (retourné par la propriété <see cref="P:System.Data.DataSet.Locale" />) auquel appartient <see cref="T:System.Data.DataTable" />. Si la table n'appartient pas à <see cref="T:System.Data.DataSet" />, la valeur par défaut est le <see cref="T:System.Globalization.CultureInfo" /> du système en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Globalization.CultureInfo> représente les préférences logicielles d’une culture particulière ou de la Communauté.  
  
 Lorsqu’il est utilisé pour les comparaisons de chaînes, la <xref:System.Globalization.CultureInfo> affecte le tri, les comparaisons et le filtrage.  
  
> [!NOTE]
>  Dans les colonnes qui contiennent des expressions, le <xref:System.StringComparison.InvariantCulture> est utilisé. Le <xref:System.StringComparison.CurrentCulture> est ignoré.  
  
   
  
## Examples  
 L’exemple suivant définit la <xref:System.Globalization.CultureInfo> via la <xref:System.Data.DataTable.Locale%2A> et imprime le nom de langue ISO.  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fusionnez le <see cref="T:System.Data.DataTable" /> spécifié avec le <see cref="T:System.Data.DataTable" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Merge` méthode est utilisée pour fusionner deux <xref:System.Data.DataTable> objets qui ont des schémas très similaires. Une fusion est généralement utilisée sur une application cliente pour incorporer les dernières modifications à partir d’une source de données dans une existante <xref:System.Data.DataTable>. Cela permet à l’application cliente avoir un actualisé <xref:System.Data.DataTable> avec les données les plus récentes à partir de la source de données.  
  
 L’opération de fusion prend en compte uniquement la table d’origine et la table à fusionner. Tables enfants ne sont pas affectées ou inclus. Si une table possède une ou plusieurs tables enfant en tant que partie d’une relation, chaque table enfant doit être fusionnée individuellement.  
  
   
  
## Examples  
 L’application console suivante montre le comportement de la `missingSchemaAction` paramètre de la <xref:System.Data.DataTable.Merge%2A> (méthode). Cet exemple crée deux versions de la même table, la modification du schéma pour la deuxième version. Le code tente ensuite de fusionner la deuxième table dans la première.  
  
> [!NOTE]
>  Cet exemple montre comment utiliser une des versions surchargées de fusion. Pour obtenir des exemples qui peuvent être disponibles, consultez les rubriques de surcharges individuelles.  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataTable.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table"><see cref="T:System.Data.DataTable" /> à fusionner avec le <see cref="T:System.Data.DataTable" /> actuel.</param>
        <summary>Fusionnez le <see cref="T:System.Data.DataTable" /> spécifié avec le <see cref="T:System.Data.DataTable" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode Merge est utilisée pour fusionner deux <xref:System.Data.DataTable> objets qui ont des schémas très similaires. Une fusion est généralement utilisée sur une application cliente pour incorporer les dernières modifications à partir d’une source de données dans une existante <xref:System.Data.DataTable>. Cela permet à l’application cliente avoir un actualisé <xref:System.Data.DataTable> avec les données les plus récentes à partir de la source de données.  
  
 L’opération de fusion prend en compte uniquement la table d’origine et la table à fusionner. Tables enfants ne sont pas affectées ou inclus. Si une table possède une ou plusieurs tables enfant en tant que partie d’une relation, chaque table enfant doit être fusionnée individuellement.  
  
 Le `Merge` méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, harmonisation des erreurs, la mise à jour de la source de données avec les modifications et enfin l’actualisation existant <xref:System.Data.DataTable>.  
  
 Lorsque vous effectuez une fusion, les modifications apportées aux données existantes avant la fusion sont conservées pendant l’opération de fusion par défaut. Les développeurs peuvent modifier ce comportement en appelant une des deux autres surcharges pour cette méthode et en spécifiant une valeur false pour le `preserveChanges` paramètre.  
  
 Dans une application cliente, il est habituel d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de les envoyer à un composant de couche intermédiaire. Dans ce scénario, le <xref:System.Data.DataTable.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataTable> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataTable> objet contient uniquement le <xref:System.Data.DataRow> les objets qui ont été modifiés, ce qui entraîne un sous-ensemble de l’original <xref:System.Data.DataTable>. Ce sous-ensemble est généralement plus petit et donc être passé plus efficacement à un composant de couche intermédiaire. Le composant de couche intermédiaire puis met à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataTable> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications qui ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées à l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataTable> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataTable> avec la <xref:System.Data.DataTable.Merge%2A> (méthode).  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataTable> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted`, est mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaires. Source des lignes avec un <xref:System.Data.DataRowState> valeur `Added` sont mis en correspondance avec les nouvelles lignes cible avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes de code source.  
  
   
  
## Examples  
 L’application console suivante crée un simple <xref:System.Data.DataTable> et ajoute à la table de données. L’exemple crée ensuite une copie de la table en ajoutant des lignes à la copie. Enfin, l’exemple appelle la <xref:System.Data.DataTable.Merge%2A> méthode pour fusionner les données dans la deuxième table avec les données de la première table.  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool -&gt; unit" Usage="dataTable.Merge (table, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table"><see langword="DataTable" /> à fusionner avec le <see langword="DataTable" /> actuel.</param>
        <param name="preserveChanges"><see langword="true" /> pour préserver les modifications apportées au <see langword="DataTable" /> en cours ; sinon, <see langword="false" />.</param>
        <summary>Fusionnez le <see cref="T:System.Data.DataTable" /> spécifié avec le <see langword="DataTable" /> actuel, en indiquant s'il faut conserver les modifications dans le <see langword="DataTable" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode Merge est utilisée pour fusionner deux <xref:System.Data.DataTable> objets qui ont des schémas très similaires. Une fusion est généralement utilisée sur une application cliente pour incorporer les dernières modifications à partir d’une source de données dans une existante <xref:System.Data.DataTable>. Cela permet à l’application cliente avoir un actualisé <xref:System.Data.DataTable> avec les données les plus récentes à partir de la source de données.  
  
 L’opération de fusion prend en compte uniquement la table d’origine et la table à fusionner. Tables enfants ne sont pas affectées ou inclus. Si une table possède une ou plusieurs tables enfant en tant que partie d’une relation, chaque table enfant doit être fusionnée individuellement.  
  
 Le `Merge` méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, harmonisation des erreurs, la mise à jour de la source de données avec les modifications et enfin l’actualisation existant <xref:System.Data.DataTable>.  
  
 Lorsque vous effectuez une fusion, les modifications apportées aux données existantes avant la fusion sont conservées pendant l’opération de fusion, sauf si le développeur affecte la valeur false pour le `preserveChanges` paramètre. Si le `preserveChanges` paramètre est défini sur `true`, des valeurs entrantes ne remplacent pas les valeurs existantes dans la version actuelle de la ligne de la ligne existante. Si le `preserveChanges` paramètre est défini sur `false`, les valeurs entrantes remplacent les valeurs existantes dans la version actuelle de la ligne de la ligne existante. Pour plus d’informations sur les versions de ligne, consultez [États des lignes et des Versions de ligne](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Dans une application cliente, il est habituel d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de les envoyer à un composant de couche intermédiaire. Dans ce scénario, le <xref:System.Data.DataTable.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataTable> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataTable> objet contient uniquement le <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, ce qui entraîne un sous-ensemble de l’original <xref:System.Data.DataTable>. Ce sous-ensemble est généralement plus petit, et donc ce sous-ensemble est passé plus efficacement à un composant de couche intermédiaire. Le composant de couche intermédiaire puis met à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataTable> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications qui ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées à l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataTable> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataTable> avec la <xref:System.Data.DataTable.Merge%2A> (méthode).  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataTable> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaires. Source des lignes avec un <xref:System.Data.DataRowState> valeur `Added` sont mis en correspondance avec les nouvelles lignes cible avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes de code source.  
  
   
  
## Examples  
 L’application console suivante crée un <xref:System.Data.DataTable> contenant des lignes, modifie certaines données dans ces lignes et tente de fusionner des données à partir d’un autre <xref:System.Data.DataTable>. L’exemple montre les différents comportements pour le `preserveChanges` paramètre.  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataTable.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table"><see cref="T:System.Data.DataTable" /> à fusionner avec le <see cref="T:System.Data.DataTable" /> actuel.</param>
        <param name="preserveChanges"><see langword="true" /> pour préserver les modifications apportées au <see cref="T:System.Data.DataTable" /> en cours ; sinon, <see langword="false" />.</param>
        <param name="missingSchemaAction">Une des valeurs de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Fusionnez le <see cref="T:System.Data.DataTable" /> spécifié avec le <see langword="DataTable" /> actuel, en indiquant s'il faut conserver les modifications et comment gérer le schéma manquant dans le <see langword="DataTable" /> actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Merge` méthode est utilisée pour fusionner deux <xref:System.Data.DataTable> objets qui ont des schémas très similaires. Une fusion est généralement utilisée sur une application cliente pour incorporer les dernières modifications à partir d’une source de données dans une existante <xref:System.Data.DataTable>. Cela permet à l’application cliente avoir un actualisé <xref:System.Data.DataTable> avec les données les plus récentes à partir de la source de données.  
  
 L’opération de fusion prend en compte uniquement la table d’origine et la table à fusionner. Tables enfants ne sont pas affectées ou inclus. Si une table possède une ou plusieurs tables enfant en tant que partie d’une relation, chaque table enfant doit être fusionnée individuellement.  
  
 Le `Merge` méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, harmonisation des erreurs, la mise à jour de la source de données avec les modifications et enfin l’actualisation existant <xref:System.Data.DataTable>.  
  
 Lorsque vous effectuez une fusion, les modifications apportées aux données existantes avant la fusion sont conservées pendant l’opération de fusion, sauf si le développeur affecte la valeur false pour le `preserveChanges` paramètre. Si le `preserveChanges` paramètre est défini sur `true`, des valeurs entrantes ne remplacent pas les valeurs existantes dans la version actuelle de la ligne de la ligne existante. Si le `preserveChanges` paramètre est défini sur `false`, les valeurs entrantes remplacent les valeurs existantes dans la version actuelle de la ligne de la ligne existante. Pour plus d’informations sur les versions de ligne, consultez [États des lignes et des Versions de ligne](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Dans une application cliente, il est habituel d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de les envoyer à un composant de couche intermédiaire. Dans ce scénario, le <xref:System.Data.DataTable.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataTable> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataTable> objet contient uniquement le <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, ce qui entraîne un sous-ensemble de l’original <xref:System.Data.DataTable>. Ce sous-ensemble est généralement plus petit, et donc ce sous-ensemble est passé plus efficacement à un composant de couche intermédiaire. Le composant de couche intermédiaire puis met à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataTable> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications qui ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées à l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataTable> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataTable> avec la <xref:System.Data.DataTable.Merge%2A> (méthode).  
  
 Lorsque le <xref:System.Data.DataTable.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataTable> objets sont comparées, car il est possible que les schémas peuvent avoir été changés. Par exemple, dans un scénario business-to-business, nouvelles colonnes peuvent ont été ajoutées à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataTable> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataTable> contient les données et le schéma ajouté.  
  
 Après avoir fusionné les schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataTable> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaires. Source des lignes avec un <xref:System.Data.DataRowState> valeur `Added` sont mis en correspondance avec les nouvelles lignes cible avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes de code source.  
  
   
  
## Examples  
 L’application console suivante montre le comportement de la `missingSchemaAction` paramètre de la <xref:System.Data.DataTable.Merge%2A> (méthode). Cet exemple crée deux versions de la même table, la modification du schéma pour la deuxième version. Le code tente ensuite de fusionner la deuxième table dans la première.  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumCapacity : int with get, set" Usage="System.Data.DataTable.MinimumCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableMinimumCapacityDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille de départ initiale pour cette table.</summary>
        <value>Taille de départ initiale des lignes de cette table. La valeur par défaut est 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.MinimumCapacity%2A> permet au système créer un ensemble approprié de ressources avant d’extraire des données. Dans une situation où les performances sont critiques, définition de cette propriété peut optimiser les performances.  
  
   
  
## Examples  
 L’exemple suivant définit la <xref:System.Data.DataTable.MinimumCapacity%2A> d’un <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataTable.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'espace de noms de la représentation XML des données stockées dans le <see cref="T:System.Data.DataTable" />.</summary>
        <value>L’espace de noms du <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberSignature Language="F#" Value="member this.NewRow : unit -&gt; System.Data.DataRow" Usage="dataTable.NewRow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un nouveau <see cref="T:System.Data.DataRow" /> possédant le même schéma que la table.</summary>
        <returns><see cref="T:System.Data.DataRow" /> possédant le même schéma que <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez utiliser le <xref:System.Data.DataTable.NewRow%2A> méthode pour créer de nouveaux <xref:System.Data.DataRow> objets avec le même schéma que la <xref:System.Data.DataTable>. Après avoir créé un <xref:System.Data.DataRow>, vous pouvez l’ajouter à la <xref:System.Data.DataRowCollection>, jusqu'à la <xref:System.Data.DataTable> l’objet <xref:System.Data.DataTable.Rows%2A> propriété. Lorsque vous utilisez <xref:System.Data.DataTable.NewRow%2A> pour créer de nouvelles lignes, les lignes doivent être ajoutés ou supprimés à partir de la table de données avant d’appeler <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataTable>, ajoute deux <xref:System.Data.DataColumn> objets qui déterminent le schéma de la table et crée plusieurs nouveaux <xref:System.Data.DataRow> objets à l’aide de la <xref:System.Data.DataTable.NewRow%2A> (méthode). Ceux <xref:System.Data.DataRow> objets sont ensuite ajoutés à la <xref:System.Data.DataRowCollection> à l’aide de la <xref:System.Data.DataRowCollection.Add%2A> (méthode).  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberSignature Language="F#" Value="member this.NewRowArray : int -&gt; System.Data.DataRow[]" Usage="dataTable.NewRowArray size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">Valeur <see cref="T:System.Int32" /> qui décrit la taille du tableau.</param>
        <summary>Retourne un tableau de <see cref="T:System.Data.DataRow" />.</summary>
        <returns>Nouveau tableau.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow&#xA;override this.NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow" Usage="dataTable.NewRowFromBuilder builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Objet <see cref="T:System.Data.DataRowBuilder" />.</param>
        <summary>Crée une nouvelle ligne à partir d'une ligne existante.</summary>
        <returns>Classe dérivée <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Data.DataColumnChangeEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Data.DataTable.ColumnChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> (méthode).</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Data.DataColumnChangeEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Data.DataTable.ColumnChanging" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> (méthode).</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataTable.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent"><see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> (méthode).</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveColumn : System.Data.DataColumn -&gt; unit&#xA;override this.OnRemoveColumn : System.Data.DataColumn -&gt; unit" Usage="dataTable.OnRemoveColumn column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column"><see cref="T:System.Data.DataColumn" /> en cours de suppression.</param>
        <summary>Avertit <see cref="T:System.Data.DataTable" /> que <see cref="T:System.Data.DataColumn" /> est en cours de suppression.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> (méthode).</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Data.DataRowChangeEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Data.DataTable.RowChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> (méthode).</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Data.DataRowChangeEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Data.DataTable.RowChanging" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> (méthode).</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Data.DataRowChangeEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Data.DataTable.RowDeleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> (méthode).</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Data.DataRowChangeEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Data.DataTable.RowDeleting" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> (méthode).</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableCleared e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Data.DataTableClearEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Data.DataTable.TableCleared" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Déclenche la <xref:System.Data.DataTable.TableCleared> événement, qui est déclenché immédiatement après toutes les lignes ont été effacées avec succès, mais avant le <xref:System.Data.DataTable.Clear%2A> méthode retourne le contrôle à l’appelant.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableClearing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Data.DataTableClearEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Data.DataTable.TableClearing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Déclenche la <xref:System.Data.DataTable.TableClearing> événement, qui est déclenché avant le traitement de la <xref:System.Data.DataTable.Clear%2A> début de l’opération.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit&#xA;override this.OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit" Usage="dataTable.OnTableNewRow e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Data.DataTableNewRowEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Data.DataTable.TableNewRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Déclenche la <xref:System.Data.DataTable.TableNewRow> événement, qui se déclenche après une nouvelle <xref:System.Data.DataRow> a été créé à l’aide de <xref:System.Data.DataTable.NewRow%2A>.  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ParentRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableParentRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection des relations parentes de ce <see cref="T:System.Data.DataTable" />.</summary>
        <value><see cref="T:System.Data.DataRelationCollection" /> qui contient les relations parentes pour la table. Une collection vide est retournée si aucun objet <see cref="T:System.Data.DataRelation" /> n'existe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataTable.ParentRelations%2A> propriété pour retourner chaque parent <xref:System.Data.DataRelation> dans un <xref:System.Data.DataTable>. Chaque relation est ensuite utilisée en tant qu’argument dans le <xref:System.Data.DataRow.GetParentRows%2A> méthode de la <xref:System.Data.DataRow> pour retourner un tableau de lignes. La valeur de chaque colonne dans la ligne s’affiche ensuite.  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataTable.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'espace de noms de la représentation XML des données stockées dans le <see cref="T:System.Data.DataTable" />.</summary>
        <value>Préfixe de <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : System.Data.DataColumn[] with get, set" Usage="System.Data.DataTable.PrimaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrimaryKeyDescr")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un tableau de colonnes qui fonctionnent comme des clés primaires pour la table de données.</summary>
        <value>Tableau d'objets <see cref="T:System.Data.DataColumn" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clé primaire d’une table doit être unique pour identifier l’enregistrement dans la table. Il est également possible d’avoir une table avec une clé primaire constituée de deux ou plusieurs colonnes. Cela se produit lorsqu’une seule colonne ne peut pas contenir suffisamment de valeurs uniques. Par exemple, une clé primaire de deux colonnes peut être constitué d’une colonne « FirstName » et « LastName ». Étant donné que les clés primaires peuvent être constitués de plusieurs colonnes, la <xref:System.Data.DataTable.PrimaryKey%2A> propriété se compose d’un tableau de <xref:System.Data.DataColumn> objets.  
  
   
  
## Examples  
 Le premier exemple montre comment retourner les colonnes clés primaires pour un <xref:System.Data.DataTable> affiché dans un `DataGrid`. Le deuxième exemple montre comment définir les colonnes clés primaires pour un <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">Il s'agit d'une clé étrangère.</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataTable> à partir d’un document XML, tandis que le <xref:System.Data.DataTable.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui incluent le `XmlReadMode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.WriteXml%2A> et <xref:System.Data.DataTable.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataTable`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Objet qui dérive de <see cref="T:System.IO.Stream" />.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataTable" /> à l'aide du <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <returns><see cref="T:System.Data.XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuel <xref:System.Data.DataTable> et ses descendants sont chargés avec les données à partir de le <xref:System.IO.Stream>. Le comportement de cette méthode est identique à celle de la <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> méthode, sauf que dans ce cas, les données est chargée uniquement pour la table actuelle et ses descendants.  
  
 Le <xref:System.Data.DataTable.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataTable> à partir d’un document XML, tandis que le <xref:System.Data.DataTable.ReadXmlSchema%2A> méthode lit uniquement le schéma.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.WriteXml%2A> et <xref:System.Data.DataTable.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataTable`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma inline est utilisé pour étendre la structure relationnelle existante avant de charger les données. S’il existe des conflits (par exemple, la même colonne dans la même table définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma inline est spécifié, la structure relationnelle est étendue par inférence, en fonction des besoins, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML légaux comme (« _ ») sont ignorés dans le code XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lorsque les caractères valides dans le nom d’élément XML sont ignorés, l’élément est ignoré lors du traitement.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataTable> contenant deux colonnes et dix lignes. L’exemple écrit la <xref:System.Data.DataTable> schéma et les données dans un flux de mémoire, en appelant le <xref:System.Data.DataTable.WriteXml%2A> (méthode). L’exemple crée un deuxième <xref:System.Data.DataTable> et appelle le <xref:System.Data.DataTable.ReadXml%2A> méthode à remplir avec le schéma et données.  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.IO.TextReader" /> qui sera utilisé pour lire les données.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataTable" /> à l'aide du <see cref="T:System.IO.TextReader" /> spécifié.</summary>
        <returns><see cref="T:System.Data.XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuel <xref:System.Data.DataTable> et ses descendants sont chargés avec les données à partir de le <xref:System.IO.TextReader>. Le comportement de cette méthode est identique à celle de la <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> méthode, sauf que dans ce cas, les données est chargée uniquement pour la table actuelle et ses descendants.  
  
 Le <xref:System.Data.DataTable.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataTable> à partir d’un document XML, tandis que le <xref:System.Data.DataTable.ReadXmlSchema%2A> méthode lit uniquement le schéma.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.WriteXml%2A> et <xref:System.Data.DataTable.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataTable`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma inline est utilisé pour étendre la structure relationnelle existante avant de charger les données. S’il existe des conflits (par exemple, la même colonne dans la même table définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma inline est spécifié, la structure relationnelle est étendue par inférence, en fonction des besoins, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML légaux comme (« _ ») sont ignorés dans le code XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lorsque les caractères valides dans le nom d’élément XML sont ignorés, l’élément est ignoré lors du traitement.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataTable> contenant deux colonnes et dix lignes. L’exemple écrit la <xref:System.Data.DataTable> schéma et les données dans un flux de mémoire, en appelant le <xref:System.Data.DataTable.WriteXml%2A> (méthode). L’exemple crée un deuxième <xref:System.Data.DataTable> et appelle le <xref:System.Data.DataTable.ReadXml%2A> méthode à remplir avec le schéma et données.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier à partir duquel lire les données.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataTable" /> à partir du fichier spécifié.</summary>
        <returns><see cref="T:System.Data.XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuel <xref:System.Data.DataTable> et ses descendants sont chargés avec les données à partir du fichier nommé dans fourni <xref:System.String>. Le comportement de cette méthode est identique à celle de la <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> méthode, sauf que dans ce cas, les données est chargée uniquement pour la table actuelle et ses descendants.  
  
 Le <xref:System.Data.DataTable.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataTable> à partir d’un document XML, tandis que le <xref:System.Data.DataTable.ReadXmlSchema%2A> méthode lit uniquement le schéma.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.WriteXml%2A> et <xref:System.Data.DataTable.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataTable`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma inline est utilisé pour étendre la structure relationnelle existante avant de charger les données. S’il existe des conflits (par exemple, la même colonne dans la même table définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma inline est spécifié, la structure relationnelle est étendue par inférence, en fonction des besoins, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML légaux comme (« _ ») sont ignorés dans le code XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lorsque les caractères valides dans le nom d’élément XML sont ignorés, l’élément est ignoré lors du traitement.  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataTable> contenant deux colonnes et dix lignes. L’exemple écrit la <xref:System.Data.DataTable> schéma et les données sur le disque. L’exemple crée un deuxième <xref:System.Data.DataTable> et appelle le <xref:System.Data.DataTable.ReadXml%2A> méthode à remplir avec le schéma et données.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" /> qui sera utilisé pour lire les données.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataTable" /> à l'aide du <see cref="T:System.Xml.XmlReader" /> spécifié.</summary>
        <returns><see cref="T:System.Data.XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actuel <xref:System.Data.DataTable> et ses descendants sont chargés avec les données à partir du fichier nommé dans fourni <xref:System.Xml.XmlReader>. Le comportement de cette méthode est identique à celle de la <xref:System.Data.DataTable.ReadXml%2A> méthode, sauf que dans ce cas, les données est chargée uniquement pour la table actuelle et ses descendants.  
  
 Le <xref:System.Data.DataTable.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataTable> à partir d’un document XML, tandis que le <xref:System.Data.DataTable.ReadXmlSchema%2A> méthode lit uniquement le schéma.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.WriteXml%2A> et <xref:System.Data.DataTable.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataTable`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma inline est utilisé pour étendre la structure relationnelle existante avant de charger les données. S’il existe des conflits (par exemple, la même colonne dans la même table définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma inline est spécifié, la structure relationnelle est étendue par inférence, en fonction des besoins, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML légaux comme (« _ ») sont ignorés dans le code XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lorsque les caractères valides dans le nom d’élément XML sont ignorés, l’élément est ignoré lors du traitement.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataTable> contenant deux colonnes et dix lignes. L’exemple écrit la <xref:System.Data.DataTable> schéma et les données à un <xref:System.Xml.XmlReader>. L’exemple crée un deuxième <xref:System.Data.DataTable> et appelle le <xref:System.Data.DataTable.ReadXml%2A> méthode à remplir avec le schéma et données à partir de la <xref:System.Xml.XmlReader> instance.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit un schéma XML dans le <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `ReadXmlSchema` méthode pour créer le schéma pour un <xref:System.Data.DataTable>. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est interprété en fonction de la norme XSD.  
  
 Le `ReadXmlSchema` méthode est généralement appelée avant la <xref:System.Data.DataTable.ReadXml%2A> méthode qui est utilisée pour remplir le <xref:System.Data.DataTable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de données utilisé pour lire le schéma.</param>
        <summary>Lit un schéma XML dans le <see cref="T:System.Data.DataTable" /> à l'aide du flux de données spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.ReadXmlSchema%2A> méthode pour créer le schéma pour un <xref:System.Data.DataTable>. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est interprété en fonction de la norme XSD.  
  
 Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas. Aucune exception n’est levée.  
  
 Le `ReadXmlSchema` méthode est généralement appelée avant la <xref:System.Data.DataTable.ReadXml%2A> méthode qui est utilisée pour remplir le <xref:System.Data.DataTable>.  
  
 Pour créer une relation imbriquée à l’aide du schéma XML, utilisez des éléments imbriqués implicites. Vous pouvez également configurer la relation imbriquée pour utiliser des noms de colonnes explicite. Éléments doivent être implicitement imbriqués dans l’ordre pour les tables de données correspondant à participer à une relation imbriquée.  
  
   
  
## Examples  
 L’application console suivante crée un nouveau <xref:System.Data.DataTable>et écrit le schéma pour cette table à un <xref:System.IO.MemoryStream>. Ensuite, l’exemple crée un nouveau <xref:System.Data.DataTable> et lit son schéma à partir du schéma XML enregistré.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.IO.TextReader" /> utilisé pour lire les informations de schéma.</param>
        <summary>Lit un schéma XML dans le <see cref="T:System.Data.DataTable" /> à l'aide du <see cref="T:System.IO.TextReader" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.ReadXmlSchema%2A> méthode pour créer le schéma pour un <xref:System.Data.DataTable>. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est interprété en fonction de la norme XSD.  
  
 Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas. Aucune exception n’est levée.  
  
 Le `ReadXmlSchema` méthode est généralement appelée avant la <xref:System.Data.DataTable.ReadXml%2A> méthode qui est utilisée pour remplir le <xref:System.Data.DataTable>.  
  
 Pour créer une relation imbriquée à l’aide du schéma XML, utilisez des éléments imbriqués implicites. Vous pouvez également reconfigurer la relation imbriquée pour utiliser des noms de colonnes explicite. Éléments doivent être implicitement imbriqués dans l’ordre pour les tables de données correspondant à participer à une relation imbriquée.  
  
   
  
## Examples  
 L’application console suivante crée un nouveau <xref:System.Data.DataTable>et écrit le schéma pour cette table à un <xref:System.IO.MemoryStream>. Ensuite, l’exemple crée un nouveau <xref:System.Data.DataTable> et lit son schéma à partir du schéma XML enregistré, en utilisant un <xref:System.IO.StreamReader> (qui hérite <xref:System.IO.TextReader>) comme source.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataTable.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier à partir duquel lire les informations de schéma.</param>
        <summary>Lit un schéma XML dans le <see cref="T:System.Data.DataTable" /> à partir du fichier spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.ReadXmlSchema%2A> méthode pour créer le schéma pour un <xref:System.Data.DataTable>. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est interprété en fonction de la norme XSD.  
  
 Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas. Aucune exception n’est levée.  
  
 Le `ReadXmlSchema` méthode est généralement appelée avant la <xref:System.Data.DataTable.ReadXml%2A> méthode qui est utilisée pour remplir le `DataTable`.  
  
 Pour créer une relation imbriquée à l’aide du schéma XML, utilisez des éléments imbriqués implicites. Vous pouvez également reconfigurer la relation imbriquée pour utiliser des noms de colonnes explicite. Éléments doivent être implicitement imbriqués dans l’ordre pour les tables de données correspondant à participer à une relation imbriquée.  
  
   
  
## Examples  
 L’application console suivante crée un nouveau <xref:System.Data.DataTable>et écrit le schéma pour cette table dans un fichier. Ensuite, l’exemple crée un nouveau <xref:System.Data.DataTable> et lit son schéma à partir du schéma XML enregistré, en utilisant le fichier comme source.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" /> utilisé pour lire les informations de schéma.</param>
        <summary>Lit un schéma XML dans le <see cref="T:System.Data.DataTable" /> à l'aide du <see cref="T:System.Xml.XmlReader" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.ReadXmlSchema%2A> méthode pour créer le schéma pour un <xref:System.Data.DataTable>. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est interprété en fonction de la norme XSD.  
  
 Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas. Aucune exception n’est levée.  
  
 Le `ReadXmlSchema` méthode est généralement appelée avant la <xref:System.Data.DataTable.ReadXml%2A> méthode qui est utilisée pour remplir le <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Le moyen de créer une relation imbriquée à l’aide du schéma XML est d’avoir des éléments imbriqués implicites. En outre, la relation imbriquée peut être ré-câblée, d’utiliser des noms de colonnes explicite. Il est obligatoire pour les éléments implicitement imbriquée pour les tables de données correspondant à participer à une relation imbriquée.  
  
   
  
## Examples  
 L’application console suivante crée un nouveau <xref:System.Data.DataTable>et écrit le schéma pour cette table à un <xref:System.IO.MemoryStream>. Ensuite, l’exemple crée un nouveau <xref:System.Data.DataTable> et lit son schéma à partir du schéma XML enregistré, en utilisant un <xref:System.Xml.XmlTextReader> (qui hérite <xref:System.Xml.XmlReader>) comme source.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Objet <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Lectures d'un flux de données XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberSignature Language="F#" Value="member this.RejectChanges : unit -&gt; unit" Usage="dataTable.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restaure toutes les modifications apportées à la table depuis son chargement ou le dernier appel à <see cref="M:System.Data.DataTable.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Data.DataTable.RejectChanges%2A> est appelé, tout <xref:System.Data.DataRow> objets qui sont toujours en mode édition annulent ses modifications. Nouvelles lignes sont supprimées. Lignes avec le <xref:System.Data.DataRowState> définie sur `Modified` ou `Deleted` retour à leur état d’origine.  
  
   
  
## Examples  
 L’exemple suivant apporte plusieurs modifications à un <xref:System.Data.DataTable>, mais rejette les modifications en appelant le <xref:System.Data.DataTable.RejectChanges%2A> (méthode).  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataTable.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le format de sérialisation.</summary>
        <value>Énumération <see cref="T:System.Data.SerializationFormat" /> spécifiant la sérialisation <see langword="Binary" /> ou <see langword="Xml" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataTable.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rétablit l'état d'origine de <see cref="T:System.Data.DataTable" />. La réinitialisation supprime toutes les données, relations et colonnes de la table. Si un DataSet inclut un DataTable, la table fera partie du DataSet après sa réinitialisation.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberSignature Language="F#" Value="member this.RowChanged : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanged : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après la modification réussie de <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [gestion des événements de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberSignature Language="F#" Value="member this.RowChanging : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanging : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque <see cref="T:System.Data.DataRow" /> est en cours de modification.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [gestion des événements de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberSignature Language="F#" Value="member this.RowDeleted : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleted : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une ligne de la table a été supprimée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [gestion des événements de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberSignature Language="F#" Value="member this.RowDeleting : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleting : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit avant qu'une ligne de la table soit sur le point d'être supprimée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez [gestion des événements de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Rows : System.Data.DataRowCollection" Usage="System.Data.DataTable.Rows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection des lignes qui appartiennent à cette table.</summary>
        <value><see cref="T:System.Data.DataRowCollection" /> qui contient des objets <see cref="T:System.Data.DataRow" />, ou une valeur null s'il n'existe aucun objet <see cref="T:System.Data.DataRow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour créer un nouveau <xref:System.Data.DataRow>, vous devez utiliser le <xref:System.Data.DataTable.NewRow%2A> méthode retourne un nouvel objet. Ce type d’objet est automatiquement configuré selon le schéma défini pour le <xref:System.Data.DataTable> via sa collection de <xref:System.Data.DataColumn> objets. Après avoir créé une nouvelle ligne et définir les valeurs pour chaque colonne dans la ligne, ajoutez la ligne à la <xref:System.Data.DataRowCollection> à l’aide de la `Add` (méthode).  
  
 Chaque <xref:System.Data.DataRow> dans la collection représente une ligne de données dans la table. Pour valider une modification à la valeur d’une colonne dans la ligne, vous devez appeler la <xref:System.Data.DataTable.AcceptChanges%2A> (méthode).  
  
   
  
## Examples  
 Voici deux exemples de retour et la définition des lignes. Le premier exemple utilise le <xref:System.Data.DataTable.Rows%2A> propriété et imprime la valeur de chaque colonne pour chaque ligne. Le deuxième exemple utilise le <xref:System.Data.DataTable> l’objet <xref:System.Data.DataTable.NewRow%2A> pour créer une nouvelle méthode <xref:System.Data.DataRow> objet avec le schéma de la <xref:System.Data.DataTable>. Après avoir défini les valeurs de ligne, la ligne est ajoutée à la <xref:System.Data.DataRowCollection> via la `Add` (méthode).  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un tableau d’objets <see cref="T:System.Data.DataRow" />.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; System.Data.DataRow[]" Usage="dataTable.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un tableau de tous les objets <see cref="T:System.Data.DataRow" />.</summary>
        <returns>Tableau d'objets <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour garantir l’ordre de tri approprié, spécifiez les critères de tri avec <xref:System.Data.DataTable.Select(System.String,System.String)> ou <xref:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)>.  
  
   
  
## Examples  
 L’exemple suivant retourne un tableau de <xref:System.Data.DataRow> objets via le <xref:System.Data.DataTable.Select%2A> (méthode).  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Valeurs Null</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberSignature Language="F#" Value="member this.Select : string -&gt; System.Data.DataRow[]" Usage="dataTable.Select filterExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Critères à utiliser pour filtrer les lignes. Pour obtenir des exemples sur la manière de filtrer les lignes, consultez la rubrique relative à la [syntaxe DataView RowFilter [C#]](https://www.csharp-examples.net/dataview-rowfilter/).</param>
        <summary>Obtient un tableau de tous les objets <see cref="T:System.Data.DataRow" /> qui correspondent aux critères de filtre.</summary>
        <returns>Tableau d'objets <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour créer le `filterExpression` argument, utiliser les mêmes règles qui s’appliquent à la <xref:System.Data.DataColumn> la classe <xref:System.Data.DataColumn.Expression%2A> valeur de propriété pour la création de filtres.  
  
Pour garantir l’ordre de tri approprié, spécifiez les critères de tri avec <xref:System.Data.DataTable.Select(System.String,System.String)> ou <xref:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)>.
  
 Si la colonne sur le filtre contient une valeur null, il ne fera pas partie du résultat.  
  
   
  
## Examples  
 L’exemple suivant utilise une expression de filtre pour retourner un tableau de <xref:System.Data.DataRow> objets.  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Valeurs Null</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Critères à utiliser pour filtrer les lignes. Pour obtenir des exemples sur la manière de filtrer les lignes, consultez la rubrique relative à la [syntaxe DataView RowFilter [C#]](https://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Chaîne spécifiant la colonne et le sens du tri.</param>
        <summary>Obtient un tableau de tous les objets <see cref="T:System.Data.DataRow" /> qui correspondent aux critères de filtre, dans l'ordre de tri spécifié.</summary>
        <returns>Tableau d'objets <see cref="T:System.Data.DataRow" /> correspondant à l'expression de filtre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour former le `filterExpression` argument, utiliser les mêmes règles pour la création de la <xref:System.Data.DataColumn> la classe de <xref:System.Data.DataColumn.Expression%2A> valeur de propriété. Le `Sort` argument utilise également les mêmes règles pour la création de la classe <xref:System.Data.DataColumn.Expression%2A> chaînes.  
  
 Si la colonne sur le filtre contient une valeur null, il ne fera pas partie du résultat.  
  
   
  
## Examples  
 L’exemple suivant utilise une expression de filtre pour retourner un tableau de <xref:System.Data.DataRow> objets.  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Valeurs Null</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string * System.Data.DataViewRowState -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort, recordStates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Critères à utiliser pour filtrer les lignes. Pour obtenir des exemples sur la manière de filtrer les lignes, consultez la rubrique relative à la [syntaxe DataView RowFilter [C#]](https://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Chaîne spécifiant la colonne et le sens du tri.</param>
        <param name="recordStates">Une des valeurs de <see cref="T:System.Data.DataViewRowState" />.</param>
        <summary>Obtient un tableau de tous les objets <see cref="T:System.Data.DataRow" /> qui correspondent au filtre et à l'état spécifié, dans l'ordre de tri.</summary>
        <returns>Tableau d'objets <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour former le `filterExpression` argument, utiliser les mêmes règles pour la création de la <xref:System.Data.DataColumn> la classe de <xref:System.Data.DataColumn.Expression%2A> valeur de propriété. Le `Sort` argument utilise également les mêmes règles pour la création de la classe <xref:System.Data.DataColumn.Expression%2A> chaînes.  
  
 Si la colonne sur le filtre contient une valeur null, il ne fera pas partie du résultat.  
  
   
  
## Examples  
 L’exemple suivant utilise un état d’expression et un enregistrement de filtre pour retourner un tableau de <xref:System.Data.DataRow> objets.  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Valeurs Null</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataTable.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un élément <see cref="T:System.ComponentModel.ISite" /> pour l'élément <see cref="T:System.Data.DataTable" />.</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> pour <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites lient un <xref:System.ComponentModel.Component> à un <xref:System.ComponentModel.Container> et activer la communication entre eux, ainsi que fournir un moyen pour le conteneur gérer ses composants.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IListSource.ContainsListCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value><see langword="true" /> si la collection est une collection d'objets <see cref="T:System.Collections.IList" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.DataTable> est castée en interface <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IListSource.GetList</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns><see cref="T:System.Collections.IList" /> pouvant être lié à une source de données à partir de l'objet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.DataTable> est castée en interface <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <summary>Remplit un objet d’informations de sérialisation avec les données nécessaires pour sérialiser <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns><see cref="T:System.Xml.Schema.XmlSchema" /> qui décrit la représentation XML de l’objet qui est généré par la méthode <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> et utilisé par la méthode <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.DataSet> est castée en interface <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Un XmlReader.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.DataSet> est castée en interface <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Un XmlWriter.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.DataSet> est castée en interface <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberSignature Language="F#" Value="member this.TableCleared : System.Data.DataTableClearEventHandler " Usage="member this.TableCleared : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit une fois <see cref="T:System.Data.DataTable" /> effacé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.TableCleared> événement est déclenché immédiatement après que toutes les lignes ont été effacées avec succès, mais avant le <xref:System.Data.DataTable.Clear%2A> méthode retourne le contrôle à l’appelant. Le <xref:System.Data.DataTable.TableCleared> événement n’est pas déclenché si il existe des exceptions pendant l’opération d’effacement.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberSignature Language="F#" Value="member this.TableClearing : System.Data.DataTableClearEventHandler " Usage="member this.TableClearing : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque <see cref="T:System.Data.DataTable" /> est effacé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.TableClearing> événement est déclenché avant le traitement de la <xref:System.Data.DataTable.Clear%2A> début de l’opération. Cet événement est toujours déclenché lorsque la <xref:System.Data.DataTable.Clear%2A> méthode est appelée, même si la table ne contient aucune ligne.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Data.DataTable.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableTableNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de l'objet <see cref="T:System.Data.DataTable" />.</summary>
        <value>Nom du <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.TableName%2A> est utilisé pour retourner cette table à partir du parent <xref:System.Data.DataSet> l’objet <xref:System.Data.DataTableCollection> (retourné par la <xref:System.Data.DataSet.Tables%2A> propriété).  
  
   
  
## Examples  
 L’exemple suivant imprime le <xref:System.Data.DataTable.TableName%2A> pour chaque table dans une collection de <xref:System.Data.DataTable> objets.  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une chaîne vide ("") ou <see langword="null" /> est passé et cette table appartient à une collection.</exception>
        <exception cref="T:System.Data.DuplicateNameException">La table appartient à une collection qui contient déjà une table portant le même nom. (La comparaison respecte la casse).</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberSignature Language="F#" Value="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " Usage="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un nouveau <see cref="T:System.Data.DataRow" /> est inséré.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se déclenche après une nouvelle <xref:System.Data.DataRow> a été créé à l’aide de <xref:System.Data.DataTable.NewRow%2A>. Cet événement est déclenché avant l’appelée `NewRow` méthode retourne. La nouvelle <xref:System.Data.DataRow> instance est détachée ; il n’a pas été ajouté à la collection.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Utilisation des événements de DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dataTable.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le <see cref="P:System.Data.DataTable.TableName" /> et le <see cref="P:System.Data.DataTable.DisplayExpression" /> éventuels sous la forme d'une chaîne concaténée.</summary>
        <returns>Chaîne constituée des valeurs <see cref="P:System.Data.DataTable.TableName" /> et <see cref="P:System.Data.DataTable.DisplayExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obtient le <xref:System.Data.DataTable.TableName%2A> et <xref:System.Data.DataTable.DisplayExpression%2A> pour le <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 L’exemple suivant retourne le <xref:System.Data.DataTable.TableName%2A> et <xref:System.Data.DataTable.DisplayExpression%2A> à l’aide de la <xref:System.Data.DataTable.ToString%2A> (méthode).  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit le contenu actuel du <see cref="T:System.Data.DataTable" /> au format XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui incluent le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L’application console suivante crée deux <xref:System.Data.DataTable> instances, ajoute chacun d’eux à un <xref:System.Data.DataSet>, crée un <xref:System.Data.DataRelation> concernant les deux tables, puis utilise le <xref:System.Data.DataTable.WriteXml%2A> méthode pour écrire les données contenues dans la table parente à une <xref:System.IO.TextWriter>. L’exemple illustre le comportement lors de la définition du `writeHierarchy` paramètre à chacun de ses valeurs.  
  
> [!NOTE]
>  Cet exemple montre comment utiliser une des versions surchargées de WriteXml. Pour obtenir des exemples qui peuvent être disponibles, consultez les rubriques de surcharges individuelles.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 L'exemple affiche la sortie suivante dans la fenêtre de console :  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de données dans lequel les données seront écrites.</param>
        <summary>Écrit le contenu actuel de l’objet <see cref="T:System.Data.DataTable" /> sous forme XML à l’aide de <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> avec lequel écrire le contenu.</param>
        <summary>Écrit le contenu actuel de l’objet <see cref="T:System.Data.DataTable" /> sous forme XML à l’aide de <see cref="T:System.IO.TextWriter" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataTable.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Fichier dans lequel écrire les données XML.</param>
        <summary>Écrit le contenu actuel du <see cref="T:System.Data.DataTable" /> au format XML à l'aide du fichier spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /> à l'aide duquel écrire le contenu.</param>
        <summary>Écrit le contenu actuel de l’objet <see cref="T:System.Data.DataTable" /> sous forme XML à l’aide de <see cref="T:System.Xml.XmlWriter" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui incluent le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXml (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de données dans lequel les données seront écrites.</param>
        <param name="writeHierarchy">Si <see langword="true" />, écrivez le contenu de la table en cours et de tous ses descendants. Si <see langword="false" /> (valeur par défaut), écrivez les données pour la table en cours uniquement.</param>
        <summary>Écrit le contenu actuel de l’objet <see cref="T:System.Data.DataTable" /> sous forme XML à l’aide de <see cref="T:System.IO.Stream" /> spécifié. Pour enregistrer les données pour la table et tous ses descendants, affectez au paramètre <paramref name="writeHierarchy" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataTable> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXml%2A> (méthode).  
  
 Normalement le `WriteXml` méthode écrit les données uniquement pour la table actuelle. Pour écrire les données pour la table actuelle et tous ses descendants, les tables associées, appelez la méthode avec le `writeHierarchy` paramètre défini sur `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de données dans lequel les données seront écrites.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Écrit les données en cours, et éventuellement le schéma, de <see cref="T:System.Data.DataTable" /> dans le fichier spécifié à l'aide du <see cref="T:System.Data.XmlWriteMode" /> spécifié. Pour écrire le schéma, affectez <see langword="WriteSchema" /> comme valeur du paramètre <paramref name="mode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> avec lequel écrire le contenu.</param>
        <param name="writeHierarchy">Si <see langword="true" />, écrivez le contenu de la table en cours et de tous ses descendants. Si <see langword="false" /> (valeur par défaut), écrivez les données pour la table en cours uniquement.</param>
        <summary>Écrit le contenu actuel de l’objet <see cref="T:System.Data.DataTable" /> sous forme XML à l’aide de <see cref="T:System.IO.TextWriter" /> spécifié. Pour enregistrer les données pour la table et tous ses descendants, affectez au paramètre <paramref name="writeHierarchy" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Normalement le `WriteXml` méthode écrit les données uniquement pour la table actuelle. Pour écrire les données pour la table actuelle et tous ses descendants et tables associées, appelez la méthode avec le `writeHierarchy` paramètre défini sur `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L’application console suivante crée deux <xref:System.Data.DataTable> instances, ajoute chacun d’eux à un <xref:System.Data.DataSet>, crée un <xref:System.Data.DataRelation> concernant les deux tables, puis utilise le <xref:System.Data.DataTable.WriteXml%2A> méthode pour écrire les données contenues dans la table parente à une <xref:System.IO.TextWriter>. L’exemple illustre le comportement lors de la définition du `writeHierarchy` paramètre `true`.  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> utilisé pour écrire le document.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Écrit les données en cours, et éventuellement le schéma, de <see cref="T:System.Data.DataTable" /> à l'aide des <see cref="T:System.IO.TextWriter" /> et <see cref="T:System.Data.XmlWriteMode" /> spécifiés. Pour écrire le schéma, affectez <see langword="WriteSchema" /> comme valeur du paramètre <paramref name="mode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Fichier dans lequel écrire les données XML.</param>
        <param name="writeHierarchy">Si <see langword="true" />, écrivez le contenu de la table en cours et de tous ses descendants. Si <see langword="false" /> (valeur par défaut), écrivez les données pour la table en cours uniquement.</param>
        <summary>Écrit le contenu actuel du <see cref="T:System.Data.DataTable" /> au format XML à l'aide du fichier spécifié. Pour enregistrer les données pour la table et tous ses descendants, affectez au paramètre <paramref name="writeHierarchy" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
 Normalement le `WriteXml` méthode écrit les données uniquement pour la table actuelle. Pour écrire les données pour la table actuelle et tous ses descendants, les tables associées, appelez la méthode avec le `writeHierarchy` paramètre défini sur `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier dans lequel les données seront écrites.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Écrit les données en cours, et éventuellement le schéma, de <see cref="T:System.Data.DataTable" /> à l'aide du fichier et <see cref="T:System.Data.XmlWriteMode" /> spécifiés. Pour écrire le schéma, affectez <see langword="WriteSchema" /> comme valeur du paramètre <paramref name="mode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui incluent le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /> à l'aide duquel écrire le contenu.</param>
        <param name="writeHierarchy">Si <see langword="true" />, écrivez le contenu de la table en cours et de tous ses descendants. Si <see langword="false" /> (valeur par défaut), écrivez les données pour la table en cours uniquement.</param>
        <summary>Écrit le contenu actuel de l’objet <see cref="T:System.Data.DataTable" /> sous forme XML à l’aide de <see cref="T:System.Xml.XmlWriter" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui incluent le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
 Normalement le `WriteXml` méthode écrit les données uniquement pour la table actuelle. Pour écrire les données pour la table actuelle et son ensemble descendants et tables associées, appelez la méthode avec le `writeHierarchy` paramètre défini sur `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /> utilisé pour écrire le document.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Écrit les données en cours, et éventuellement le schéma, de <see cref="T:System.Data.DataTable" /> à l'aide des <see cref="T:System.Xml.XmlWriter" /> et <see cref="T:System.Data.XmlWriteMode" /> spécifiés. Pour écrire le schéma, affectez <see langword="WriteSchema" /> comme valeur du paramètre <paramref name="mode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui incluent le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (stream, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de données dans lequel les données seront écrites.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Si <see langword="true" />, écrivez le contenu de la table en cours et de tous ses descendants. Si <see langword="false" /> (valeur par défaut), écrivez les données pour la table en cours uniquement.</param>
        <summary>Écrit les données en cours, et éventuellement le schéma, de <see cref="T:System.Data.DataTable" /> dans le fichier spécifié à l'aide du <see cref="T:System.Data.XmlWriteMode" /> spécifié. Pour écrire le schéma, affectez <see langword="WriteSchema" /> comme valeur du paramètre <paramref name="mode" />. Pour enregistrer les données pour la table et tous ses descendants, affectez au paramètre <paramref name="writeHierarchy" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un `DataTable` dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le `XmlWriteMode` paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
 Normalement, le `WriteXml` méthode enregistre les données uniquement pour la table actuelle. Le `WriteXml` méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un `DataTable` dans un document XML, tandis que le `WriteXmlSchema` méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le `XmlWriteMode` paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
 Normalement le `WriteXml` méthode écrit les données uniquement pour la table actuelle. Pour écrire les données pour la table actuelle et tous ses descendants, les tables associées, appelez la méthode avec le `writeHierarchy` paramètre défini sur `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> utilisé pour écrire le document.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Si <see langword="true" />, écrivez le contenu de la table en cours et de tous ses descendants. Si <see langword="false" /> (valeur par défaut), écrivez les données pour la table en cours uniquement.</param>
        <summary>Écrit les données en cours, et éventuellement le schéma, de <see cref="T:System.Data.DataTable" /> à l'aide des <see cref="T:System.IO.TextWriter" /> et <see cref="T:System.Data.XmlWriteMode" /> spécifiés. Pour écrire le schéma, affectez <see langword="WriteSchema" /> comme valeur du paramètre <paramref name="mode" />. Pour enregistrer les données pour la table et tous ses descendants, affectez au paramètre <paramref name="writeHierarchy" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
 Normalement, le `WriteXml` méthode enregistre les données uniquement pour la table actuelle. Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
 Normalement le `WriteXml` méthode écrit les données uniquement pour la table actuelle. Pour écrire les données pour la table actuelle et tous ses descendants, les tables associées, appelez la méthode avec le `writeHierarchy` paramètre défini sur `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L’application console suivante crée deux <xref:System.Data.DataTable> instances, ajoute chacun d’eux à un <xref:System.Data.DataSet>, crée un <xref:System.Data.DataRelation> concernant les deux tables, puis utilise le <xref:System.Data.DataTable.WriteXml%2A> méthode pour écrire les données contenues dans la table parente à une <xref:System.IO.TextWriter>. L’exemple illustre le comportement lors de la définition du `writeHierarchy` paramètre à chacun de ses valeurs.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 L'exemple affiche la sortie suivante dans la fenêtre de console :  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier dans lequel les données seront écrites.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Si <see langword="true" />, écrivez le contenu de la table en cours et de tous ses descendants. Si <see langword="false" /> (valeur par défaut), écrivez les données pour la table en cours uniquement.</param>
        <summary>Écrit les données en cours, et éventuellement le schéma, de <see cref="T:System.Data.DataTable" /> à l'aide du fichier et <see cref="T:System.Data.XmlWriteMode" /> spécifiés. Pour écrire le schéma, affectez <see langword="WriteSchema" /> comme valeur du paramètre <paramref name="mode" />. Pour enregistrer les données pour la table et tous ses descendants, affectez au paramètre <paramref name="writeHierarchy" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui incluent le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
 Normalement, le `WriteXml` méthode enregistre les données uniquement pour la table actuelle. Si vous souhaitez enregistrer les données pour la table actuelle et l’ensemble du schéma, le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui incluent le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
 Normalement le `WriteXml` méthode écrit les données uniquement pour la table actuelle. Pour écrire les données pour la table actuelle et tous les descendants et tables associées, appelez la méthode avec le `writeHierarchy` paramètre défini sur `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /> utilisé pour écrire le document.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <param name="writeHierarchy">Si <see langword="true" />, écrivez le contenu de la table en cours et de tous ses descendants. Si <see langword="false" /> (valeur par défaut), écrivez les données pour la table en cours uniquement.</param>
        <summary>Écrit les données en cours, et éventuellement le schéma, de <see cref="T:System.Data.DataTable" /> à l'aide des <see cref="T:System.Xml.XmlWriter" /> et <see cref="T:System.Data.XmlWriteMode" /> spécifiés. Pour écrire le schéma, affectez <see langword="WriteSchema" /> comme valeur du paramètre <paramref name="mode" />. Pour enregistrer les données pour la table et tous ses descendants, affectez au paramètre <paramref name="writeHierarchy" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.WriteXml%2A> méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataTable> dans un document XML, tandis que le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui incluent le <xref:System.Data.XmlWriteMode> paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataTable.ReadXml%2A> et <xref:System.Data.DataTable.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataTable`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
 Normalement le `WriteXml` méthode écrit les données uniquement pour la table actuelle. Pour écrire les données pour la table actuelle et son ensemble descendants et tables associées, appelez la méthode avec le `writeHierarchy` paramètre défini sur `true`.  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit la structure de données actuelle du <see cref="T:System.Data.DataTable" /> sous la forme d'un schéma XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataTable> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXml%2A> (méthode).  
  
   
  
## Examples  
 L’application console suivante crée deux <xref:System.Data.DataTable> instances, ajoute chacun d’eux à un <xref:System.Data.DataSet>, crée un <xref:System.Data.DataRelation> concernant les deux tables, puis utilise le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode pour écrire les données contenues dans la table parente à une <xref:System.IO.TextWriter>. L’exemple illustre le comportement lors de la définition du `writeHierarchy` paramètre à chacun de ses valeurs.  
  
> [!NOTE]
>  Cet exemple montre comment utiliser une des versions surchargées de `WriteXmlSchema` pour d’autres exemples qui peuvent être disponibles, consultez les rubriques de surcharges individuelles.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 L'exemple affiche la sortie suivante dans la fenêtre de console :  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de données dans lequel le schéma XML sera écrit.</param>
        <summary>Écrit la structure de données actuelle du <see cref="T:System.Data.DataTable" /> sous la forme d'un schéma XML dans le flux de données spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataTable> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXml%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> à l'aide duquel effectuer l'écriture.</param>
        <summary>Écrit la structure de données actuelle du <see cref="T:System.Data.DataTable" /> sous la forme d'un schéma XML à l'aide du <see cref="T:System.IO.TextWriter" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataTable> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXml%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataTable.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier à utiliser.</param>
        <summary>Écrit la structure de données actuelle du <see cref="T:System.Data.DataTable" /> sous la forme d'un schéma XML dans le fichier spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataTable> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXml%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /> à utiliser.</param>
        <summary>Écrit la structure de données actuelle du <see cref="T:System.Data.DataTable" /> sous la forme d'un schéma XML à l'aide du <see cref="T:System.Xml.XmlWriter" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataTable> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXml%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de données dans lequel le schéma XML sera écrit.</param>
        <param name="writeHierarchy">Si <see langword="true" />, écrivez le schéma de la table en cours et de tous ses descendants. Si <see langword="false" /> (valeur par défaut), écrivez le schéma pour la table en cours uniquement.</param>
        <summary>Écrit la structure de données actuelle du <see cref="T:System.Data.DataTable" /> sous la forme d'un schéma XML dans le flux de données spécifié. Pour enregistrer le schéma pour la table et tous ses descendants, affectez au paramètre <paramref name="writeHierarchy" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataTable> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXml%2A> (méthode).  
  
 Normalement le `WriteXmlSchema` méthode écrit le schéma uniquement pour la table actuelle. Pour écrire le schéma pour la table actuelle et son ensemble descendants et tables associées, appelez la méthode avec le `writeHierarchy` paramètre défini sur `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> à l'aide duquel effectuer l'écriture.</param>
        <param name="writeHierarchy">Si <see langword="true" />, écrivez le schéma de la table en cours et de tous ses descendants. Si <see langword="false" /> (valeur par défaut), écrivez le schéma pour la table en cours uniquement.</param>
        <summary>Écrit la structure de données actuelle du <see cref="T:System.Data.DataTable" /> sous la forme d'un schéma XML à l'aide du <see cref="T:System.IO.TextWriter" /> spécifié. Pour enregistrer le schéma pour la table et tous ses descendants, affectez au paramètre <paramref name="writeHierarchy" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataTable> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXml%2A> (méthode).  
  
 Normalement le `WriteXmlSchema` méthode écrit le schéma uniquement pour la table actuelle. Pour écrire le schéma pour la table actuelle et son ensemble descendants et tables associées, appelez la méthode avec le `writeHierarchy` paramètre défini sur `true`.  
  
   
  
## Examples  
 L’application console suivante crée deux <xref:System.Data.DataTable> instances, ajoute chacun d’eux à un <xref:System.Data.DataSet>, crée un <xref:System.Data.DataRelation> concernant les deux tables, puis utilise le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode pour écrire les données contenues dans la table parente à une <xref:System.IO.TextWriter>. L’exemple illustre le comportement lors de la définition du `writeHierarchy` paramètre à chacun de ses valeurs.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 L'exemple affiche la sortie suivante dans la fenêtre de console :  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier à utiliser.</param>
        <param name="writeHierarchy">Si <see langword="true" />, écrivez le schéma de la table en cours et de tous ses descendants. Si <see langword="false" /> (valeur par défaut), écrivez le schéma pour la table en cours uniquement.</param>
        <summary>Écrit la structure de données actuelle du <see cref="T:System.Data.DataTable" /> sous la forme d'un schéma XML dans le fichier spécifié. Pour enregistrer le schéma pour la table et tous ses descendants, affectez au paramètre <paramref name="writeHierarchy" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataTable> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXml%2A> (méthode).  
  
 Normalement le `WriteXmlSchema` méthode écrit le schéma uniquement pour la table actuelle. Pour écrire le schéma pour la table actuelle et son ensemble descendants et tables associées, appelez la méthode avec le `writeHierarchy` paramètre défini sur `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /> utilisé pour écrire le document.</param>
        <param name="writeHierarchy">Si <see langword="true" />, écrivez le schéma de la table en cours et de tous ses descendants. Si <see langword="false" /> (valeur par défaut), écrivez le schéma pour la table en cours uniquement.</param>
        <summary>Écrit la structure de données actuelle du <see cref="T:System.Data.DataTable" /> sous la forme d'un schéma XML à l'aide du <see cref="T:System.Xml.XmlWriter" /> spécifié. Pour enregistrer le schéma pour la table et tous ses descendants, affectez au paramètre <paramref name="writeHierarchy" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataTable.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataTable> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataTable.WriteXml%2A> (méthode).  
  
 Normalement le `WriteXmlSchema` méthode écrit le schéma uniquement pour la table actuelle. Pour écrire le schéma pour la table actuelle et son ensemble descendants et tables associées, appelez la méthode avec le `writeHierarchy` paramètre défini sur `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Création et utilisation de DataTables</related>
      </Docs>
    </Member>
  </Members>
</Type>