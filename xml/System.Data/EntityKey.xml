<Type Name="EntityKey" FullName="System.Data.EntityKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="34b9a65980ca289fb3ed6280bf21413c381fdafa" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52344143" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class EntityKey : IEquatable&lt;System.Data.EntityKey&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityKey extends System.Object implements class System.IEquatable`1&lt;class System.Data.EntityKey&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Data.EntityKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityKey&#xA;Implements IEquatable(Of EntityKey)" />
  <TypeSignature Language="C++ CLI" Value="public ref class EntityKey sealed : IEquatable&lt;System::Data::EntityKey ^&gt;" />
  <TypeSignature Language="F#" Value="type EntityKey = class&#xA;    interface IEquatable&lt;EntityKey&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Data.EntityKey&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{ConcatKeyValue()}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.Serialization.DataContract(IsReference=true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit une référence durable à un objet qui est une instance d'un type d'entité.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les objets <xref:System.Data.EntityKey> sont immuables, ce qui signifie qu'ils ne peuvent plus être modifiés une fois construits.  
  
 Pour plus d’informations, consultez [utilisation des clés d’entité](https://msdn.microsoft.com/library/fe3f4206-d277-43a1-a72f-4e86fdf12b9f).  
  
   
  
## Examples  
 Ces exemples sont basés sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Les exemples vous montrent comment créer et utiliser un <xref:System.Data.EntityKey>.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]  
  
 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.EntityKey" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.EntityKey" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; entityKeyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; entityKeyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, entityKeyValues As IEnumerable(Of KeyValuePair(Of String, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ entityKeyValues);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityKey : string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Data.EntityKey" Usage="new System.Data.EntityKey (qualifiedEntitySetName, entityKeyValues)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="entityKeyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">Objet <see cref="T:System.String" /> qui correspond au nom du jeu d'entités, qualifié par le nom du conteneur d'entités.</param>
        <param name="entityKeyValues">Collection <see cref="T:System.Collections.Generic.KeyValuePair" /> générique.  
  
Chaque paire clé/valeur a un nom de propriété comme clé et la valeur de cette propriété comme valeur. Il doit y avoir une paire pour chaque propriété qui fait partie de l'objet <see cref="T:System.Data.EntityKey" />. L'ordre des paires clé/valeur n'est pas important, mais chaque propriété de clé doit être incluse. Les noms de propriétés sont des noms simples qui ne sont pas qualifiés avec un nom de type d'entité ou le nom de schéma.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.EntityKey" /> avec un nom de jeu d'entités et une collection <see cref="T:System.Collections.Generic.KeyValuePair" /> générique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L’exemple vous montre comment créer et utiliser un <xref:System.Data.EntityKey>.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, System.Collections.Generic.IEnumerable&lt;System.Data.EntityKeyMember&gt; entityKeyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.EntityKeyMember&gt; entityKeyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Data.EntityKeyMember})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, entityKeyValues As IEnumerable(Of EntityKeyMember))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::Collections::Generic::IEnumerable&lt;System::Data::EntityKeyMember ^&gt; ^ entityKeyValues);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityKey : string * seq&lt;System.Data.EntityKeyMember&gt; -&gt; System.Data.EntityKey" Usage="new System.Data.EntityKey (qualifiedEntitySetName, entityKeyValues)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="entityKeyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.EntityKeyMember&gt;" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">Objet <see cref="T:System.String" /> qui correspond au nom du jeu d'entités, qualifié par le nom du conteneur d'entités.</param>
        <param name="entityKeyValues">Collection <see cref="T:System.Collections.Generic.IEnumerable`1" /> d’objets <see cref="T:System.Data.EntityKeyMember" /> avec lesquels initialiser la clé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.EntityKey" /> avec un nom de jeu d'entités et une collection <see cref="T:System.Collections.Generic.IEnumerable`1" /> de <see cref="T:System.Data.EntityKeyMember" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, string keyName, object keyValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, string keyName, object keyValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, keyName As String, keyValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::String ^ keyName, System::Object ^ keyValue);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityKey : string * string * obj -&gt; System.Data.EntityKey" Usage="new System.Data.EntityKey (qualifiedEntitySetName, keyName, keyValue)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="keyValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">Objet <see cref="T:System.String" /> qui correspond au nom du jeu d'entités, qualifié par le nom du conteneur d'entités.</param>
        <param name="keyName">Objet <see cref="T:System.String" /> qui correspond au nom de la clé.</param>
        <param name="keyValue">Objet <see cref="T:System.Object" /> qui correspond à la valeur de la clé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.EntityKey" /> avec un nom de jeu d'entités et une paire de clés d'entités spécifique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple est basé sur le [AdventureWorks Sales Model](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). L’exemple vous montre comment créer et utiliser un <xref:System.Data.EntityKey>.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityContainerName">
      <MemberSignature Language="C#" Value="public string EntityContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EntityContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntityContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EntityContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EntityContainerName : string with get, set" Usage="System.Data.EntityKey.EntityContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom du conteneur d'entités.</summary>
        <value>Valeur <see cref="T:System.String" /> qui correspond au nom du conteneur d'entités pour l'entité à laquelle l'objet <see cref="T:System.Data.EntityKey" /> appartient.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityKeyValues">
      <MemberSignature Language="C#" Value="public System.Data.EntityKeyMember[] EntityKeyValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.EntityKeyMember[] EntityKeyValues" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntityKeyValues" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityKeyValues As EntityKeyMember()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ EntityKeyValues { cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ get(); void set(cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EntityKeyValues : System.Data.EntityKeyMember[] with get, set" Usage="System.Data.EntityKey.EntityKeyValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.EntityKeyMember[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les valeurs de clés associées à cet objet <see cref="T:System.Data.EntityKey" />.</summary>
        <value>
          <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de valeurs de clés pour cet objet <see cref="T:System.Data.EntityKey" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe <xref:System.Data.EntityKey> contient une copie des valeurs qui composent la clé logique spécifiée pour ce type d'entité.  
  
 Les membres de l'objet <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> possèdent chacun un nom de propriété et une valeur dans un objet <xref:System.Collections.Generic.KeyValuePair%602>, où la clé est le nom de propriété et la valeur est la valeur réelle de cette propriété sur l'objet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityNotValidKey">
      <MemberSignature Language="C#" Value="public static readonly System.Data.EntityKey EntityNotValidKey;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.EntityKey EntityNotValidKey" />
      <MemberSignature Language="DocId" Value="F:System.Data.EntityKey.EntityNotValidKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EntityNotValidKey As EntityKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::EntityKey ^ EntityNotValidKey;" />
      <MemberSignature Language="F#" Value=" staticval mutable EntityNotValidKey : System.Data.EntityKey" Usage="System.Data.EntityKey.EntityNotValidKey" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Data.EntityKey" /> simple qui identifie une entité résultant d’une opération [TREAT](~/docs/framework/data/adonet/ef/language-reference/treat-entity-sql.md) ayant échoué.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il existe différentes méthodes pour obtenir une entité non valide. Le scénario le plus courant est quand un [!INCLUDE[esql](~/includes/esql-md.md)] requête utilise le [traiter](~/docs/framework/data/adonet/ef/language-reference/treat-entity-sql.md) opérateur pour interpréter une instance d’un type polymorphe en tant qu’un type particulier et l’instance en question ne correspond pas. ([Traiter](~/docs/framework/data/adonet/ef/language-reference/treat-entity-sql.md) est similaire à celle de C# `as` opérateur). Dans ce cas, la requête retourne une entité qui n'est pas valide et la clé d'entité de l'entité résultante est définie à la valeur <xref:System.Data.EntityKey.EntityNotValidKey>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntitySetName">
      <MemberSignature Language="C#" Value="public string EntitySetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EntitySetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntitySetName" />
      <MemberSignature Language="VB.NET" Value="Public Property EntitySetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EntitySetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EntitySetName : string with get, set" Usage="System.Data.EntityKey.EntitySetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom du jeu d'entités.</summary>
        <value>Valeur <see cref="T:System.String" /> qui correspond au nom du jeu d'entités pour l'entité à laquelle l'objet <see cref="T:System.Data.EntityKey" /> appartient.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une valeur qui indique si cette instance est égale à un objet spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Data.EntityKey other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Data.EntityKey other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.Equals(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Data::EntityKey ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Data.EntityKey -&gt; bool" Usage="entityKey.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="other">Objet <see cref="T:System.Data.EntityKey" /> à comparer à cette instance.</param>
        <summary>Retourne une valeur qui indique si cette instance est égale à un objet <see cref="T:System.Data.EntityKey" /> spécifié.</summary>
        <returns>
          <see langword="true" /> si cette instance et l'<paramref name="other" /> ont des valeurs égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les clés temporaires ont une sémantique de comparaison différente des clés permanentes :  
  
-   Les clés temporaires utilisent l'égalité de référence. Autrement dit, deux références à la même instance <xref:System.Data.EntityKey> temporaire exacte sont égales, mais aucune autre instance <xref:System.Data.EntityKey> n'est égale.  
  
-   Les clés permanentes déterminent l'égalité en fonction des valeurs des propriétés de clés contenues et des objets <xref:System.Data.Metadata.Edm.EntitySet>. Autrement dit, vous pouvez avoir deux instances <xref:System.Data.EntityKey> distinctes égales si leurs jeux d'entités sont identiques et si leurs valeurs de clés sont égales.  
  
 De plus, les clés temporaires n'ont pas de <xref:System.Data.Metadata.Edm.EntitySet> ou de valeurs de clés, alors que les clés permanentes en ont.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="entityKey.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet <see cref="T:System.Object" /> à comparer à cette instance.</param>
        <summary>Retourne une valeur qui indique si cette instance est égale à un objet spécifié.</summary>
        <returns>
          <see langword="true" /> si cette instance et l'<paramref name="obj" /> ont des valeurs égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les clés temporaires ont une sémantique de comparaison différente des clés permanentes :  
  
-   Les clés temporaires utilisent l'égalité de référence. Autrement dit, deux références à la même instance <xref:System.Data.EntityKey> temporaire exacte sont égales, mais aucune autre instance <xref:System.Data.EntityKey> n'est égale.  
  
-   Les clés permanentes déterminent l'égalité en fonction des valeurs des propriétés de clés contenues et des objets <xref:System.Data.Metadata.Edm.EntitySet>. Autrement dit, vous pouvez avoir deux instances <xref:System.Data.EntityKey> distinctes égales si leurs objets <xref:System.Data.Metadata.Edm.EntitySet> sont identiques et si leurs valeurs de clés sont égales.  
  
 De plus, les clés temporaires n'ont pas de <xref:System.Data.Metadata.Edm.EntitySet> ou de valeurs de clés, alors que les clés permanentes en ont.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntitySet">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.EntitySet GetEntitySet (System.Data.Metadata.Edm.MetadataWorkspace metadataWorkspace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Metadata.Edm.EntitySet GetEntitySet(class System.Data.Metadata.Edm.MetadataWorkspace metadataWorkspace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.GetEntitySet(System.Data.Metadata.Edm.MetadataWorkspace)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Metadata::Edm::EntitySet ^ GetEntitySet(System::Data::Metadata::Edm::MetadataWorkspace ^ metadataWorkspace);" />
      <MemberSignature Language="F#" Value="member this.GetEntitySet : System.Data.Metadata.Edm.MetadataWorkspace -&gt; System.Data.Metadata.Edm.EntitySet" Usage="entityKey.GetEntitySet metadataWorkspace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.EntitySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataWorkspace" Type="System.Data.Metadata.Edm.MetadataWorkspace" />
      </Parameters>
      <Docs>
        <param name="metadataWorkspace">Espace de travail des métadonnées qui contient l'entité.</param>
        <summary>Obtient le jeu d'entités pour cette clé d'entité à partir de l'espace de travail des métadonnées fourni.</summary>
        <returns>
          <see cref="T:System.Data.Metadata.Edm.EntitySet" /> pour la clé d'entité.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeu d'entités est accessible en fonction du nom de conteneur d'entités et du nom de jeu d'entités de la clé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le jeu d'entités est introuvable dans l'espace de travail des métadonnées spécifié.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="entityKey.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sert de fonction de hachage à l'objet <see cref="T:System.Data.EntityKey" /> en cours. <see cref="M:System.Data.EntityKey.GetHashCode" /> convient à une utilisation dans des algorithmes de hachage et des structures de données comme une table de hachage.</summary>
        <returns>Code de hachage du <see cref="T:System.Data.EntityKey" /> actuel.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.EntityKey.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'objet <see cref="T:System.Data.EntityKey" /> est temporaire.</summary>
        <value>
          <see langword="true" /> si la <see cref="T:System.Data.EntityKey" /> est temporaire ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu'une nouvelle entité est créée, [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] définit la clé temporaire et la propriété <xref:System.Data.EntityKey.IsTemporary%2A> sur `true`. Lorsque vous appelez le <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> (méthode), le [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] assigne une clé permanente et définit la <xref:System.Data.EntityKey.IsTemporary%2A> propriété `false`.  
  
> [!NOTE]
>  Les clés temporaires sont construites automatiquement par l'infrastructure ; elles ne peuvent pas être construites directement par un utilisateur.  
  
 Les clés temporaires ont une sémantique de comparaison différente des clés permanentes :  
  
-   Les clés temporaires utilisent l'égalité de référence. Autrement dit, deux références à la même instance <xref:System.Data.EntityKey> temporaire exacte sont égales, mais aucune autre instance <xref:System.Data.EntityKey> n'est égale.  
  
-   Les clés permanentes déterminent l'égalité en fonction des valeurs des propriétés de clés contenues et des objets <xref:System.Data.Metadata.Edm.EntitySet>. Autrement dit, vous pouvez avoir deux instances <xref:System.Data.EntityKey> distinctes égales si leurs jeux d'entités sont identiques et si leurs valeurs de clés sont égales.  
  
 De plus, les clés temporaires n'ont pas de <xref:System.Data.Metadata.Edm.EntitySet> ou de valeurs de clés, alors que les clés permanentes en ont.  
  
 Lorsque la méthode <xref:System.Data.Objects.ObjectStateEntry.AcceptChanges%2A> est appelée sur l'objet <xref:System.Data.Objects.ObjectStateEntry> d'une entité et que l'entité bascule de l'état <xref:System.Data.EntityState.Added> à l'état <xref:System.Data.EntityState.Unchanged>, l'[!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] calcule automatiquement une nouvelle clé permanente pour l'entité et synchronise toutes les références de clés temporaires.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoEntitySetKey">
      <MemberSignature Language="C#" Value="public static readonly System.Data.EntityKey NoEntitySetKey;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.EntityKey NoEntitySetKey" />
      <MemberSignature Language="DocId" Value="F:System.Data.EntityKey.NoEntitySetKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoEntitySetKey As EntityKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::EntityKey ^ NoEntitySetKey;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoEntitySetKey : System.Data.EntityKey" Usage="System.Data.EntityKey.NoEntitySetKey" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Singleton <see cref="T:System.Data.EntityKey" /> par lequel une entité en lecture seule est identifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une entité en lecture seule identifie une entité qui est valide dans tous les cas, mais qui n'est associée à aucun jeu d'entités réel. Cela peut se produire dans le cadre du résultat d'une requête [!INCLUDE[esql](~/includes/esql-md.md)] qui construit et retourne une instance d'entité spécifiée dans le texte de la requête (par opposition à une entité récupérée à partir d'une table de base de données). Une entité qui n'a pas de jeu d'entités ne peut pas être rendue persistante dans la base de données tant qu'elle n'a pas été associée à un jeu d'entités. Par conséquent, le matérialiseur d'objet traite ce type d'entité comme si l'option de fusion <xref:System.Data.Objects.MergeOption.NoTracking> avait été spécifiée, quelle que soit l'option de fusion réelle spécifiée. Un objet entité sera créé, mais son identité ne sera pas résolue et il ne sera pas ajouté au gestionnaire d'état dans le cadre du processus de matérialisation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialized">
      <MemberSignature Language="C#" Value="public void OnDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.OnDeserialized(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnDeserialized (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnDeserialized(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnDeserialized : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityKey.OnDeserialized context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OnDeserialized</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Décrit la source et la destination d'un flux sérialisé donné et fournit un contexte supplémentaire défini par l'appelant.</param>
        <summary>Méthode d'assistance utilisée pour désérialiser un objet <see cref="T:System.Data.EntityKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Data.EntityKey.OnDeserialized%2A> est utilisée par Object Services lors de la désérialisation d'un objet <xref:System.Data.EntityKey>. Pour plus d’informations, consultez [sérialisation d’objets](https://msdn.microsoft.com/library/06c77f9b-5b2e-4c78-b3e3-8c148ba0ea99).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserializing">
      <MemberSignature Language="C#" Value="public void OnDeserializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnDeserializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.OnDeserializing(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnDeserializing (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnDeserializing(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnDeserializing : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityKey.OnDeserializing context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OnDeserializing</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Décrit la source et la destination d'un flux sérialisé donné et fournit un contexte supplémentaire défini par l'appelant.</param>
        <summary>Méthode d'assistance utilisée pour désérialiser un objet <see cref="T:System.Data.EntityKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode <xref:System.Data.EntityKey.OnDeserializing%2A> est utilisée par Object Services lors de la désérialisation d'un objet <xref:System.Data.EntityKey>. Pour plus d’informations, consultez [sérialisation d’objets](https://msdn.microsoft.com/library/06c77f9b-5b2e-4c78-b3e3-8c148ba0ea99).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Equality(System.Data.EntityKey,System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (key1 As EntityKey, key2 As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Data::EntityKey ^ key1, System::Data::EntityKey ^ key2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Data.EntityKey * System.Data.EntityKey -&gt; bool" Usage="key1 = key2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key1" Type="System.Data.EntityKey" />
        <Parameter Name="key2" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key1">
          <see cref="T:System.Data.EntityKey" /> à comparer.</param>
        <param name="key2">
          <see cref="T:System.Data.EntityKey" /> à comparer.</param>
        <summary>Compare deux objets <see cref="T:System.Data.EntityKey" />.</summary>
        <returns>
          <see langword="true" /> si les valeurs <paramref name="key1" /> et <paramref name="key2" /> sont égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les clés temporaires ont une sémantique de comparaison différente des clés permanentes :  
  
-   Les clés temporaires utilisent l'égalité de référence. Autrement dit, deux références à la même instance <xref:System.Data.EntityKey> temporaire exacte sont égales, mais aucune autre instance <xref:System.Data.EntityKey> n'est égale.  
  
-   Les clés permanentes déterminent l'égalité en fonction des valeurs des propriétés de clés contenues et des objets <xref:System.Data.Metadata.Edm.EntitySet>. Autrement dit, vous pouvez avoir deux instances <xref:System.Data.EntityKey> distinctes égales si leurs jeux d'entités sont identiques et si leurs valeurs de clés sont égales.  
  
 De plus, les clés temporaires n'ont pas de <xref:System.Data.Metadata.Edm.EntitySet> ou de valeurs de clés, alors que les clés permanentes en ont.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Data.EntityKey.Equals%28System.Data.EntityKey%29?displayProperty=nameWithType></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality"> <MemberSignature Language="C#" Value="public static bool op_Inequality (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Inequality(System.Data.EntityKey,System.Data.EntityKey)" />
      <MemberType>Méthode</MemberType> <AssemblyInfo> <AssemblyName>System.Data.Entity</AssemblyName> <AssemblyVersion>4.0.0.0</AssemblyVersion> </AssemblyInfo>
      <ReturnValue> <ReturnType>System.Boolean</ReturnType> </ReturnValue>
      <Parameters> <Parameter Name="key1" Type="System.Data.EntityKey" /> <Parameter Name="key2" Type="System.Data.EntityKey" /> </Parameters>
      <Docs>
        <param name="key1"><see cref="T:System.Data.EntityKey" /> à comparer.</param>
        <param name="key2"><see cref="T:System.Data.EntityKey" /> à comparer.</param>
        <summary>Compare deux objets <see cref="T:System.Data.EntityKey" />.</summary>
        <returns>
          <see langword="true" /> si les valeurs <paramref name="key1" /> et <paramref name="key2" /> ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown">&LT; ! [CDATA [  
  
## Remarks  
 Les clés temporaires ont une sémantique de comparaison différente des clés permanentes :  
  
-   Les clés temporaires utilisent l'égalité de référence. Autrement dit, deux références à la même instance <xref:System.Data.EntityKey> temporaire exacte sont égales, mais aucune autre instance <xref:System.Data.EntityKey> n'est égale.  
  
-   Les clés permanentes déterminent l'égalité en fonction des valeurs des propriétés de clés contenues et des objets <xref:System.Data.Metadata.Edm.EntitySet>. Autrement dit, vous pouvez avoir deux instances <xref:System.Data.EntityKey> distinctes égales si leurs jeux d'entités sont identiques et si leurs valeurs de clés sont égales.  
  
 De plus, les clés temporaires n'ont pas de <xref:System.Data.Metadata.Edm.EntitySet> ou de valeurs de clés, alors que les clés ordinaires en ont.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Data.EntityKey.Equals%28System.Data.EntityKey%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Inequality(System.Data.EntityKey,System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (key1 As EntityKey, key2 As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Data::EntityKey ^ key1, System::Data::EntityKey ^ key2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Data.EntityKey * System.Data.EntityKey -&gt; bool" Usage="System.Data.EntityKey.op_Inequality (key1, key2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key1" Type="System.Data.EntityKey" />
        <Parameter Name="key2" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key1">
          <see cref="T:System.Data.EntityKey" /> à comparer.</param>
        <param name="key2">
          <see cref="T:System.Data.EntityKey" /> à comparer.</param>
        <summary>Compare deux objets <see cref="T:System.Data.EntityKey" />.</summary>
        <returns>
          <see langword="true" /> si les valeurs <paramref name="key1" /> et <paramref name="key2" /> ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les clés temporaires ont une sémantique de comparaison différente des clés permanentes :  
  
-   Les clés temporaires utilisent l'égalité de référence. Autrement dit, deux références à la même instance <xref:System.Data.EntityKey> temporaire exacte sont égales, mais aucune autre instance <xref:System.Data.EntityKey> n'est égale.  
  
-   Les clés permanentes déterminent l'égalité en fonction des valeurs des propriétés de clés contenues et des objets <xref:System.Data.Metadata.Edm.EntitySet>. Autrement dit, vous pouvez avoir deux instances <xref:System.Data.EntityKey> distinctes égales si leurs jeux d'entités sont identiques et si leurs valeurs de clés sont égales.  
  
 De plus, les clés temporaires n'ont pas de <xref:System.Data.Metadata.Edm.EntitySet> ou de valeurs de clés, alors que les clés ordinaires en ont.]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>