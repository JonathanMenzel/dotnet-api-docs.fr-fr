<Type Name="DataTableReader" FullName="System.Data.DataTableReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="29593a8cafbdc6b69f6caeda60868612a408b7dc" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37670269" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DataTableReader : System.Data.Common.DbDataReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DataTableReader extends System.Data.Common.DbDataReader" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTableReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DataTableReader&#xA;Inherits DbDataReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTableReader sealed : System::Data::Common::DbDataReader" />
  <TypeSignature Language="F#" Value="type DataTableReader = class&#xA;    inherit DbDataReader" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbDataReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>L'objet <see cref="T:System.Data.DataTableReader" /> obtient le contenu d'un ou plusieurs objets <see cref="T:System.Data.DataTable" /> sous la forme d'un ou plusieurs jeux de résultats en lecture seule et en avant uniquement.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTableReader> fonctionne comme tout autre lecteur de données, telles que la <xref:System.Data.SqlClient.SqlDataReader>, sauf que le <xref:System.Data.DataTableReader> permet d’itérer les lignes dans un <xref:System.Data.DataTable>. En d’autres termes, il fournit pour itérer sur des lignes dans un cache. Les données mises en cache peuvent être modifiées pendant que le <xref:System.Data.DataTableReader> est actif, et le lecteur maintient automatiquement sa position.  
  
 Lorsque vous créez un <xref:System.Data.DataTableReader> à partir d’un <xref:System.Data.DataTable>, résultant <xref:System.Data.DataTableReader> objet contient un jeu de résultats avec les mêmes données que le <xref:System.Data.DataTable> à partir de laquelle il a été créé, à l’exception de toutes les lignes qui ont été marquées comme supprimées. Les colonnes apparaissent dans le même ordre que dans la version d’origine <xref:System.Data.DataTable>. La structure du résultat retourné est identique dans le schéma et les données à l’original <xref:System.Data.DataTable>. Un <xref:System.Data.DataTableReader> qui a été créé en appelant le <xref:System.Data.DataSet.CreateDataReader*> méthode d’un <xref:System.Data.DataSet> objet contient plusieurs jeux de résultats si le <xref:System.Data.DataSet> contient plusieurs tables. Les résultats sont dans la même séquence que les <xref:System.Data.DataTable> des objets dans le <xref:System.Data.DataTableCollection> de la <xref:System.Data.DataSet> objet.  
  
 Le jeu de résultats retourné contient uniquement la version actuelle de chaque <xref:System.Data.DataRow>; les lignes marquées pour suppression sont ignorées.  
  
 Le `DataTableReader` fournit une stable itérateur ; autrement dit, le contenu de la `DataTableReader` ne sont pas invalidées si la taille de la collection sous-jacente est modifiée pendant l’itération. Par exemple, si une ou plusieurs lignes dans le <xref:System.Data.DataTable.Rows%2A> collection sont supprimés ou supprimées pendant l’itération, la position actuelle dans le `DataTableReader` est conservée de manière appropriée et elle n’invalide pas l’itérateur.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataTableReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTable" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">
          <see cref="T:System.Data.DataTable" /> à partir duquel le nouveau <see cref="T:System.Data.DataTableReader" /> obtient son jeu de résultats.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataTableReader" /> en utilisant des données provenant du <see cref="T:System.Data.DataTable" /> spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataTables As DataTable())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTables" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
      </Parameters>
      <Docs>
        <param name="dataTables">Tableau d'objets <see cref="T:System.Data.DataTable" /> qui fournit les résultats pour le nouvel objet <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataTableReader" /> avec le tableau d'objets <see cref="T:System.Data.DataTable" /> fourni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous devez créer un <xref:System.Data.DataTableReader> basé sur tout ou partie des tables au sein d’un spécifique <xref:System.Data.DataSet>, appelez le `DataSet`de <xref:System.Data.DataSet.CreateDataReader*> (méthode). Si vous souhaitez créer un nouveau <xref:System.Data.DataTableReader> instance basée sur un groupe de `DataTable` instances qui ne sont pas autres liées, utilisez ce constructeur. Vous pouvez également tirer parti de ce constructeur pour réorganiser l’ordre de la `DataTables` au sein de la `DataTableReader`, si leur classement dans leur source `DataSet` ne répond pas à vos besoins.  
  
   
  
## Examples  
 Dans l’exemple suivant, la méthode TestConstructor crée deux <xref:System.Data.DataTable> instances. Pour montrer ce constructeur pour le <xref:System.Data.DataTableReader> (classe), l’exemple crée un `DataTableReader` basé sur un tableau qui contient les deux `DataTables`et effectue une opération simple, en imprimant le contenu à partir des premières colonnes dans la console fenêtre. Pour tester cette application, créez une application Console et collez l’exemple de code dans le fichier nouvellement créé.  
  
 [!code-csharp[DataWorks DataTableReader.ctor#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/VB/source.vb#1)]  
  
 La fenêtre de Console affiche les résultats suivants :  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="dataTableReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme le <see cref="T:System.Data.DataTableReader" /> en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel `Close()` sur un fermé `DataTableReader` objet ne génère pas d’erreur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Data.DataTableReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Profondeur d'imbrication de la ligne en cours du <see cref="T:System.Data.DataTableReader" />.</summary>
        <value>Profondeur d'imbrication de la ligne en cours ; toujours zéro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DataTableReader` ne prend pas en charge l’imbrication. Le `Depth` propriété retourne toujours zéro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldCount">
      <MemberSignature Language="C#" Value="public override int FieldCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FieldCount" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.FieldCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FieldCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int FieldCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.FieldCount : int" Usage="System.Data.DataTableReader.FieldCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne le nombre de colonnes figurant dans la ligne en cours.</summary>
        <value>0 en l'absence de positionnement dans un jeu de résultats valide ; sinon, le nombre de colonnes figurant dans la ligne en cours.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour récupérer le nombre de champs dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public override bool GetBoolean (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool GetBoolean(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBoolean(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBoolean (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool GetBoolean(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetBoolean : int -&gt; bool" Usage="dataTableReader.GetBoolean ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée sous la forme d'un <see cref="T:System.Boolean" />.</summary>
        <returns>Valeur de la colonne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucuns conversions ne sont effectuées ; Par conséquent, les données récupérées doivent déjà être une valeur booléenne ou être converti en une valeur booléenne ou une exception est générée.  
  
 Appelez <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le passé dans <xref:System.Data.DataTableReader>. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne ne sont pas le type correct, l’exemple affiche un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas de <see langword="Boolean" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public override byte GetByte (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8 GetByte(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetByte(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByte (ordinal As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Byte GetByte(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetByte : int -&gt; byte" Usage="dataTableReader.GetByte ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée sous la forme d'un octet.</summary>
        <returns>Valeur de la colonne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucuns conversions ne sont effectuées ; Par conséquent les données récupérées doivent déjà être octet ou être converti en un octet.  
  
 Appelez <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le passé dans <xref:System.Data.DataTableReader>. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne ne sont pas du type correct, l’exemple affiche un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.GetByte#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetByte#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see langword="DataTableReader" /> fermé.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas d'octet.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override long GetBytes (int ordinal, long dataIndex, byte[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetBytes(int32 ordinal, int64 dataIndex, unsigned int8[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (ordinal As Integer, dataIndex As Long, buffer As Byte(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetBytes(int ordinal, long dataIndex, cli::array &lt;System::Byte&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int * int64 * byte[] * int * int -&gt; int64" Usage="dataTableReader.GetBytes (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <param name="dataIndex">L’index figurant dans le champ à partir duquel l’opération de lecture doit être lancée.</param>
        <param name="buffer">La mémoire tampon dans laquelle le flux d’octets doit être lu.</param>
        <param name="bufferIndex">Index de la mémoire tampon à partir duquel commencer à placer les données.</param>
        <param name="length">Longueur maximale à copier dans la mémoire tampon.</param>
        <summary>Lit un flux d'octets à partir de l'offset de colonne spécifié dans la mémoire tampon, sous la forme d'un tableau en commençant à l'offset de mémoire tampon spécifié.</summary>
        <returns>Nombre réel d'octets lus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetBytes` Retourne le nombre d’octets disponibles dans le champ. La plupart du temps il s’agit de la longueur exacte du champ. Toutefois, le nombre retourné peut être inférieure à la longueur réelle du champ si `GetBytes` a déjà été utilisé pour obtenir des octets à partir du champ. Cela peut être le cas, par exemple, lorsque le <xref:System.Data.DataTableReader> lit une structure de données volumineux dans une mémoire tampon  
  
 Si vous passez une mémoire tampon qui est `null` (`Nothing` en Visual Basic), `GetBytes` retourne la longueur totale du champ en octets, pas la taille restante selon le paramètre offset de mémoire tampon.  
  
 Aucuns conversions ne sont effectuées ; Par conséquent, les données récupérées doivent déjà être un tableau d’octets ou pouvoir être converties en un tableau d’octets.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataTableReader> en fonction des données dans la base de données AdventureWorks et enregistre chaque image récupérée dans un fichier distinct dans le dossier C:\. Pour tester cette application, créez une application Console, référencer l’assembly System.Drawing.dll et collez l’exemple de code dans le fichier nouvellement créé.  
  
 [!code-csharp[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see langword="DataTableReader" /> fermé.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas de tableau d'octets.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChar">
      <MemberSignature Language="C#" Value="public override char GetChar (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance char GetChar(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChar(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChar (ordinal As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override char GetChar(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetChar : int -&gt; char" Usage="dataTableReader.GetChar ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée sous la forme d'un caractère.</summary>
        <returns>La valeur de la colonne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucuns conversions ne sont effectuées ; Par conséquent les données récupérées doivent déjà être un caractère ou pouvoir être converties en un caractère.  
  
 Appelez <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le DataTableReader passé. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne ne sont pas du type correct, l’exemple affiche un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.GetChar#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChar#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see langword="DataTableReader" /> fermé.</exception>
        <exception cref="T:System.InvalidCastException">Le champ spécifié ne contient pas de caractère.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override long GetChars (int ordinal, long dataIndex, char[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetChars(int32 ordinal, int64 dataIndex, char[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (ordinal As Integer, dataIndex As Long, buffer As Char(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetChars(int ordinal, long dataIndex, cli::array &lt;char&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetChars : int * int64 * char[] * int * int -&gt; int64" Usage="dataTableReader.GetChars (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <param name="dataIndex">L’index figurant dans le champ à partir duquel l’opération de lecture doit être lancée.</param>
        <param name="buffer">Mémoire tampon dans laquelle lire le flux de caractères.</param>
        <param name="bufferIndex">Index de la mémoire tampon à partir duquel commencer à placer les données.</param>
        <param name="length">Longueur maximale à copier dans la mémoire tampon.</param>
        <summary>Retourne la valeur de la colonne spécifiée sous la forme d'un tableau de caractères.</summary>
        <returns>Nombre réel de caractères lus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetChars` Retourne le nombre de caractères disponibles dans le champ. La plupart du temps il s’agit de la longueur exacte du champ. Toutefois, le nombre retourné peut être inférieure à la longueur réelle du champ si `GetChars` a déjà été utilisé pour obtenir des caractères à partir du champ.  
  
 Le nombre réel de caractères lus peut être inférieure à la longueur demandée, si la fin du champ est atteinte. Si vous passez une mémoire tampon qui a la valeur null (`Nothing` en Visual Basic), `GetChars` retourne la longueur du champ entier en caractères, pas la taille restante selon le paramètre offset de mémoire tampon.  
  
 Aucuns conversions ne sont effectuées ; Par conséquent, les données à récupérer doivent déjà être un tableau de caractères ou pouvoir être converties en un tableau de caractères.  
  
   
  
## Examples  
 L’exemple suivant montre le `GetChars` (méthode). Le `TestGetChars` méthode s’attend à être transmis un `DataTableReader` rempli avec deux colonnes de données : un nom de fichier dans la première colonne et un tableau de caractères dans la seconde. En outre, `TestGetChars` vous permet de spécifier la taille de mémoire tampon à utiliser comme il lit les données du tableau de caractères dans le `DataTableReader`. `TestGetChars` Crée un fichier correspondant à chaque ligne de données dans le `DataTableReader`, à l’aide des données fournies dans la première colonne de la `DataTableReader` comme nom de fichier.  
  
 Cette procédure illustre l’utilisation de la `GetChars` méthode de lecture de données qui ont été stockées dans le `DataTable` comme un tableau de caractères. Tout autre type de données entraîne la `GetChars` méthode lève un `InvalidCastException`.  
  
 [!code-csharp[DataWorks DataTableReader.GetChars#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see langword="DataTableReader" /> fermé.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas de tableau de caractères.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDataTypeName">
      <MemberSignature Language="C#" Value="public override string GetDataTypeName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetDataTypeName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDataTypeName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDataTypeName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetDataTypeName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDataTypeName : int -&gt; string" Usage="dataTableReader.GetDataTypeName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient une chaîne qui représente le type de données de la colonne spécifiée.</summary>
        <returns>Chaîne représentant le type de données de la colonne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTableReader.GetDataTypeName%2A> méthode retourne toujours le type de l’objet sous-jacent <xref:System.Data.DataColumn> au lieu d’un type spécifique au fournisseur.  
  
   
  
## Examples  
 L’application console suivante affiche une liste de champs et leurs noms de types à partir d’une simple <xref:System.Data.DataTable>:  
  
 [!code-csharp[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/VB/source.vb#1)]  
  
 La fenêtre de Console affiche les résultats suivants :  
  
```  
ID: Int32  
Name: String  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTime">
      <MemberSignature Language="C#" Value="public override DateTime GetDateTime (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.DateTime GetDateTime(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDateTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDateTime (ordinal As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override DateTime GetDateTime(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDateTime : int -&gt; DateTime" Usage="dataTableReader.GetDateTime ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée sous la forme d'un objet <see cref="T:System.DateTime" />.</summary>
        <returns>Valeur de la colonne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucuns conversions ne sont effectuées ; Par conséquent, les données récupérées doivent déjà être un <xref:System.DateTime> ou être converti en un `DataTime`.  
  
 Appelez <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le passé dans <xref:System.Data.DataTableReader>. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne ne sont pas du type correct, l’exemple affiche un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see langword="DataTableReader" /> fermé.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas de valeur DateTime.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public override decimal GetDecimal (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Decimal GetDecimal(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDecimal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecimal (ordinal As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Decimal GetDecimal(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDecimal : int -&gt; decimal" Usage="dataTableReader.GetDecimal ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée sous la forme d'un <see cref="T:System.Decimal" />.</summary>
        <returns>Valeur de la colonne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucuns conversions ne sont effectuées ; Par conséquent, les données récupérées doivent déjà être un <xref:System.Decimal> ou être converti en un `Decimal`.  
  
 Appelez <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le passé dans <xref:System.Data.DataTableReader>. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne ne sont pas du type correct, l’exemple affiche un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see langword="DataTableReader" /> fermé.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas de valeur <see langword="Decimal" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public override double GetDouble (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float64 GetDouble(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDouble(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDouble (ordinal As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override double GetDouble(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDouble : int -&gt; double" Usage="dataTableReader.GetDouble ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro en base zéro de la colonne.</param>
        <summary>Obtient la valeur de la colonne sous la forme d'un nombre à virgule flottante double précision.</summary>
        <returns>Valeur de la colonne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucuns conversions ne sont effectuées ; Par conséquent, les données récupérées doivent déjà être un nombre à virgule flottante double précision ou doivent pouvoir être converties dans un nombre à virgule flottante double précision.  
  
 Appelez <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le passé dans <xref:System.Data.DataTableReader>. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne ne sont pas du type correct, l’exemple affiche un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see langword="DataTableReader" /> fermé.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas de nombre à virgule flottante double précision.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public override System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="dataTableReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui peut être utilisé pour itérer au sein de la collection d'éléments.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> représentant la collection d'éléments.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les énumérateurs permettent uniquement la lecture des données dans le <xref:System.Data.DataTableReader>. Les énumérateurs ne peuvent pas être utilisés pour modifier la collection sous-jacente.  
  
 Dans un premier temps, l’énumérateur est positionné avant le premier élément dans la collection. À cette position, l’appel <xref:System.Collections.IEnumerator.Current%2A> lève une exception. Par conséquent, vous devez appeler `MoveNext` pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de `Current`.  
  
 `Current` Retourne un <xref:System.Data.Common.DbDataRecord>et retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> est appelée. `MoveNext` affecte l'élément suivant à `Current`.  
  
 Après la fin de la collection est passée, l’énumérateur est positionné après le dernier élément dans la collection et l’appel `MoveNext` retourne la valeur false. Si le dernier appel à `MoveNext` retourné `false`, l’appel `Current` lève une exception. En outre, étant donné que le <xref:System.Data.DataTableReader> fournit un accès avant uniquement à ses données, en appelant le <xref:System.Collections.IEnumerator.Reset%2A> méthode de l’objet IEnumerator lève un <xref:System.NotSupportedException>.  
  
 Le <xref:System.Data.DataTableReader> fournit un énumérateur stable. Cela signifie que même si les suppressions de lignes ou des ajouts se produisent dans les données sous-jacentes, l’énumérateur retourné par un appel à <xref:System.Data.DataTableReader.GetEnumerator%2A> est toujours valide.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Data.DataTableReader.GetEnumerator%2A>. Cela inclut le comportement de l’énumérateur lorsque des lignes sont supprimées sous-jacent <xref:System.Data.DataTable> pendant que l’énumérateur est actif.  
  
 [!code-csharp[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/VB/source.vb#1)]  
  
 La procédure affiche le texte suivant dans la fenêtre de Console :  
  
```  
Peter  
Mary  
Russ  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldType">
      <MemberSignature Language="C#" Value="public override Type GetFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFieldType : int -&gt; Type" Usage="dataTableReader.GetFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient le <see cref="T:System.Type" /> qui correspond au type de données de l'objet.</summary>
        <returns>Le <see cref="T:System.Type" /> qui est le type de données de l’objet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Appelez la procédure suivante, en passant un <xref:System.Data.DataTableReader> instance afin d’afficher une liste de tous les champs et le nom complet pour chaque type dans la fenêtre de Console.  
  
 [!code-csharp[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative de lecture d’une colonne ou d’accès à une colonne dans un <see cref="T:System.Data.DataTableReader" /> fermé a été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFloat">
      <MemberSignature Language="C#" Value="public override float GetFloat (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float32 GetFloat(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFloat(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFloat (ordinal As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override float GetFloat(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFloat : int -&gt; single" Usage="dataTableReader.GetFloat ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée sous la forme d'un nombre à virgule flottante simple précision.</summary>
        <returns>La valeur de la colonne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucuns conversions ne sont effectuées ; Par conséquent, les données récupérées doivent déjà être un nombre à virgule flottante simple précision ou doivent pouvoir être converties dans un nombre à virgule flottante simple précision.  
  
 Appelez <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le passé dans <xref:System.Data.DataTableReader>. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne ne sont pas du type correct, l’exemple affiche un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas de nombre à virgule flottante simple précision.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public override Guid GetGuid (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Guid GetGuid(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetGuid(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGuid (ordinal As Integer) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Guid GetGuid(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetGuid : int -&gt; Guid" Usage="dataTableReader.GetGuid ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée sous la forme d'un identificateur global unique (GUID, Globally Unique IDentifier).</summary>
        <returns>Valeur de la colonne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucuns conversions ne sont effectuées ; Par conséquent, les données récupérées doivent déjà être un <xref:System.Guid> ou être converti en un `Guid`.  
  
 Appelez <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le DataTableReader passé. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne ne sont pas du type correct, l’exemple affiche un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas de GUID.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt16">
      <MemberSignature Language="C#" Value="public override short GetInt16 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int16 GetInt16(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt16(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt16 (ordinal As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override short GetInt16(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt16 : int -&gt; int16" Usage="dataTableReader.GetInt16 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée sous la forme d'un entier signé 16 bits.</summary>
        <returns>Valeur de la colonne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucuns conversions ne sont effectuées ; Par conséquent, les données récupérées doivent déjà être un <xref:System.Int16> ou être converti en un `Int16`.  
  
 Appelez <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le passé dans <xref:System.Data.DataTableReader>. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne ne sont pas du type correct, l’exemple affiche un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas d'entier signé 16 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public override int GetInt32 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetInt32(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt32 (ordinal As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetInt32(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt32 : int -&gt; int" Usage="dataTableReader.GetInt32 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée sous la forme d’un entier signé 32 bits.</summary>
        <returns>Valeur de la colonne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucuns conversions ne sont effectuées ; Par conséquent, les données récupérées doivent déjà être un <xref:System.Int32> ou être converti en un `Int32`.  
  
 Appelez <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le passé dans <xref:System.Data.DataTableReader>. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne ne sont pas du type correct, l’exemple affiche un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative de lecture d’une colonne ou d’accès à une colonne dans un <see cref="T:System.Data.DataTableReader" /> fermé a été effectuée.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas de valeur entière signée 32 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public override long GetInt64 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetInt64(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt64(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt64 (ordinal As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetInt64(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt64 : int -&gt; int64" Usage="dataTableReader.GetInt64 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée sous la forme d'un entier signé 64 bits.</summary>
        <returns>Valeur de la colonne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aucuns conversions ne sont effectuées ; Par conséquent, les données récupérées doivent déjà être un <xref:System.Int64> ou être converti en un `Int64`.  
  
 Appelez <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le passé dans <xref:System.Data.DataTableReader>. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne ne sont pas du type correct, l’exemple affiche un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative de lecture d’une colonne ou d’accès à une colonne dans un <see cref="T:System.Data.DataTableReader" /> fermé a été effectuée.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas de valeur entière signée 64 bits.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public override string GetName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetName : int -&gt; string" Usage="dataTableReader.GetName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée sous la forme d'un <see cref="T:System.String" />.</summary>
        <returns>Nom de la colonne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `GetName` et <xref:System.Data.DataTableReader.GetOrdinal%2A> méthodes fournissent les fonctionnalités inverses. Autrement dit, l’appel `GetOrdinal` sur la valeur de retour de l’appel `GetName` doit retourner le paramètre d’origine passé à `GetName`; va de même pour l’appelant les procédures dans l’ordre inverse.  
  
   
  
## Examples  
 L’exemple simple suivant inclut une procédure qui répertorie les noms de toutes les colonnes dans le texte spécifié `DataTableReader`et la position ordinale de la colonne, dans la fenêtre de Console.  
  
 [!code-csharp[DataWorks DataTableReader.GetName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrdinal">
      <MemberSignature Language="C#" Value="public override int GetOrdinal (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetOrdinal(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetOrdinal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetOrdinal (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetOrdinal(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetOrdinal : string -&gt; int" Usage="dataTableReader.GetOrdinal name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la colonne.</param>
        <summary>Obtient le numéro de la colonne, en fonction du nom de la colonne.</summary>
        <returns>Numéro de colonne de base zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que la plupart des méthodes fournies par le <xref:System.Data.DataTableReader> classe doit être fourni avec un numéro de colonne, vous pouvez utiliser la `GetOrdinal` méthode pour récupérer le numéro de colonne, étant donné le nom de la colonne.  
  
 `GetOrdinal` effectue d’abord une recherche qui respecte la casse. En cas d’échec, un deuxième non-respect de la casse est recherché. Si le numéro de colonne n’est pas trouvé un `IndexOutOfRangeException` est levée.  
  
 `GetOrdinal` est la largeur des caractères kana, non-respect de.  
  
 Étant donné que les recherches basées sur un ordinal sont plus efficaces que les recherches par nom, il est inutile d’appeler `GetOrdinal` dans une boucle. Gagnez du temps en appelant `GetOrdinal` une fois et en assignant les résultats à une variable de type entier pour une utilisation dans la boucle  
  
   
  
## Examples  
 Si vous avez uniquement un nom de colonne, auquel cas le nom de colonne est fourni, par l’utilisateur et vous devez récupérer des informations à partir de la colonne, vous pouvez utiliser une procédure similaire à celui-ci pour extraire les informations requises. Dans cet exemple, la procédure accepte un nom de colonne et retourne les données contenues dans cette colonne pour la ligne actuelle dans le <xref:System.Data.DataTableReader> :  
  
 [!code-csharp[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
        <exception cref="T:System.ArgumentException">Le nom spécifié n'est pas un nom de colonne valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificFieldType">
      <MemberSignature Language="C#" Value="public override Type GetProviderSpecificFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetProviderSpecificFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetProviderSpecificFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificFieldType : int -&gt; Type" Usage="dataTableReader.GetProviderSpecificFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient le type de la colonne spécifiée dans le format spécifique au fournisseur.</summary>
        <returns>Le <see cref="T:System.Type" /> qui est le type de données de l’objet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que le <xref:System.Data.DataTableReader> retourne toujours le type stocké dans sous-jacent <xref:System.Data.DataColumn>, la valeur retournée en appelant le <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> méthode retourne toujours le même type que le type stocké dans le <xref:System.Data.DataTable>. Lorsque vous travaillez avec le <xref:System.Data.DataTableReader> classe, appelant le <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> méthode retourne le même type que si vous appelez le <xref:System.Type.GetType%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValue">
      <MemberSignature Language="C#" Value="public override object GetProviderSpecificValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetProviderSpecificValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetProviderSpecificValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValue : int -&gt; obj" Usage="dataTableReader.GetProviderSpecificValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de base zéro de la colonne dont la valeur est récupérée.</param>
        <summary>Obtient la valeur de la colonne spécifiée dans le format spécifique au fournisseur.</summary>
        <returns>Valeur de la colonne spécifiée dans le format spécifique au fournisseur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que le <xref:System.Data.DataTableReader> retourne toujours le type stocké dans sous-jacent <xref:System.Data.DataColumn>, la valeur retournée en appelant le <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> méthode retourne toujours les données du même type que les données stockées dans le <xref:System.Data.DataTable>. Lorsque vous travaillez avec le <xref:System.Data.DataTableReader> classe, appelant le <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> méthode retourne la même valeur et que vous tapez que si vous appelez le <xref:System.Data.DataTableReader.GetValue%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValues">
      <MemberSignature Language="C#" Value="public override int GetProviderSpecificValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetProviderSpecificValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetProviderSpecificValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValues : obj[] -&gt; int" Usage="dataTableReader.GetProviderSpecificValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Tableau d'objets à remplir avec les informations de type des colonnes du <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Remplit le tableau fourni avec les informations de type spécifiques au fournisseur pour toutes les colonnes du <see cref="T:System.Data.DataTableReader" />.</summary>
        <returns>Nombre de valeurs de colonne copiées dans le tableau.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que le <xref:System.Data.DataTableReader> retourne toujours les données du type stocké dans sous-jacent <xref:System.Data.DataColumn>, les valeurs retournées en appelant le <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> méthode est toujours les mêmes types que les données stockées dans le <xref:System.Data.DataTable>. Lorsque vous travaillez avec le <xref:System.Data.DataTableReader> classe, appelant le <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> méthode retourne les valeurs et les types de même que si vous appelez le <xref:System.Data.DataTableReader.GetValues%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="GetSchemaTable">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchemaTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchemaTable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetSchemaTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchemaTable () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchemaTable();" />
      <MemberSignature Language="F#" Value="override this.GetSchemaTable : unit -&gt; System.Data.DataTable" Usage="dataTableReader.GetSchemaTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Data.DataTable" /> qui décrit les métadonnées de colonne de <see cref="T:System.Data.DataTableReader" />.</summary>
        <returns>
          <see cref="T:System.Data.DataTable" /> qui décrit les métadonnées de colonne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode GetSchemaTable retourne les métadonnées de chaque colonne dans l’ordre suivant :  
  
|Colonne de DataReader|Description |  
|-----------------------|-----------------|  
|Nom de colonne|Le nom de la colonne tel qu’il apparaît dans le <xref:System.Data.DataTable>.|  
|ColumnOrdinal|L’ordinal de la colonne|  
|ColumnSize|-1 si le <xref:System.Data.Common.SchemaTableColumn.ColumnSize> (ou <xref:System.Data.DataColumn.MaxLength%2A>) la propriété de la <xref:System.Data.DataColumn> ne peut pas être déterminé ou n’est pas pertinente ; sinon, 0 ou un entier positif qui contient le `MaxLength` valeur.|  
|NumericPrecision|Si le type de colonne est un type numérique, il s’agit de la précision maximale de la colonne. Si le type de colonne n’est pas un type de données numérique, il s’agit d’une valeur null.|  
|NumericScale|Si le type de données de colonne a un composant de mise à l’échelle, retourne le nombre de chiffres à droite de la virgule décimale. Sinon, retourne une valeur null.|  
|Type de données|Le type sous-jacent de la colonne.|  
|ProviderType|L’indicateur de la colonne type de données. Si le type de données de la colonne varie d’une ligne, cette valeur est <xref:System.Object>. Cette colonne ne peut pas contenir une valeur null.|  
|IsLong|`true` Si le type de données de la colonne est <xref:System.String> et son <xref:System.Data.DataColumn.MaxLength%2A> propriété est -1. Sinon, `false`.|  
|AllowDBNull|`true` Si la contrainte AllowDbNull est définie sur true pour la colonne ; Sinon, `false`.|  
|IsReadOnly|`true` Si la colonne ne peut pas être modifiée ; sinon `false`.|  
|IsRowVersion|`false`, pour chaque colonne.|  
|IsUnique|`true`: Deux lignes dans la <xref:System.Data.DataTable> peut avoir la même valeur dans cette colonne. `IsUnique` est garanti être true si la colonne représente une clé en soi ou s’il existe une contrainte de type UNIQUE qui s’applique uniquement à cette colonne. `false`: La colonne peut contenir des valeurs dupliquées dans le `DataTable`. La valeur par défaut de cette colonne est `false`.|  
|IsKey|`true`: La colonne fait partie d’un jeu de colonnes qui, ensemble, identifient de manière unique la ligne dans le <xref:System.Data.DataTable>. L’ensemble de colonnes avec `IsKey` définie sur `true` doit identifier de manière unique une ligne dans le `DataTable`. Il n’existe aucune exigence que cet ensemble de colonnes est un ensemble minimal de colonnes. Cet ensemble de colonnes peut-être être généré à partir d’un `DataTable` clé primaire, une contrainte unique ou un index unique. `false`: La colonne n’est pas nécessaire pour identifier la ligne. Cette valeur est `true` si la colonne participe à une clé primaire unique ou composite. Sinon, sa valeur est `false`.|  
|IsAutoIncrement|`true`: La colonne assigne des valeurs aux nouvelles lignes selon des incréments fixes. `false`: La colonne n’affecte pas les valeurs aux nouvelles lignes selon des incréments fixes. La valeur par défaut de cette colonne est `false`.|  
|BaseCatalogName|Le nom du catalogue dans le magasin de données qui contient la colonne. `Null` Si le nom de catalogue de base ne peut pas être déterminé. La valeur par défaut pour cette colonne est un `null` valeur.|  
|BaseSchemaName|Cette valeur est toujours `Null`.|  
|BaseTableName|Nom du <xref:System.Data.DataTable>.|  
|BaseColumnName|Le nom de la colonne dans la <xref:System.Data.DataTable>.|  
|AutoIncrementSeed|La valeur de la <xref:System.Data.DataTable>de <xref:System.Data.DataColumn.AutoIncrementSeed%2A> propriété.|  
|AutoIncrementStep|La valeur de la <xref:System.Data.DataTable>de <xref:System.Data.DataColumn.AutoIncrementStep%2A> propriété.|  
|DefaultValue|La valeur de la <xref:System.Data.DataColumn>de <xref:System.Data.DataColumn.DefaultValue%2A> propriété.|  
|Expression|La chaîne d’expression, si la colonne actuelle est une colonne d’expression et toutes les colonnes utilisées dans l’expression appartiennent au même `T:System.Data.DataTable` qui contient la colonne d’expression ; sinon `null`.|  
|ColumnMapping|Le <xref:System.Data.MappingType> valeur associée à la <xref:System.Data.DataColumn>. Le type peut être une des `Attribute`, `Element`, `Hidden`, ou `SimpleContent`. La valeur par défaut est `Element`.|  
|BaseTableNamespace|La valeur de la <xref:System.Data.DataTable>de <xref:System.Data.DataTable.Namespace%2A> propriété.|  
|BaseColumnNamespace|La valeur de la <xref:System.Data.DataColumn>de <xref:System.Data.DataColumn.Namespace%2A> propriété.|  
  
   
  
## Examples  
 L’exemple d’application console suivant récupère des informations de schéma sur la colonne spécifiée. Passer le `DisplaySchemaTableInfo` procédure un <xref:System.Data.DataTableReader> et un entier qui représente la position ordinale d’une colonne dans la `DataTableReader`, et la procédure renvoie des informations de schéma à la fenêtre de console.  
  
 [!code-csharp[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Data.DataTableReader" /> est fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetString : int -&gt; string" Usage="dataTableReader.GetString ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée sous la forme d'une chaîne.</summary>
        <returns>Valeur de la colonne spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le passé dans <xref:System.Data.DataTableReader>. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne du type correct, l’exemple affichent un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.GetString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
        <exception cref="T:System.InvalidCastException">La colonne spécifiée ne contient pas de chaîne.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public override object GetValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetValue : int -&gt; obj" Usage="dataTableReader.GetValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée dans son format natif.</summary>
        <returns>Valeur de la colonne spécifiée. Cette méthode retourne <see langword="DBNull" /> pour les colonnes ayant la valeur null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que vous pouvez appeler <xref:System.Data.DataTableReader.IsDBNull%2A> pour voir s’il existe des valeurs null avant d’appeler cette méthode, vous n’êtes pas obligé de cela.  
  
   
  
## Examples  
 L’exemple suivant effectue une itération dans toutes les colonnes dans la ligne actuelle dans un <xref:System.Data.DataTableReader>, affichant le contenu de chaque colonne et le nom de colonne. En règle générale, si votre objectif est d’utiliser toutes les colonnes d’une ligne récupérée par un <xref:System.Data.DataTableReader>, envisagez d’utiliser le <xref:System.Data.DataTableReader.GetValues%2A> méthode au lieu de cela, car il est plus efficace.  
  
 [!code-csharp[DataWorks DataTableReader.GetValue#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative de lecture de colonnes ou d’accès à des colonnes dans un <see cref="T:System.Data.DataTableReader" /> fermé a été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override int GetValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetValues : obj[] -&gt; int" Usage="dataTableReader.GetValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Tableau de <see cref="T:System.Object" /> dans lequel copier les valeurs des colonnes à partir du <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Remplit un tableau d'objets avec les valeurs de colonne de la ligne en cours.</summary>
        <returns>Nombre de valeurs de colonne copiées dans le tableau.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour la plupart des applications, cette méthode fournit un moyen efficace pour récupérer toutes les colonnes, au lieu de récupérer chaque colonne individuellement. Si votre intention est de récupérer toutes les valeurs de colonne d’une ligne dans le <xref:System.Data.DataTableReader>, le `GetValues` méthode offre la solution la plus efficace.  
  
 Vous pouvez passer un <xref:System.Object> tableau qui contient un nombre inférieur au nombre de colonnes qui sont contenues dans la ligne obtenue. Uniquement la quantité de données le `Object` tableau peut contenir est copié dans le tableau. Vous pouvez également passer un `Object` tableau dont la longueur est supérieure au nombre de colonnes qui sont contenus dans la ligne résultante, auquel cas les éléments de tableau supplémentaires demeurent inchangés par l’appel de méthode.  
  
 Cette méthode place `DBNull` dans le tableau de sortie pour les colonnes null.  
  
   
  
## Examples  
 L’exemple suivant montre à l’aide d’un tableau qui est la taille correcte, pour lire toutes les valeurs à partir de la ligne actuelle dans la liste fournie <xref:System.Data.DataTableReader>. En outre, l’exemple montre à l’aide d’un tableau de taille fixe qui peut être inférieure ou supérieure au nombre de colonnes disponibles.  
  
 [!code-csharp[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative de lecture d’une colonne ou d’accès à une colonne dans un <see cref="T:System.Data.DataTableReader" /> fermé a été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasRows">
      <MemberSignature Language="C#" Value="public override bool HasRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasRows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.HasRows" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasRows As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasRows { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasRows : bool" Usage="System.Data.DataTableReader.HasRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Data.DataTableReader" /> contient une ou plusieurs lignes.</summary>
        <value>
          <see langword="true" /> si le <see cref="T:System.Data.DataTableReader" /> contient une ou plusieurs lignes ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `HasRows` propriété renvoie des informations sur le jeu de résultats actuel. Si le <xref:System.Data.DataTableReader> contient le résultat de plusieurs jeux, vous pouvez examiner la valeur de la `HasRows` propriété immédiatement après avoir appelé la <xref:System.Data.DataTableReader.NextResult%2A> méthode afin de déterminer si le nouveau jeu de résultats contient des lignes.  
  
 Utilisez le `HasRows` propriété évite d’avoir à appeler le <xref:System.Data.DataTableReader.Read%2A> méthode de la <xref:System.Data.DataTableReader> si aucune ligne dans le jeu de résultats actuel.  
  
   
  
## Examples  
 L’exemple suivant remplit deux <xref:System.Data.DataTable> instances avec des données. Le premier <xref:System.Data.DataTable> contient une ligne, et la seconde ne contient aucune ligne. L’exemple crée ensuite un <xref:System.Data.DataTableReader> qui contient à la fois <xref:System.Data.DataTable> objets et appelle la méthode PrintData pour afficher le contenu de chacun, en vérifiant la valeur de la <xref:System.Data.DataTableReader.HasRows%2A> propriété de chacun avant d’appeler PrintData.  
  
 [!code-csharp[DataWorks DataTableReader.HasRows#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.HasRows#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour récupérer des informations sur un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
        <altmember cref="M:System.Data.DataTableReader.NextResult" />
        <altmember cref="M:System.Data.DataTableReader.Read" />
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public override bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Data.DataTableReader.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le <see cref="T:System.Data.DataTableReader" /> est fermé.</summary>
        <value>Retourne <see langword="true" /> si le <see cref="T:System.Data.DataTableReader" /> est fermé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTableReader.Close%2A> est la seule méthode et `IsClosed` et <xref:System.Data.DataTableReader.RecordsAffected%2A> sont les seules propriétés qui sont accessibles après le <xref:System.Data.DataTableReader> a été fermé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDBNull">
      <MemberSignature Language="C#" Value="public override bool IsDBNull (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDBNull(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.IsDBNull(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDBNull (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDBNull(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.IsDBNull : int -&gt; bool" Usage="dataTableReader.IsDBNull ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient une valeur qui indique si la colonne contient des valeurs inexistantes ou manquantes.</summary>
        <returns>
          <see langword="true" /> si la valeur de colonne spécifiée équivaut à <see cref="T:System.DBNull" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode pour voir s’il existe des valeurs de colonne null avant d’appeler les méthodes get typées (par exemple, <xref:System.Data.DataTableReader.GetByte%2A>, <xref:System.Data.DataTableReader.GetChar%2A>, et ainsi de suite) pour éviter de lever une erreur.  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de la colonne numéroté 2 dans le passé dans <xref:System.Data.DataTableReader>. Si la valeur de la colonne dans une ligne particulière est null, le code affiche le texte \<NULL >. Si les données figurant dans la colonne du type correct, l’exemple affichent un message d’erreur pour chaque ligne.  
  
 [!code-csharp[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative de lecture d’une colonne ou d’accès à une colonne dans un <see cref="T:System.Data.DataTableReader" /> fermé a été effectuée.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient la valeur de la colonne spécifiée dans son format natif.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[int ordinal] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int ordinal); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numéro de colonne de base zéro.</param>
        <summary>Obtient la valeur de la colonne spécifiée dans son format natif en fonction du numéro de la colonne.</summary>
        <value>Valeur de la colonne spécifiée dans son format natif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge pour <xref:System.Data.DataTableReader.Item%2A> se comporte comme le <xref:System.Data.DataTableReader.GetValue%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant affiche le contenu de toutes les colonnes, dans toutes les lignes à partir de le <xref:System.Data.DataTableReader>. Le code utilise le <xref:System.Data.DataTableReader.Item%2A> (méthode) (l’indexeur dans Microsoft c#) pour récupérer la valeur contenue dans chaque colonne.  
  
 [!code-csharp[DataWorks DataTableReader.Item#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Item#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">L'index passé était en dehors de la plage comprise entre 0 et <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la colonne.</param>
        <summary>Obtient la valeur de la colonne spécifiée dans son format natif en fonction du nom de la colonne.</summary>
        <value>Valeur de la colonne spécifiée dans son format natif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une recherche respectant la casse est effectuée en premier. En cas d’échec, un deuxième non-respect de la casse est recherché.  
  
 Cette méthode est la longueur des caractères kana, non-respect de.  
  
 Cette version surchargée de <xref:System.Data.DataTableReader.Item%2A> correspond à l’appel le <xref:System.Data.DataTableReader.GetOrdinal%2A> (méthode), puis par la suite en appelant le <xref:System.Data.DataTableReader.GetValue%2A> (méthode).  
  
   
  
## Examples  
 Étant donné un <xref:System.Data.DataTableReader> et un nom de colonne, la procédure GetValueByName retourne la valeur de la colonne spécifiée. Avant d’appeler cette procédure, vous devez créer un nouveau <xref:System.Data.DataTableReader> de l’instance et appelez sa méthode Read au moins une fois pour positionner le pointeur de la ligne sur une ligne de données.  
  
 [!code-csharp[DataWorks DataTableReader.ItemName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ItemName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom spécifié n'est pas un nom de colonne valide.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Une tentative a été effectuée pour récupérer des données à partir d'une ligne supprimée.</exception>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour lire une colonne ou y accéder dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextResult">
      <MemberSignature Language="C#" Value="public override bool NextResult ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool NextResult() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.NextResult" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function NextResult () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool NextResult();" />
      <MemberSignature Language="F#" Value="override this.NextResult : unit -&gt; bool" Usage="dataTableReader.NextResult " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Avance le <see cref="T:System.Data.DataTableReader" /> jusqu'au jeu de résultats suivant, s'il existe.</summary>
        <returns>
          <see langword="true" /> s'il existe un autre jeu de résultats ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisé pour traiter plusieurs résultats qui peuvent être générées en créant un <xref:System.Data.DataTableReader> via un <xref:System.Data.DataSet> qui contient deux ou plusieurs tables, ou un tableau qui contient deux ou plusieurs <xref:System.Data.DataTable> instances.  
  
 Un nouveau <xref:System.Data.DataTableReader> est positionné sur le premier résultat.  
  
   
  
## Examples  
 Dans l’exemple suivant, la méthode TestConstructor crée deux <xref:System.Data.DataTable> instances. Pour montrer ce constructeur pour le <xref:System.Data.DataTableReader> (classe), l’exemple crée un `DataTableReader` basé sur un tableau qui contient les deux `DataTables`et effectue une opération simple, en imprimant le contenu à partir des premières colonnes dans la console fenêtre. Pour tester cette application, créez une application Console et collez l’exemple de code dans le fichier nouvellement créé.  
  
 [!code-csharp[DataWorks DataTableReader.NextResult#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.NextResult#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/VB/source.vb#1)]  
  
 La fenêtre de Console affiche les résultats suivants :  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une tentative a été effectuée pour naviguer dans un <see cref="T:System.Data.DataTableReader" /> fermé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; bool" Usage="dataTableReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait passer le <see cref="T:System.Data.DataTableReader" /> à l’enregistrement suivant.</summary>
        <returns>
          <see langword="true" /> s'il y avait une autre ligne à lire; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La position par défaut de la <xref:System.Data.DataTableReader> est avant le premier enregistrement. Par conséquent, vous devez appeler `Read` pour commencer à accéder aux données.  
  
   
  
## Examples  
 La procédure de PrintColumns effectue une boucle sur toutes les lignes dans le <xref:System.Data.DataTableReader>, affichant le contenu de chaque colonne dans la fenêtre de Console.  
  
 [!code-csharp[DataWorks DataTableReader.Read#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Read#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une tentative de lecture d’une colonne ou d’accès à une colonne dans un <see cref="T:System.Data.DataTableReader" /> fermé a été effectuée.</exception>
      </Docs>
    </Member>
    <Member MemberName="RecordsAffected">
      <MemberSignature Language="C#" Value="public override int RecordsAffected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecordsAffected" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.RecordsAffected" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RecordsAffected As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int RecordsAffected { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecordsAffected : int" Usage="System.Data.DataTableReader.RecordsAffected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de lignes insérées, modifiées ou supprimées par l'exécution de l'instruction SQL.</summary>
        <value>Le <see cref="T:System.Data.DataTableReader" /> ne prend pas en charge cette propriété et retourne toujours 0.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>