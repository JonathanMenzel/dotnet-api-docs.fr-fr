<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2e2a9f9609b7cc29be43e2c8071d5d8e731d0672" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683505" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un cache de données en mémoire.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet>, qui est un cache en mémoire des données récupérées à partir d’une source de données est un composant majeur de l’architecture ADO.NET. Le <xref:System.Data.DataSet> se compose d’une collection de <xref:System.Data.DataTable> les objets que vous pouvez sont liés entre eux avec <xref:System.Data.DataRelation> objets. Vous pouvez également appliquer l’intégrité des données dans le <xref:System.Data.DataSet> à l’aide de la <xref:System.Data.UniqueConstraint> et <xref:System.Data.ForeignKeyConstraint> objets. Pour plus d’informations sur l’utilisation de <xref:System.Data.DataSet> , consultez [DataSets, DataTables et DataViews](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md).  
  
 Alors que <xref:System.Data.DataTable> objets contiennent les données, le <xref:System.Data.DataRelationCollection> vous permet de naviguer au sein de la hiérarchie de la table. Les tables sont contenus dans un <xref:System.Data.DataTableCollection> accessibles via le <xref:System.Data.DataSet.Tables%2A> propriété. Lors de l’accès <xref:System.Data.DataTable> objets, notez qu’ils sont en casse dans certaines conditions. Par exemple, si un <xref:System.Data.DataTable> est appelé « mydatatable » et un autre nommé « Mydatatable », une chaîne utilisée pour rechercher une des tables est considérée comme respectant la casse. Cependant, si « mydatatable » existe et n’est pas le cas de « Mydatatable », la chaîne de recherche est considérée comme la casse. Pour plus d’informations sur l’utilisation de <xref:System.Data.DataTable> , consultez [création d’un DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 A <xref:System.Data.DataSet> peuvent lire et écrire des données et le schéma comme des documents XML. Les données et le schéma peuvent ensuite être traversent HTTP et utilisées par n’importe quelle application, sur n’importe quelle plateforme qui prend en charge de XML. Vous pouvez enregistrer le schéma en tant qu’un schéma XML avec la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode) et le schéma et les données peuvent être enregistrées à l’aide de la <xref:System.Data.DataSet.WriteXml%2A> (méthode). Pour lire un document XML qui inclut le schéma et les données, utilisez le <xref:System.Data.DataSet.ReadXml%2A> (méthode).  
  
 Dans une implémentation classique à plusieurs niveaux, les étapes de création et d’actualisation une <xref:System.Data.DataSet>, et à son tour, la mise à jour les données d’origine :  
  
1.  Générer et remplir chaque <xref:System.Data.DataTable> dans un <xref:System.Data.DataSet> avec les données d’une source de données à l’aide un <xref:System.Data.Common.DataAdapter>.  
  
2.  Modifier les données dans les <xref:System.Data.DataTable> les objets par l’ajout, la mise à jour ou suppression <xref:System.Data.DataRow> objets.  
  
3.  Appeler le <xref:System.Data.DataSet.GetChanges%2A> méthode pour créer un second <xref:System.Data.DataSet> qui comprend uniquement les modifications aux données.  
  
4.  Appelez le <xref:System.Data.Common.DataAdapter.Update%2A> méthode de la <xref:System.Data.Common.DataAdapter>, en passant le deuxième <xref:System.Data.DataSet> en tant qu’argument.  
  
5.  Appeler le <xref:System.Data.DataSet.Merge%2A> pour fusionner les modifications de la deuxième méthode <xref:System.Data.DataSet> dans le premier.  
  
6.  Appeler le <xref:System.Data.DataSet.AcceptChanges%2A> sur la <xref:System.Data.DataSet>. Vous pouvez également appeler <xref:System.Data.DataSet.RejectChanges%2A> pour annuler les modifications.  
  
> [!NOTE]
>  Le <xref:System.Data.DataSet> et <xref:System.Data.DataTable> objets héritent de <xref:System.ComponentModel.MarshalByValueComponent>et prennent en charge la <xref:System.Runtime.Serialization.ISerializable> interface pour la communication à distance. Ce sont les seuls objets ADO.NET qui peuvent être exécutés à distance.  
  
> [!NOTE]
>  Classes héritées de <xref:System.Data.DataSet> ne sont pas finalisées par le garbage collector, car le finaliseur a été supprimé dans <xref:System.Data.DataSet>. La classe dérivée peut appeler le <xref:System.GC.ReRegisterForFinalize%2A> méthode dans son constructeur pour permettre à la classe d’être finalisée par le garbage collector.  
  
   
  
## Examples  
 L’exemple suivant se compose de plusieurs méthodes qui, combinés, créer et remplir un <xref:System.Data.DataSet> à partir de la **Northwind** base de données.  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est sécurisé pour les opérations de lecture multithreads. Vous devez synchroniser des opérations d’écriture.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation de la <xref:System.Data.DataSet> constructeur n’accepte aucun paramètre et crée un nom par défaut, « NewDataSet », pour la nouvelle instance.  
  
 Un nom pour le <xref:System.Data.DataSet> est nécessaire pour garantir que la représentation XML de le <xref:System.Data.DataSet> a toujours un nom pour l’élément de document, qui est l’élément de niveau supérieur dans une définition de schéma.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Data.DataSet>et ajoute deux <xref:System.Data.DataTable> objets.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName">Nom du <see cref="T:System.Data.DataSet" />.</param>
        <summary>Initialise une nouvelle instance d'une classe <see cref="T:System.Data.DataSet" /> portant le nom donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nom pour le <xref:System.Data.DataSet> est nécessaire pour garantir que la représentation XML de le <xref:System.Data.DataSet> a toujours un nom pour l’élément de document, qui est l’élément de niveau le plus élevé dans une définition de schéma.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Data.DataSet>, pour les deux <xref:System.Data.DataTable> objets sont ajoutés.  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Données nécessaires à la sérialisation et à la désérialisation d’un objet.</param>
        <param name="context">Source et destination d’un flux sérialisé donné.</param>
        <summary>Initialise une nouvelle instance d'une classe <see cref="T:System.Data.DataSet" /> qui contient les informations de sérialisation et le contexte donnés.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <param name="ConstructSchema">Valeur booléenne.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Valide toutes les modifications apportées à ce <see cref="T:System.Data.DataSet" /> depuis son chargement ou depuis le dernier appel à <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À la fois le <xref:System.Data.DataRow> et <xref:System.Data.DataTable> classes ont <xref:System.Data.DataSet.AcceptChanges%2A> méthodes. Appel <xref:System.Data.DataTable.AcceptChanges%2A> à la <xref:System.Data.DataTable> niveau entraîne la <xref:System.Data.DataRow.AcceptChanges%2A> méthode pour chaque <xref:System.Data.DataRow> à appeler. De même, l’appel <xref:System.Data.DataSet.AcceptChanges%2A> sur la <xref:System.Data.DataSet> entraîne <xref:System.Data.DataTable.AcceptChanges%2A> à appeler sur chaque table contenue dans le <xref:System.Data.DataSet>. De cette manière, vous disposez de plusieurs niveaux à laquelle la méthode peut être appelée. Appel de la <xref:System.Data.DataSet.AcceptChanges%2A> de la <xref:System.Data.DataSet> vous permet d’appeler la méthode sur tous les objets subordonnés (par exemple, les tables et les lignes) avec un seul appel.  
  
 Lorsque vous appelez `AcceptChanges` sur la `DataSet`, tout <xref:System.Data.DataRow> objets toujours en mode édition achève correctement ses modifications. Le <xref:System.Data.DataRow.RowState%2A> propriété de chaque <xref:System.Data.DataRow> change également ; `Added` et `Modified` lignes deviennent `Unchanged`, et `Deleted` lignes sont supprimées.  
  
 Si le `DataSet` contient <xref:System.Data.ForeignKeyConstraint> objets, en appelant le `AcceptChanges` entraîne également la méthode le <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> pour être appliqué.  
  
> [!NOTE]
>  `AcceptChanges` et `RejectChanges` s’appliquent uniquement aux `DataRow` des modifications (c'est-à-dire, ajouter, supprimer, supprimer et modifier). Ils ne sont pas applicables au schéma ou des modifications structurelles.  
>   
>  Appeler AcceptChanges pas réplique ces modifications vers la source de données si le jeu de données a été passée à l’aide d’un DataAdapter. Dans ce cas, appelez <xref:System.Data.Common.DataAdapter.Update%2A> à la place. Consultez [mise à jour des Sources de données avec DataAdapters](http://msdn.microsoft.com/library/33y2221y.aspx) pour plus d’informations.  
  
   
  
## Examples  
 L’exemple suivant ajoute un <xref:System.Data.DataRow> à un <xref:System.Data.DataTable> dans un <xref:System.Data.DataSet>. Le <xref:System.Data.DataSet.AcceptChanges%2A> méthode est ensuite appelée sur le <xref:System.Data.DataSet>, les cascades à tous les <xref:System.Data.DataTable> les objets qu’il contient.  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commence l'initialisation d'un <see cref="T:System.Data.DataSet" /> qui est utilisé dans un formulaire ou par un autre composant. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’environnement de conception de Visual Studio .NET utilise cette méthode pour démarrer l’initialisation d’un composant qui est utilisé sur un formulaire ou par un autre composant. Le <xref:System.Data.DataSet.EndInit%2A> méthode termine l’initialisation. À l’aide de la <xref:System.Data.DataSet.BeginInit%2A> et <xref:System.Data.DataSet.EndInit%2A> méthodes empêche le contrôle avant son initialisation complète.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si les comparaisons de chaînes au sein d'objets <see cref="T:System.Data.DataTable" /> respectent la casse.</summary>
        <value>
          <see langword="true" /> si les comparaisons de chaînes respectent la casse ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.CaseSensitive%2A> propriété affecte la tri, recherche et filtrage des opérations sont effectuées sur chaque <xref:System.Data.DataTable> objet contenu dans un <xref:System.Data.DataSet> lors de l’utilisation du <xref:System.Data.DataTable.Select%2A> (méthode).  
  
 Par défaut, la définition la <xref:System.Data.DataSet.CaseSensitive%2A> propriété pour un <xref:System.Data.DataSet> définit également la <xref:System.Data.DataTable.CaseSensitive%2A> propriété de chaque associés <xref:System.Data.DataTable> sur la même valeur.  
  
   
  
## Examples  
 L’exemple suivant active ou désactive le <xref:System.Data.DataSet.CaseSensitive%2A> propriété.  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface toutes les données de <see cref="T:System.Data.DataSet" /> en supprimant toutes les lignes de l'ensemble des tables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Data.DataSet> est lié à un <xref:System.Xml.XmlDataDocument>, l’appel <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> ou <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> déclenche le <xref:System.NotSupportedException>. Pour éviter cette situation, parcourez chaque table et supprimez les lignes une à la fois.  
  
   
  
## Examples  
 L’exemple suivant efface le <xref:System.Data.DataSet> de toutes les lignes de toutes les tables.  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie la structure de <see cref="T:System.Data.DataSet" />, y compris tous les schémas, relations et contraintes <see cref="T:System.Data.DataTable" />. Ne copie aucune donnée.</summary>
        <returns>Nouveau <see cref="T:System.Data.DataSet" /> avec le même schéma que le <see cref="T:System.Data.DataSet" /> en cours, mais aucune donnée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si ces classes ont été sous-classé, le clone sera également aux mêmes sous-classes.  
  
   
  
## Examples  
 L’exemple suivant crée un clone d’un <xref:System.Data.DataSet> schéma de l’objet.  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie à la fois la structure et les données de ce <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Nouveau <see cref="T:System.Data.DataSet" /> possédant la même structure (contraintes, relations et schémas de table) et les mêmes données que ce <see cref="T:System.Data.DataSet" />.  
  
 <block subset="none" type="note"><para>  
 Si ces classes ont été sous-classées, la copie appartient également aux mêmes sous-classes.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataSet.Copy%2A> méthode pour créer une copie de l’original <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un <see cref="T:System.Data.DataTableReader" /> avec un jeu de résultats par <see cref="T:System.Data.DataTable" />, dans la même séquence que les tables dans la collection <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Afin de garantir l’ordre des jeux de résultats dans la liste retournée <xref:System.Data.DataTableReader>, si un <xref:System.Data.DataTable> au sein de la <xref:System.Data.DataSet> est vide, il sera représenté par un jeu dans retourné de résultats vide `DataTableReader`.  
  
   
  
## Examples  
 Cet exemple, une application Console, crée trois <xref:System.Data.DataTable> instances et les ajoute à un <xref:System.Data.DataSet>. L’exemple appelle la <xref:System.Data.DataSet.CreateDataReader%2A> (méthode) et affiche le contenu de retourné <xref:System.Data.DataTableReader>. Notez que l’ordre du résultat définit dans le `DataTableReader` est contrôlé par l’ordre de la `DataTable` instances passés comme paramètres.  
  
> [!NOTE]
>  Cet exemple montre comment utiliser une des versions surchargées de `CreateDataReader`. Pour obtenir des exemples qui peuvent être disponibles, consultez les rubriques de surcharge individuels.  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 L’exemple affiche le code suivant dans la fenêtre de Console :  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Data.DataTableReader" /> avec un jeu de résultats par <see cref="T:System.Data.DataTable" />, dans la même séquence que les tables dans la collection <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <returns>
          <see cref="T:System.Data.DataTableReader" /> contenant un ou plusieurs jeux de résultats, correspondant aux instances de <see cref="T:System.Data.DataTable" />, contenues dans le <see cref="T:System.Data.DataSet" /> source.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Afin de garantir l’ordre des jeux de résultats dans la liste retournée <xref:System.Data.DataTableReader>, si un <xref:System.Data.DataTable> au sein de la <xref:System.Data.DataSet> est vide, il est représenté par un jeu dans retourné de résultats vide `DataTableReader`.  
  
   
  
## Examples  
 L’exemple suivant crée trois <xref:System.Data.DataTable> instances et les ajoute à un <xref:System.Data.DataSet>. L’exemple passe ensuite la pleine `DataSet` à une procédure qui appelle la <xref:System.Data.DataSet.CreateDataReader%2A> méthode et passe à une itération au sein de tous les jeux de résultats contenus dans le <xref:System.Data.DataTableReader>. L’exemple affiche les résultats dans la fenêtre de Console.  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">Tableau de DataTables qui fournit l'ordre des jeux de résultats à retourner dans le <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Retourne un <see cref="T:System.Data.DataTableReader" /> avec un jeu de résultats par <see cref="T:System.Data.DataTable" />.</summary>
        <returns>
          <see cref="T:System.Data.DataTableReader" /> contenant un ou plusieurs jeux de résultats, correspondant aux instances de <see cref="T:System.Data.DataTable" />, contenues dans le <see cref="T:System.Data.DataSet" /> source. Les jeux de résultats retournés sont dans l'ordre spécifié par le paramètre <paramref name="dataTables" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Afin de garantir que l’ordre du résultat jeux dans retourné <xref:System.Data.DataTableReader>, si un <xref:System.Data.DataTable> au sein de la <xref:System.Data.DataSet> est vide, il est représenté par un jeu dans retourné de résultats vide `DataTableReader`. Étant donné que cette version surchargée vous permet de fournir une liste de `DataTable` instances en tant que paramètres, vous pouvez spécifier l’ordre dans lequel les jeux de résultats apparaissent dans la liste retournée `DataTableReader`.  
  
   
  
## Examples  
 Cet exemple, une application Console, crée trois <xref:System.Data.DataTable> instances et les ajoute à un <xref:System.Data.DataSet>. L’exemple appelle la <xref:System.Data.DataSet.CreateDataReader%2A> (méthode) et affiche le contenu de retourné <xref:System.Data.DataTableReader>. Notez que l’ordre du résultat définit dans le `DataTableReader` est contrôlé par l’ordre de la `DataTable` instances passés comme paramètres. L’exemple affiche les résultats dans la fenêtre de Console.  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom du <see cref="T:System.Data.DataSet" /> en cours.</summary>
        <value>Nom du <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Data.DataSet> avec la donnée <xref:System.Data.DataSet.DataSetName%2A>.  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une vue personnalisée des données contenues dans le <see cref="T:System.Data.DataSet" />, permettant de filtrer, rechercher et naviguer à l'aide d'un <see cref="T:System.Data.DataViewManager" /> personnalisé.</summary>
        <value>Objet <see cref="T:System.Data.DataViewManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataViewManager> retournée par le <xref:System.Data.DataSet.DefaultViewManager%2A> propriété vous permet de créer des paramètres personnalisés pour chaque <xref:System.Data.DataTable> dans le <xref:System.Data.DataSet>.  
  
 Lors de l’obtenir un <xref:System.Data.DataView> à partir d’un <xref:System.Data.DataTable>, l’ordre de tri, le filtrage, et <xref:System.Data.DataViewRowState> sont configurés selon les paramètres de la <xref:System.Data.DataSet.DefaultViewManager%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant obtient la valeur par défaut <xref:System.Data.DataViewManager> pour un <xref:System.Data.DataSet>et ajoute un <xref:System.Data.DataTable> à la <xref:System.Data.DataTableCollection>.  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine le <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> pour un <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lors de la désérialisation typé <xref:System.Data.DataSet> afin de déterminer son <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Instance de <see cref="T:System.Xml.XmlReader" /> qui est passée pendant la désérialisation du <see cref="T:System.Data.DataSet" />.</param>
        <summary>Détermine le <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> pour un <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Énumération <see cref="T:System.Data.SchemaSerializationMode" /> qui indique si des informations de schéma ont été omises de la charge utile.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lors de la désérialisation typé <xref:System.Data.DataSet> afin de déterminer son <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> avec lequel le <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> du constructeur protégé d'un <see langword="DataSet" /> est appelé pendant la désérialisation, dans les scénarios de communication à distance.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> avec lequel le <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> du constructeur protégé d'un <see langword="DataSet" /> est appelé pendant la désérialisation, dans les scénarios de communication à distance.</param>
        <summary>Détermine le <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> pour un <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Énumération <see cref="T:System.Data.SchemaSerializationMode" /> qui indique si des informations de schéma ont été omises de la charge utile.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lors de la désérialisation typé <xref:System.Data.DataSet> afin de déterminer son <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termine l'initialisation d'un <see cref="T:System.Data.DataSet" /> qui est utilisé dans un formulaire ou par un autre composant. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’environnement de conception de Visual Studio .NET utilise cette méthode pour terminer l’initialisation d’un composant qui est utilisé sur un formulaire ou par un autre composant. Le <xref:System.Data.DataSet.BeginInit%2A> méthode démarre l’initialisation. À l’aide de la <xref:System.Data.DataSet.BeginInit%2A> et <xref:System.Data.DataSet.EndInit%2A> méthodes empêche le contrôle avant son initialisation complète.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si les règles de contrainte doivent être respectées lorsque vous tentez une opération de mise à jour.</summary>
        <value>
          <see langword="true" /> si les règles sont appliquées ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les contraintes sont définies au niveau du <xref:System.Data.DataTable> niveau (<xref:System.Data.DataTable.Constraints%2A> propriété). Pour plus d’informations sur la création de contraintes, consultez [contraintes DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataSet> avec une table, une colonne, cinq lignes et un <xref:System.Data.UniqueConstraint>. Le <xref:System.Data.DataSet.EnforceConstraints%2A> est définie sur `false` et les valeurs de chaque ligne sont définis sur la même valeur. Lorsque le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`, un <xref:System.Data.ConstraintException> est généré.  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Une ou plusieurs contraintes ne peuvent pas être appliquées.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection d'informations utilisateur personnalisées associée au <see langword="DataSet" />.</summary>
        <value>
          <see cref="T:System.Data.PropertyCollection" /> contenant toutes les informations utilisateur personnalisées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ExtendedProperties%2A> propriété vous permet de stocker des informations personnalisées avec la `DataSet`. Par exemple, vous pouvez stocker une heure à laquelle les données doivent être actualisées.  
  
 Les propriétés étendues doivent être de type <xref:System.String> si vous souhaitez les rendues persistantes lorsque le <xref:System.Data.DataSet> est écrit au format XML.  
  
   
  
## Examples  
 L’exemple suivant ajoute une propriété personnalisée à la <xref:System.Data.PropertyCollection> retournée par le <xref:System.Data.DataColumn.ExtendedProperties%2A> propriété. Le deuxième exemple récupère la propriété personnalisée.  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une copie du <see cref="T:System.Data.DataSet" /> contenant l'ensemble des modifications qui lui ont été apportées depuis son dernier chargement ou depuis l'appel à <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une copie du <see cref="T:System.Data.DataSet" /> qui contient l'ensemble des modifications qui lui ont été apportées depuis son chargement ou depuis le dernier appel à <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <returns>Copie des modifications de ce <see cref="T:System.Data.DataSet" /> sur lequel des actions peuvent être exécutées, et ensuite refusionnées à l'aide de <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Si aucune ligne modifiée n'est trouvée, la méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée un nouveau <xref:System.Data.DataSet> qui contient une copie de toutes les lignes dans l’original <xref:System.Data.DataSet> qui ont les modifications en attente. Les contraintes de relation peuvent entraîner des lignes inchangées supplémentaires à ajouter à la nouvelle <xref:System.Data.DataSet> si les lignes inchangées contiennent des clés primaires correspondant aux clés étrangères dans les lignes modifiées. La méthode retourne `null` s’il en existe aucune ligne dans la version d’origine <xref:System.Data.DataSet> qui ont les modifications en attente.  
  
   
  
## Examples  
 L’exemple suivant crée un simple <xref:System.Data.DataSet> avec une table, deux colonnes et dix lignes. Deux valeurs sont modifiées et qu’une ligne est ajoutée. Un sous-ensemble des données modifiées est créé à l’aide de la <xref:System.Data.DataSet.GetChanges%2A> (méthode). Après résolution des erreurs, une nouvelle colonne est ajoutée au sous-ensemble, modification du schéma. Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée avec le `missingSchemaAction` la valeur `MissingSchemaAction.Add`, la nouvelle colonne est ajoutée à l’original <xref:System.Data.DataSet> schéma de l’objet.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Une des valeurs de <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Obtient une copie du <see cref="T:System.Data.DataSet" /> contenant l'ensemble des modifications qui lui ont été apportées depuis son dernier chargement ou depuis l'appel à <see cref="M:System.Data.DataSet.AcceptChanges" />, filtrée par <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Copie filtrée du <see cref="T:System.Data.DataSet" /> sur lequel des actions peuvent être exécutées, puis refusionnées à l'aide de <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Si aucune ligne du <see cref="T:System.Data.DataRowState" /> souhaité n'est détectée, la méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.GetChanges%2A> méthode est utilisée pour générer un deuxième <xref:System.Data.DataSet> objet qui contient uniquement les modifications introduites dans la version d’origine. Utilisez le `rowStates` argument afin de spécifier le type de l’objet doit inclure des modifications.  
  
 Cette copie retournée est conçue à fusionner dans ce original <xref:System.Data.DataSet>. Les contraintes de relation peuvent entraîner des lignes parentes marquées comme `Unchanged` à inclure. Si aucune ligne de l’élément <xref:System.Data.DataRowState> sont trouvées, le <xref:System.Data.DataSet.GetChanges%2A> méthode renvoie `null`.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataSet.GetChanges%2A> méthode pour créer un second <xref:System.Data.DataSet> objet, qui est ensuite utilisé pour mettre à jour une source de données.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Jeu de schémas spécifié.</param>
        <summary>Obtient une copie de <see cref="T:System.Xml.Schema.XmlSchemaSet" /> pour le DataSet.</summary>
        <returns>Copie de l'objet <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> qui contient les données sérialisées associées à l'<see cref="T:System.Data.DataSet" />.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> qui contient la source et la destination du flux sérialisé associé à l'<see cref="T:System.Data.DataSet" />.</param>
        <summary>Remplit un objet d’informations de sérialisation avec les données nécessaires pour sérialiser <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="info" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une instance sérialisable de <see cref="T:System.Xml.Schema.XMLSchema" />.</summary>
        <returns>Instance <see cref="T:System.Xml.Schema.XMLSchema" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Instance <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Contexte de diffusion en continu.</param>
        <summary>Désérialise les données de table du flux binaire ou de données XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la représentation XML des données stockées dans le <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Chaîne qui est une représentation des données stockées dans le <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode est identique à l’appel <xref:System.Data.DataSet.WriteXml%2A> avec <xref:System.Data.XmlWriteMode> la valeur <xref:System.Data.XmlWriteMode.IgnoreSchema>.  
  
 <xref:System.Data.DataSet.GetXml%2A> Retourne des données XML sous forme de chaîne et par conséquent requiert plus de charge que <xref:System.Data.DataSet.WriteXml%2A> à écrire du code XML dans un fichier.  
  
 Si vous générez un <xref:System.Data.DataSet> à l’aide de l’inférence de schéma et sérialiser à l’aide de services XML ou Web, l’ordre de tri peut changer.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataSet> et <xref:System.Data.DataTable>, ajoute les exemples de données, puis affiche les données au format XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 Cet exemple montre comment écrire des données dans un fichier XML à partir d’un jeu de données et lire des données dans le jeu de données à partir de XML. Cet exemple est créer un jeu de données avec deux tables, utiliser deux méthodes d’exportation d’un jeu de données dans les fichiers XML (WriteXml et GetXml) et utiliser deux méthodes (ReadXml et InferXmlSchema) pour importer un jeu de données à partir des fichiers XML.  
  
 Avant de compiler et exécuter l’exemple, vous devez créer quatre fichiers XML dans le répertoire d’exemple. Commencez par créer ElementsWithAttributes.xml :  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 Ensuite, créez ElementsWithChildElementsxml.xml :  
  
```  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 Créer ElementsWithOnlyAttributes.xml :  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 Et enfin, créez RepeatingElements.xml :  
  
```  
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 Vous pouvez maintenant compiler et exécuter le code source suivant.  [Comment le magasin de données du jeu de données dans un fichier .XML](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) a des projets Visual Basic et c# de cet exemple.  
  
```  
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le schéma XML de la représentation XML des données stockées dans le <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Chaîne qui est le schéma XML de la représentation XML des données stockées dans le <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode est identique à l’appel <xref:System.Data.DataSet.WriteXmlSchema%2A>, sauf que seul le schéma principal est écrit.  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> Retourne des données XML sous forme de chaîne et par conséquent requiert plus de charge que <xref:System.Data.DataSet.WriteXmlSchema%2A> à écrire du code XML dans un fichier.  
  
 Si vous générez un <xref:System.Data.DataSet> à l’aide de l’inférence de schéma et sérialiser à l’aide de services XML ou Web, l’ordre de tri peut changer.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataSet> et <xref:System.Data.DataTable>, puis affiche le schéma au format XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Data.DataSet" /> contient des modifications, notamment des lignes nouvelles, supprimées ou modifiées.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Data.DataSet" /> contient des modifications, notamment des lignes nouvelles, supprimées ou modifiées.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.Data.DataSet" /> contient des modifications ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataSet.GetChanges%2A> méthode pour créer un second <xref:System.Data.DataSet> objet qui est ensuite utilisé pour mettre à jour une source de données.  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Une des valeurs de <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Data.DataSet" /> contient des modifications, notamment des lignes nouvelles, supprimées ou modifiées, filtrées par <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.Data.DataSet" /> contient des modifications ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Examinez le <xref:System.Data.DataSet.HasChanges%2A> propriété de la `DataSet` avant d’appeler le <xref:System.Data.DataSet.GetChanges%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataSet.GetChanges%2A> méthode pour créer un second <xref:System.Data.DataSet> objet, qui est ensuite utilisé pour mettre à jour une source de données.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant s'il existe des erreurs dans les objets <see cref="T:System.Data.DataTable" /> de ce <see cref="T:System.Data.DataSet" />.</summary>
        <value>
          <see langword="true" /> si une table contient une erreur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque <xref:System.Data.DataTable> dans un <xref:System.Data.DataSet> a également un <xref:System.Data.DataTable.HasErrors%2A> propriété. Utilisez le `HasErrors` propriété de la `DataSet` premier, afin de déterminer si une table contient des erreurs, avant de vérifier des <xref:System.Data.DataTable> objets. Si un `DataTable` comporte des erreurs, la <xref:System.Data.DataTable.GetErrors%2A> méthode retourne un tableau de <xref:System.Data.DataRow> objets contenant les erreurs.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataSet.HasErrors%2A> propriété pour déterminer si un <xref:System.Data.DataSet> objet contient des erreurs. Dans ce cas, les erreurs pour chaque <xref:System.Data.DataRow> dans chaque <xref:System.Data.DataTable> sont imprimés.  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Applique le schéma XML du <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see langword="Stream" /> à partir duquel lire le schéma.</param>
        <param name="nsArray">Tableau des chaînes d'URI (Uniform Resource Identifier) d'espace de noms à exclure de l'inférence de schéma.</param>
        <summary>Applique le schéma XML à partir du <see cref="T:System.IO.Stream" /> spécifié à <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="TextReader" /> à partir duquel lire le schéma.</param>
        <param name="nsArray">Tableau des chaînes d'URI (Uniform Resource Identifier) d'espace de noms à exclure de l'inférence de schéma.</param>
        <summary>Applique le schéma XML à partir du <see cref="T:System.IO.TextReader" /> spécifié à <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier (chemin d'accès inclus) à partir duquel lire le schéma.</param>
        <param name="nsArray">Tableau des chaînes d'URI (Uniform Resource Identifier) d'espace de noms à exclure de l'inférence de schéma.</param>
        <summary>Applique le schéma XML à partir du fichier spécifié du <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> n'a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="XMLReader" /> à partir duquel lire le schéma.</param>
        <param name="nsArray">Tableau des chaînes d'URI (Uniform Resource Identifier) d'espace de noms à exclure de l'inférence de schéma.</param>
        <summary>Applique le schéma XML à partir du <see cref="T:System.Xml.XmlReader" /> spécifié à <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit une fois que le <see cref="T:System.Data.DataSet" /> est initialisé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations, consultez <xref:System.Data.DataSet.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Désérialisez toutes les données de tables du DataSet du flux binaire ou de données XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <summary>Inspecte le format de la représentation sérialisée de <see langword="DataSet" />.</summary>
        <returns>
          <see langword="true" /> si le <see cref="T:System.Runtime.Serialization.SerializationInfo" /> spécifié représente un <see langword="DataSet" /> sérialisé dans son format binaire ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre prend en charge l'infrastructure .NET Framework et n'est pas destiné à être utilisé directement à partir de votre code.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Data.DataSet" /> est initialisé.</summary>
        <value>
          <see langword="true" /> pour indiquer que le composant a terminé l'initialisation ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourne l’état de la <xref:System.Data.DataSet> pendant qu’il est en cours de construction, par exemple par Visual Studio. Le <xref:System.Data.DataSet.BeginInit%2A> méthode lui affecte la valeur `false` et <xref:System.Data.DataSet.EndInit%2A> méthode lui affecte la valeur `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remplit un <see cref="T:System.Data.DataSet" /> avec des valeurs issues d'une source de données à l'aide du <see cref="T:System.Data.IDataReader" /> fourni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.Load%2A> méthode fournit une technique de remplissage d’un seul <xref:System.Data.DataTable> avec les données extraites une <xref:System.Data.IDataReader> instance. Cette méthode fournit les mêmes fonctionnalités, mais vous permet de charger plusieurs jeux de résultats d’une `IDataReader` dans plusieurs tables d’un `DataSet`.  
  
 Si `DataSet` contient déjà des lignes, les données entrantes à partir de la source de données sont fusionnées avec les lignes existantes.  
  
 Le `Load` méthode peut être utilisée dans plusieurs scénarios courants, tous centrés sur l’obtention de données à partir d’une source de données spécifiée et en l’ajoutant au conteneur de données actuel (dans ce cas, un `DataSet`). Les scénarios suivants décrivent l’utilisation standard pour un `DataSet`, décrivant sa mise à jour et le comportement de fusion.  
  
 A `DataSet` synchronise ou met à jour avec une source de données primaire. Le `DataSet` effectue le suivi des modifications, autorisant la synchronisation avec la source de données primaire. En outre, un `DataSet` peut accepter des données incrémentielles d’une ou plusieurs sources de données secondaires. Le `DataSet` n’est pas responsable du suivi des modifications afin de permettre la synchronisation avec la source de données secondaire.  
  
 Étant donné ces deux sources de données hypothétiques, un utilisateur est susceptible de demander un des comportements suivants :  
  
-   Initialiser `DataSet` à partir d’une source de données principale. Dans ce scénario, l’utilisateur souhaite initialiser vide `DataSet` avec les valeurs de la source de données primaire. Un ou plusieurs de contenu du DataTable est modifiés. Plus tard, l’utilisateur envisage propager les modifications à la source de données primaire.  
  
-   Conserver les modifications et resynchroniser à partir de la source de données primaire. Dans ce scénario, l’utilisateur souhaite prendre le `DataSet` remplie dans le scénario précédent et exécuter une synchronisation incrémentielle avec la source de données principale, en conservant les modifications apportées dans le `DataSet`.  
  
-   Flux de données incrémentielles à partir de sources de données secondaires. Dans ce scénario, l’utilisateur souhaite fusionner les modifications à partir d’une ou plusieurs sources de données secondaires et propager ces modifications à la source de données primaire.  
  
 Le `Load` méthode rend tous ces scénarios possibles. Cette méthode vous permet de spécifier un paramètre d’option de chargement, indiquant comment les lignes déjà présentes dans un <xref:System.Data.DataTable> associées aux lignes en cours de chargement. Le tableau suivant décrit les trois options de chargement fournies par le <xref:System.Data.LoadOption> énumération. Dans chaque cas, la description indique le comportement lorsque la clé primaire d’une ligne dans les données entrantes correspond à la clé primaire d’une ligne existante.  
  
|Option de chargement|Description |  
|-----------------|-----------------|  
|`PreserveChanges` (par défaut)|Met à jour la version d’origine de la ligne avec la valeur de la ligne entrante.|  
|`OverwriteChanges`|Met à jour les versions actuelles et d’origine de la ligne avec la valeur de la ligne entrante.|  
|`Upsert`|Met à jour la version actuelle de la ligne avec la valeur de la ligne entrante.|  
  
 En général, les `PreserveChanges` et `OverwriteChanges` options sont destinées aux scénarios dans lesquels l’utilisateur doit synchroniser le `DataSet` et ses modifications avec la source de données primaire. Le `Upsert` option facilite l’agrégation des modifications à partir d’une ou plusieurs sources de données secondaires.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> qui fournit un ou plusieurs jeux de résultats.</param>
        <param name="loadOption">Valeur issue de l'énumération <see cref="T:System.Data.LoadOption" /> qui indique comment les lignes déjà présentes dans les instances de <see cref="T:System.Data.DataTable" /> du <see cref="T:System.Data.DataSet" /> seront associées aux lignes entrantes qui partagent la même clé primaire.</param>
        <param name="tables">Tableau d'instances de <see cref="T:System.Data.DataTable" /> à partir desquelles la méthode <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> récupère les informations de nom et d'espace de noms. Chacune de ces tables doit être membre du <see cref="T:System.Data.DataTableCollection" /> contenu par ce <see cref="T:System.Data.DataSet" />.</param>
        <summary>Remplit un <see cref="T:System.Data.DataSet" /> avec des valeurs issues d'une source de données, à l'aide du <see cref="T:System.Data.IDataReader" /> fourni, en utilisant un tableau d'instances de <see cref="T:System.Data.DataTable" /> pour fournir les informations de schéma et d'espace de noms.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.Load%2A> méthode fournit une technique de remplissage d’un seul <xref:System.Data.DataTable> avec les données extraites une <xref:System.Data.IDataReader> instance. Cette méthode fournit les mêmes fonctionnalités, mais vous permet de charger plusieurs jeux de résultats d’une <xref:System.Data.IDataReader> dans plusieurs tables d’un <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  L’opération de chargement échoue avec un <xref:System.InvalidOperationException> si les colonnes de données source en entrant `reader` sont des colonnes calculées.  
  
 Le `loadOption` paramètre vous permet de spécifier comment les données importées pour interagir avec des données existantes et peut prendre l’une des valeurs de la <xref:System.Data.LoadOption> énumération. Consultez la documentation relative à la <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> méthode pour plus d’informations sur l’utilisation de ce paramètre.  
  
 Le `tables` paramètre vous permet de spécifier un tableau de <xref:System.Data.DataTable> instances, indiquant l’ordre des tables correspondant à chaque jeux de résultats chargés à partir du lecteur. Le <xref:System.Data.DataSet.Load%2A> méthode remplit chaque fourni <xref:System.Data.DataTable> instance avec les données en un seul jeu de résultats à partir du lecteur de données source. Après chaque jeu de résultats, le <xref:System.Data.DataSet.Load%2A> méthode déplace le résultat suivant défini dans le lecteur, jusqu'à ce qu’il n’y a plus de jeux de résultats.  
  
 Le schéma de résolution de noms de cette méthode est le même que celui suivi par le <xref:System.Data.Common.DbDataAdapter.Fill%2A> méthode de la <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Data.DataSet>, ajoute deux <xref:System.Data.DataTable> instances à la <xref:System.Data.DataSet>, puis remplit la <xref:System.Data.DataSet> à l’aide de la <xref:System.Data.DataSet.Load%2A> méthode, la récupération des données à partir d’un <xref:System.Data.DataTableReader> qui contient deux jeux de résultats. Enfin, l’exemple affiche le contenu des tables dans la fenêtre de console.  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> qui fournit un ou plusieurs jeux de résultats.</param>
        <param name="loadOption">Valeur issue de l'énumération <see cref="T:System.Data.LoadOption" /> qui indique comment les lignes déjà présentes dans les instances de <see cref="T:System.Data.DataTable" /> du <see langword="DataSet" /> seront associées aux lignes entrantes qui partagent la même clé primaire.</param>
        <param name="tables">Tableau de chaînes à partir duquel la méthode <see langword="Load" /> récupère les informations de nom de table.</param>
        <summary>Remplit un <see cref="T:System.Data.DataSet" /> avec des valeurs issues d'une source de données, à l'aide du <see cref="T:System.Data.IDataReader" /> fourni, en utilisant un tableau de chaînes pour fournir les noms des tables dans le <see langword="DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.Load%2A> méthode fournit une technique de remplissage d’un seul <xref:System.Data.DataTable> avec les données extraites une <xref:System.Data.IDataReader> instance. Cette méthode fournit les mêmes fonctionnalités, mais vous permet de charger plusieurs jeux de résultats d’une `IDataReader` dans plusieurs tables d’un `DataSet`.  
  
> [!NOTE]
>  L’opération de chargement échoue avec un <xref:System.InvalidOperationException> si les colonnes de données source en entrant `reader` sont des colonnes calculées.  
  
 Le `loadOption` paramètre vous permet de spécifier comment les données importées pour interagir avec des données existantes et peut prendre l’une des valeurs de la <xref:System.Data.LoadOption> énumération. Consultez la documentation relative à la <xref:System.Data.DataTable.Load%2A> méthode pour plus d’informations sur l’utilisation de ce paramètre.  
  
 Le `tables` paramètre vous permet de spécifier un tableau des noms de table, qui indique l’ordre des tables correspondant à chaque jeux de résultats chargés à partir du lecteur. Le `Load` méthode tente de trouver une table dans le `DataSet` correspondant au nom trouvé dans le tableau des noms de table, dans l’ordre. Si une table de correspondance est trouvée, cette table est chargée avec le contenu du jeu de résultats actuel. Si aucune table correspondante n’est trouvée, une table est créée en utilisant le nom fourni dans le tableau des noms de table et schéma de la nouvelle table est déduit du jeu de résultats. Après chaque jeu de résultats, le `Load` méthode déplace le résultat suivant défini dans le lecteur, jusqu'à ce qu’il n’y a plus de jeux de résultats.  
  
 L’espace de noms par défaut associé à `DataSet`, le cas échéant, est associé à chaque nouvellement créé `DataTable`. Le schéma de résolution de noms de cette méthode est le même que celui suivi par le <xref:System.Data.Common.DbDataAdapter.Fill%2A> méthode de la <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 Tout d’abord, l’exemple d’application Console suivant crée les tables et charge les données à partir d’un lecteur dans un <xref:System.Data.DataSet>, à l’aide du `Load` (méthode). L’exemple ajoute ensuite les tables à une <xref:System.Data.DataSet> et tente de se remplir les tables avec les données d’un <xref:System.Data.DataTableReader>. Dans cet exemple, étant donné que les paramètres transmis à la `Load` méthode indiquer un nom de table qui n’existe pas, le `Load` méthode crée une nouvelle table pour correspondre au nom passé comme paramètre. Une fois que les données ont été chargées, l’exemple affiche le contenu de toutes ses tables dans la fenêtre de Console.  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> qui fournit un ou plusieurs jeux de résultats.</param>
        <param name="loadOption">Valeur issue de l'énumération <see cref="T:System.Data.LoadOption" /> qui indique comment les lignes déjà présentes dans les instances de <see cref="T:System.Data.DataTable" /> du <see cref="T:System.Data.DataSet" /> seront associées aux lignes entrantes qui partagent la même clé primaire.</param>
        <param name="errorHandler">Un délégué <see cref="T:System.Data.FillErrorEventHandler" /> à appeler lorsqu'une erreur se produit en chargeant des données.</param>
        <param name="tables">Tableau d'instances de <see cref="T:System.Data.DataTable" /> à partir desquelles la méthode <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> récupère les informations de nom et d'espace de noms.</param>
        <summary>Remplit un <see cref="T:System.Data.DataSet" /> avec des valeurs issues d'une source de données, à l'aide du <see cref="T:System.Data.IDataReader" /> fourni, en utilisant un tableau d'instances de <see cref="T:System.Data.DataTable" /> pour fournir les informations de schéma et d'espace de noms.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.Load%2A> méthode fournit une technique de remplissage d’un seul <xref:System.Data.DataTable> avec les données extraites une <xref:System.Data.IDataReader> instance. Cette méthode fournit les mêmes fonctionnalités, mais vous permet de charger plusieurs jeux de résultats d’une <xref:System.Data.IDataReader> dans plusieurs tables d’un <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  L’opération de chargement échoue avec un <xref:System.InvalidOperationException> si les colonnes de données source en entrant `reader` sont des colonnes calculées.  
  
 Le `loadOption` paramètre vous permet de spécifier comment les données importées pour interagir avec des données existantes et peut prendre l’une des valeurs de la <xref:System.Data.LoadOption> énumération. Consultez la documentation relative à la <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> méthode pour plus d’informations sur l’utilisation de ce paramètre.  
  
 Le `errorHandler` paramètre est un <xref:System.Data.FillErrorEventHandler> délégué qui fait référence à une procédure qui est appelée lorsqu’une erreur se produit lors du chargement des données. Le <xref:System.Data.FillErrorEventArgs> passés à la procédure fournit les propriétés qui vous permettent de récupérer des informations sur l’erreur qui s’est produite, la ligne actuelle de données, et le <xref:System.Data.DataTable> remplie. À l’aide de ce mécanisme de délégué, au lieu d’un bloc try/catch plus simple, vous permet de déterminer l’erreur, gérer la situation et continuer le traitement si vous le souhaitez. Le <xref:System.Data.FillErrorEventArgs> paramètre fournit une <xref:System.Data.FillErrorEventArgs.Continue%2A> propriété : définissez cette propriété sur `true` pour indiquer que vous avez géré l’erreur et souhaitez continuer le traitement ; affectez à la propriété `false` pour indiquer que vous souhaitez arrêter le traitement. N’oubliez pas que la définition de la propriété `false` provoque le code qui a déclenché le problème pour lever une exception.  
  
 Le `tables` paramètre vous permet de spécifier un tableau de <xref:System.Data.DataTable> instances, indiquant l’ordre des tables correspondant à chaque jeux de résultats chargés à partir du lecteur. Le <xref:System.Data.DataSet.Load%2A> méthode remplit chaque fourni <xref:System.Data.DataTable> instance avec les données en un seul jeu de résultats à partir du lecteur de données source. Après chaque jeu de résultats, le <xref:System.Data.DataSet.Load%2A> méthode déplace le résultat suivant défini dans le lecteur, jusqu'à ce qu’il n’y a plus de jeux de résultats.  
  
 Le schéma de résolution de noms de cette méthode est le même que celui suivi par le <xref:System.Data.Common.DbDataAdapter.Fill%2A> méthode de la <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 L’exemple suivant ajoute une table à un <xref:System.Data.DataSet>et tente d’utiliser le <xref:System.Data.DataSet.Load%2A> méthode pour charger les données d’une <xref:System.Data.DataTableReader> qui contient un schéma incompatible. Au lieu d’intercepter l’erreur, cet exemple utilise un <xref:System.Data.FillErrorEventHandler> délégué pour examiner et gérer l’erreur. La sortie s’affiche dans la fenêtre de console.  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les paramètres régionaux utilisés pour comparer des chaînes dans la table.</summary>
        <value>
          <see cref="T:System.Globalization.CultureInfo" /> qui contient les données relatives aux paramètres régionaux de l'ordinateur de l'utilisateur. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Locale%2A> propriété spécifie les paramètres régionaux auxquels le tri s’applique.  
  
 Par défaut, la définition du <xref:System.Data.DataSet.Locale%2A> pour un <xref:System.Data.DataSet> définit également la <xref:System.Data.DataSet.Locale%2A> pour chaque <xref:System.Data.DataTable> objet de `DataSet` sur la même valeur.  
  
> [!NOTE]
>  Dans les colonnes qui contiennent des expressions, le <xref:System.StringComparison.InvariantCulture> est utilisé. Le <xref:System.StringComparison.CurrentCulture> est ignoré.  
  
   
  
## Examples  
 L’exemple suivant obtient la <xref:System.Globalization.CultureInfo> pour un <xref:System.Data.DataSet> et imprime la <xref:System.Globalization.CultureInfo.DisplayName%2A> et <xref:System.Globalization.CultureInfo.EnglishName%2A> propriétés.  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fusionne un <see cref="T:System.Data.DataSet" />, un <see cref="T:System.Data.DataTable" /> ou un tableau d'objets <see cref="T:System.Data.DataRow" /> dans le <see langword="DataSet" /> ou le <see langword="DataTable" /> en cours.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">Tableau d'objets <see langword="DataRow" /> à fusionner dans le <see langword="DataSet" />.</param>
        <summary>Fusionne un tableau d'objets <see cref="T:System.Data.DataRow" /> dans le <see cref="T:System.Data.DataSet" /> en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <xref:System.Data.DataSet>. Cela permet à l’application cliente pour avoir une actualisation <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <xref:System.Data.DataSet>.  
  
 Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet ne contient que les <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petite et donc être passé plus efficacement à un composant de niveau intermédiaire. Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changées. Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après la fusion des schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire. Source des lignes avec un <xref:System.Data.DataRowState> valeur `Added` sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin d’une fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de rétablir le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see langword="DataSet" /> dont les données et le schéma doivent être fusionnés.</param>
        <summary>Fusionne un <see cref="T:System.Data.DataSet" /> spécifié et son schéma dans le <see langword="DataSet" /> en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <xref:System.Data.DataSet>. Cela permet à l’application cliente pour avoir une actualisation <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <xref:System.Data.DataSet>.  
  
 Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet ne contient que les <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit, et donc plus efficacement passé à un composant de niveau intermédiaire. Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changées. Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après la fusion des schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire. Source des lignes avec un `DataRowState` valeur `Added` sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de rétablir le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataSet.GetChanges%2A>, mise à jour, et <xref:System.Data.DataSet.Merge%2A> méthodes sur un <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Une ou plusieurs contraintes ne peuvent pas être activées.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" /> dont les données et le schéma doivent être fusionnés.</param>
        <summary>Fusionne un <see cref="T:System.Data.DataTable" /> spécifié et son schéma dans le <see cref="T:System.Data.DataSet" /> en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <xref:System.Data.DataSet>. Cela permet à l’application cliente pour avoir une actualisation <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <xref:System.Data.DataSet>.  
  
 Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet ne contient que les <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit, et donc plus efficacement passé à un composant de niveau intermédiaire. Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changées. Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après la fusion des schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire. Source des lignes avec un `DataRowState` valeur `Added` sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de rétablir le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un simple <xref:System.Data.DataSet> avec une table, deux colonnes et dix lignes. Une seconde <xref:System.Data.DataTable> est créé qui est identique à la première. Deux lignes sont ajoutées à la deuxième table, qui est ensuite fusionnée dans le <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="table" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see langword="DataSet" /> dont les données et le schéma doivent être fusionnés.</param>
        <param name="preserveChanges">
          <see langword="true" /> pour préserver les modifications apportées au <see langword="DataSet" /> en cours ; sinon, <see langword="false" />.</param>
        <summary>Fusionne un <see cref="T:System.Data.DataSet" /> spécifié et son schéma dans le <see langword="DataSet" /> en cours, en préservant ou en supprimant les modifications effectuées dans ce <see langword="DataSet" /> conformément à l'argument donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <xref:System.Data.DataSet>. Cela permet à l’application cliente pour avoir une actualisation <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <xref:System.Data.DataSet>.  
  
 Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet ne contient que les <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit, et donc plus efficacement passé à un composant de niveau intermédiaire. Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changées. Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après la fusion des schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire. Source des lignes avec un `DataRowState` valeur `Added` sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de rétablir le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un simple <xref:System.Data.DataSet> avec une table, deux colonnes et dix lignes. Après avoir ajouté les dix lignes, deux valeurs sont modifiées, et une ligne est ajoutée. Un sous-ensemble des données modifiées est créé à l’aide de la <xref:System.Data.DataSet.GetChanges%2A> (méthode). Après résolution des erreurs, les données de sous-ensemble sont fusionnées dans la version d’origine <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">Tableau d'objets <see cref="T:System.Data.DataRow" /> à fusionner dans le <see langword="DataSet" />.</param>
        <param name="preserveChanges">
          <see langword="true" /> pour préserver les modifications apportées au <see langword="DataSet" /> ; sinon, <see langword="false" />.</param>
        <param name="missingSchemaAction">Une des valeurs de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Fusionne un tableau d'objets <see cref="T:System.Data.DataRow" /> dans le <see cref="T:System.Data.DataSet" /> en cours, en préservant ou en supprimant les modifications apportées au <see langword="DataSet" /> et en traitant tout schéma incompatible conformément aux arguments donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <xref:System.Data.DataSet>. Cela permet à l’application cliente pour avoir une actualisation <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <xref:System.Data.DataSet>.  
  
 Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet ne contient que les <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit, et donc plus efficacement passé à un composant de niveau intermédiaire. Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Pour faciliter l’explication de la <xref:System.Data.DataSet.Merge%2A> (méthode), nous utilisons le « cible » pour indiquer que l’actuel <xref:System.Data.DataSet>et « source » pour le deuxième (paramètre) <xref:System.Data.DataSet>. La cible <xref:System.Data.DataSet> est ainsi nommé car il s’agit de l’objet sur lequel une action (la fusion) se produit. La seconde <xref:System.Data.DataSet> est appelée une « source », car les informations qu’il contient ne changent pas, mais au lieu de cela sont fusionnées dans la zone actuelle <xref:System.Data.DataSet>.  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changées. Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après la fusion des schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire. Source des lignes avec un `DataRowState` valeur `Added` sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de rétablir le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see langword="DataSet" /> dont les données et le schéma doivent être fusionnés.</param>
        <param name="preserveChanges">
          <see langword="true" /> pour préserver les modifications apportées au <see langword="DataSet" /> en cours ; sinon, <see langword="false" />.</param>
        <param name="missingSchemaAction">Une des valeurs de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Fusionne un <see cref="T:System.Data.DataSet" /> spécifié et son schéma avec le <see langword="DataSet" /> en cours, en préservant ou en supprimant les modifications apportées au <see langword="DataSet" /> en cours, et en traitant un schéma incompatible conformément aux arguments donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <xref:System.Data.DataSet>. Cela permet à l’application cliente pour avoir une actualisation <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <xref:System.Data.DataSet>.  
  
 Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet ne contient que les <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit, et donc plus efficacement passé à un composant de niveau intermédiaire. Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Pour faciliter l’explication de la <xref:System.Data.DataSet.Merge%2A> (méthode), nous utilisons le « cible » pour indiquer que l’actuel <xref:System.Data.DataSet>et « source » pour le deuxième (paramètre) <xref:System.Data.DataSet>. La cible <xref:System.Data.DataSet> est ainsi nommé car il s’agit de l’objet sur lequel une action (la fusion) se produit. La seconde <xref:System.Data.DataSet> est appelée une « source », car les informations qu’il contient ne changent pas, mais au lieu de cela sont fusionnées dans la zone actuelle <xref:System.Data.DataSet>.  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changées. Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après la fusion des schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire. Source des lignes avec un `DataRowState` valeur `Added` sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de rétablir le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un simple <xref:System.Data.DataSet> avec une table, deux colonnes et dix lignes. Deux valeurs sont modifiées et qu’une ligne est ajoutée. Un sous-ensemble des données modifiées est créé à l’aide de la <xref:System.Data.DataSet.GetChanges%2A> (méthode). Après résolution des erreurs, une nouvelle colonne est ajoutée au sous-ensemble, modification du schéma. Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée avec le `missingSchemaAction` la valeur `MissingSchemaAction.Add`, la nouvelle colonne est ajoutée à l’original <xref:System.Data.DataSet> schéma de l’objet.  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">
          <see langword="DataTable" /> dont les données et le schéma doivent être fusionnés.</param>
        <param name="preserveChanges">Une des valeurs de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <param name="missingSchemaAction">
          <see langword="true" /> pour préserver les modifications apportées au <see langword="DataSet" /> ; sinon, <see langword="false" />.</param>
        <summary>Fusionne un <see cref="T:System.Data.DataTable" /> spécifié et son schéma dans le <see langword="DataSet" /> en cours, en préservant ou en supprimant les modifications apportées au <see langword="DataSet" /> et en traitant un schéma incompatible conformément aux arguments donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <xref:System.Data.DataSet>. Cela permet à l’application cliente pour avoir une actualisation <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <xref:System.Data.DataSet>.  
  
 une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet ne contient que les <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit, et donc plus efficacement passé à un composant de niveau intermédiaire. Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changées. Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après la fusion des schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire. Source des lignes avec un `DataRowState` valeur `Added` sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de rétablir le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un simple <xref:System.Data.DataSet> avec une table, deux colonnes et dix lignes. Une seconde <xref:System.Data.DataTable> est créé qui est quasiment identique à la première, sauf qu’un nouveau `DataColumn` est ajouté à la table. Deux lignes sont ajoutées à la deuxième table, qui est ensuite fusionnée dans le <xref:System.Data.DataSet> avec la `preserveChanges` affectée à l’argument `false`et le `missingSchemaAction` affectée à l’argument `MissingSchemaAction.Add`.  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque des <see cref="T:System.Data.DataRow" /> cible et source possèdent la même valeur de clé primaire et que <see cref="P:System.Data.DataSet.EnforceConstraints" /> a la valeur true.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la gestion des événements, consultez [NIB : consommation d’événements](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Data.DataSet.MergeFailed> événement.  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'espace de noms de <see cref="T:System.Data.DataSet" />.</summary>
        <value>L’espace de noms du <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Namespace%2A> propriété est utilisée lors de la lecture et l’écriture d’un document XML de document dans le <xref:System.Data.DataSet> à l’aide de la <xref:System.Data.DataSet.ReadXml%2A>, <xref:System.Data.DataSet.WriteXml%2A>, <xref:System.Data.DataSet.ReadXmlSchema%2A>, ou <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes.  
  
 L’espace de noms d’un document XML est utilisé pour définir l’étendue des attributs XML et les éléments lors de la lecture dans un <xref:System.Data.DataSet>. Par exemple, si un <xref:System.Data.DataSet> contient un schéma qui a été lu à partir d’un document avec l’espace de noms « myCompany » et une tentative est effectuée pour lire des données uniquement à partir d’un document avec un espace de noms différent, les données qui ne correspondant pas au schéma existant sont ignorées.  
  
   
  
## Examples  
 L’exemple suivant définit la <xref:System.Data.DataSet.Prefix%2A> avant d’appeler le <xref:System.Data.DataSet.ReadXml%2A> (méthode).  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'espace de noms contient déjà des données.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">
          <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> (méthode).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">
          <see cref="T:System.Data.DataRelation" /> en cours de suppression.</param>
        <summary>Se produit lorsqu'un objet <see cref="T:System.Data.DataRelation" /> est supprimé de <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit être substituée par des sous-classes pour restreindre les tables en cours de suppression  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" /> en cours de suppression.</param>
        <summary>Se produit lorsqu'un <see cref="T:System.Data.DataTable" /> est supprimé de <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par des sous-classes pour empêcher les tables d’être supprimé.  
  
   
  
## Examples  
 L’exemple suivant montre une classe dérivée de la <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.OnRemoveTable%2A> méthode substituée.  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un préfixe XML qui associe un alias à l'espace de noms de <see cref="T:System.Data.DataSet" />.</summary>
        <value>Préfixe XML de l'espace de noms de <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Prefix%2A> propriété est utilisée dans un document XML pour identifier les éléments qui appartiennent à l’espace de noms de la <xref:System.Data.DataSet> objet (comme défini par le <xref:System.Data.DataSet.Namespace%2A> propriété).  
  
   
  
## Examples  
 L’exemple suivant définit la <xref:System.Data.DataSet.Prefix%2A> avant d’appeler le <xref:System.Data.DataSet.ReadXml%2A> (méthode).  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la propriété sur le point d'être modifiée.</param>
        <summary>Envoie une notification indiquant que la propriété <see cref="T:System.Data.DataSet" /> spécifiée est sur le point d'être modifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Objet qui dérive de <see cref="T:System.IO.Stream" />.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataSet" /> à l'aide du <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, alors que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui incluent le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données. S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut `targetNamespace`, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML, comme illustré dans l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée d’abord un simple <xref:System.Data.DataSet> avec un <xref:System.Data.DataTable>, deux colonnes et dix lignes. Le <xref:System.Data.DataSet> schéma et les données sont écrites sur le disque en appelant le <xref:System.Data.DataSet.WriteXml%2A> (méthode). Une seconde <xref:System.Data.DataSet> est créé et le <xref:System.Data.DataSet.ReadXml%2A> méthode est utilisée pour le remplir avec le schéma et les données.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="TextReader" /> à partir duquel lire le schéma et les données.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataSet" /> à l'aide du <see cref="T:System.IO.TextReader" /> spécifié.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, alors que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui incluent le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données. S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut `targetNamespace`, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 Les classes qui héritent de la <xref:System.IO.TextReader> classe incluent le <xref:System.IO.StreamReader> et <xref:System.IO.StringReader> classes.  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée d’abord un simple <xref:System.Data.DataSet> avec un <xref:System.Data.DataTable>, deux colonnes et dix lignes. Le <xref:System.Data.DataSet> schéma et les données sont écrites sur le disque en appelant le <xref:System.Data.DataSet.WriteXml%2A> (méthode). Une seconde <xref:System.Data.DataSet> est créé et le <xref:System.Data.DataSet.ReadXml%2A> méthode est utilisée pour le remplir avec le schéma et les données.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier (chemin d'accès inclus) à partir duquel effectuer la lecture.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataSet" /> à l'aide du fichier spécifié.</summary>
        <returns>
          <see langword="XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, alors que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui incluent le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données. S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut un `targetNamespace`, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée d’abord un simple <xref:System.Data.DataSet> avec un <xref:System.Data.DataTable>, deux colonnes et dix lignes. Le <xref:System.Data.DataSet> schéma et les données sont écrites sur le disque en appelant le <xref:System.Data.DataSet.WriteXml%2A> (méthode). Une seconde <xref:System.Data.DataSet> est créé et le <xref:System.Data.DataSet.ReadXml%2A> méthode est utilisée pour le remplir avec le schéma et les données.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> n'a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> dans lequel effectuer la lecture.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataSet" /> à l'aide du <see cref="T:System.Xml.XmlReader" /> spécifié.</summary>
        <returns>
          <see langword="XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, alors que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui incluent le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données. S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut un `targetNamespace`, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> hérite de <xref:System.Xml.XmlReader>.  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée d’abord un simple <xref:System.Data.DataSet> avec un <xref:System.Data.DataTable>, deux colonnes et dix lignes. Le <xref:System.Data.DataSet> schéma et les données sont écrites sur le disque en appelant le <xref:System.Data.DataSet.WriteXml%2A> (méthode). Une seconde <xref:System.Data.DataSet> est créé et le <xref:System.Data.DataSet.ReadXml%2A> méthode est utilisée pour le remplir avec le schéma et les données.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> dans lequel effectuer la lecture.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataSet" /> à l'aide des <see cref="T:System.IO.Stream" /> et <see cref="T:System.Data.XmlReadMode" /> spécifiés.</summary>
        <returns>
          <see langword="XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, alors que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui incluent le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Est de même pour le <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Lorsque vous utilisez <xref:System.Data.DataSet.ReadXml%2A> et que vous définissez <xref:System.Data.XmlReadMode> à `Diffgram`, le contenu de la cible de `DataSet` et d’origine `DataSet` peuvent varier en raison de la façon dont le diffgram est généré et traité. Pour plus d’informations sur les diffgrams, consultez [DiffGrams](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données. S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut `targetNamespace`, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" /> dans lequel effectuer la lecture.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataSet" /> à l'aide des <see cref="T:System.IO.TextReader" /> et <see cref="T:System.Data.XmlReadMode" /> spécifiés.</summary>
        <returns>
          <see langword="XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, alors que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui incluent le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données. S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut `targetNamespace`, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier (chemin d'accès inclus) à partir duquel effectuer la lecture.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataSet" /> à l'aide du fichier et du <see cref="T:System.Data.XmlReadMode" /> spécifiés.</summary>
        <returns>
          <see langword="XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, alors que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui incluent le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données. S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut un `targetNamespace`, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> n'a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> dans lequel effectuer la lecture.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataSet" /> à l'aide des <see cref="T:System.Xml.XmlReader" /> et <see cref="T:System.Data.XmlReadMode" /> spécifiés.</summary>
        <returns>
          <see langword="XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, alors que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui incluent le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données. S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut un `targetNamespace`, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit un schéma XML dans le <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> dans lequel effectuer la lecture.</param>
        <summary>Lit le schéma XML à partir du <see cref="T:System.IO.Stream" /> spécifié dans le <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode pour créer le schéma pour un <xref:System.Data.DataSet>. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrite à l’aide de la norme XSD.  
  
> [!NOTE]
>  Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas. Aucune exception n’est levée.  
  
 Le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode est généralement appelée avant la <xref:System.Data.DataSet.ReadXml%2A> méthode qui est utilisée pour remplir le <xref:System.Data.DataSet>.  
  
 Classes dérivées de la <xref:System.IO.Stream> classe inclure <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, et <xref:System.Net.Sockets.NetworkStream>.  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXmlSchema%2A>. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.IO.FileStream> pour lire un schéma XML de l’objet et appelle la <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode avec l’objet.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" /> dans lequel effectuer la lecture.</param>
        <summary>Lit le schéma XML à partir du <see cref="T:System.IO.TextReader" /> spécifié dans le <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode pour créer le schéma pour un <xref:System.Data.DataSet>. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrite à l’aide de la norme XSD.  
  
> [!NOTE]
>  Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas. Aucune exception n’est levée.  
  
 Le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode est généralement appelée avant la <xref:System.Data.DataSet.ReadXml%2A> méthode qui est utilisée pour remplir le <xref:System.Data.DataSet>.  
  
 Les classes qui héritent de la <xref:System.IO.TextReader> classe incluent le <xref:System.IO.StreamReader> et <xref:System.IO.StringReader> classes.  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXmlSchema%2A>. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.IO.StreamReader> objet permettant de lire un schéma et appelle la <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode avec l’objet.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier (chemin d'accès inclus) dans lequel effectuer la lecture.</param>
        <summary>Lit le schéma XML à partir du fichier spécifié dans le <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode pour créer le schéma pour un <xref:System.Data.DataSet>. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrite à l’aide de la norme XSD.  
  
> [!NOTE]
>  Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas. Aucune exception n’est levée.  
  
 Le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode est généralement appelée avant la <xref:System.Data.DataSet.ReadXml%2A> méthode qui est utilisée pour remplir le <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXmlSchema%2A>. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> n'a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> dans lequel effectuer la lecture.</param>
        <summary>Lit le schéma XML à partir du <see cref="T:System.Xml.XmlReader" /> spécifié dans le <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode pour créer le schéma pour un <xref:System.Data.DataSet>. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Le schéma XML est écrite à l’aide de la norme XSD.  
  
> [!NOTE]
>  Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas. Aucune exception n’est levée.  
  
 Le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode est généralement appelée avant la <xref:System.Data.DataSet.ReadXml%2A> méthode qui est utilisée pour remplir le <xref:System.Data.DataSet>.  
  
 La <xref:System.Xml.XmlReader?displayProperty=nameWithType> classe est abstraite. Une classe qui hérite de la `XmlReader` est la <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> classe.  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXmlSchema%2A>. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Data.DataSet> et <xref:System.IO.FileStream?displayProperty=nameWithType> objet. Le <xref:System.IO.FileStream> objet, créé avec un chemin d’accès et le nom de fichier, est utilisé pour créer un <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> qui est passé comme argument à la <xref:System.Data.DataSet.ReadXmlSchema%2A> (méthode).  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Lecteur XML spécifié.</param>
        <summary>Ignore les attributs et retourne un DataSet vide.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restaure toutes les modifications apportées à <see cref="T:System.Data.DataSet" /> depuis sa création ou le dernier appel à <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appeler le <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType> pour appeler le <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> méthode sur tous les <xref:System.Data.DataTable> les objets contenus dans le <xref:System.Data.DataSet>.  
  
 <xref:System.Data.DataRow> les objets contenus dans le <xref:System.Data.DataSet> peuvent tous être définis en mode édition en appelant le <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType> (méthode). Après l’appel la <xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType> méthode, modifications peuvent être refusées en appelant le <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> sur la <xref:System.Data.DataTable> auquel le <xref:System.Data.DataRow> objets appartiennent.  
  
 Lorsque le <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> est appelée, les lignes en mode édition annulent leurs modifications. Nouvelles lignes sont supprimées. Retournent des lignes modifiées et supprimées à leur état d’origine (`DataRowState.Unchanged`).  
  
 AcceptChanges et RejectChanges s’appliquent uniquement aux <xref:System.Data.DataRow> les modifications associées (c'est-à-dire, `Add`, `Remove`, `Delete`, et `Modify`). Ils ne sont pas applicables au schéma ou des modifications structurelles.  
  
   
  
## Examples  
 L’exemple suivant montre une classe dérivée de la <xref:System.Data.DataSet> classe. Le <xref:System.Data.DataSet.RejectChanges%2A> événements sont appelé à partir d’une fonction.  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection des relations qui relient des tables et permettent de naviguer des tables parentes aux tables enfants.</summary>
        <value>
          <see cref="T:System.Data.DataRelationCollection" /> qui contient une collection d'objets <see cref="T:System.Data.DataRelation" />. Une collection vide est retournée si aucun objet <see cref="T:System.Data.DataRelation" /> n'existe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant imprime le nom de colonne de toutes les tables enfants via la <xref:System.Data.DataSet.Relations%2A> propriété.  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un <see cref="T:System.Data.SerializationFormat" /> pour le <see cref="T:System.Data.DataSet" /> utilisé pendant la communication à distance.</summary>
        <value>Objet <see cref="T:System.Data.SerializationFormat" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface toutes les tables et supprime toutes les relations, contraintes étrangères et tables du <see cref="T:System.Data.DataSet" />. Les sous-classes doivent substituer <see cref="M:System.Data.DataSet.Reset" /> pour rétablir l'état d'origine de <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un <see cref="T:System.Data.SchemaSerializationMode" /> pour un <see cref="T:System.Data.DataSet" />.</summary>
        <value>Obtient ou définit un <see cref="T:System.Data.SchemaSerializationMode" /> pour un <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.DataSet> sérialise ses données de schéma et l’instance par défaut dans les services Web et les scénarios de communication à distance. Définition de la <xref:System.Data.DataSet.SchemaSerializationMode%2A> propriété d’un typé `DataSet` à <xref:System.Data.SchemaSerializationMode.ExcludeSchema> , les informations de schéma à exclure de la charge utile de sérialisation.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> est pris en charge uniquement pour un typé `DataSet`. Pour un non typé `DataSet` cette propriété peut uniquement être définie <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> ne doit être utilisée dans les cas où les informations de schéma de sous-jacent tapées `DataTables`, `DataRelations` et `Constraints` n’a pas été modifié. Si vous ont des modifications des informations de schéma s’est produite, complète doivent être sérialisées avec <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> est pris en charge dans la version 2.0 du .NET Framework ou une version ultérieure.  
  
 Lorsque <xref:System.Data.SchemaSerializationMode.ExcludeSchema> est défini, seules les propriétés d’exécution de niveau supérieur présentes sur le <xref:System.Data.DataSet> sont sérialisés. En outre, elles sont sérialisées que si elles sont trouvent différents à partir des valeurs par défaut. Aucun de la `Tables`, `Relations` ou `Constraints` sont sérialisés. Les propriétés d’exécution sérialisées incluent <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Namespace%2A>, <xref:System.Data.DataSet.Prefix%2A>, <xref:System.Data.DataSet.Locale%2A>, <xref:System.Data.DataSet.EnforceConstraints%2A>, et <xref:System.Data.DataSet.CaseSensitive%2A>. Ces propriétés sont sérialisées pour vous assurer que l’intégrité des données de runtime globale sont conservé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une valeur indiquant si la propriété <see cref="P:System.Data.DataSet.Relations" /> doit être rendue persistante.</summary>
        <returns>
          <see langword="true" /> si la propriété n'utilise plus sa valeur par défaut ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, vous utilisez cette méthode si vous créez un concepteur pour le <xref:System.Data.DataSet>, ou en créant votre propre contrôle incorporant la <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 Les exemples suivants montrent une classe dérivée de la <xref:System.Data.DataSet> classe. Le <xref:System.Data.DataSet.Reset%2A> et <xref:System.Data.DataSet.ShouldSerializeRelations%2A> méthodes sont appelées à partir de fonctions dans la classe dérivée.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une valeur indiquant si la propriété <see cref="P:System.Data.DataSet.Tables" /> doit être rendue persistante.</summary>
        <returns>
          <see langword="true" /> si la propriété n'utilise plus sa valeur par défaut ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez généralement cette méthode uniquement si vous créez un concepteur pour le <xref:System.Data.DataSet>, ou en créant votre propre contrôle incorporant la <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 L’exemple suivant montre une classe dérivée de la <xref:System.Data.DataSet> classe. Le <xref:System.Data.DataSet.ShouldSerializeTables%2A> méthode est appelée depuis l’intérieur de fonctions dans la classe dérivée.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un élément <see cref="T:System.ComponentModel.ISite" /> pour l'élément <see cref="T:System.Data.DataSet" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> pour <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites lient un <xref:System.ComponentModel.Component> à un <xref:System.ComponentModel.Container> et activer la communication entre eux, ainsi que fournir un moyen pour le conteneur de gérer ses composants.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>Pour obtenir une description de ce membre, consultez <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.DataSet> est castée en interface <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Pour obtenir une description de ce membre, consultez <see cref="M:System.ComponentModel.IListSource.GetList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.DataSet> est castée en interface <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Pour obtenir une description de ce membre, consultez <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.DataSet> est castée en interface <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" />
        </param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.DataSet> est castée en interface <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" />
        </param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Data.DataSet> est castée en interface <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection des tables contenues dans le <see cref="T:System.Data.DataSet" />.</summary>
        <value>
          <see cref="T:System.Data.DataTableCollection" /> contenu dans ce <see cref="T:System.Data.DataSet" />. Une collection vide est retournée si aucun objet <see cref="T:System.Data.DataTable" /> n'existe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour ajouter des tables à la collection, utilisez <xref:System.Data.DataTableCollection.Add%2A> méthode de la <xref:System.Data.DataTableCollection>. Pour supprimer des tables, utilisez le <xref:System.Data.DataTableCollection.Remove%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant retourne le <xref:System.Data.DataSet> l’objet <xref:System.Data.DataTableCollection>et affiche les colonnes et les lignes de chaque table.  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit des données XML, et éventuellement le schéma, à partir du <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Objet <see cref="T:System.IO.Stream" /> utilisé pour écrire dans un fichier.</param>
        <summary>Écrit les données en cours de <see cref="T:System.Data.DataSet" /> à l'aide du <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, alors que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire les données et le schéma, utilisez une des surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L'exemple suivant crée un objet <xref:System.IO.FileStream?displayProperty=nameWithType>. L’objet est ensuite utilisé avec la <xref:System.Data.DataSet.WriteXml%2A> méthode pour écrire un document XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objet<see cref="T:System.IO.TextWriter" /> avec lequel écrire.</param>
        <summary>Écrit les données en cours de <see cref="T:System.Data.DataSet" /> à l'aide du <see cref="T:System.IO.TextWriter" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, alors que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire les données et le schéma, utilisez une des surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier (chemin d'accès inclus) dans lequel effectuer l'écriture.</param>
        <summary>Écrit les données en cours de <see cref="T:System.Data.DataSet" /> dans le fichier spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, alors que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire les données et le schéma, utilisez une des surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> n'a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> à l'aide duquel effectuer l'écriture.</param>
        <summary>Écrit les données en cours de <see cref="T:System.Data.DataSet" /> dans le <see cref="T:System.Xml.XmlWriter" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, alors que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire les données et le schéma, utilisez une des surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Objet <see cref="T:System.IO.Stream" /> utilisé pour écrire dans un fichier.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Écrit les données en cours, et éventuellement le schéma, de <see cref="T:System.Data.DataSet" /> à l'aide des <see cref="T:System.IO.Stream" /> et <see cref="T:System.Data.XmlWriteMode" /> spécifiés. Pour écrire le schéma, affectez <see langword="WriteSchema" /> comme valeur du paramètre <paramref name="mode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, alors que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire les données et le schéma, définissez la `mode` paramètre `WriteSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Objet <see cref="T:System.IO.TextWriter" /> utilisé pour écrire le document.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Écrit les données en cours, et éventuellement le schéma, de <see cref="T:System.Data.DataSet" /> à l'aide des <see cref="T:System.IO.TextWriter" /> et <see cref="T:System.Data.XmlWriteMode" /> spécifiés. Pour écrire le schéma, affectez <see langword="WriteSchema" /> comme valeur du paramètre <paramref name="mode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, alors que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire les données et le schéma, définissez la `mode` paramètre `WriteSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L’exemple suivant crée d’abord un simple <xref:System.Data.DataSet> avec un <xref:System.Data.DataTable>, deux colonnes et dix lignes. Le <xref:System.Data.DataSet> schéma et les données sont écrites sur le disque en appelant le <xref:System.Data.DataSet.WriteXml%2A> (méthode). Une seconde <xref:System.Data.DataSet> est créé et le <xref:System.Data.DataSet.ReadXml%2A> méthode est utilisée pour le remplir avec le schéma et les données.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier (chemin d'accès inclus) dans lequel effectuer l'écriture.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Écrit les données en cours, et éventuellement le schéma, de <see cref="T:System.Data.DataSet" /> dans le fichier spécifié à l'aide du <see cref="T:System.Data.XmlWriteMode" /> spécifié. Pour écrire le schéma, affectez <see langword="WriteSchema" /> comme valeur du paramètre <paramref name="mode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, alors que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire les données et le schéma, définissez la `mode` paramètre `WriteSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Data.DataSet.WriteXml%2A> méthode pour écrire un document XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> n'a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> à l'aide duquel effectuer l'écriture.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Écrit les données en cours, et éventuellement le schéma, de <see cref="T:System.Data.DataSet" /> à l'aide des <see cref="T:System.Xml.XmlWriter" /> et <see cref="T:System.Data.XmlWriteMode" /> spécifiés. Pour écrire le schéma, affectez <see langword="WriteSchema" /> comme valeur du paramètre <paramref name="mode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, alors que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire les données et le schéma, définissez la `mode` paramètre `WriteSchema`.  
  
 Notez que le même a la valeur true pour le <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` en cours de lecture ou d’écriture implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.IO.FileStream?displayProperty=nameWithType> objet qui est utilisé pour créer un nouveau <xref:System.Xml.XmlTextWriter>. Le <xref:System.Xml.XmlTextWriter> objet est utilisé avec le <xref:System.Data.DataSet.WriteXml%2A> méthode pour écrire un document XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit la structure <see cref="T:System.Data.DataSet" /> sous la forme d'un schéma XML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Objet <see cref="T:System.IO.Stream" /> utilisé pour écrire dans un fichier.</param>
        <summary>Écrit la structure <see cref="T:System.Data.DataSet" /> en tant que schéma XML dans l’objet <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataSet> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrite à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXml%2A> (méthode).  
  
 Classes dérivées de la <xref:System.IO.Stream> classe inclure <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, et <xref:System.Net.Sockets.NetworkStream>.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.IO.FileStream> objet est passé à la <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode pour écrire le schéma sur le disque.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objet<see cref="T:System.IO.TextWriter" /> avec lequel écrire.</param>
        <summary>Écrit la structure <see cref="T:System.Data.DataSet" /> en tant que schéma XML dans l’objet <see cref="T:System.IO.TextWriter" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataSet> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrite à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXml%2A> (méthode).  
  
 Classes qui dérivent de la <xref:System.IO.TextWriter?displayProperty=nameWithType> classe incluent le <xref:System.Web.HttpWriter?displayProperty=nameWithType>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>, <xref:System.IO.StreamWriter?displayProperty=nameWithType>, et <xref:System.IO.StringWriter?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Text.StringBuilder?displayProperty=nameWithType> objet qui est utilisé pour créer un nouveau <xref:System.IO.StringWriter?displayProperty=nameWithType>. Le <xref:System.IO.StringWriter> est passé à la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode) et la chaîne résultante est écrit dans la fenêtre de console.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier (chemin d'accès inclus) dans lequel effectuer l'écriture.</param>
        <summary>Écrit la structure <see cref="T:System.Data.DataSet" /> sous la forme d'un schéma XML dans un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataSet> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrite à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXml%2A> (méthode).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> n'a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> dans lequel écrire.</param>
        <summary>Écrit la structure <see cref="T:System.Data.DataSet" /> sous la forme d'un schéma XML dans un objet <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataSet> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrite à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXml%2A> (méthode).  
  
 Une classe qui hérite de la <xref:System.Xml.XmlWriter?displayProperty=nameWithType> classe est la <xref:System.Xml.XmlTextWriter> classe.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.IO.FileStream?displayProperty=nameWithType> objet avec le chemin d’accès spécifié. Le <xref:System.IO.FileStream> objet est utilisé pour créer un <xref:System.Xml.XmlTextWriter> objet. Le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode est ensuite appelée avec le <xref:System.Xml.XmlTextWriter> objet à écrire le schéma sur le disque.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">Objet <see cref="T:System.IO.Stream" /> dans lequel écrire.</param>
        <param name="multipleTargetConverter">Délégué servant à convertir <see cref="T:System.Type" /> en une chaîne.</param>
        <summary>Écrit la structure <see cref="T:System.Data.DataSet" /> en tant que schéma XML dans l’objet <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">Objet <see cref="T:System.IO.TextWriter" /> dans lequel écrire.</param>
        <param name="multipleTargetConverter">Délégué servant à convertir <see cref="T:System.Type" /> en une chaîne.</param>
        <summary>Écrit la structure de <see cref="T:System.Data.DataSet" /> sous la forme d'un schéma XML dans le <see cref="T:System.IO.TextWriter" /> spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">Nom du fichier dans lequel écrire.</param>
        <param name="multipleTargetConverter">Délégué servant à convertir <see cref="T:System.Type" /> en une chaîne.</param>
        <summary>Écrit la structure <see cref="T:System.Data.DataSet" /> sous la forme d'un schéma XML dans un fichier.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">Objet <see cref="T:System.Xml.XmlWriter" /> dans lequel écrire.</param>
        <param name="multipleTargetConverter">Délégué servant à convertir <see cref="T:System.Type" /> en une chaîne.</param>
        <summary>Écrit la structure de <see cref="T:System.Data.DataSet" /> sous la forme d'un schéma XML dans le <see cref="T:System.Xml.XmlWriter" /> spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>