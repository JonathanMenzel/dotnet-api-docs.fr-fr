<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DataSet.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac54b95d33b05cb8084754f0bd53d012081a1b820a3.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4b95d33b05cb8084754f0bd53d012081a1b820a3</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Represents an in-memory cache of data.</source>
          <target state="translated">Représente un cache de données en mémoire.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, which is an in-memory cache of data retrieved from a data source, is a major component of the ADO.NET architecture.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, qui est un cache en mémoire des données récupérées à partir d’une source de données est un composant majeur de l’architecture ADO.NET.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> consists of a collection of <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects that you can relate to each other with <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> objects.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> se compose d’une collection de <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> les objets que vous pouvez sont liés entre eux avec <ph id="ph3">&lt;xref:System.Data.DataRelation&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>You can also enforce data integrity in the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> by using the <ph id="ph2">&lt;xref:System.Data.UniqueConstraint&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.ForeignKeyConstraint&gt;</ph> objects.</source>
          <target state="translated">Vous pouvez également appliquer l’intégrité des données dans le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> à l’aide de la <ph id="ph2">&lt;xref:System.Data.UniqueConstraint&gt;</ph> et <ph id="ph3">&lt;xref:System.Data.ForeignKeyConstraint&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>For further details about working with <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objects, see <bpt id="p1">[</bpt>DataSets, DataTables, and DataViews<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> , consultez <bpt id="p1">[</bpt>DataSets, DataTables et DataViews<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Whereas <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects contain the data, the <ph id="ph2">&lt;xref:System.Data.DataRelationCollection&gt;</ph> allows you to navigate though the table hierarchy.</source>
          <target state="translated">Alors que <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objets contiennent les données, le <ph id="ph2">&lt;xref:System.Data.DataRelationCollection&gt;</ph> vous permet de naviguer au sein de la hiérarchie de la table.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The tables are contained in a <ph id="ph1">&lt;xref:System.Data.DataTableCollection&gt;</ph> accessed through the <ph id="ph2">&lt;xref:System.Data.DataSet.Tables%2A&gt;</ph> property.</source>
          <target state="translated">Les tables sont contenus dans un <ph id="ph1">&lt;xref:System.Data.DataTableCollection&gt;</ph> accessibles via le <ph id="ph2">&lt;xref:System.Data.DataSet.Tables%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>When accessing <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects, note that they are conditionally case sensitive.</source>
          <target state="translated">Lors de l’accès <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objets, notez qu’ils sont en casse dans certaines conditions.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>For example, if one <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> is named "mydatatable" and another is named "Mydatatable", a string used to search for one of the tables is regarded as case sensitive.</source>
          <target state="translated">Par exemple, si un <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> est appelé « mydatatable » et un autre nommé « Mydatatable », une chaîne utilisée pour rechercher une des tables est considérée comme respectant la casse.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>However, if "mydatatable" exists and "Mydatatable" does not, the search string is regarded as case insensitive.</source>
          <target state="translated">Cependant, si « mydatatable » existe et n’est pas le cas de « Mydatatable », la chaîne de recherche est considérée comme la casse.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>For more information about working with <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects, see <bpt id="p1">[</bpt>Creating a DataTable<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur l’utilisation de <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> , consultez <bpt id="p1">[</bpt>création d’un DataTable<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)</ept>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>A <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can read and write data and schema as XML documents.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> peuvent lire et écrire des données et le schéma comme des documents XML.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The data and schema can then be transported across HTTP and used by any application, on any platform that is XML-enabled.</source>
          <target state="translated">Les données et le schéma peuvent ensuite être traversent HTTP et utilisées par n’importe quelle application, sur n’importe quelle plateforme qui prend en charge de XML.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>You can save the schema as an XML schema with the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method, and both schema and data can be saved using the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez enregistrer le schéma en tant qu’un schéma XML avec la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> (méthode) et le schéma et les données peuvent être enregistrées à l’aide de la <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>To read an XML document that includes both schema and data, use the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method.</source>
          <target state="translated">Pour lire un document XML qui inclut le schéma et les données, utilisez le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In a typical multiple-tier implementation, the steps for creating and refreshing a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, and in turn, updating the original data are to:</source>
          <target state="translated">Dans une implémentation classique à plusieurs niveaux, les étapes de création et d’actualisation une <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, et à son tour, la mise à jour les données d’origine :</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Build and fill each <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> in a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with data from a data source using a <ph id="ph3">&lt;xref:System.Data.Common.DataAdapter&gt;</ph>.</source>
          <target state="translated">Générer et remplir chaque <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> dans un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec les données d’une source de données à l’aide un <ph id="ph3">&lt;xref:System.Data.Common.DataAdapter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Change the data in individual <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> objects by adding, updating, or deleting <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> objects.</source>
          <target state="translated">Modifier les données dans les <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> les objets par l’ajout, la mise à jour ou suppression <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Invoke the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method to create a second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> that features only the changes to the data.</source>
          <target state="translated">Appeler le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode pour créer un second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> qui comprend uniquement les modifications aux données.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Call the <ph id="ph1">&lt;xref:System.Data.Common.DataAdapter.Update%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Data.Common.DataAdapter&gt;</ph>, passing the second <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> as an argument.</source>
          <target state="translated">Appelez le <ph id="ph1">&lt;xref:System.Data.Common.DataAdapter.Update%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.Data.Common.DataAdapter&gt;</ph>, en passant le deuxième <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> en tant qu’argument.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Invoke the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method to merge the changes from the second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into the first.</source>
          <target state="translated">Appeler le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> pour fusionner les modifications de la deuxième méthode <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> dans le premier.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Invoke the <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> on the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Appeler le <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> sur la <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Alternatively, invoke <ph id="ph1">&lt;xref:System.Data.DataSet.RejectChanges%2A&gt;</ph> to cancel the changes.</source>
          <target state="translated">Vous pouvez également appeler <ph id="ph1">&lt;xref:System.Data.DataSet.RejectChanges%2A&gt;</ph> pour annuler les modifications.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects inherit from <ph id="ph3">&lt;xref:System.ComponentModel.MarshalByValueComponent&gt;</ph>, and support the <ph id="ph4">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface for remoting.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objets héritent de <ph id="ph3">&lt;xref:System.ComponentModel.MarshalByValueComponent&gt;</ph>et prennent en charge la <ph id="ph4">&lt;xref:System.Runtime.Serialization.ISerializable&gt;</ph> interface pour la communication à distance.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>These are the only ADO.NET objects that can be remoted.</source>
          <target state="translated">Ce sont les seuls objets ADO.NET qui peuvent être exécutés à distance.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Classes inherited from <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> are not finalized by the garbage collector, because the finalizer has been suppressed in <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Classes héritées de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> ne sont pas finalisées par le garbage collector, car le finaliseur a été supprimé dans <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The derived class can call the <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method in its constructor to allow the class to be finalized by the garbage collector.</source>
          <target state="translated">La classe dérivée peut appeler le <ph id="ph1">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> méthode dans son constructeur pour permettre à la classe d’être finalisée par le garbage collector.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The following example consists of several methods that, combined, create and fill a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> from the <bpt id="p1">**</bpt>Northwind<ept id="p1">**</ept> database.</source>
          <target state="translated">L’exemple suivant se compose de plusieurs méthodes qui, combinés, créer et remplir un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> à partir de la <bpt id="p1">**</bpt>Northwind<ept id="p1">**</ept> base de données.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>This type is safe for multithreaded read operations.</source>
          <target state="translated">Ce type est sécurisé pour les opérations de lecture multithreads.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>You must synchronize any write operations.</source>
          <target state="translated">Vous devez synchroniser des opérations d’écriture.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.#ctor">
          <source>This implementation of the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> constructor takes no parameters, and creates a default name, "NewDataSet," for the new instance.</source>
          <target state="translated">Cette implémentation de la <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> constructeur n’accepte aucun paramètre et crée un nom par défaut, « NewDataSet », pour la nouvelle instance.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.#ctor">
          <source>A name for the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is required to ensure that the XML representation of the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> always has a name for the document element, which is the highest-level element in a schema definition.</source>
          <target state="translated">Un nom pour le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est nécessaire pour garantir que la représentation XML de le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> a toujours un nom pour l’élément de document, qui est l’élément de niveau supérieur dans une définition de schéma.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.#ctor">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, and adds two <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects to it.</source>
          <target state="translated">L’exemple suivant crée un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>et ajoute deux <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.String)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Nom du <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.String)">
          <source>Initializes a new instance of a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> class with the given name.</source>
          <target state="translated">Initialise une nouvelle instance d'une classe <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> portant le nom donné.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.#ctor(System.String)">
          <source>A name for the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is required to ensure that the XML representation of the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> always has a name for the document element, which is the highest level element in a schema definition.</source>
          <target state="translated">Un nom pour le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est nécessaire pour garantir que la représentation XML de le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> a toujours un nom pour l’élément de document, qui est l’élément de niveau le plus élevé dans une définition de schéma.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.#ctor(System.String)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, to which two <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objects are added.</source>
          <target state="translated">L’exemple suivant crée un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, pour les deux <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objets sont ajoutés.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The data needed to serialize or deserialize an object.</source>
          <target state="translated">Données nécessaires à la sérialisation et à la désérialisation d’un objet.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The source and destination of a given serialized stream.</source>
          <target state="translated">Source et destination d’un flux sérialisé donné.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> class that has the given serialization information and context.</source>
          <target state="translated">Initialise une nouvelle instance d'une classe <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> qui contient les informations de sérialisation et le contexte donnés.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)">
          <source>The boolean value.</source>
          <target state="translated">Valeur booléenne.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.AcceptChanges">
          <source>Commits all the changes made to this <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> since it was loaded or since the last time <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph> was called.</source>
          <target state="translated">Valide toutes les modifications apportées à ce <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> depuis son chargement ou depuis le dernier appel à <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>Both the <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> classes have <ph id="ph3">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> methods.</source>
          <target state="translated">À la fois le <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> classes ont <ph id="ph3">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>Calling <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> at the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> level causes the <ph id="ph3">&lt;xref:System.Data.DataRow.AcceptChanges%2A&gt;</ph> method for each <ph id="ph4">&lt;xref:System.Data.DataRow&gt;</ph> to be called.</source>
          <target state="translated">Appel <ph id="ph1">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> à la <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> niveau entraîne la <ph id="ph3">&lt;xref:System.Data.DataRow.AcceptChanges%2A&gt;</ph> méthode pour chaque <ph id="ph4">&lt;xref:System.Data.DataRow&gt;</ph> à appeler.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>Similarly, invoking <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> on the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> causes <ph id="ph3">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> to be called on each table within the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">De même, l’appel <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> sur la <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> entraîne <ph id="ph3">&lt;xref:System.Data.DataTable.AcceptChanges%2A&gt;</ph> à appeler sur chaque table contenue dans le <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>In this manner, you have multiple levels at which the method can be invoked.</source>
          <target state="translated">De cette manière, vous disposez de plusieurs niveaux à laquelle la méthode peut être appelée.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>Calling the <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> of the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> enables you to invoke the method on all subordinate objects (for example, tables and rows) with one call.</source>
          <target state="translated">Appel de la <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> de la <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> vous permet d’appeler la méthode sur tous les objets subordonnés (par exemple, les tables et les lignes) avec un seul appel.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>When you call <ph id="ph1">`AcceptChanges`</ph> on the <ph id="ph2">`DataSet`</ph>, any <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects still in edit-mode end their edits successfully.</source>
          <target state="translated">Lorsque vous appelez <ph id="ph1">`AcceptChanges`</ph> sur la <ph id="ph2">`DataSet`</ph>, tout <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objets toujours en mode édition achève correctement ses modifications.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataRow.RowState%2A&gt;</ph> property of each <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> also changes; <ph id="ph3">`Added`</ph> and <ph id="ph4">`Modified`</ph> rows become <ph id="ph5">`Unchanged`</ph>, and <ph id="ph6">`Deleted`</ph> rows are removed.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataRow.RowState%2A&gt;</ph> propriété de chaque <ph id="ph2">&lt;xref:System.Data.DataRow&gt;</ph> change également ; <ph id="ph3">`Added`</ph> et <ph id="ph4">`Modified`</ph> lignes deviennent <ph id="ph5">`Unchanged`</ph>, et <ph id="ph6">`Deleted`</ph> lignes sont supprimées.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>If the <ph id="ph1">`DataSet`</ph> contains <ph id="ph2">&lt;xref:System.Data.ForeignKeyConstraint&gt;</ph> objects, invoking the <ph id="ph3">`AcceptChanges`</ph> method also causes the <ph id="ph4">&lt;xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A&gt;</ph> to be enforced.</source>
          <target state="translated">Si le <ph id="ph1">`DataSet`</ph> contient <ph id="ph2">&lt;xref:System.Data.ForeignKeyConstraint&gt;</ph> objets, en appelant le <ph id="ph3">`AcceptChanges`</ph> entraîne également la méthode le <ph id="ph4">&lt;xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A&gt;</ph> pour être appliqué.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source><ph id="ph1">`AcceptChanges`</ph> and <ph id="ph2">`RejectChanges`</ph> only apply to <ph id="ph3">`DataRow`</ph> related changes (that is, Add, Remove, Delete, and Modify).</source>
          <target state="translated"><ph id="ph1">`AcceptChanges`</ph> et <ph id="ph2">`RejectChanges`</ph> s’appliquent uniquement aux <ph id="ph3">`DataRow`</ph> des modifications (c'est-à-dire, ajouter, supprimer, supprimer et modifier).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>They are not applicable to schema or structural changes.</source>
          <target state="translated">Ils ne sont pas applicables au schéma ou des modifications structurelles.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>Calling AcceptChanges will not replicate these changes back to the data source if the DataSet was filled using a DataAdapter.</source>
          <target state="translated">Appeler AcceptChanges pas réplique ces modifications vers la source de données si le jeu de données a été passée à l’aide d’un DataAdapter.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>In that situation, call <ph id="ph1">&lt;xref:System.Data.Common.DataAdapter.Update%2A&gt;</ph> instead.</source>
          <target state="translated">Dans ce cas, appelez <ph id="ph1">&lt;xref:System.Data.Common.DataAdapter.Update%2A&gt;</ph> à la place.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>See <bpt id="p1">[</bpt>Updating Data Sources with DataAdapters<ept id="p1">](http://msdn.microsoft.com/library/33y2221y.aspx)</ept> for more information.</source>
          <target state="translated">Consultez <bpt id="p1">[</bpt>mise à jour des Sources de données avec DataAdapters<ept id="p1">](http://msdn.microsoft.com/library/33y2221y.aspx)</ept> pour plus d’informations.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>The following example adds a <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> to a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> in a <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">L’exemple suivant ajoute un <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> à un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> dans un <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.AcceptChanges">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> method is then called on the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, which cascades to all <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> objects that it contains.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.AcceptChanges%2A&gt;</ph> méthode est ensuite appelée sur le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, les cascades à tous les <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> les objets qu’il contient.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.BeginInit">
          <source>Begins the initialization of a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> that is used on a form or used by another component.</source>
          <target state="translated">Commence l'initialisation d'un <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> qui est utilisé dans un formulaire ou par un autre composant.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.BeginInit">
          <source>The initialization occurs at run time.</source>
          <target state="translated">L'initialisation se produit au moment de l'exécution.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.BeginInit">
          <source>The Visual Studio .NET design environment uses this method to start the initialization of a component that is used on a form or used by another component.</source>
          <target state="translated">L’environnement de conception de Visual Studio .NET utilise cette méthode pour démarrer l’initialisation d’un composant qui est utilisé sur un formulaire ou par un autre composant.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.BeginInit">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> method ends the initialization.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> méthode termine l’initialisation.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.BeginInit">
          <source>Using the <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> methods prevents the control from being used before it is fully initialized.</source>
          <target state="translated">À l’aide de la <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> méthodes empêche le contrôle avant son initialisation complète.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.CaseSensitive">
          <source>Gets or sets a value indicating whether string comparisons within <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> objects are case-sensitive.</source>
          <target state="translated">Obtient ou définit une valeur indiquant si les comparaisons de chaînes au sein d'objets <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> respectent la casse.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.CaseSensitive">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if string comparisons are case-sensitive; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si les comparaisons de chaînes respectent la casse ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.CaseSensitive">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.CaseSensitive">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph> property affects how sorting, searching, and filtering operations are performed on each <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> object contained in a <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> when using the <ph id="ph4">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph> propriété affecte la tri, recherche et filtrage des opérations sont effectuées sur chaque <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> objet contenu dans un <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> lors de l’utilisation du <ph id="ph4">&lt;xref:System.Data.DataTable.Select%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.CaseSensitive">
          <source>By default, setting the <ph id="ph1">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph> property for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> also sets the <ph id="ph3">&lt;xref:System.Data.DataTable.CaseSensitive%2A&gt;</ph> property of each associated <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph> to the same value.</source>
          <target state="translated">Par défaut, la définition la <ph id="ph1">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph> propriété pour un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> définit également la <ph id="ph3">&lt;xref:System.Data.DataTable.CaseSensitive%2A&gt;</ph> propriété de chaque associés <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph> sur la même valeur.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.CaseSensitive">
          <source>The following example toggles the <ph id="ph1">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple suivant active ou désactive le <ph id="ph1">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Clear">
          <source>Clears the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> of any data by removing all rows in all tables.</source>
          <target state="translated">Efface toutes les données de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en supprimant toutes les lignes de l'ensemble des tables.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Clear">
          <source>If the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is bound to an <ph id="ph2">&lt;xref:System.Xml.XmlDataDocument&gt;</ph>, calling <ph id="ph3">&lt;xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph4">&lt;xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType&gt;</ph> raises the <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Si le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est lié à un <ph id="ph2">&lt;xref:System.Xml.XmlDataDocument&gt;</ph>, l’appel <ph id="ph3">&lt;xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph4">&lt;xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType&gt;</ph> déclenche le <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Clear">
          <source>To avoid this situation, traverse each table, removing each row one at a time.</source>
          <target state="translated">Pour éviter cette situation, parcourez chaque table et supprimez les lignes une à la fois.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Clear">
          <source>The following example clears the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> of all rows in all tables.</source>
          <target state="translated">L’exemple suivant efface le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> de toutes les lignes de toutes les tables.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Clone">
          <source>Copies the structure of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, including all <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> schemas, relations, and constraints.</source>
          <target state="translated">Copie la structure de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, y compris tous les schémas, relations et contraintes <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Clone">
          <source>Does not copy any data.</source>
          <target state="translated">Ne copie aucune donnée.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Clone">
          <source>A new <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> with the same schema as the current <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, but none of the data.</source>
          <target state="translated">Nouveau <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> avec le même schéma que le <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en cours, mais aucune donnée.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Clone">
          <source>If these classes have been subclassed, the clone will also be of the same subclasses.</source>
          <target state="translated">Si ces classes ont été sous-classé, le clone sera également aux mêmes sous-classes.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Clone">
          <source>The following example creates a clone of a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object's schema.</source>
          <target state="translated">L’exemple suivant crée un clone d’un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schéma de l’objet.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Copy">
          <source>Copies both the structure and data for this <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Copie à la fois la structure et les données de ce <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Copy">
          <source>A new <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> with the same structure (table schemas, relations, and constraints) and data as this <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Nouveau <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> possédant la même structure (contraintes, relations et schémas de table) et les mêmes données que ce <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Copy">
          <source>If these classes have been subclassed, the copy will also be of the same subclasses.</source>
          <target state="translated">Si ces classes ont été sous-classées, la copie appartient également aux mêmes sous-classes.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Copy">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.Copy%2A&gt;</ph> method to create a copy of the original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Data.DataSet.Copy%2A&gt;</ph> méthode pour créer une copie de l’original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> with one result set per <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, in the same sequence as the tables appear in the <ph id="ph3">&lt;see cref="P:System.Data.DataSet.Tables" /&gt;</ph> collection.</source>
          <target state="translated">Retourne un <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> avec un jeu de résultats par <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, dans la même séquence que les tables dans la collection <ph id="ph3">&lt;see cref="P:System.Data.DataSet.Tables" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In order to ensure the order of the result sets within the returned <ph id="ph1">&lt;xref:System.Data.DataTableReader&gt;</ph>, if a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> within the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> is empty, it will be represented by an empty result set within the returned <ph id="ph4">`DataTableReader`</ph>.</source>
          <target state="translated">Afin de garantir l’ordre des jeux de résultats dans la liste retournée <ph id="ph1">&lt;xref:System.Data.DataTableReader&gt;</ph>, si un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> au sein de la <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> est vide, il sera représenté par un jeu dans retourné de résultats vide <ph id="ph4">`DataTableReader`</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>This example, a Console application, creates three <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances and adds each to a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Cet exemple, une application Console, crée trois <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances et les ajoute à un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Data.DataSet.CreateDataReader%2A&gt;</ph> method and displays the contents of the returned <ph id="ph2">&lt;xref:System.Data.DataTableReader&gt;</ph>.</source>
          <target state="translated">L’exemple appelle la <ph id="ph1">&lt;xref:System.Data.DataSet.CreateDataReader%2A&gt;</ph> (méthode) et affiche le contenu de retourné <ph id="ph2">&lt;xref:System.Data.DataTableReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Note that the order of the result sets in the <ph id="ph1">`DataTableReader`</ph> is controlled by the order of the <ph id="ph2">`DataTable`</ph> instances passed as parameters.</source>
          <target state="translated">Notez que l’ordre du résultat définit dans le <ph id="ph1">`DataTableReader`</ph> est contrôlé par l’ordre de la <ph id="ph2">`DataTable`</ph> instances passés comme paramètres.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>This example shows how to use one of the overloaded versions of <ph id="ph1">`CreateDataReader`</ph>.</source>
          <target state="translated">Cet exemple montre comment utiliser une des versions surchargées de <ph id="ph1">`CreateDataReader`</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>For other examples that might be available, see the individual overload topics.</source>
          <target state="translated">Pour obtenir des exemples qui peuvent être disponibles, consultez les rubriques de surcharge individuels.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The example displays the following code in the Console window:</source>
          <target state="translated">L’exemple affiche le code suivant dans la fenêtre de Console :</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.CreateDataReader">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> with one result set per <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, in the same sequence as the tables appear in the <ph id="ph3">&lt;see cref="P:System.Data.DataSet.Tables" /&gt;</ph> collection.</source>
          <target state="translated">Retourne un <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> avec un jeu de résultats par <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, dans la même séquence que les tables dans la collection <ph id="ph3">&lt;see cref="P:System.Data.DataSet.Tables" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.CreateDataReader">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> containing one or more result sets, corresponding to the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances contained within the source <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> contenant un ou plusieurs jeux de résultats, correspondant aux instances de <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, contenues dans le <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> source.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader">
          <source>In order to ensure the order of the result sets within the returned <ph id="ph1">&lt;xref:System.Data.DataTableReader&gt;</ph>, if a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> within the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> is empty, it is represented by an empty result set within the returned <ph id="ph4">`DataTableReader`</ph>.</source>
          <target state="translated">Afin de garantir l’ordre des jeux de résultats dans la liste retournée <ph id="ph1">&lt;xref:System.Data.DataTableReader&gt;</ph>, si un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> au sein de la <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> est vide, il est représenté par un jeu dans retourné de résultats vide <ph id="ph4">`DataTableReader`</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader">
          <source>The following example creates three <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances, and adds each to a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">L’exemple suivant crée trois <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances et les ajoute à un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader">
          <source>The example then passes the filled <ph id="ph1">`DataSet`</ph> to a procedure that calls the <ph id="ph2">&lt;xref:System.Data.DataSet.CreateDataReader%2A&gt;</ph> method, and proceeds to iterate through all the result sets contained within the <ph id="ph3">&lt;xref:System.Data.DataTableReader&gt;</ph>.</source>
          <target state="translated">L’exemple passe ensuite la pleine <ph id="ph1">`DataSet`</ph> à une procédure qui appelle la <ph id="ph2">&lt;xref:System.Data.DataSet.CreateDataReader%2A&gt;</ph> méthode et passe à une itération au sein de tous les jeux de résultats contenus dans le <ph id="ph3">&lt;xref:System.Data.DataTableReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader">
          <source>The example displays the results in the Console window.</source>
          <target state="translated">L’exemple affiche les résultats dans la fenêtre de Console.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>An array of DataTables providing the order of the result sets to be returned in the <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph>.</source>
          <target state="translated">Tableau de DataTables qui fournit l'ordre des jeux de résultats à retourner dans le <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> with one result set per <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">Retourne un <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> avec un jeu de résultats par <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> containing one or more result sets, corresponding to the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances contained within the source <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTableReader" /&gt;</ph> contenant un ou plusieurs jeux de résultats, correspondant aux instances de <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, contenues dans le <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> source.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>The returned result sets are in the order specified by the <ph id="ph1">&lt;paramref name="dataTables" /&gt;</ph> parameter.</source>
          <target state="translated">Les jeux de résultats retournés sont dans l'ordre spécifié par le paramètre <ph id="ph1">&lt;paramref name="dataTables" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>In order to ensure that the order of the result sets within the returned <ph id="ph1">&lt;xref:System.Data.DataTableReader&gt;</ph>, if a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> within the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> is empty, it is represented by an empty result set within the returned <ph id="ph4">`DataTableReader`</ph>.</source>
          <target state="translated">Afin de garantir que l’ordre du résultat jeux dans retourné <ph id="ph1">&lt;xref:System.Data.DataTableReader&gt;</ph>, si un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> au sein de la <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph> est vide, il est représenté par un jeu dans retourné de résultats vide <ph id="ph4">`DataTableReader`</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>Because this overloaded version allows you to supply a list of <ph id="ph1">`DataTable`</ph> instances as parameters, you can specify the order in which the result sets appear within the returned <ph id="ph2">`DataTableReader`</ph>.</source>
          <target state="translated">Étant donné que cette version surchargée vous permet de fournir une liste de <ph id="ph1">`DataTable`</ph> instances en tant que paramètres, vous pouvez spécifier l’ordre dans lequel les jeux de résultats apparaissent dans la liste retournée <ph id="ph2">`DataTableReader`</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>This example, a Console application, creates three <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances and adds each to a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Cet exemple, une application Console, crée trois <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> instances et les ajoute à un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Data.DataSet.CreateDataReader%2A&gt;</ph> method and displays the contents of the returned <ph id="ph2">&lt;xref:System.Data.DataTableReader&gt;</ph>.</source>
          <target state="translated">L’exemple appelle la <ph id="ph1">&lt;xref:System.Data.DataSet.CreateDataReader%2A&gt;</ph> (méthode) et affiche le contenu de retourné <ph id="ph2">&lt;xref:System.Data.DataTableReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>Note that the order of the result sets in the <ph id="ph1">`DataTableReader`</ph> is controlled by the order of the <ph id="ph2">`DataTable`</ph> instances passed as parameters.</source>
          <target state="translated">Notez que l’ordre du résultat définit dans le <ph id="ph1">`DataTableReader`</ph> est contrôlé par l’ordre de la <ph id="ph2">`DataTable`</ph> instances passés comme paramètres.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])">
          <source>The example displays the results in the Console window.</source>
          <target state="translated">L’exemple affiche les résultats dans la fenêtre de Console.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.DataSetName">
          <source>Gets or sets the name of the current <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtient ou définit le nom du <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.DataSetName">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Nom du <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.DataSetName">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the given <ph id="ph2">&lt;xref:System.Data.DataSet.DataSetName%2A&gt;</ph>.</source>
          <target state="translated">L’exemple suivant crée un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec la donnée <ph id="ph2">&lt;xref:System.Data.DataSet.DataSetName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.DefaultViewManager">
          <source>Gets a custom view of the data contained in the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to allow filtering, searching, and navigating using a custom <ph id="ph2">&lt;see cref="T:System.Data.DataViewManager" /&gt;</ph>.</source>
          <target state="translated">Obtient une vue personnalisée des données contenues dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, permettant de filtrer, rechercher et naviguer à l'aide d'un <ph id="ph2">&lt;see cref="T:System.Data.DataViewManager" /&gt;</ph> personnalisé.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.DefaultViewManager">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataViewManager" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Data.DataViewManager" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.DefaultViewManager">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataViewManager&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Data.DataSet.DefaultViewManager%2A&gt;</ph> property allows you to create custom settings for each <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> in the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataViewManager&gt;</ph> retournée par le <ph id="ph2">&lt;xref:System.Data.DataSet.DefaultViewManager%2A&gt;</ph> propriété vous permet de créer des paramètres personnalisés pour chaque <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> dans le <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.DefaultViewManager">
          <source>When you obtain a <ph id="ph1">&lt;xref:System.Data.DataView&gt;</ph> from a <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, the sort order, filtering, and <ph id="ph3">&lt;xref:System.Data.DataViewRowState&gt;</ph> are configured according to the settings in the <ph id="ph4">&lt;xref:System.Data.DataSet.DefaultViewManager%2A&gt;</ph> property.</source>
          <target state="translated">Lors de l’obtenir un <ph id="ph1">&lt;xref:System.Data.DataView&gt;</ph> à partir d’un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, l’ordre de tri, le filtrage, et <ph id="ph3">&lt;xref:System.Data.DataViewRowState&gt;</ph> sont configurés selon les paramètres de la <ph id="ph4">&lt;xref:System.Data.DataSet.DefaultViewManager%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.DefaultViewManager">
          <source>The following example gets the default <ph id="ph1">&lt;xref:System.Data.DataViewManager&gt;</ph> for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, and adds a <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> to the <ph id="ph4">&lt;xref:System.Data.DataTableCollection&gt;</ph>.</source>
          <target state="translated">L’exemple suivant obtient la valeur par défaut <ph id="ph1">&lt;xref:System.Data.DataViewManager&gt;</ph> pour un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>et ajoute un <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> à la <ph id="ph4">&lt;xref:System.Data.DataTableCollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Determines the <ph id="ph1">&lt;see cref="P:System.Data.DataSet.SchemaSerializationMode" /&gt;</ph> for a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Détermine le <ph id="ph1">&lt;see cref="P:System.Data.DataSet.SchemaSerializationMode" /&gt;</ph> pour un <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>This method can be called when deserializing a typed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> to determine its <ph id="ph2">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode peut être appelée lors de la désérialisation typé <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> afin de déterminer son <ph id="ph2">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> instance that is passed during deserialization of the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Instance de <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> qui est passée pendant la désérialisation du <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)">
          <source>Determines the <ph id="ph1">&lt;see cref="P:System.Data.DataSet.SchemaSerializationMode" /&gt;</ph> for a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Détermine le <ph id="ph1">&lt;see cref="P:System.Data.DataSet.SchemaSerializationMode" /&gt;</ph> pour un <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> enumeration indicating whether schema information has been omitted from the payload.</source>
          <target state="translated">Énumération <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> qui indique si des informations de schéma ont été omises de la charge utile.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)">
          <source>This method can be called when deserializing a typed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> to determine its <ph id="ph2">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode peut être appelée lors de la désérialisation typé <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> afin de déterminer son <ph id="ph2">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> that a <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>’s protected constructor <ph id="ph3">&lt;see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /&gt;</ph> is invoked with during deserialization in remoting scenarios.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> avec lequel le <ph id="ph3">&lt;see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /&gt;</ph> du constructeur protégé d'un <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> est appelé pendant la désérialisation, dans les scénarios de communication à distance.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> that a <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>’s protected constructor <ph id="ph3">&lt;see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /&gt;</ph> is invoked with during deserialization in remoting scenarios.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> avec lequel le <ph id="ph3">&lt;see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /&gt;</ph> du constructeur protégé d'un <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> est appelé pendant la désérialisation, dans les scénarios de communication à distance.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Determines the <ph id="ph1">&lt;see cref="P:System.Data.DataSet.SchemaSerializationMode" /&gt;</ph> for a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Détermine le <ph id="ph1">&lt;see cref="P:System.Data.DataSet.SchemaSerializationMode" /&gt;</ph> pour un <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> enumeration indicating whether schema information has been omitted from the payload.</source>
          <target state="translated">Énumération <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> qui indique si des informations de schéma ont été omises de la charge utile.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method can be called when deserializing a typed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> to determine its <ph id="ph2">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph>.</source>
          <target state="translated">Cette méthode peut être appelée lors de la désérialisation typé <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> afin de déterminer son <ph id="ph2">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.EndInit">
          <source>Ends the initialization of a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> that is used on a form or used by another component.</source>
          <target state="translated">Termine l'initialisation d'un <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> qui est utilisé dans un formulaire ou par un autre composant.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.EndInit">
          <source>The initialization occurs at run time.</source>
          <target state="translated">L'initialisation se produit au moment de l'exécution.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.EndInit">
          <source>The Visual Studio .NET design environment uses this method to end the initialization of a component that is used on a form or used by another component.</source>
          <target state="translated">L’environnement de conception de Visual Studio .NET utilise cette méthode pour terminer l’initialisation d’un composant qui est utilisé sur un formulaire ou par un autre composant.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.EndInit">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> method starts the initialization.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> méthode démarre l’initialisation.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.EndInit">
          <source>Using the <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> methods prevents the control from being used before it is fully initialized.</source>
          <target state="translated">À l’aide de la <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> méthodes empêche le contrôle avant son initialisation complète.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>Gets or sets a value indicating whether constraint rules are followed when attempting any update operation.</source>
          <target state="translated">Obtient ou définit une valeur indiquant si les règles de contrainte doivent être respectées lorsque vous tentez une opération de mise à jour.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if rules are enforced; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si les règles sont appliquées ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>Constraints are set at the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> level (<ph id="ph2">&lt;xref:System.Data.DataTable.Constraints%2A&gt;</ph> property).</source>
          <target state="translated">Les contraintes sont définies au niveau du <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> niveau (<ph id="ph2">&lt;xref:System.Data.DataTable.Constraints%2A&gt;</ph> propriété).</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>For more information about creating constraints, see <bpt id="p1">[</bpt>DataTable Constraints<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la création de contraintes, consultez <bpt id="p1">[</bpt>contraintes DataTable<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)</ept>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one table, one column, five rows, and one <ph id="ph2">&lt;xref:System.Data.UniqueConstraint&gt;</ph>.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec une table, une colonne, cinq lignes et un <ph id="ph2">&lt;xref:System.Data.UniqueConstraint&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph> and the values of each row are set to the same value.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> est définie sur <ph id="ph2">`false`</ph> et les valeurs de chaque ligne sont définis sur la même valeur.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is reset to <ph id="ph2">`true`</ph>, a <ph id="ph3">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propriété <ph id="ph2">`true`</ph>, un <ph id="ph3">&lt;xref:System.Data.ConstraintException&gt;</ph> est généré.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.EnforceConstraints">
          <source>One or more constraints cannot be enforced.</source>
          <target state="translated">Une ou plusieurs contraintes ne peuvent pas être appliquées.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>Gets the collection of customized user information associated with the <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtient la collection d'informations utilisateur personnalisées associée au <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.PropertyCollection" /&gt;</ph> with all custom user information.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.PropertyCollection" /&gt;</ph> contenant toutes les informations utilisateur personnalisées.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ExtendedProperties%2A&gt;</ph> property enables you to store custom information with the <ph id="ph2">`DataSet`</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ExtendedProperties%2A&gt;</ph> propriété vous permet de stocker des informations personnalisées avec la <ph id="ph2">`DataSet`</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>For example, you might store a time when the data should be refreshed.</source>
          <target state="translated">Par exemple, vous pouvez stocker une heure à laquelle les données doivent être actualisées.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>Extended properties must be of type <ph id="ph1">&lt;xref:System.String&gt;</ph> if you want them persisted when the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> is written as XML.</source>
          <target state="translated">Les propriétés étendues doivent être de type <ph id="ph1">&lt;xref:System.String&gt;</ph> si vous souhaitez les rendues persistantes lorsque le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> est écrit au format XML.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>The following example adds a custom property to the <ph id="ph1">&lt;xref:System.Data.PropertyCollection&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Data.DataColumn.ExtendedProperties%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple suivant ajoute une propriété personnalisée à la <ph id="ph1">&lt;xref:System.Data.PropertyCollection&gt;</ph> retournée par le <ph id="ph2">&lt;xref:System.Data.DataColumn.ExtendedProperties%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.ExtendedProperties">
          <source>The second example retrieves the custom property.</source>
          <target state="translated">Le deuxième exemple récupère la propriété personnalisée.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Gets a copy of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> containing all changes made to it since it was last loaded, or since <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph> was called.</source>
          <target state="translated">Obtient une copie du <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> contenant l'ensemble des modifications qui lui ont été apportées depuis son dernier chargement ou depuis l'appel à <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges">
          <source>Gets a copy of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> that contains all changes made to it since it was loaded or since <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph> was last called.</source>
          <target state="translated">Obtient une copie du <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> qui contient l'ensemble des modifications qui lui ont été apportées depuis son chargement ou depuis le dernier appel à <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges">
          <source>A copy of the changes from this <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> that can have actions performed on it and later be merged back in using <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /&gt;</ph>.</source>
          <target state="translated">Copie des modifications de ce <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> sur lequel des actions peuvent être exécutées, et ensuite refusionnées à l'aide de <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges">
          <source>If no changed rows are found, the method returns <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si aucune ligne modifiée n'est trouvée, la méthode retourne <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>Creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that contains a copy of all rows in the original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> that have pending changes.</source>
          <target state="translated">Crée un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> qui contient une copie de toutes les lignes dans l’original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> qui ont les modifications en attente.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>Relationship constraints can cause additional unchanged rows to be added to the new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> if the unchanged rows contain primary keys corresponding to foreign keys in the changed rows.</source>
          <target state="translated">Les contraintes de relation peuvent entraîner des lignes inchangées supplémentaires à ajouter à la nouvelle <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> si les lignes inchangées contiennent des clés primaires correspondant aux clés étrangères dans les lignes modifiées.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>The method returns <ph id="ph1">`null`</ph> if there are no rows in the original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> that have pending changes.</source>
          <target state="translated">La méthode retourne <ph id="ph1">`null`</ph> s’il en existe aucune ligne dans la version d’origine <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> qui ont les modifications en attente.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>The following example creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one table, two columns, and ten rows.</source>
          <target state="translated">L’exemple suivant crée un simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec une table, deux colonnes et dix lignes.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>Two values are changed, and one row is added.</source>
          <target state="translated">Deux valeurs sont modifiées et qu’une ligne est ajoutée.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>A subset of the changed data is created using the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method.</source>
          <target state="translated">Un sous-ensemble des données modifiées est créé à l’aide de la <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>After reconciling errors, a new column is added to the subset, changing the schema.</source>
          <target state="translated">Après résolution des erreurs, une nouvelle colonne est ajoutée au sous-ensemble, modification du schéma.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called with the <ph id="ph2">`missingSchemaAction`</ph> set to <ph id="ph3">`MissingSchemaAction.Add`</ph>, the new column is added to the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> object's schema.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est appelée avec le <ph id="ph2">`missingSchemaAction`</ph> la valeur <ph id="ph3">`MissingSchemaAction.Add`</ph>, la nouvelle colonne est ajoutée à l’original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> schéma de l’objet.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>Gets a copy of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> containing all changes made to it since it was last loaded, or since <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph> was called, filtered by <ph id="ph3">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</source>
          <target state="translated">Obtient une copie du <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> contenant l'ensemble des modifications qui lui ont été apportées depuis son dernier chargement ou depuis l'appel à <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph>, filtrée par <ph id="ph3">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>A filtered copy of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> that can have actions performed on it, and subsequently be merged back in using <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /&gt;</ph>.</source>
          <target state="translated">Copie filtrée du <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> sur lequel des actions peuvent être exécutées, puis refusionnées à l'aide de <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>If no rows of the desired <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph> are found, the method returns <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si aucune ligne du <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph> souhaité n'est détectée, la méthode retourne <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is used to produce a second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object that contains only the changes introduced into the original.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode est utilisée pour générer un deuxième <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objet qui contient uniquement les modifications introduites dans la version d’origine.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>Use the <ph id="ph1">`rowStates`</ph> argument to specify the type of changes the new object should include.</source>
          <target state="translated">Utilisez le <ph id="ph1">`rowStates`</ph> argument afin de spécifier le type de l’objet doit inclure des modifications.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>This returned copy is designed to be merged back in to this original <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Cette copie retournée est conçue à fusionner dans ce original <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>Relationship constraints may cause parent rows marked <ph id="ph1">`Unchanged`</ph> to be included.</source>
          <target state="translated">Les contraintes de relation peuvent entraîner des lignes parentes marquées comme <ph id="ph1">`Unchanged`</ph> à inclure.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>If no rows of the desired <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> are found, the <ph id="ph2">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Si aucune ligne de l’élément <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> sont trouvées, le <ph id="ph2">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode renvoie <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method to create a second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object, which is then used to update a data source.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode pour créer un second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objet, qui est ensuite utilisé pour mettre à jour une source de données.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)">
          <source>The specified schema set.</source>
          <target state="translated">Jeu de schémas spécifié.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)">
          <source>Gets a copy of <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph> for the DataSet.</source>
          <target state="translated">Obtient une copie de <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph> pour le DataSet.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)">
          <source>A copy of <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph>.</source>
          <target state="translated">Copie de l'objet <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XmlSchemaSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> that holds the serialized data associated with the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> qui contient les données sérialisées associées à l'<ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> that contains the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> qui contient la source et la destination du flux sérialisé associé à l'<ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a serialization information object with the data needed to serialize the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Remplit un objet d’informations de sérialisation avec les données nécessaires pour sérialiser <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;paramref name="info" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="info" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetSchemaSerializable">
          <source>Returns a serializable <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XMLSchema" /&gt;</ph> instance.</source>
          <target state="translated">Retourne une instance sérialisable de <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XMLSchema" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetSchemaSerializable">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XMLSchema" /&gt;</ph> instance.</source>
          <target state="translated">Instance <ph id="ph1">&lt;see cref="T:System.Xml.Schema.XMLSchema" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> instance.</source>
          <target state="translated">Instance <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The streaming context.</source>
          <target state="translated">Contexte de diffusion en continu.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Deserializes the table data from the binary or XML stream.</source>
          <target state="translated">Désérialise les données de table du flux binaire ou de données XML.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetXml">
          <source>Returns the XML representation of the data stored in the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Retourne la représentation XML des données stockées dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetXml">
          <source>A string that is a representation of the data stored in the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Chaîne qui est une représentation des données stockées dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>Calling this method is identical to calling <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> with <ph id="ph2">&lt;xref:System.Data.XmlWriteMode&gt;</ph> set to <ph id="ph3">&lt;xref:System.Data.XmlWriteMode.IgnoreSchema&gt;</ph>.</source>
          <target state="translated">Appel de cette méthode est identique à l’appel <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> avec <ph id="ph2">&lt;xref:System.Data.XmlWriteMode&gt;</ph> la valeur <ph id="ph3">&lt;xref:System.Data.XmlWriteMode.IgnoreSchema&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source><ph id="ph1">&lt;xref:System.Data.DataSet.GetXml%2A&gt;</ph> returns XML as a string, and therefore requires more overhead than <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> to write XML to a file.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataSet.GetXml%2A&gt;</ph> Retourne des données XML sous forme de chaîne et par conséquent requiert plus de charge que <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> à écrire du code XML dans un fichier.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>If you build a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> using schema inference and serialize it using XML or Web services, the column ordering may change.</source>
          <target state="translated">Si vous générez un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> à l’aide de l’inférence de schéma et sérialiser à l’aide de services XML ou Web, l’ordre de tri peut changer.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, adds sample data, and then displays the data in XML format.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, ajoute les exemples de données, puis affiche les données au format XML.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>This sample demonstrates how to write data into an XML file from a DataSet and read data into DataSet from XML.</source>
          <target state="translated">Cet exemple montre comment écrire des données dans un fichier XML à partir d’un jeu de données et lire des données dans le jeu de données à partir de XML.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>This sample will create one dataset with two tables, use two ways to export a dataset into the XML files (WriteXml and GetXml), and use two ways (ReadXml and InferXmlSchema) to import a dataset from the XML files.</source>
          <target state="translated">Cet exemple est créer un jeu de données avec deux tables, utiliser deux méthodes d’exportation d’un jeu de données dans les fichiers XML (WriteXml et GetXml) et utiliser deux méthodes (ReadXml et InferXmlSchema) pour importer un jeu de données à partir des fichiers XML.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>Before you compile and run the sample, you need to create four XML files in the sample directory.</source>
          <target state="translated">Avant de compiler et exécuter l’exemple, vous devez créer quatre fichiers XML dans le répertoire d’exemple.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>First, create ElementsWithAttributes.xml:</source>
          <target state="translated">Commencez par créer ElementsWithAttributes.xml :</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>Next, create ElementsWithChildElementsxml.xml:</source>
          <target state="translated">Ensuite, créez ElementsWithChildElementsxml.xml :</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>Now create ElementsWithOnlyAttributes.xml:</source>
          <target state="translated">Créer ElementsWithOnlyAttributes.xml :</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>And finally, create RepeatingElements.xml:</source>
          <target state="translated">Et enfin, créez RepeatingElements.xml :</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source>Now you can compile and run the following source code.</source>
          <target state="translated">Vous pouvez maintenant compiler et exécuter le code source suivant.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXml">
          <source><bpt id="p1">[</bpt>How to Store Data of DataSet into XML File<ept id="p1">](http://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3)</ept> has Visual Basic and C# projects for this sample.</source>
          <target state="translated"><bpt id="p1">[</bpt>Comment le magasin de données du jeu de données dans un fichier .XML<ept id="p1">](http://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3)</ept> a des projets Visual Basic et c# de cet exemple.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetXmlSchema">
          <source>Returns the XML Schema for the XML representation of the data stored in the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Retourne le schéma XML de la représentation XML des données stockées dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.GetXmlSchema">
          <source>String that is the XML Schema for the XML representation of the data stored in the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Chaîne qui est le schéma XML de la représentation XML des données stockées dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXmlSchema">
          <source>Calling this method is identical to calling <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph>, except that only the primary schema is written.</source>
          <target state="translated">Appel de cette méthode est identique à l’appel <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph>, sauf que seul le schéma principal est écrit.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXmlSchema">
          <source><ph id="ph1">&lt;xref:System.Data.DataSet.GetXmlSchema%2A&gt;</ph> returns XML as a string, and therefore requires more overhead than <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> to write XML to a file.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataSet.GetXmlSchema%2A&gt;</ph> Retourne des données XML sous forme de chaîne et par conséquent requiert plus de charge que <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> à écrire du code XML dans un fichier.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXmlSchema">
          <source>If you build a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> using schema inference and serialize it using XML or Web services, the column ordering may change.</source>
          <target state="translated">Si vous générez un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> à l’aide de l’inférence de schéma et sérialiser à l’aide de services XML ou Web, l’ordre de tri peut changer.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.GetXmlSchema">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, and then displays the schema in XML format.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, puis affiche le schéma au format XML.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> has changes, including new, deleted, or modified rows.</source>
          <target state="translated">Obtient une valeur indiquant si <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> contient des modifications, notamment des lignes nouvelles, supprimées ou modifiées.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.HasChanges">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> has changes, including new, deleted, or modified rows.</source>
          <target state="translated">Obtient une valeur indiquant si <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> contient des modifications, notamment des lignes nouvelles, supprimées ou modifiées.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.HasChanges">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> has changes; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> contient des modifications ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.HasChanges">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method to create a second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object that is then used to update a data source.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode pour créer un second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objet qui est ensuite utilisé pour mettre à jour une source de données.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> has changes, including new, deleted, or modified rows, filtered by <ph id="ph2">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</source>
          <target state="translated">Obtient une valeur indiquant si <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> contient des modifications, notamment des lignes nouvelles, supprimées ou modifiées, filtrées par <ph id="ph2">&lt;see cref="T:System.Data.DataRowState" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> has changes; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> contient des modifications ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)">
          <source>Examine the <ph id="ph1">&lt;xref:System.Data.DataSet.HasChanges%2A&gt;</ph> property of the <ph id="ph2">`DataSet`</ph> before invoking the <ph id="ph3">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method.</source>
          <target state="translated">Examinez le <ph id="ph1">&lt;xref:System.Data.DataSet.HasChanges%2A&gt;</ph> propriété de la <ph id="ph2">`DataSet`</ph> avant d’appeler le <ph id="ph3">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method to create a second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object, which is then used to update a data source.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode pour créer un second <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objet, qui est ensuite utilisé pour mettre à jour une source de données.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.HasErrors">
          <source>Gets a value indicating whether there are errors in any of the <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> objects within this <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtient une valeur indiquant s'il existe des erreurs dans les objets <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> de ce <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.HasErrors">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if any table contains an error;otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si une table contient une erreur ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.HasErrors">
          <source>Each <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> in a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> also has a <ph id="ph3">&lt;xref:System.Data.DataTable.HasErrors%2A&gt;</ph> property.</source>
          <target state="translated">Chaque <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> dans un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> a également un <ph id="ph3">&lt;xref:System.Data.DataTable.HasErrors%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.HasErrors">
          <source>Use the <ph id="ph1">`HasErrors`</ph> property of the <ph id="ph2">`DataSet`</ph> first, to determine if any table has errors, before checking individual <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> objects.</source>
          <target state="translated">Utilisez le <ph id="ph1">`HasErrors`</ph> propriété de la <ph id="ph2">`DataSet`</ph> premier, afin de déterminer si une table contient des erreurs, avant de vérifier des <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.HasErrors">
          <source>If a <ph id="ph1">`DataTable`</ph> has errors, the <ph id="ph2">&lt;xref:System.Data.DataTable.GetErrors%2A&gt;</ph> method returns an array of <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects containing the errors.</source>
          <target state="translated">Si un <ph id="ph1">`DataTable`</ph> comporte des erreurs, la <ph id="ph2">&lt;xref:System.Data.DataTable.GetErrors%2A&gt;</ph> méthode retourne un tableau de <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objets contenant les erreurs.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.HasErrors">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.HasErrors%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object contains errors.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Data.DataSet.HasErrors%2A&gt;</ph> propriété pour déterminer si un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objet contient des erreurs.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.HasErrors">
          <source>If so, the errors for each <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> in each <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> are printed.</source>
          <target state="translated">Dans ce cas, les erreurs pour chaque <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> dans chaque <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> sont imprimés.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Applies XML schema to the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Applique le schéma XML du <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])">
          <source>The <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> from which to read the schema.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Stream" /&gt;</ph> à partir duquel lire le schéma.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])">
          <source>An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference.</source>
          <target state="translated">Tableau des chaînes d'URI (Uniform Resource Identifier) d'espace de noms à exclure de l'inférence de schéma.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])">
          <source>Applies the XML schema from the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> to the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Applique le schéma XML à partir du <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> spécifié à <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])">
          <source>The <ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> from which to read the schema.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> à partir duquel lire le schéma.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])">
          <source>An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference.</source>
          <target state="translated">Tableau des chaînes d'URI (Uniform Resource Identifier) d'espace de noms à exclure de l'inférence de schéma.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])">
          <source>Applies the XML schema from the specified <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> to the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Applique le schéma XML à partir du <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> spécifié à <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])">
          <source>The name of the file (including the path) from which to read the schema.</source>
          <target state="translated">Nom du fichier (chemin d'accès inclus) à partir duquel lire le schéma.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])">
          <source>An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference.</source>
          <target state="translated">Tableau des chaînes d'URI (Uniform Resource Identifier) d'espace de noms à exclure de l'inférence de schéma.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])">
          <source>Applies the XML schema from the specified file to the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Applique le schéma XML à partir du fichier spécifié du <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> n'a pas la valeur <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])">
          <source>For reading and writing files.</source>
          <target state="translated">Pour lire et écrire des fichiers.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph>.</source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])">
          <source>The <ph id="ph1">&lt;see langword="XMLReader" /&gt;</ph> from which to read the schema.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XMLReader" /&gt;</ph> à partir duquel lire le schéma.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])">
          <source>An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference.</source>
          <target state="translated">Tableau des chaînes d'URI (Uniform Resource Identifier) d'espace de noms à exclure de l'inférence de schéma.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])">
          <source>Applies the XML schema from the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> to the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Applique le schéma XML à partir du <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> spécifié à <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="E:System.Data.DataSet.Initialized">
          <source>Occurs after the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> is initialized.</source>
          <target state="translated">Se produit une fois que le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> est initialisé.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataSet.Initialized">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Data.DataSet.IsInitialized%2A&gt;</ph>.</source>
          <target state="translated">Pour plus d'informations, consultez <ph id="ph1">&lt;xref:System.Data.DataSet.IsInitialized%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.InitializeDerivedDataSet">
          <source>Deserialize all of the tables data of the DataSet from the binary or XML stream.</source>
          <target state="translated">Désérialisez toutes les données de tables du DataSet du flux binaire ou de données XML.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Inspects the format of the serialized representation of the <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph>.</source>
          <target state="translated">Inspecte le format de la représentation sérialisée de <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> represents a <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> serialized in its binary format, <ph id="ph4">&lt;see langword="false" /&gt;</ph> otherwise.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le <ph id="ph2">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> spécifié représente un <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> sérialisé dans son format binaire ; sinon, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</source>
          <target state="translated">Ce membre prend en charge l'infrastructure .NET Framework et n'est pas destiné à être utilisé directement à partir de votre code.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.IsInitialized">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> is initialized.</source>
          <target state="translated">Obtient une valeur qui indique si <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> est initialisé.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.IsInitialized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to indicate the component has completed initialization; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour indiquer que le composant a terminé l'initialisation ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.IsInitialized">
          <source>Returns the status of the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> while it’s being constructed, for instance by Visual Studio.</source>
          <target state="translated">Retourne l’état de la <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> pendant qu’il est en cours de construction, par exemple par Visual Studio.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.IsInitialized">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> method sets it to <ph id="ph2">`false`</ph> and <ph id="ph3">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> method sets it to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.BeginInit%2A&gt;</ph> méthode lui affecte la valeur <ph id="ph2">`false`</ph> et <ph id="ph3">&lt;xref:System.Data.DataSet.EndInit%2A&gt;</ph> méthode lui affecte la valeur <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Fills a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> with values from a data source using the supplied <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>.</source>
          <target state="translated">Remplit un <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> avec des valeurs issues d'une source de données à l'aide du <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> fourni.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method provides a technique for filling a single <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> with data, retrieved from an <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instance.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> méthode fournit une technique de remplissage d’un seul <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> avec les données extraites une <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>This method provides the same functionality, but allows you to load multiple result sets from an <ph id="ph1">`IDataReader`</ph> into multiple tables within a <ph id="ph2">`DataSet`</ph>.</source>
          <target state="translated">Cette méthode fournit les mêmes fonctionnalités, mais vous permet de charger plusieurs jeux de résultats d’une <ph id="ph1">`IDataReader`</ph> dans plusieurs tables d’un <ph id="ph2">`DataSet`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>If the <ph id="ph1">`DataSet`</ph> already contains rows, the incoming data from the data source is merged with the existing rows.</source>
          <target state="translated">Si <ph id="ph1">`DataSet`</ph> contient déjà des lignes, les données entrantes à partir de la source de données sont fusionnées avec les lignes existantes.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">`Load`</ph> method can be used in several common scenarios, all centered around getting data from a specified data source and adding it to the current data container (in this case, a <ph id="ph2">`DataSet`</ph>).</source>
          <target state="translated">Le <ph id="ph1">`Load`</ph> méthode peut être utilisée dans plusieurs scénarios courants, tous centrés sur l’obtention de données à partir d’une source de données spécifiée et en l’ajoutant au conteneur de données actuel (dans ce cas, un <ph id="ph2">`DataSet`</ph>).</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>These scenarios describe standard usage for a <ph id="ph1">`DataSet`</ph>, describing its update and merge behavior.</source>
          <target state="translated">Les scénarios suivants décrivent l’utilisation standard pour un <ph id="ph1">`DataSet`</ph>, décrivant sa mise à jour et le comportement de fusion.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>A <ph id="ph1">`DataSet`</ph> synchronizes or updates with a single primary data source.</source>
          <target state="translated">A <ph id="ph1">`DataSet`</ph> synchronise ou met à jour avec une source de données primaire.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">`DataSet`</ph> tracks changes, allowing synchronization with the primary data source.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> effectue le suivi des modifications, autorisant la synchronisation avec la source de données primaire.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In addition, a <ph id="ph1">`DataSet`</ph> can accept incremental data from one or more secondary data sources.</source>
          <target state="translated">En outre, un <ph id="ph1">`DataSet`</ph> peut accepter des données incrémentielles d’une ou plusieurs sources de données secondaires.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">`DataSet`</ph> isn't responsible for tracking changes in order to allow synchronization with the secondary data source.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> n’est pas responsable du suivi des modifications afin de permettre la synchronisation avec la source de données secondaire.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Given these two hypothetical data sources, a user is likely to require one of the following behaviors:</source>
          <target state="translated">Étant donné ces deux sources de données hypothétiques, un utilisateur est susceptible de demander un des comportements suivants :</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Initialize <ph id="ph1">`DataSet`</ph> from a primary data source.</source>
          <target state="translated">Initialiser <ph id="ph1">`DataSet`</ph> à partir d’une source de données principale.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In this scenario, the user wants to initialize an empty <ph id="ph1">`DataSet`</ph> with values from the primary data source.</source>
          <target state="translated">Dans ce scénario, l’utilisateur souhaite initialiser vide <ph id="ph1">`DataSet`</ph> avec les valeurs de la source de données primaire.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>One or more DataTable's contents are modified.</source>
          <target state="translated">Un ou plusieurs de contenu du DataTable est modifiés.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Later the user intends to propagate changes back to the primary data source.</source>
          <target state="translated">Plus tard, l’utilisateur envisage propager les modifications à la source de données primaire.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Preserve changes and re-synchronize from the primary data source.</source>
          <target state="translated">Conserver les modifications et resynchroniser à partir de la source de données primaire.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In this scenario, the user wants to take the <ph id="ph1">`DataSet`</ph> filled in the previous scenario and perform an incremental synchronization with the primary data source, preserving modifications made in the <ph id="ph2">`DataSet`</ph>.</source>
          <target state="translated">Dans ce scénario, l’utilisateur souhaite prendre le <ph id="ph1">`DataSet`</ph> remplie dans le scénario précédent et exécuter une synchronisation incrémentielle avec la source de données principale, en conservant les modifications apportées dans le <ph id="ph2">`DataSet`</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Incremental data feed from secondary data sources.</source>
          <target state="translated">Flux de données incrémentielles à partir de sources de données secondaires.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In this scenario, the user wants to merge changes from one or more secondary data sources, and propagate those changes back to the primary data source.</source>
          <target state="translated">Dans ce scénario, l’utilisateur souhaite fusionner les modifications à partir d’une ou plusieurs sources de données secondaires et propager ces modifications à la source de données primaire.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">`Load`</ph> method makes all these scenarios possible.</source>
          <target state="translated">Le <ph id="ph1">`Load`</ph> méthode rend tous ces scénarios possibles.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>This method allows you to specify a load option parameter, indicating how rows already in a <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> combine with rows being loaded.</source>
          <target state="translated">Cette méthode vous permet de spécifier un paramètre d’option de chargement, indiquant comment les lignes déjà présentes dans un <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> associées aux lignes en cours de chargement.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The following table describes the three load options provided by the <ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> enumeration.</source>
          <target state="translated">Le tableau suivant décrit les trois options de chargement fournies par le <ph id="ph1">&lt;xref:System.Data.LoadOption&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In each case, the description indicates the behavior when the primary key of a row in the incoming data matches the primary key of an existing row.</source>
          <target state="translated">Dans chaque cas, la description indique le comportement lorsque la clé primaire d’une ligne dans les données entrantes correspond à la clé primaire d’une ligne existante.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Load Option</source>
          <target state="translated">Option de chargement</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source><ph id="ph1">`PreserveChanges`</ph> (default)</source>
          <target state="translated"><ph id="ph1">`PreserveChanges`</ph> (par défaut)</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Updates the original version of the row with the value of the incoming row.</source>
          <target state="translated">Met à jour la version d’origine de la ligne avec la valeur de la ligne entrante.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Updates the current and original versions of the row with the value of the incoming row.</source>
          <target state="translated">Met à jour les versions actuelles et d’origine de la ligne avec la valeur de la ligne entrante.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>Updates the current version of the row with the value of the incoming row.</source>
          <target state="translated">Met à jour la version actuelle de la ligne avec la valeur de la ligne entrante.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>In general, the <ph id="ph1">`PreserveChanges`</ph> and <ph id="ph2">`OverwriteChanges`</ph> options are intended for scenarios in which the user needs to synchronize the <ph id="ph3">`DataSet`</ph> and its changes with the primary data source.</source>
          <target state="translated">En général, les <ph id="ph1">`PreserveChanges`</ph> et <ph id="ph2">`OverwriteChanges`</ph> options sont destinées aux scénarios dans lesquels l’utilisateur doit synchroniser le <ph id="ph3">`DataSet`</ph> et ses modifications avec la source de données primaire.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Data.DataSet">
          <source>The <ph id="ph1">`Upsert`</ph> option facilitates aggregating changes from one or more secondary data sources.</source>
          <target state="translated">Le <ph id="ph1">`Upsert`</ph> option facilite l’agrégation des modifications à partir d’une ou plusieurs sources de données secondaires.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> that provides one or more result sets.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> qui fournit un ou plusieurs jeux de résultats.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>A value from the <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> enumeration that indicates how rows already in the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances within the <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> will be combined with incoming rows that share the same primary key.</source>
          <target state="translated">Valeur issue de l'énumération <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> qui indique comment les lignes déjà présentes dans les instances de <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> du <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> seront associées aux lignes entrantes qui partagent la même clé primaire.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances, from which the <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /&gt;</ph> method retrieves name and namespace information.</source>
          <target state="translated">Tableau d'instances de <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> à partir desquelles la méthode <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /&gt;</ph> récupère les informations de nom et d'espace de noms.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>Each of these tables must be a member of the <ph id="ph1">&lt;see cref="T:System.Data.DataTableCollection" /&gt;</ph> contained by this <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Chacune de ces tables doit être membre du <ph id="ph1">&lt;see cref="T:System.Data.DataTableCollection" /&gt;</ph> contenu par ce <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>Fills a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> with values from a data source using the supplied <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>, using an array of <ph id="ph3">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances to supply the schema and namespace information.</source>
          <target state="translated">Remplit un <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> avec des valeurs issues d'une source de données, à l'aide du <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> fourni, en utilisant un tableau d'instances de <ph id="ph3">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> pour fournir les informations de schéma et d'espace de noms.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method provides a technique for filling a single <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> with data, retrieved from an <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instance.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> méthode fournit une technique de remplissage d’un seul <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> avec les données extraites une <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>This method provides the same functionality, but allows you to load multiple result sets from an <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph> into multiple tables within a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Cette méthode fournit les mêmes fonctionnalités, mais vous permet de charger plusieurs jeux de résultats d’une <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph> dans plusieurs tables d’un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The load operation will fail with an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> if any of the source data columns in the incoming <ph id="ph2">`reader`</ph> are computed columns.</source>
          <target state="translated">L’opération de chargement échoue avec un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> si les colonnes de données source en entrant <ph id="ph2">`reader`</ph> sont des colonnes calculées.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The <ph id="ph1">`loadOption`</ph> parameter allows you to specify how you want the imported data to interact with existing data, and can be any of the values from the <ph id="ph2">&lt;xref:System.Data.LoadOption&gt;</ph> enumeration.</source>
          <target state="translated">Le <ph id="ph1">`loadOption`</ph> paramètre vous permet de spécifier comment les données importées pour interagir avec des données existantes et peut prendre l’une des valeurs de la <ph id="ph2">&lt;xref:System.Data.LoadOption&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>See the documentation for the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph><ph id="ph2">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method for more information on using this parameter.</source>
          <target state="translated">Consultez la documentation relative à la <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> <ph id="ph2">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> méthode pour plus d’informations sur l’utilisation de ce paramètre.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The <ph id="ph1">`tables`</ph> parameter allows you to specify an array of <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instances, indicating the order of the tables corresponding to each result set loaded from the reader.</source>
          <target state="translated">Le <ph id="ph1">`tables`</ph> paramètre vous permet de spécifier un tableau de <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instances, indiquant l’ordre des tables correspondant à chaque jeux de résultats chargés à partir du lecteur.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> method fills each supplied <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instance with data from a single result set from the source data reader.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> méthode remplit chaque fourni <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instance avec les données en un seul jeu de résultats à partir du lecteur de données source.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>After each result set, the <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> method moves on to the next result set within the reader, until there are no more result sets.</source>
          <target state="translated">Après chaque jeu de résultats, le <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> méthode déplace le résultat suivant défini dans le lecteur, jusqu'à ce qu’il n’y a plus de jeux de résultats.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The name resolution scheme for this method is the same as that followed by the <ph id="ph1">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter&gt;</ph> class.</source>
          <target state="translated">Le schéma de résolution de noms de cette méthode est le même que celui suivi par le <ph id="ph1">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, adds two <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instances to the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>, and then fills the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> using the <ph id="ph5">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> method, retrieving data from a <ph id="ph6">&lt;xref:System.Data.DataTableReader&gt;</ph> that contains two result sets.</source>
          <target state="translated">L’exemple suivant crée un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, ajoute deux <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instances à la <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>, puis remplit la <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> à l’aide de la <ph id="ph5">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> méthode, la récupération des données à partir d’un <ph id="ph6">&lt;xref:System.Data.DataTableReader&gt;</ph> qui contient deux jeux de résultats.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])">
          <source>Finally, the example displays the contents of the tables in the console window.</source>
          <target state="translated">Enfin, l’exemple affiche le contenu des tables dans la fenêtre de console.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> that provides one or more result sets.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> qui fournit un ou plusieurs jeux de résultats.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>A value from the <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> enumeration that indicates how rows already in the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances within the <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> will be combined with incoming rows that share the same primary key.</source>
          <target state="translated">Valeur issue de l'énumération <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> qui indique comment les lignes déjà présentes dans les instances de <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> du <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> seront associées aux lignes entrantes qui partagent la même clé primaire.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>An array of strings, from which the <ph id="ph1">&lt;see langword="Load" /&gt;</ph> method retrieves table name information.</source>
          <target state="translated">Tableau de chaînes à partir duquel la méthode <ph id="ph1">&lt;see langword="Load" /&gt;</ph> récupère les informations de nom de table.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>Fills a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> with values from a data source using the supplied <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>, using an array of strings to supply the names for the tables within the <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph>.</source>
          <target state="translated">Remplit un <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> avec des valeurs issues d'une source de données, à l'aide du <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> fourni, en utilisant un tableau de chaînes pour fournir les noms des tables dans le <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method provides a technique for filling a single <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> with data, retrieved from an <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instance.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> méthode fournit une technique de remplissage d’un seul <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> avec les données extraites une <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>This method provides the same functionality, but allows you to load multiple result sets from an <ph id="ph1">`IDataReader`</ph> into multiple tables within a <ph id="ph2">`DataSet`</ph>.</source>
          <target state="translated">Cette méthode fournit les mêmes fonctionnalités, mais vous permet de charger plusieurs jeux de résultats d’une <ph id="ph1">`IDataReader`</ph> dans plusieurs tables d’un <ph id="ph2">`DataSet`</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The load operation will fail with an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> if any of the source data columns in the incoming <ph id="ph2">`reader`</ph> are computed columns.</source>
          <target state="translated">L’opération de chargement échoue avec un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> si les colonnes de données source en entrant <ph id="ph2">`reader`</ph> sont des colonnes calculées.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The <ph id="ph1">`loadOption`</ph> parameter allows you to specify how you want the imported data to interact with existing data, and can be any of the values from the <ph id="ph2">&lt;xref:System.Data.LoadOption&gt;</ph> enumeration.</source>
          <target state="translated">Le <ph id="ph1">`loadOption`</ph> paramètre vous permet de spécifier comment les données importées pour interagir avec des données existantes et peut prendre l’une des valeurs de la <ph id="ph2">&lt;xref:System.Data.LoadOption&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>See the documentation for the <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method for more information on using this parameter.</source>
          <target state="translated">Consultez la documentation relative à la <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> méthode pour plus d’informations sur l’utilisation de ce paramètre.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The <ph id="ph1">`tables`</ph> parameter allows you to specify an array of table names, indicating the order of the tables corresponding to each result set loaded from the reader.</source>
          <target state="translated">Le <ph id="ph1">`tables`</ph> paramètre vous permet de spécifier un tableau des noms de table, qui indique l’ordre des tables correspondant à chaque jeux de résultats chargés à partir du lecteur.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The <ph id="ph1">`Load`</ph> method attempts to find a table within the <ph id="ph2">`DataSet`</ph> matching the name found in the array of table names, in order.</source>
          <target state="translated">Le <ph id="ph1">`Load`</ph> méthode tente de trouver une table dans le <ph id="ph2">`DataSet`</ph> correspondant au nom trouvé dans le tableau des noms de table, dans l’ordre.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>If a matching table is found, that table is loaded with the content of the current result set.</source>
          <target state="translated">Si une table de correspondance est trouvée, cette table est chargée avec le contenu du jeu de résultats actuel.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>If no matching table is found, a table is created using the name supplied in the array of table names, and the new table's schema is inferred from the result set.</source>
          <target state="translated">Si aucune table correspondante n’est trouvée, une table est créée en utilisant le nom fourni dans le tableau des noms de table et schéma de la nouvelle table est déduit du jeu de résultats.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>After each result set, the <ph id="ph1">`Load`</ph> method moves on to the next result set within the reader, until there are no more result sets.</source>
          <target state="translated">Après chaque jeu de résultats, le <ph id="ph1">`Load`</ph> méthode déplace le résultat suivant défini dans le lecteur, jusqu'à ce qu’il n’y a plus de jeux de résultats.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The default namespace associated with <ph id="ph1">`DataSet`</ph>, if any, is associated with each newly created <ph id="ph2">`DataTable`</ph>.</source>
          <target state="translated">L’espace de noms par défaut associé à <ph id="ph1">`DataSet`</ph>, le cas échéant, est associé à chaque nouvellement créé <ph id="ph2">`DataTable`</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The name resolution scheme for this method is the same as that followed by the <ph id="ph1">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter&gt;</ph> class.</source>
          <target state="translated">Le schéma de résolution de noms de cette méthode est le même que celui suivi par le <ph id="ph1">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The following Console application example first creates tables and loads data from a reader into a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, using the <ph id="ph2">`Load`</ph> method.</source>
          <target state="translated">Tout d’abord, l’exemple d’application Console suivant crée les tables et charge les données à partir d’un lecteur dans un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, à l’aide du <ph id="ph2">`Load`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>The example then adds tables to a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and attempts to fill the tables with data from a <ph id="ph2">&lt;xref:System.Data.DataTableReader&gt;</ph>.</source>
          <target state="translated">L’exemple ajoute ensuite les tables à une <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> et tente de se remplir les tables avec les données d’un <ph id="ph2">&lt;xref:System.Data.DataTableReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>In this example, because the parameters passed to the <ph id="ph1">`Load`</ph> method indicate a table name that does not exist, the <ph id="ph2">`Load`</ph> method creates a new table to match the name passed as a parameter.</source>
          <target state="translated">Dans cet exemple, étant donné que les paramètres transmis à la <ph id="ph1">`Load`</ph> méthode indiquer un nom de table qui n’existe pas, le <ph id="ph2">`Load`</ph> méthode crée une nouvelle table pour correspondre au nom passé comme paramètre.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])">
          <source>Once the data has been loaded, the example displays the contents of all its tables in the Console window.</source>
          <target state="translated">Une fois que les données ont été chargées, l’exemple affiche le contenu de toutes ses tables dans la fenêtre de Console.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> that provides one or more result sets.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> qui fournit un ou plusieurs jeux de résultats.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>A value from the <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> enumeration that indicates how rows already in the <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances within the <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> will be combined with incoming rows that share the same primary key.</source>
          <target state="translated">Valeur issue de l'énumération <ph id="ph1">&lt;see cref="T:System.Data.LoadOption" /&gt;</ph> qui indique comment les lignes déjà présentes dans les instances de <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> du <ph id="ph3">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> seront associées aux lignes entrantes qui partagent la même clé primaire.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.FillErrorEventHandler" /&gt;</ph> delegate to call when an error occurs while loading data.</source>
          <target state="translated">Un délégué <ph id="ph1">&lt;see cref="T:System.Data.FillErrorEventHandler" /&gt;</ph> à appeler lorsqu'une erreur se produit en chargeant des données.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances, from which the <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /&gt;</ph> method retrieves name and namespace information.</source>
          <target state="translated">Tableau d'instances de <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> à partir desquelles la méthode <ph id="ph2">&lt;see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /&gt;</ph> récupère les informations de nom et d'espace de noms.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>Fills a <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> with values from a data source using the supplied <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph>, using an array of <ph id="ph3">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> instances to supply the schema and namespace information.</source>
          <target state="translated">Remplit un <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> avec des valeurs issues d'une source de données, à l'aide du <ph id="ph2">&lt;see cref="T:System.Data.IDataReader" /&gt;</ph> fourni, en utilisant un tableau d'instances de <ph id="ph3">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> pour fournir les informations de schéma et d'espace de noms.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method provides a technique for filling a single <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> with data, retrieved from an <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instance.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> méthode fournit une technique de remplissage d’un seul <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> avec les données extraites une <ph id="ph3">&lt;xref:System.Data.IDataReader&gt;</ph> instance.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>This method provides the same functionality, but allows you to load multiple result sets from an <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph> into multiple tables within a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Cette méthode fournit les mêmes fonctionnalités, mais vous permet de charger plusieurs jeux de résultats d’une <ph id="ph1">&lt;xref:System.Data.IDataReader&gt;</ph> dans plusieurs tables d’un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The load operation will fail with an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> if any of the source data columns in the incoming <ph id="ph2">`reader`</ph> are computed columns.</source>
          <target state="translated">L’opération de chargement échoue avec un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> si les colonnes de données source en entrant <ph id="ph2">`reader`</ph> sont des colonnes calculées.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">`loadOption`</ph> parameter allows you to specify how you want the imported data to interact with existing data, and can be any of the values from the <ph id="ph2">&lt;xref:System.Data.LoadOption&gt;</ph> enumeration.</source>
          <target state="translated">Le <ph id="ph1">`loadOption`</ph> paramètre vous permet de spécifier comment les données importées pour interagir avec des données existantes et peut prendre l’une des valeurs de la <ph id="ph2">&lt;xref:System.Data.LoadOption&gt;</ph> énumération.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>See the documentation for the <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph><ph id="ph2">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> method for more information on using this parameter.</source>
          <target state="translated">Consultez la documentation relative à la <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> <ph id="ph2">&lt;xref:System.Data.DataTable.Load%2A&gt;</ph> méthode pour plus d’informations sur l’utilisation de ce paramètre.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">`errorHandler`</ph> parameter is a <ph id="ph2">&lt;xref:System.Data.FillErrorEventHandler&gt;</ph> delegate that refers to a procedure that is called when an error occurs while loading data.</source>
          <target state="translated">Le <ph id="ph1">`errorHandler`</ph> paramètre est un <ph id="ph2">&lt;xref:System.Data.FillErrorEventHandler&gt;</ph> délégué qui fait référence à une procédure qui est appelée lorsqu’une erreur se produit lors du chargement des données.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.FillErrorEventArgs&gt;</ph> parameter passed to the procedure provides properties that allow you to retrieve information about the error that occurred, the current row of data, and the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> being filled.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.FillErrorEventArgs&gt;</ph> passés à la procédure fournit les propriétés qui vous permettent de récupérer des informations sur l’erreur qui s’est produite, la ligne actuelle de données, et le <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> remplie.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>Using this delegate mechanism, rather than a simpler try/catch block, allows you to determine the error, handle the situation, and continue processing if you like.</source>
          <target state="translated">À l’aide de ce mécanisme de délégué, au lieu d’un bloc try/catch plus simple, vous permet de déterminer l’erreur, gérer la situation et continuer le traitement si vous le souhaitez.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.FillErrorEventArgs&gt;</ph> parameter supplies a <ph id="ph2">&lt;xref:System.Data.FillErrorEventArgs.Continue%2A&gt;</ph> property: set this property to <ph id="ph3">`true`</ph> to indicate that you have handled the error and wish to continue processing; set the property to <ph id="ph4">`false`</ph> to indicate that you wish to halt processing.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.FillErrorEventArgs&gt;</ph> paramètre fournit une <ph id="ph2">&lt;xref:System.Data.FillErrorEventArgs.Continue%2A&gt;</ph> propriété : définissez cette propriété sur <ph id="ph3">`true`</ph> pour indiquer que vous avez géré l’erreur et souhaitez continuer le traitement ; affectez à la propriété <ph id="ph4">`false`</ph> pour indiquer que vous souhaitez arrêter le traitement.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>Be aware that setting the property to <ph id="ph1">`false`</ph> causes the code that triggered the problem to throw an exception.</source>
          <target state="translated">N’oubliez pas que la définition de la propriété <ph id="ph1">`false`</ph> provoque le code qui a déclenché le problème pour lever une exception.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">`tables`</ph> parameter allows you to specify an array of <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instances, indicating the order of the tables corresponding to each result set loaded from the reader.</source>
          <target state="translated">Le <ph id="ph1">`tables`</ph> paramètre vous permet de spécifier un tableau de <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instances, indiquant l’ordre des tables correspondant à chaque jeux de résultats chargés à partir du lecteur.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> method fills each supplied <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instance with data from a single result set from the source data reader.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> méthode remplit chaque fourni <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> instance avec les données en un seul jeu de résultats à partir du lecteur de données source.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>After each result set, the <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> method moves on to the next result set within the reader, until there are no more result sets.</source>
          <target state="translated">Après chaque jeu de résultats, le <ph id="ph1">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> méthode déplace le résultat suivant défini dans le lecteur, jusqu'à ce qu’il n’y a plus de jeux de résultats.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The name resolution scheme for this method is the same as that followed by the <ph id="ph1">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter&gt;</ph> class.</source>
          <target state="translated">Le schéma de résolution de noms de cette méthode est le même que celui suivi par le <ph id="ph1">&lt;xref:System.Data.Common.DbDataAdapter.Fill%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.Data.Common.DbDataAdapter&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The following example adds a table to a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, and then attempts to use the <ph id="ph2">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> method to load data from a <ph id="ph3">&lt;xref:System.Data.DataTableReader&gt;</ph> that contains an incompatible schema.</source>
          <target state="translated">L’exemple suivant ajoute une table à un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>et tente d’utiliser le <ph id="ph2">&lt;xref:System.Data.DataSet.Load%2A&gt;</ph> méthode pour charger les données d’une <ph id="ph3">&lt;xref:System.Data.DataTableReader&gt;</ph> qui contient un schéma incompatible.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>Rather than trapping the error, this example uses a <ph id="ph1">&lt;xref:System.Data.FillErrorEventHandler&gt;</ph> delegate to investigate and handle the error.</source>
          <target state="translated">Au lieu d’intercepter l’erreur, cet exemple utilise un <ph id="ph1">&lt;xref:System.Data.FillErrorEventHandler&gt;</ph> délégué pour examiner et gérer l’erreur.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])">
          <source>The output is displayed in the console window.</source>
          <target state="translated">La sortie s’affiche dans la fenêtre de console.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Locale">
          <source>Gets or sets the locale information used to compare strings within the table.</source>
          <target state="translated">Obtient ou définit les paramètres régionaux utilisés pour comparer des chaînes dans la table.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>A <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> that contains data about the user's machine locale.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> qui contient les données relatives aux paramètres régionaux de l'ordinateur de l'utilisateur.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>The default is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La valeur par défaut est <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> property specifies the locale for which sorting applies.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> propriété spécifie les paramètres régionaux auxquels le tri s’applique.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>By default, setting the <ph id="ph1">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> also sets the <ph id="ph3">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> for each <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph> object in that <ph id="ph5">`DataSet`</ph> to the same value.</source>
          <target state="translated">Par défaut, la définition du <ph id="ph1">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> pour un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> définit également la <ph id="ph3">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph> pour chaque <ph id="ph4">&lt;xref:System.Data.DataTable&gt;</ph> objet de <ph id="ph5">`DataSet`</ph> sur la même valeur.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>In columns that contain expressions, the <ph id="ph1">&lt;xref:System.StringComparison.InvariantCulture&gt;</ph> is used.</source>
          <target state="translated">Dans les colonnes qui contiennent des expressions, le <ph id="ph1">&lt;xref:System.StringComparison.InvariantCulture&gt;</ph> est utilisé.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>The <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture&gt;</ph> is ignored.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture&gt;</ph> est ignoré.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Locale">
          <source>The following example gets the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> and prints the <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.DisplayName%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Globalization.CultureInfo.EnglishName%2A&gt;</ph> properties.</source>
          <target state="translated">L’exemple suivant obtient la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> pour un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> et imprime la <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.DisplayName%2A&gt;</ph> et <ph id="ph4">&lt;xref:System.Globalization.CultureInfo.EnglishName%2A&gt;</ph> propriétés.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Merges a specified <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>, or array of <ph id="ph3">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects into the current <ph id="ph4">&lt;see langword="DataSet" /&gt;</ph> or <ph id="ph5">&lt;see langword="DataTable" /&gt;</ph>.</source>
          <target state="translated">Fusionne un <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, un <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> ou un tableau d'objets <ph id="ph3">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> dans le <ph id="ph4">&lt;see langword="DataSet" /&gt;</ph> ou le <ph id="ph5">&lt;see langword="DataTable" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>The array of <ph id="ph1">&lt;see langword="DataRow" /&gt;</ph> objects to be merged into the <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see langword="DataRow" /&gt;</ph> à fusionner dans le <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>Merges an array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects into the current <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Fusionne un tableau d'objets <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> dans le <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est utilisée pour fusionner deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets qui ont des schémas très similaires.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Cela permet à l’application cliente pour avoir une actualisation <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec les données les plus récentes à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">Dans ce scénario, le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode est appelée en premier.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Cette méthode retourne un deuxième <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimisé pour la validation et la fusion.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Cette seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objet ne contient que les <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> et <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>This subset is generally smaller and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Ce sous-ensemble est généralement plus petite et donc être passé plus efficacement à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">La couche intermédiaire renvoie alors un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> peuvent être fusionnées dans d’origine de l’application cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est appelée, les schémas des deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets sont comparées, car il est possible que les schémas peuvent avoir été changées.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si la source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les éléments de schéma (ajouté <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le <ph id="ph3">`missingSchemaAction`</ph> argument <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">Dans ce cas, les données fusionné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les données et le schéma ajouté.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Après la fusion des schémas, les données sont fusionnées.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Lors de la fusion d’une nouvelle source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> dans la cible, toutes les lignes sources avec un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valeur <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, ou <ph id="ph5">`Deleted`</ph> sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>Source rows with a <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Source des lignes avec un <ph id="ph1">&lt;xref:System.Data.DataRowState&gt;</ph> valeur <ph id="ph2">`Added`</ph> sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Pendant une fusion, les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>If any constraints cannot be enabled at the end of a merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si toutes les contraintes ne peuvent pas être activés à la fin d’une fusion, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> est définie sur <ph id="ph2">`false`</ph>, et toutes les lignes qui ne sont pas valides sont marquées comme erreur.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[])">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Les erreurs doivent être résolues avant de tenter de rétablir le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propriété <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph> whose data and schema will be merged.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="DataSet" /&gt;</ph> dont les données et le schéma doivent être fusionnés.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>Merges a specified <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> and its schema into the current <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>.</source>
          <target state="translated">Fusionne un <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> spécifié et son schéma dans le <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est utilisée pour fusionner deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets qui ont des schémas très similaires.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Cela permet à l’application cliente pour avoir une actualisation <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec les données les plus récentes à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">Dans ce scénario, le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode est appelée en premier.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Cette méthode retourne un deuxième <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimisé pour la validation et la fusion.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Cette seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objet ne contient que les <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> et <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Ce sous-ensemble est généralement plus petit, et donc plus efficacement passé à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">La couche intermédiaire renvoie alors un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> peuvent être fusionnées dans d’origine de l’application cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est appelée, les schémas des deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets sont comparées, car il est possible que les schémas peuvent avoir été changées.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si la source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les éléments de schéma (ajouté <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le <ph id="ph3">`missingSchemaAction`</ph> argument <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">Dans ce cas, les données fusionné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les données et le schéma ajouté.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Après la fusion des schémas, les données sont fusionnées.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Lors de la fusion d’une nouvelle source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> dans la cible, toutes les lignes sources avec un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valeur <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, ou <ph id="ph5">`Deleted`</ph> sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Source des lignes avec un <ph id="ph1">`DataRowState`</ph> valeur <ph id="ph2">`Added`</ph> sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Pendant une fusion, les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>If any constraints cannot be enabled at the end of merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> est définie sur <ph id="ph2">`false`</ph>, et toutes les lignes qui ne sont pas valides sont marquées comme erreur.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Les erreurs doivent être résolues avant de tenter de rétablir le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propriété <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph>, Update, and <ph id="ph2">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> methods on a <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph>, mise à jour, et <ph id="ph2">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthodes sur un <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>One or more constraints cannot be enabled.</source>
          <target state="translated">Une ou plusieurs contraintes ne peuvent pas être activées.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet)">
          <source>The <ph id="ph1">&lt;paramref name="dataSet" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dataSet" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> whose data and schema will be merged.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> dont les données et le schéma doivent être fusionnés.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>Merges a specified <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> and its schema into the current <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Fusionne un <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> spécifié et son schéma dans le <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en cours.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est utilisée pour fusionner deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets qui ont des schémas très similaires.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Cela permet à l’application cliente pour avoir une actualisation <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec les données les plus récentes à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">Dans ce scénario, le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode est appelée en premier.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Cette méthode retourne un deuxième <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimisé pour la validation et la fusion.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Cette seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objet ne contient que les <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> et <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Ce sous-ensemble est généralement plus petit, et donc plus efficacement passé à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">La couche intermédiaire renvoie alors un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> peuvent être fusionnées dans d’origine de l’application cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est appelée, les schémas des deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets sont comparées, car il est possible que les schémas peuvent avoir été changées.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si la source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les éléments de schéma (ajouté <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le <ph id="ph3">`missingSchemaAction`</ph> argument <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">Dans ce cas, les données fusionné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les données et le schéma ajouté.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Après la fusion des schémas, les données sont fusionnées.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Lors de la fusion d’une nouvelle source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> dans la cible, toutes les lignes sources avec un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valeur <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, ou <ph id="ph5">`Deleted`</ph> sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Source des lignes avec un <ph id="ph1">`DataRowState`</ph> valeur <ph id="ph2">`Added`</ph> sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Pendant une fusion, les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>If any constraints cannot be enabled at the end of merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> est définie sur <ph id="ph2">`false`</ph>, et toutes les lignes qui ne sont pas valides sont marquées comme erreur.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Les erreurs doivent être résolues avant de tenter de rétablir le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propriété <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The following example creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one table, two columns, and ten rows.</source>
          <target state="translated">L’exemple suivant crée un simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec une table, deux colonnes et dix lignes.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> is created that is identical to the first.</source>
          <target state="translated">Une seconde <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> est créé qui est identique à la première.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>Two rows are added to the second table, which is then merged into the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Deux lignes sont ajoutées à la deuxième table, qui est ensuite fusionnée dans le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable)">
          <source>The <ph id="ph1">&lt;paramref name="table" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="table" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph> whose data and schema will be merged.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="DataSet" /&gt;</ph> dont les données et le schéma doivent être fusionnés.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to preserve changes in the current <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour préserver les modifications apportées au <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> en cours ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>Merges a specified <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> and its schema into the current <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>, preserving or discarding any changes in this <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> according to the given argument.</source>
          <target state="translated">Fusionne un <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> spécifié et son schéma dans le <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> en cours, en préservant ou en supprimant les modifications effectuées dans ce <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> conformément à l'argument donné.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est utilisée pour fusionner deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets qui ont des schémas très similaires.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Cela permet à l’application cliente pour avoir une actualisation <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec les données les plus récentes à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">Dans ce scénario, le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode est appelée en premier.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Cette méthode retourne un deuxième <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimisé pour la validation et la fusion.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Cette seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objet ne contient que les <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> et <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Ce sous-ensemble est généralement plus petit, et donc plus efficacement passé à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">La couche intermédiaire renvoie alors un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> peuvent être fusionnées dans d’origine de l’application cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est appelée, les schémas des deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets sont comparées, car il est possible que les schémas peuvent avoir été changées.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si la source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les éléments de schéma (ajouté <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le <ph id="ph3">`missingSchemaAction`</ph> argument <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">Dans ce cas, les données fusionné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les données et le schéma ajouté.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Après la fusion des schémas, les données sont fusionnées.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Lors de la fusion d’une nouvelle source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> dans la cible, toutes les lignes sources avec un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valeur <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, ou <ph id="ph5">`Deleted`</ph> sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Source des lignes avec un <ph id="ph1">`DataRowState`</ph> valeur <ph id="ph2">`Added`</ph> sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Pendant une fusion, les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>If any constraints cannot be enabled at the end of merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> est définie sur <ph id="ph2">`false`</ph>, et toutes les lignes qui ne sont pas valides sont marquées comme erreur.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Les erreurs doivent être résolues avant de tenter de rétablir le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propriété <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>The following example creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one table, two columns, and ten rows.</source>
          <target state="translated">L’exemple suivant crée un simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec une table, deux colonnes et dix lignes.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>After adding ten rows, two values are changed, and one row is added.</source>
          <target state="translated">Après avoir ajouté les dix lignes, deux valeurs sont modifiées, et une ligne est ajoutée.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>A subset of the changed data is created using the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method.</source>
          <target state="translated">Un sous-ensemble des données modifiées est créé à l’aide de la <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)">
          <source>After reconciling errors, the subset data is merged into the original <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Après résolution des erreurs, les données de sous-ensemble sont fusionnées dans la version d’origine <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects to be merged into the <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>.</source>
          <target state="translated">Tableau d'objets <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> à fusionner dans le <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to preserve changes in the <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour préserver les modifications apportées au <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>Merges an array of <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> objects into the current <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>, preserving or discarding changes in the <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> and handling an incompatible schema according to the given arguments.</source>
          <target state="translated">Fusionne un tableau d'objets <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> dans le <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en cours, en préservant ou en supprimant les modifications apportées au <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> et en traitant tout schéma incompatible conformément aux arguments donnés.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est utilisée pour fusionner deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets qui ont des schémas très similaires.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Cela permet à l’application cliente pour avoir une actualisation <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec les données les plus récentes à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">Dans ce scénario, le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode est appelée en premier.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Cette méthode retourne un deuxième <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimisé pour la validation et la fusion.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Cette seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objet ne contient que les <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> et <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Ce sous-ensemble est généralement plus petit, et donc plus efficacement passé à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">La couche intermédiaire renvoie alors un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> peuvent être fusionnées dans d’origine de l’application cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>To facilitate explanation of the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method, we use "target" to signify the current <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, and "source" to name the second (parameter) <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Pour faciliter l’explication de la <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> (méthode), nous utilisons le « cible » pour indiquer que l’actuel <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>et « source » pour le deuxième (paramètre) <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The target <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is so named because it is the object upon which an action (the merge) occurs.</source>
          <target state="translated">La cible <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est ainsi nommé car il s’agit de l’objet sur lequel une action (la fusion) se produit.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is called a "source" because the information it contains does not change, but instead is merged into the current <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">La seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est appelée une « source », car les informations qu’il contient ne changent pas, mais au lieu de cela sont fusionnées dans la zone actuelle <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est appelée, les schémas des deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets sont comparées, car il est possible que les schémas peuvent avoir été changées.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si la source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les éléments de schéma (ajouté <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le <ph id="ph3">`missingSchemaAction`</ph> argument <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">Dans ce cas, les données fusionné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les données et le schéma ajouté.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Après la fusion des schémas, les données sont fusionnées.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Lors de la fusion d’une nouvelle source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> dans la cible, toutes les lignes sources avec un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valeur <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, ou <ph id="ph5">`Deleted`</ph> sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Source des lignes avec un <ph id="ph1">`DataRowState`</ph> valeur <ph id="ph2">`Added`</ph> sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Pendant une fusion, les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>If any constraints cannot be enabled at the end of merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> est définie sur <ph id="ph2">`false`</ph>, et toutes les lignes qui ne sont pas valides sont marquées comme erreur.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Les erreurs doivent être résolues avant de tenter de rétablir le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propriété <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;see langword="DataSet" /&gt;</ph> whose data and schema will be merged.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="DataSet" /&gt;</ph> dont les données et le schéma doivent être fusionnés.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to preserve changes in the current <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour préserver les modifications apportées au <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> en cours ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Merges a specified <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> and its schema with the current <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>, preserving or discarding changes in the current <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> and handling an incompatible schema according to the given arguments.</source>
          <target state="translated">Fusionne un <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> spécifié et son schéma avec le <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> en cours, en préservant ou en supprimant les modifications apportées au <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> en cours, et en traitant un schéma incompatible conformément aux arguments donnés.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est utilisée pour fusionner deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets qui ont des schémas très similaires.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Cela permet à l’application cliente pour avoir une actualisation <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec les données les plus récentes à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">Dans ce scénario, le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode est appelée en premier.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Cette méthode retourne un deuxième <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimisé pour la validation et la fusion.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Cette seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objet ne contient que les <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> et <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Ce sous-ensemble est généralement plus petit, et donc plus efficacement passé à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">La couche intermédiaire renvoie alors un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> peuvent être fusionnées dans d’origine de l’application cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>To facilitate explanation of the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method, we use "target" to signify the current <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>, and "source" to name the second (parameter) <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Pour faciliter l’explication de la <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> (méthode), nous utilisons le « cible » pour indiquer que l’actuel <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>et « source » pour le deuxième (paramètre) <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The target <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is so named because it is the object upon which an action (the merge) occurs.</source>
          <target state="translated">La cible <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est ainsi nommé car il s’agit de l’objet sur lequel une action (la fusion) se produit.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is called a "source" because the information it contains does not change, but instead is merged into the current <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">La seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est appelée une « source », car les informations qu’il contient ne changent pas, mais au lieu de cela sont fusionnées dans la zone actuelle <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est appelée, les schémas des deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets sont comparées, car il est possible que les schémas peuvent avoir été changées.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si la source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les éléments de schéma (ajouté <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le <ph id="ph3">`missingSchemaAction`</ph> argument <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">Dans ce cas, les données fusionné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les données et le schéma ajouté.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Après la fusion des schémas, les données sont fusionnées.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Lors de la fusion d’une nouvelle source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> dans la cible, toutes les lignes sources avec un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valeur <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, ou <ph id="ph5">`Deleted`</ph> sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Source des lignes avec un <ph id="ph1">`DataRowState`</ph> valeur <ph id="ph2">`Added`</ph> sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Pendant une fusion, les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>If any constraints cannot be enabled at the end of merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> est définie sur <ph id="ph2">`false`</ph>, et toutes les lignes qui ne sont pas valides sont marquées comme erreur.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Les erreurs doivent être résolues avant de tenter de rétablir le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propriété <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The following example creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one table, two columns, and ten rows.</source>
          <target state="translated">L’exemple suivant crée un simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec une table, deux colonnes et dix lignes.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Two values are changed, and one row is added.</source>
          <target state="translated">Deux valeurs sont modifiées et qu’une ligne est ajoutée.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>A subset of the changed data is created using the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method.</source>
          <target state="translated">Un sous-ensemble des données modifiées est créé à l’aide de la <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>After reconciling errors, a new column is added to the subset, changing the schema.</source>
          <target state="translated">Après résolution des erreurs, une nouvelle colonne est ajoutée au sous-ensemble, modification du schéma.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called with the <ph id="ph2">`missingSchemaAction`</ph> set to <ph id="ph3">`MissingSchemaAction.Add`</ph>, the new column is added to the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> object's schema.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est appelée avec le <ph id="ph2">`missingSchemaAction`</ph> la valeur <ph id="ph3">`MissingSchemaAction.Add`</ph>, la nouvelle colonne est ajoutée à l’original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> schéma de l’objet.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;paramref name="dataSet" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dataSet" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;see langword="DataTable" /&gt;</ph> whose data and schema will be merged.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="DataTable" /&gt;</ph> dont les données et le schéma doivent être fusionnés.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.MissingSchemaAction" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to preserve changes in the <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>; otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour préserver les modifications apportées au <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Merges a specified <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> and its schema into the current <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph>, preserving or discarding changes in the <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> and handling an incompatible schema according to the given arguments.</source>
          <target state="translated">Fusionne un <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> spécifié et son schéma dans le <ph id="ph2">&lt;see langword="DataSet" /&gt;</ph> en cours, en préservant ou en supprimant les modifications apportées au <ph id="ph3">&lt;see langword="DataSet" /&gt;</ph> et en traitant un schéma incompatible conformément aux arguments donnés.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is used to merge two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects that have largely similar schemas.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est utilisée pour fusionner deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets qui ont des schémas très similaires.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>A merge is typically used on a client application to incorporate the latest changes from a data source into an existing <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Une fusion est généralement utilisée dans une application cliente pour incorporer les modifications les plus récentes à partir d’une source de données dans une <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This allows the client application to have a refreshed <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the latest data from the data source.</source>
          <target state="translated">Cela permet à l’application cliente pour avoir une actualisation <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec les données les plus récentes à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is typically called at the end of a series of procedures that involve validating changes, reconciling errors, updating the data source with the changes, and finally refreshing the existing <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, l’harmonisation des erreurs, mise à jour de la source de données avec les modifications et enfin l’actualisation existants <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>iOn a client application, it is common to have a single button that the user can click that gathers the changed data and validates it before sending it back to a middle-tier component.</source>
          <target state="translated">une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de l’envoyer à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this scenario, the <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> method is first invoked.</source>
          <target state="translated">Dans ce scénario, le <ph id="ph1">&lt;xref:System.Data.DataSet.GetChanges%2A&gt;</ph> méthode est appelée en premier.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>That method returns a second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimized for validating and merging.</source>
          <target state="translated">Cette méthode retourne un deuxième <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> optimisé pour la validation et la fusion.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object contains only the <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> and <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> objects that were changed, resulting in a subset of the original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Cette seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> objet ne contient que les <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph> et <ph id="ph3">&lt;xref:System.Data.DataRow&gt;</ph> les objets qui ont été modifiés, générant ainsi un sous-ensemble de l’original <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>This subset is generally smaller, and thus more efficiently passed back to a middle-tier component.</source>
          <target state="translated">Ce sous-ensemble est généralement plus petit, et donc plus efficacement passé à un composant de niveau intermédiaire.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle-tier component then updates the original data source with the changes through stored procedures.</source>
          <target state="translated">Le composant de couche intermédiaire met ensuite à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The middle tier can then send back either a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> that includes original data and the latest data from the data source (by running the original query again), or it can send back the subset with any changes that have been made to it from the data source.</source>
          <target state="translated">La couche intermédiaire renvoie alors un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau à la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications ont été apportées à partir de la source de données.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>(For example, if the data source automatically creates unique primary key values, these values can be propagated back to the client application.) In either case, the returned <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> can be merged back into the client application's original <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method.</source>
          <target state="translated">(Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées vers l’application cliente.) Dans les deux cas, retourné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> peuvent être fusionnées dans d’origine de l’application cliente <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec la <ph id="ph3">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> method is called, the schemas of the two <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objects are compared because it is possible that the schemas may have been changed.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Data.DataSet.Merge%2A&gt;</ph> méthode est appelée, les schémas des deux <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objets sont comparées, car il est possible que les schémas peuvent avoir été changées.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>For example, in a business-to-business scenario, new columns may have been added to an XML schema by an automated process.</source>
          <target state="translated">Par exemple, dans un scénario d’entreprise-entreprise, nouvelles colonnes a peut-être été ajoutés à un schéma XML par un processus automatisé.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>If the source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains schema elements (added <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objects) that are missing in the target, the schema elements can be added to the target by setting the <ph id="ph3">`missingSchemaAction`</ph> argument to <ph id="ph4">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Si la source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les éléments de schéma (ajouté <ph id="ph2">&lt;xref:System.Data.DataColumn&gt;</ph> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le <ph id="ph3">`missingSchemaAction`</ph> argument <ph id="ph4">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In that case, the merged <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains the added schema and data.</source>
          <target state="translated">Dans ce cas, les données fusionné <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient les données et le schéma ajouté.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>After merging schemas, the data is merged.</source>
          <target state="translated">Après la fusion des schémas, les données sont fusionnées.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>When merging a new source <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> into the target, any source rows with a <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> value of <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, or <ph id="ph5">`Deleted`</ph> are matched to target rows with the same primary key values.</source>
          <target state="translated">Lors de la fusion d’une nouvelle source de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> dans la cible, toutes les lignes sources avec un <ph id="ph2">&lt;xref:System.Data.DataRowState&gt;</ph> valeur <ph id="ph3">`Unchanged`</ph>, <ph id="ph4">`Modified`</ph>, ou <ph id="ph5">`Deleted`</ph> sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaire.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Source rows with a <ph id="ph1">`DataRowState`</ph> value of <ph id="ph2">`Added`</ph> are matched to new target rows with the same primary key values as the new source rows.</source>
          <target state="translated">Source des lignes avec un <ph id="ph1">`DataRowState`</ph> valeur <ph id="ph2">`Added`</ph> sont mis en correspondance avec les nouvelles lignes cibles avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes sources.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>During a merge, constraints are disabled.</source>
          <target state="translated">Pendant une fusion, les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>If any constraints cannot be enabled at the end of merge, a <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> is generated and the merged data is retained while the constraints are disabled.</source>
          <target state="translated">Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <ph id="ph1">&lt;xref:System.Data.ConstraintException&gt;</ph> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>, and all rows that are invalid are marked in error.</source>
          <target state="translated">Dans ce cas, le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> est définie sur <ph id="ph2">`false`</ph>, et toutes les lignes qui ne sont pas valides sont marquées comme erreur.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The errors must be resolved before attempting to reset the <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Les erreurs doivent être résolues avant de tenter de rétablir le <ph id="ph1">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph> propriété <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The following example creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one table, two columns, and ten rows.</source>
          <target state="translated">L’exemple suivant crée un simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec une table, deux colonnes et dix lignes.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> is created that is nearly identical to the first except that a new <ph id="ph2">`DataColumn`</ph> is added to the table.</source>
          <target state="translated">Une seconde <ph id="ph1">&lt;xref:System.Data.DataTable&gt;</ph> est créé qui est quasiment identique à la première, sauf qu’un nouveau <ph id="ph2">`DataColumn`</ph> est ajouté à la table.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>Two rows are added to the second table, which is then merged into the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph2">`preserveChanges`</ph> argument set to <ph id="ph3">`false`</ph>, and the <ph id="ph4">`missingSchemaAction`</ph> argument set to <ph id="ph5">`MissingSchemaAction.Add`</ph>.</source>
          <target state="translated">Deux lignes sont ajoutées à la deuxième table, qui est ensuite fusionnée dans le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec la <ph id="ph2">`preserveChanges`</ph> affectée à l’argument <ph id="ph3">`false`</ph>et le <ph id="ph4">`missingSchemaAction`</ph> affectée à l’argument <ph id="ph5">`MissingSchemaAction.Add`</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)">
          <source>The <ph id="ph1">&lt;paramref name="dataSet" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dataSet" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="E:System.Data.DataSet.MergeFailed">
          <source>Occurs when a target and source <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> have the same primary key value, and <ph id="ph2">&lt;see cref="P:System.Data.DataSet.EnforceConstraints" /&gt;</ph> is set to true.</source>
          <target state="translated">Se produit lorsque des <ph id="ph1">&lt;see cref="T:System.Data.DataRow" /&gt;</ph> cible et source possèdent la même valeur de clé primaire et que <ph id="ph2">&lt;see cref="P:System.Data.DataSet.EnforceConstraints" /&gt;</ph> a la valeur true.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataSet.MergeFailed">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>NIB: Consuming Events<ept id="p1">](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)</ept>.</source>
          <target state="translated">Pour plus d’informations sur la gestion des événements, consultez <bpt id="p1">[</bpt>NIB : consommation d’événements<ept id="p1">](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)</ept>.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Data.DataSet.MergeFailed">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Data.DataSet.MergeFailed&gt;</ph> event.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation de la <ph id="ph1">&lt;xref:System.Data.DataSet.MergeFailed&gt;</ph> événement.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Namespace">
          <source>Gets or sets the namespace of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtient ou définit l'espace de noms de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Namespace">
          <source>The namespace of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">L’espace de noms du <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Namespace">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Namespace%2A&gt;</ph> property is used when reading and writing an XML document into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> using the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Namespace%2A&gt;</ph> propriété est utilisée lors de la lecture et l’écriture d’un document XML de document dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à l’aide de la <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>, ou <ph id="ph6">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Namespace">
          <source>The namespace of an XML document is used to scope XML attributes and elements when read into a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">L’espace de noms d’un document XML est utilisé pour définir l’étendue des attributs XML et les éléments lors de la lecture dans un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Namespace">
          <source>For example, if a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains a schema that was read from a document with the namespace "myCompany," and an attempt is made to read data only from a document with a different namespace, any data that does not correspond to the existing schema is ignored.</source>
          <target state="translated">Par exemple, si un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient un schéma qui a été lu à partir d’un document avec l’espace de noms « myCompany » et une tentative est effectuée pour lire des données uniquement à partir d’un document avec un espace de noms différent, les données qui ne correspondant pas au schéma existant sont ignorées.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Namespace">
          <source>The following example sets the <ph id="ph1">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant définit la <ph id="ph1">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph> avant d’appeler le <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Namespace">
          <source>The namespace already has data.</source>
          <target state="translated">L'espace de noms contient déjà des données.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>A <ph id="ph1">&lt;see cref="T:System.ComponentModel.PropertyChangedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.ComponentModel.PropertyChangedEventArgs" /&gt;</ph> qui contient les données d'événement.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> event.</source>
          <target state="translated">Déclenche l'événement <ph id="ph1">&lt;see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>Raising an event invokes the event handler through a delegate.</source>
          <target state="translated">Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>For an overview, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Pour une vue d’ensemble, consultez <bpt id="p1">[</bpt>gestion et déclenchement d’événements<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> in a derived class, be sure to call the base class' <ph id="ph2">&lt;see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> method.</source>
          <target state="translated">Lors de la substitution <ph id="ph1">&lt;see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> dans une classe dérivée, veillez à appeler la classe de base <ph id="ph2">&lt;see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> being removed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> en cours de suppression.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)">
          <source>Occurs when a <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> object is removed from a <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</source>
          <target state="translated">Se produit lorsqu'un objet <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> est supprimé de <ph id="ph2">&lt;see cref="T:System.Data.DataTable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)">
          <source>This method should be overridden by subclasses to restrict tables being removed</source>
          <target state="translated">Cette méthode doit être substituée par des sous-classes pour restreindre les tables en cours de suppression</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> being removed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> en cours de suppression.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)">
          <source>Occurs when a <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> is removed from a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Se produit lorsqu'un <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> est supprimé de <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)">
          <source>This method can be overridden by subclasses to restrict tables from being removed.</source>
          <target state="translated">Cette méthode peut être substituée par des sous-classes pour empêcher les tables d’être supprimé.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)">
          <source>The following example shows a class derived from the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with the <ph id="ph2">&lt;xref:System.Data.DataSet.OnRemoveTable%2A&gt;</ph> method overridden.</source>
          <target state="translated">L’exemple suivant montre une classe dérivée de la <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec la <ph id="ph2">&lt;xref:System.Data.DataSet.OnRemoveTable%2A&gt;</ph> méthode substituée.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Prefix">
          <source>Gets or sets an XML prefix that aliases the namespace of the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtient ou définit un préfixe XML qui associe un alias à l'espace de noms de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Prefix">
          <source>The XML prefix for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> namespace.</source>
          <target state="translated">Préfixe XML de l'espace de noms de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Prefix">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph> property is used throughout an XML document to identify elements which belong to the namespace of the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> object (as set by the <ph id="ph3">&lt;xref:System.Data.DataSet.Namespace%2A&gt;</ph> property).</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph> propriété est utilisée dans un document XML pour identifier les éléments qui appartiennent à l’espace de noms de la <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> objet (comme défini par le <ph id="ph3">&lt;xref:System.Data.DataSet.Namespace%2A&gt;</ph> propriété).</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Prefix">
          <source>The following example sets the <ph id="ph1">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method.</source>
          <target state="translated">L’exemple suivant définit la <ph id="ph1">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph> avant d’appeler le <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.RaisePropertyChanging(System.String)">
          <source>The name of the property that is about to change.</source>
          <target state="translated">Nom de la propriété sur le point d'être modifiée.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.RaisePropertyChanging(System.String)">
          <source>Sends a notification that the specified <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> property is about to change.</source>
          <target state="translated">Envoie une notification indiquant que la propriété <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> spécifiée est sur le point d'être modifiée.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Lit le schéma et les données XML dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>An object that derives from <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated">Objet qui dérive de <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated">Lit le schéma et les données XML dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide du <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> utilisé pour lire les données.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à partir d’un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode lit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Pour lire les données et le schéma, utilisez une de la <ph id="ph1">`ReadXML`</ph> surcharges qui incluent le <ph id="ph2">`mode`</ph> paramètre et définissez sa valeur sur <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Pour écrire des données XML, ou le schéma et les données à partir de la <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`WriteXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Pour écrire uniquement le schéma, utilisez la <ph id="ph1">`WriteXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> n’associe pas un élément XML avec ses correspondant <ph id="ph2">`DataColumn`</ph> ou <ph id="ph3">`DataTable`</ph> lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si le schéma XML pour un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> inclut <ph id="ph2">`targetNamespace`</ph>, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> pour charger le <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> XML qui contient des éléments sans espace de noms qualifiant.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema, as the following example demonstrates.</source>
          <target state="translated">Pour lire des éléments non qualifiés, définissez <ph id="ph1">`elementFormDefault`</ph> égale à « qualified » dans votre schéma XML, comme illustré dans l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si le schéma pour votre <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> en spécifiant <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>The following example first creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, two columns, and ten rows.</source>
          <target state="translated">L’exemple suivant crée d’abord un simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, deux colonnes et dix lignes.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schema and data are written to disk by invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schéma et les données sont écrites sur le disque en appelant le <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is created and the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method is used to fill it with schema and data.</source>
          <target state="translated">Une seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est créé et le <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> méthode est utilisée pour le remplir avec le schéma et les données.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> from which to read the schema and data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> à partir duquel lire le schéma et les données.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</source>
          <target state="translated">Lit le schéma et les données XML dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide du <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> utilisé pour lire les données.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à partir d’un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode lit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Pour lire les données et le schéma, utilisez une de la <ph id="ph1">`ReadXML`</ph> surcharges qui incluent le <ph id="ph2">`mode`</ph> paramètre et définissez sa valeur sur <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Pour écrire des données XML, ou le schéma et les données à partir de la <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`WriteXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Pour écrire uniquement le schéma, utilisez la <ph id="ph1">`WriteXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> n’associe pas un élément XML avec ses correspondant <ph id="ph2">`DataColumn`</ph> ou <ph id="ph3">`DataTable`</ph> lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si le schéma XML pour un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> inclut <ph id="ph2">`targetNamespace`</ph>, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> pour charger le <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> XML qui contient des éléments sans espace de noms qualifiant.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Pour lire des éléments non qualifiés, définissez <ph id="ph1">`elementFormDefault`</ph> égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>Classes that inherit from the <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class include the <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> and <ph id="ph3">&lt;xref:System.IO.StringReader&gt;</ph> classes.</source>
          <target state="translated">Les classes qui héritent de la <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> classe incluent le <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> et <ph id="ph3">&lt;xref:System.IO.StringReader&gt;</ph> classes.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si le schéma pour votre <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> en spécifiant <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The following example first creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, two columns, and ten rows.</source>
          <target state="translated">L’exemple suivant crée d’abord un simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, deux colonnes et dix lignes.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schema and data are written to disk by invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schéma et les données sont écrites sur le disque en appelant le <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is created and the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method is used to fill it with schema and data.</source>
          <target state="translated">Une seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est créé et le <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> méthode est utilisée pour le remplir avec le schéma et les données.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The filename (including the path) from which to read.</source>
          <target state="translated">Nom du fichier (chemin d'accès inclus) à partir duquel effectuer la lecture.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified file.</source>
          <target state="translated">Lit le schéma et les données XML dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide du fichier spécifié.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The <ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> utilisé pour lire les données.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à partir d’un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode lit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Pour lire les données et le schéma, utilisez une de la <ph id="ph1">`ReadXML`</ph> surcharges qui incluent le <ph id="ph2">`mode`</ph> paramètre et définissez sa valeur sur <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Pour écrire des données XML, ou le schéma et les données à partir de la <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`WriteXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Pour écrire uniquement le schéma, utilisez la <ph id="ph1">`WriteXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> n’associe pas un élément XML avec ses correspondant <ph id="ph2">`DataColumn`</ph> ou <ph id="ph3">`DataTable`</ph> lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes a <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si le schéma XML pour un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> inclut un <ph id="ph2">`targetNamespace`</ph>, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> pour charger le <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> XML qui contient des éléments sans espace de noms qualifiant.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Pour lire des éléments non qualifiés, définissez <ph id="ph1">`elementFormDefault`</ph> égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si le schéma pour votre <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> en spécifiant <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The following example first creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, two columns, and ten rows.</source>
          <target state="translated">L’exemple suivant crée d’abord un simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, deux colonnes et dix lignes.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schema and data are written to disk by invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schéma et les données sont écrites sur le disque en appelant le <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is created and the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method is used to fill it with schema and data.</source>
          <target state="translated">Une seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est créé et le <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> méthode est utilisée pour le remplir avec le schéma et les données.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> n'a pas la valeur <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>for reading and writing files.</source>
          <target state="translated">Pour lire et écrire des fichiers.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> from which to read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> dans lequel effectuer la lecture.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated">Lit le schéma et les données XML dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide du <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> utilisé pour lire les données.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à partir d’un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode lit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Pour lire les données et le schéma, utilisez une de la <ph id="ph1">`ReadXML`</ph> surcharges qui incluent le <ph id="ph2">`mode`</ph> paramètre et définissez sa valeur sur <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Pour écrire des données XML, ou le schéma et les données à partir de la <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`WriteXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Pour écrire uniquement le schéma, utilisez la <ph id="ph1">`WriteXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> n’associe pas un élément XML avec ses correspondant <ph id="ph2">`DataColumn`</ph> ou <ph id="ph3">`DataTable`</ph> lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes a <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si le schéma XML pour un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> inclut un <ph id="ph2">`targetNamespace`</ph>, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> pour charger le <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> XML qui contient des éléments sans espace de noms qualifiant.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Pour lire des éléments non qualifiés, définissez <ph id="ph1">`elementFormDefault`</ph> égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;xref:System.Xml.XmlTextReader?displayProperty=nameWithType&gt;</ph> inherits from <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.XmlTextReader?displayProperty=nameWithType&gt;</ph> hérite de <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si le schéma pour votre <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> en spécifiant <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The following example first creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, two columns, and ten rows.</source>
          <target state="translated">L’exemple suivant crée d’abord un simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, deux colonnes et dix lignes.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schema and data are written to disk by invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schéma et les données sont écrites sur le disque en appelant le <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is created and the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method is used to fill it with schema and data.</source>
          <target state="translated">Une seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est créé et le <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> méthode est utilisée pour le remplir avec le schéma et les données.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> from which to read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> dans lequel effectuer la lecture.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</source>
          <target state="translated">Lit le schéma et les données XML dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide des <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> et <ph id="ph3">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> spécifiés.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> utilisé pour lire les données.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à partir d’un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode lit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Pour lire les données et le schéma, utilisez une de la <ph id="ph1">`ReadXML`</ph> surcharges qui incluent le <ph id="ph2">`mode`</ph> paramètre et définissez sa valeur sur <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>The same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Est de même pour le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Pour écrire des données XML, ou le schéma et les données à partir de la <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`WriteXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Pour écrire uniquement le schéma, utilisez la <ph id="ph1">`WriteXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>When you use <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and you set <ph id="ph2">&lt;xref:System.Data.XmlReadMode&gt;</ph> to <ph id="ph3">`Diffgram`</ph>, the content of the target <ph id="ph4">`DataSet`</ph> and the original <ph id="ph5">`DataSet`</ph> may differ because of how the diffgram is generated and processed.</source>
          <target state="translated">Lorsque vous utilisez <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> et que vous définissez <ph id="ph2">&lt;xref:System.Data.XmlReadMode&gt;</ph> à <ph id="ph3">`Diffgram`</ph>, le contenu de la cible de <ph id="ph4">`DataSet`</ph> et d’origine <ph id="ph5">`DataSet`</ph> peuvent varier en raison de la façon dont le diffgram est généré et traité.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>For more information on diffgrams, see <bpt id="p1">[</bpt>DiffGrams<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur les diffgrams, consultez <bpt id="p1">[</bpt>DiffGrams<ept id="p1">](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md)</ept>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> n’associe pas un élément XML avec ses correspondant <ph id="ph2">`DataColumn`</ph> ou <ph id="ph3">`DataTable`</ph> lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si le schéma XML pour un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> inclut <ph id="ph2">`targetNamespace`</ph>, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> pour charger le <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> XML qui contient des éléments sans espace de noms qualifiant.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Pour lire des éléments non qualifiés, définissez <ph id="ph1">`elementFormDefault`</ph> égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si le schéma pour votre <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> en spécifiant <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> from which to read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> dans lequel effectuer la lecture.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</source>
          <target state="translated">Lit le schéma et les données XML dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide des <ph id="ph2">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> et <ph id="ph3">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> spécifiés.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> utilisé pour lire les données.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à partir d’un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode lit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Pour lire les données et le schéma, utilisez une de la <ph id="ph1">`ReadXML`</ph> surcharges qui incluent le <ph id="ph2">`mode`</ph> paramètre et définissez sa valeur sur <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Pour écrire des données XML, ou le schéma et les données à partir de la <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`WriteXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Pour écrire uniquement le schéma, utilisez la <ph id="ph1">`WriteXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> n’associe pas un élément XML avec ses correspondant <ph id="ph2">`DataColumn`</ph> ou <ph id="ph3">`DataTable`</ph> lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si le schéma XML pour un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> inclut <ph id="ph2">`targetNamespace`</ph>, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> pour charger le <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> XML qui contient des éléments sans espace de noms qualifiant.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Pour lire des éléments non qualifiés, définissez <ph id="ph1">`elementFormDefault`</ph> égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si le schéma pour votre <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> en spécifiant <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>The filename (including the path) from which to read.</source>
          <target state="translated">Nom du fichier (chemin d'accès inclus) à partir duquel effectuer la lecture.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified file and <ph id="ph2">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</source>
          <target state="translated">Lit le schéma et les données XML dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide du fichier et du <ph id="ph2">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> spécifiés.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> utilisé pour lire les données.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à partir d’un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode lit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Pour lire les données et le schéma, utilisez une de la <ph id="ph1">`ReadXML`</ph> surcharges qui incluent le <ph id="ph2">`mode`</ph> paramètre et définissez sa valeur sur <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Pour écrire des données XML, ou le schéma et les données à partir de la <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`WriteXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Pour écrire uniquement le schéma, utilisez la <ph id="ph1">`WriteXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> n’associe pas un élément XML avec ses correspondant <ph id="ph2">`DataColumn`</ph> ou <ph id="ph3">`DataTable`</ph> lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes a <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si le schéma XML pour un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> inclut un <ph id="ph2">`targetNamespace`</ph>, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> pour charger le <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> XML qui contient des éléments sans espace de noms qualifiant.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Pour lire des éléments non qualifiés, définissez <ph id="ph1">`elementFormDefault`</ph> égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si le schéma pour votre <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> en spécifiant <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> n'a pas la valeur <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>for reading and writing files.</source>
          <target state="translated">Pour lire et écrire des fichiers.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> from which to read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> dans lequel effectuer la lecture.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>Reads XML schema and data into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph>.</source>
          <target state="translated">Lit le schéma et les données XML dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide des <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> et <ph id="ph3">&lt;see cref="T:System.Data.XmlReadMode" /&gt;</ph> spécifiés.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> used to read the data.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="XmlReadMode" /&gt;</ph> utilisé pour lire les données.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method provides a way to read either data only, or both data and schema into a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> from an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method reads only the schema.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> (méthode) fournit un moyen de lire soit les données uniquement, ou schéma et les données dans un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à partir d’un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode lit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>To read both data and schema, use one of the <ph id="ph1">`ReadXML`</ph> overloads that includes the <ph id="ph2">`mode`</ph> parameter, and set its value to <ph id="ph3">`ReadSchema`</ph>.</source>
          <target state="translated">Pour lire les données et le schéma, utilisez une de la <ph id="ph1">`ReadXML`</ph> surcharges qui incluent le <ph id="ph2">`mode`</ph> paramètre et définissez sa valeur sur <ph id="ph3">`ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>To write XML data, or both schema and data from the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`WriteXml`</ph> method.</source>
          <target state="translated">Pour écrire des données XML, ou le schéma et les données à partir de la <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`WriteXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>To write just the schema, use the <ph id="ph1">`WriteXmlSchema`</ph> method.</source>
          <target state="translated">Pour écrire uniquement le schéma, utilisez la <ph id="ph1">`WriteXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>If an in-line schema is specified, the in-line schema is used to extend the existing relational structure prior to loading the data.</source>
          <target state="translated">Si un schéma en ligne est spécifié, le schéma en ligne est utilisé pour étendre la structure relationnelle existante avant le chargement des données.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>If there are any conflicts (for example, the same column in the same table defined with different data types) an exception is raised.</source>
          <target state="translated">S’il existe des conflits (par exemple, la même colonne dans la même table est définie avec différents types de données), une exception est levée.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>If no in-line schema is specified, the relational structure is extended through inference, as necessary, according to the structure of the XML document.</source>
          <target state="translated">Si aucun schéma en ligne n’est spécifié, la structure relationnelle est étendue par inférence, si nécessaire, en fonction de la structure du document XML.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>If the schema cannot be extended through inference in order to expose all data, an exception is raised.</source>
          <target state="translated">Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> does not associate an XML element with its corresponding <ph id="ph2">`DataColumn`</ph> or <ph id="ph3">`DataTable`</ph> when legal XML characters like ("_") are escaped in the serialized XML.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> n’associe pas un élément XML avec ses correspondant <ph id="ph2">`DataColumn`</ph> ou <ph id="ph3">`DataTable`</ph> lorsque les caractères XML reconnus comme (« _ ») sont ignorés dans le XML sérialisé.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>The <ph id="ph1">`DataSet`</ph> itself only escapes illegal XML characters in XML element names and hence can only consume the same.</source>
          <target state="translated">Le <ph id="ph1">`DataSet`</ph> lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>When legal characters in XML element name are escaped, the element is ignored while processing.</source>
          <target state="translated">Lors de l’échappement des caractères autorisés dans le nom d’élément XML, l’élément est ignoré lors du traitement.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>If the XML Schema for a <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> includes a <ph id="ph2">`targetNamespace`</ph>, data may not be read, and you may encounter exceptions when calling <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> to load the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> with XML that contains elements with no qualifying namespace.</source>
          <target state="translated">Si le schéma XML pour un <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> inclut un <ph id="ph2">`targetNamespace`</ph>, les données ne peuvent pas être lues et exceptions peuvent se produire lors de l’appel <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> pour charger le <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph> XML qui contient des éléments sans espace de noms qualifiant.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>To read unqualified elements, set <ph id="ph1">`elementFormDefault`</ph> equal to "qualified" in your XML Schema as the following example demonstrates.</source>
          <target state="translated">Pour lire des éléments non qualifiés, définissez <ph id="ph1">`elementFormDefault`</ph> égale à « qualified » dans votre schéma XML comme illustré dans l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> by specifying <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</source>
          <target state="translated">Si le schéma pour votre <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> en spécifiant <ph id="ph4">`XmlReadMode.ReadSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Reads an XML schema into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Lit un schéma XML dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> from which to read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> dans lequel effectuer la lecture.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>Reads the XML schema from the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> into the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Lit le schéma XML à partir du <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> spécifié dans le <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode pour créer le schéma pour un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">Le schéma inclut des définitions de table, des relations et des contraintes.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Pour écrire un schéma dans un document XML, utilisez la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">Le schéma XML est écrite à l’aide de la norme XSD.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>No exception will be thrown.</source>
          <target state="translated">Aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode est généralement appelée avant la <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> méthode qui est utilisée pour remplir le <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>Classes that derive from the <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> class include <ph id="ph2">&lt;xref:System.IO.BufferedStream&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream&gt;</ph>, and <ph id="ph5">&lt;xref:System.Net.Sockets.NetworkStream&gt;</ph>.</source>
          <target state="translated">Classes dérivées de la <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> classe inclure <ph id="ph2">&lt;xref:System.IO.BufferedStream&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream&gt;</ph>, et <ph id="ph5">&lt;xref:System.Net.Sockets.NetworkStream&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is be thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</source>
          <target state="translated">Si le schéma pour votre <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object to read an XML schema with, and invokes the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method with the object.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> pour lire un schéma XML de l’objet et appelle la <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode avec l’objet.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> from which to read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> dans lequel effectuer la lecture.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>Reads the XML schema from the specified <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> into the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Lit le schéma XML à partir du <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> spécifié dans le <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode pour créer le schéma pour un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">Le schéma inclut des définitions de table, des relations et des contraintes.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Pour écrire un schéma dans un document XML, utilisez la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">Le schéma XML est écrite à l’aide de la norme XSD.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>No exception will be thrown.</source>
          <target state="translated">Aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode est généralement appelée avant la <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> méthode qui est utilisée pour remplir le <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>Classes that inherit from the <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class include the <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> and <ph id="ph3">&lt;xref:System.IO.StringReader&gt;</ph> classes.</source>
          <target state="translated">Les classes qui héritent de la <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> classe incluent le <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> et <ph id="ph3">&lt;xref:System.IO.StringReader&gt;</ph> classes.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is be thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</source>
          <target state="translated">Si le schéma pour votre <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> object to read a schema with, and invokes the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method with the object.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> objet permettant de lire un schéma et appelle la <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode avec l’objet.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>The file name (including the path) from which to read.</source>
          <target state="translated">Nom du fichier (chemin d'accès inclus) dans lequel effectuer la lecture.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>Reads the XML schema from the specified file into the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Lit le schéma XML à partir du fichier spécifié dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode pour créer le schéma pour un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">Le schéma inclut des définitions de table, des relations et des contraintes.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Pour écrire un schéma dans un document XML, utilisez la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">Le schéma XML est écrite à l’aide de la norme XSD.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>No exception will be thrown.</source>
          <target state="translated">Aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode est généralement appelée avant la <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> méthode qui est utilisée pour remplir le <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</source>
          <target state="translated">Si le schéma pour votre <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> n'a pas la valeur <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>for reading and writing files.</source>
          <target state="translated">Pour lire et écrire des fichiers.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> from which to read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> dans lequel effectuer la lecture.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>Reads the XML schema from the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> into the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Lit le schéma XML à partir du <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> spécifié dans le <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method to create the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode pour créer le schéma pour un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">Le schéma inclut des définitions de table, des relations et des contraintes.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">Le schéma XML est écrite à l’aide de la norme XSD.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>Data corruption can occur if the msdata:DataType and the xs:type types do not match.</source>
          <target state="translated">Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>No exception will be thrown.</source>
          <target state="translated">Aucune exception n’est levée.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method is generally invoked before invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method which is used to fill the <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthode est généralement appelée avant la <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> méthode qui est utilisée pour remplir le <ph id="ph3">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.XmlReader?displayProperty=nameWithType&gt;</ph> class is abstract.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Xml.XmlReader?displayProperty=nameWithType&gt;</ph> classe est abstraite.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>A class that inherits from the <ph id="ph1">`XmlReader`</ph> is the <ph id="ph2">&lt;xref:System.Xml.XmlTextReader?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">Une classe qui hérite de la <ph id="ph1">`XmlReader`</ph> est la <ph id="ph2">&lt;xref:System.Xml.XmlTextReader?displayProperty=nameWithType&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>If the schema for your <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contains elements of the same name, but different type, in the same namespace, an exception is be thrown when you attempt to read the schema into the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> with <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</source>
          <target state="translated">Si le schéma pour votre <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> contient des éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> avec <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>This exception does not occur if you are using .NET Framework version 1.0.</source>
          <target state="translated">Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> object.</source>
          <target state="translated">L’exemple suivant crée un nouveau <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> et <ph id="ph2">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object, created with a file path and file name, is used to create an <ph id="ph2">&lt;xref:System.Xml.XmlTextReader?displayProperty=nameWithType&gt;</ph> that is passed as an argument to the <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objet, créé avec un chemin d’accès et le nom de fichier, est utilisé pour créer un <ph id="ph2">&lt;xref:System.Xml.XmlTextReader?displayProperty=nameWithType&gt;</ph> qui est passé comme argument à la <ph id="ph3">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)">
          <source>The specified XML reader.</source>
          <target state="translated">Lecteur XML spécifié.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)">
          <source>Ignores attributes and returns an empty DataSet.</source>
          <target state="translated">Ignore les attributs et retourne un DataSet vide.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.RejectChanges">
          <source>Rolls back all the changes made to the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> since it was created, or since the last time <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph> was called.</source>
          <target state="translated">Restaure toutes les modifications apportées à <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> depuis sa création ou le dernier appel à <ph id="ph2">&lt;see cref="M:System.Data.DataSet.AcceptChanges" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>Invoke the <ph id="ph1">&lt;xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> to call the <ph id="ph2">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> method on all <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> objects contained by the <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Appeler le <ph id="ph1">&lt;xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> pour appeler le <ph id="ph2">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> méthode sur tous les <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> les objets contenus dans le <ph id="ph4">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source><ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> objects contained by the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> can each be set into edit mode by invoking the <ph id="ph3">&lt;xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> les objets contenus dans le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> peuvent tous être définis en mode édition en appelant le <ph id="ph3">&lt;xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>After invoking the <ph id="ph1">&lt;xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType&gt;</ph> method, changes can be rejected by calling the <ph id="ph2">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> on the <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> to which the <ph id="ph4">&lt;xref:System.Data.DataRow&gt;</ph> objects belong.</source>
          <target state="translated">Après l’appel la <ph id="ph1">&lt;xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType&gt;</ph> méthode, modifications peuvent être refusées en appelant le <ph id="ph2">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> sur la <ph id="ph3">&lt;xref:System.Data.DataTable&gt;</ph> auquel le <ph id="ph4">&lt;xref:System.Data.DataRow&gt;</ph> objets appartiennent.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>When the <ph id="ph1">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> method is called, any rows still in edit-mode cancel their edits.</source>
          <target state="translated">Lorsque le <ph id="ph1">&lt;xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType&gt;</ph> est appelée, les lignes en mode édition annulent leurs modifications.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>New rows are removed.</source>
          <target state="translated">Nouvelles lignes sont supprimées.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>Modified and deleted rows return back to their original state (<ph id="ph1">`DataRowState.Unchanged`</ph>).</source>
          <target state="translated">Retournent des lignes modifiées et supprimées à leur état d’origine (<ph id="ph1">`DataRowState.Unchanged`</ph>).</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>AcceptChanges and RejectChanges only apply to <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> related changes (that is, <ph id="ph2">`Add`</ph>, <ph id="ph3">`Remove`</ph>, <ph id="ph4">`Delete`</ph>, and <ph id="ph5">`Modify`</ph>).</source>
          <target state="translated">AcceptChanges et RejectChanges s’appliquent uniquement aux <ph id="ph1">&lt;xref:System.Data.DataRow&gt;</ph> les modifications associées (c'est-à-dire, <ph id="ph2">`Add`</ph>, <ph id="ph3">`Remove`</ph>, <ph id="ph4">`Delete`</ph>, et <ph id="ph5">`Modify`</ph>).</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>They are not applicable to schema or structural changes.</source>
          <target state="translated">Ils ne sont pas applicables au schéma ou des modifications structurelles.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>The following example shows a class derived from the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> class.</source>
          <target state="translated">L’exemple suivant montre une classe dérivée de la <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.RejectChanges">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.RejectChanges%2A&gt;</ph> event is invoked from within a function.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.RejectChanges%2A&gt;</ph> événements sont appelé à partir d’une fonction.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Relations">
          <source>Get the collection of relations that link tables and allow navigation from parent tables to child tables.</source>
          <target state="translated">Obtient la collection des relations qui relient des tables et permettent de naviguer des tables parentes aux tables enfants.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Relations">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.DataRelationCollection" /&gt;</ph> that contains a collection of <ph id="ph2">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataRelationCollection" /&gt;</ph> qui contient une collection d'objets <ph id="ph2">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Relations">
          <source>An empty collection is returned if no <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> objects exist.</source>
          <target state="translated">Une collection vide est retournée si aucun objet <ph id="ph1">&lt;see cref="T:System.Data.DataRelation" /&gt;</ph> n'existe.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Relations">
          <source>The following example prints the column name of all child tables through the <ph id="ph1">&lt;xref:System.Data.DataSet.Relations%2A&gt;</ph> property.</source>
          <target state="translated">L’exemple suivant imprime le nom de colonne de toutes les tables enfants via la <ph id="ph1">&lt;xref:System.Data.DataSet.Relations%2A&gt;</ph> propriété.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.RemotingFormat">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Data.SerializationFormat" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> used during remoting.</source>
          <target state="translated">Obtient ou définit un <ph id="ph1">&lt;see cref="T:System.Data.SerializationFormat" /&gt;</ph> pour le <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> utilisé pendant la communication à distance.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.RemotingFormat">
          <source>A <ph id="ph1">&lt;see cref="T:System.Data.SerializationFormat" /&gt;</ph> object.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Data.SerializationFormat" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Reset">
          <source>Clears all tables and removes all relations, foreign constraints, and tables from the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Efface toutes les tables et supprime toutes les relations, contraintes étrangères et tables du <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.Reset">
          <source>Subclasses should override <ph id="ph1">&lt;see cref="M:System.Data.DataSet.Reset" /&gt;</ph> to restore a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to its original state.</source>
          <target state="translated">Les sous-classes doivent substituer <ph id="ph1">&lt;see cref="M:System.Data.DataSet.Reset" /&gt;</ph> pour rétablir l'état d'origine de <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> for a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtient ou définit un <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> pour un <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> for a <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtient ou définit un <ph id="ph1">&lt;see cref="T:System.Data.SchemaSerializationMode" /&gt;</ph> pour un <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>A <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> serializes its schema and instance data by default in Web services and remoting scenarios.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> sérialise ses données de schéma et l’instance par défaut dans les services Web et les scénarios de communication à distance.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>Setting the <ph id="ph1">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph> property of a typed <ph id="ph2">`DataSet`</ph> to <ph id="ph3">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> causes schema information to be excluded from the serialization payload.</source>
          <target state="translated">Définition de la <ph id="ph1">&lt;xref:System.Data.DataSet.SchemaSerializationMode%2A&gt;</ph> propriété d’un typé <ph id="ph2">`DataSet`</ph> à <ph id="ph3">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> , les informations de schéma à exclure de la charge utile de sérialisation.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source><ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> is supported only for a typed <ph id="ph2">`DataSet`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> est pris en charge uniquement pour un typé <ph id="ph2">`DataSet`</ph>.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>For an un-typed <ph id="ph1">`DataSet`</ph> this property can only be set to <ph id="ph2">&lt;xref:System.Data.SchemaSerializationMode.IncludeSchema&gt;</ph>.</source>
          <target state="translated">Pour un non typé <ph id="ph1">`DataSet`</ph> cette propriété peut uniquement être définie <ph id="ph2">&lt;xref:System.Data.SchemaSerializationMode.IncludeSchema&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source><ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> should only be used in cases where the schema information of the underlying typed <ph id="ph2">`DataTables`</ph>, <ph id="ph3">`DataRelations`</ph> and <ph id="ph4">`Constraints`</ph> has not been modified.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> ne doit être utilisée dans les cas où les informations de schéma de sous-jacent tapées <ph id="ph2">`DataTables`</ph>, <ph id="ph3">`DataRelations`</ph> et <ph id="ph4">`Constraints`</ph> n’a pas été modifié.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>If modifications have occurred, complete schema information should be serialized with <ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.IncludeSchema&gt;</ph>.</source>
          <target state="translated">Si vous ont des modifications des informations de schéma s’est produite, complète doivent être sérialisées avec <ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.IncludeSchema&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source><ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> is supported in version 2.0 of the .NET Framework or later.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> est pris en charge dans la version 2.0 du .NET Framework ou une version ultérieure.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>When <ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> is set, only the top level runtime properties present on the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> are serialized.</source>
          <target state="translated">Lorsque <ph id="ph1">&lt;xref:System.Data.SchemaSerializationMode.ExcludeSchema&gt;</ph> est défini, seules les propriétés d’exécution de niveau supérieur présentes sur le <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> sont sérialisés.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>In addition, they are serialized only if they happen to be different from the default values.</source>
          <target state="translated">En outre, elles sont sérialisées que si elles sont trouvent différents à partir des valeurs par défaut.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>None of the <ph id="ph1">`Tables`</ph>, <ph id="ph2">`Relations`</ph> or <ph id="ph3">`Constraints`</ph> are serialized.</source>
          <target state="translated">Aucun de la <ph id="ph1">`Tables`</ph>, <ph id="ph2">`Relations`</ph> ou <ph id="ph3">`Constraints`</ph> sont sérialisés.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>The serialized runtime properties include <ph id="ph1">&lt;xref:System.Data.DataSet.DataSetName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Data.DataSet.Namespace%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph>, and <ph id="ph6">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph>.</source>
          <target state="translated">Les propriétés d’exécution sérialisées incluent <ph id="ph1">&lt;xref:System.Data.DataSet.DataSetName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Data.DataSet.Namespace%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Data.DataSet.Prefix%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Data.DataSet.Locale%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Data.DataSet.EnforceConstraints%2A&gt;</ph>, et <ph id="ph6">&lt;xref:System.Data.DataSet.CaseSensitive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.SchemaSerializationMode">
          <source>These properties are serialized to make sure that overall runtime data integrity is preserved.</source>
          <target state="translated">Ces propriétés sont sérialisées pour vous assurer que l’intégrité des données de runtime globale sont conservé.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ShouldSerializeRelations">
          <source>Gets a value indicating whether <ph id="ph1">&lt;see cref="P:System.Data.DataSet.Relations" /&gt;</ph> property should be persisted.</source>
          <target state="translated">Obtient une valeur indiquant si la propriété <ph id="ph1">&lt;see cref="P:System.Data.DataSet.Relations" /&gt;</ph> doit être rendue persistante.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ShouldSerializeRelations">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property value has been changed from its default; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propriété n'utilise plus sa valeur par défaut ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ShouldSerializeRelations">
          <source>You typically use this method if you are either creating a designer for the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, or creating your own control incorporating the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">En règle générale, vous utilisez cette méthode si vous créez un concepteur pour le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, ou en créant votre propre contrôle incorporant la <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ShouldSerializeRelations">
          <source>The following examples show a class derived from the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> class.</source>
          <target state="translated">Les exemples suivants montrent une classe dérivée de la <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ShouldSerializeRelations">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.Reset%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ShouldSerializeRelations%2A&gt;</ph> methods are invoked from within functions in the derived class.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.Reset%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.ShouldSerializeRelations%2A&gt;</ph> méthodes sont appelées à partir de fonctions dans la classe dérivée.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ShouldSerializeTables">
          <source>Gets a value indicating whether <ph id="ph1">&lt;see cref="P:System.Data.DataSet.Tables" /&gt;</ph> property should be persisted.</source>
          <target state="translated">Obtient une valeur indiquant si la propriété <ph id="ph1">&lt;see cref="P:System.Data.DataSet.Tables" /&gt;</ph> doit être rendue persistante.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.ShouldSerializeTables">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property value has been changed from its default; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propriété n'utilise plus sa valeur par défaut ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ShouldSerializeTables">
          <source>You typically use this method only if you are either creating a designer for the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, or creating your own control incorporating the <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</source>
          <target state="translated">Vous utilisez généralement cette méthode uniquement si vous créez un concepteur pour le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph>, ou en créant votre propre contrôle incorporant la <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ShouldSerializeTables">
          <source>The following example shows a class derived from the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> class.</source>
          <target state="translated">L’exemple suivant montre une classe dérivée de la <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.ShouldSerializeTables">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.ShouldSerializeTables%2A&gt;</ph> method is called from within functions in the derived class.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.ShouldSerializeTables%2A&gt;</ph> méthode est appelée depuis l’intérieur de fonctions dans la classe dérivée.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Site">
          <source>Gets or sets an <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtient ou définit un élément <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph> pour l'élément <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Site">
          <source>An <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.ComponentModel.ISite" /&gt;</ph> pour <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Site">
          <source>Sites bind a <ph id="ph1">&lt;xref:System.ComponentModel.Component&gt;</ph> to a <ph id="ph2">&lt;xref:System.ComponentModel.Container&gt;</ph> and enable communication between them, as well as provide a way for the container to manage its components.</source>
          <target state="translated">Sites lient un <ph id="ph1">&lt;xref:System.ComponentModel.Component&gt;</ph> à un <ph id="ph2">&lt;xref:System.ComponentModel.Container&gt;</ph> et activer la communication entre eux, ainsi que fournir un moyen pour le conteneur de gérer ses composants.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.ComponentModel.IListSource.ContainsListCollection" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="P:System.ComponentModel.IListSource.ContainsListCollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.ComponentModel.IListSource.ContainsListCollection" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="P:System.ComponentModel.IListSource.ContainsListCollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.ComponentModel.IListSource&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.ComponentModel.IListSource&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.ComponentModel.IListSource.GetList" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.ComponentModel.IListSource.GetList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.ComponentModel.IListSource.GetList" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.ComponentModel.IListSource.GetList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.ComponentModel.IListSource&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.ComponentModel.IListSource&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /&gt;</ph>.</source>
          <target state="translated">Pour obtenir une description de ce membre, consultez <ph id="ph1">&lt;see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ce membre est une implémentation d'un membre d'interface explicite.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph> interface.</source>
          <target state="translated">Il peut uniquement être utilisé lorsque l'instance de <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est castée en interface <ph id="ph2">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="P:System.Data.DataSet.Tables">
          <source>Gets the collection of tables contained in the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Obtient la collection des tables contenues dans le <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Tables">
          <source>The <ph id="ph1">&lt;see cref="T:System.Data.DataTableCollection" /&gt;</ph> contained by this <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Data.DataTableCollection" /&gt;</ph> contenu dans ce <ph id="ph2">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Tables">
          <source>An empty collection is returned if no <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> objects exist.</source>
          <target state="translated">Une collection vide est retournée si aucun objet <ph id="ph1">&lt;see cref="T:System.Data.DataTable" /&gt;</ph> n'existe.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Tables">
          <source>To add tables to the collection, use <ph id="ph1">&lt;xref:System.Data.DataTableCollection.Add%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Data.DataTableCollection&gt;</ph>.</source>
          <target state="translated">Pour ajouter des tables à la collection, utilisez <ph id="ph1">&lt;xref:System.Data.DataTableCollection.Add%2A&gt;</ph> méthode de la <ph id="ph2">&lt;xref:System.Data.DataTableCollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Tables">
          <source>To remove tables, use the <ph id="ph1">&lt;xref:System.Data.DataTableCollection.Remove%2A&gt;</ph> method.</source>
          <target state="translated">Pour supprimer des tables, utilisez le <ph id="ph1">&lt;xref:System.Data.DataTableCollection.Remove%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Data.DataSet.Tables">
          <source>The following example returns the <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> object's <ph id="ph2">&lt;xref:System.Data.DataTableCollection&gt;</ph>, and prints the columns and rows in each table.</source>
          <target state="translated">L’exemple suivant retourne le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> l’objet <ph id="ph2">&lt;xref:System.Data.DataTableCollection&gt;</ph>et affiche les colonnes et les lignes de chaque table.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Writes XML data, and optionally the schema, from the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</source>
          <target state="translated">Écrit des données XML, et éventuellement le schéma, à partir du <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object used to write to a file.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> utilisé pour écrire dans un fichier.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>Writes the current data for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated">Écrit les données en cours de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide du <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">Le <ph id="ph1">`WriteXml`</ph> méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> dans un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode écrit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`mode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Pour écrire les données et le schéma, utilisez une des surcharges qui inclut le <ph id="ph1">`mode`</ph> paramètre et définissez sa valeur sur <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Pour lire des données XML, ou le schéma et les données dans le <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`ReadXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Pour lire uniquement le schéma, utilisez la <ph id="ph1">`ReadXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> object.</source>
          <target state="translated">L'exemple suivant crée un objet <ph id="ph1">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream)">
          <source>The object is then used with the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method to write an XML document.</source>
          <target state="translated">L’objet est ensuite utilisé avec la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> méthode pour écrire un document XML.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> object with which to write.</source>
          <target state="translated">Objet<ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> avec lequel écrire.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>Writes the current data for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>.</source>
          <target state="translated">Écrit les données en cours de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide du <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">Le <ph id="ph1">`WriteXml`</ph> méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> dans un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode écrit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`mode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Pour écrire les données et le schéma, utilisez une des surcharges qui inclut le <ph id="ph1">`mode`</ph> paramètre et définissez sa valeur sur <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Pour lire des données XML, ou le schéma et les données dans le <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`ReadXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Pour lire uniquement le schéma, utilisez la <ph id="ph1">`ReadXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>The file name (including the path) to which to write.</source>
          <target state="translated">Nom du fichier (chemin d'accès inclus) dans lequel effectuer l'écriture.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>Writes the current data for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to the specified file.</source>
          <target state="translated">Écrit les données en cours de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> dans le fichier spécifié.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">Le <ph id="ph1">`WriteXml`</ph> méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> dans un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode écrit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`mode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Pour écrire les données et le schéma, utilisez une des surcharges qui inclut le <ph id="ph1">`mode`</ph> paramètre et définissez sa valeur sur <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Pour lire des données XML, ou le schéma et les données dans le <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`ReadXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Pour lire uniquement le schéma, utilisez la <ph id="ph1">`ReadXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> n'a pas la valeur <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>for reading and writing files.</source>
          <target state="translated">Pour lire et écrire des fichiers.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> with which to write.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> à l'aide duquel effectuer l'écriture.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>Writes the current data for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">Écrit les données en cours de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> dans le <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">Le <ph id="ph1">`WriteXml`</ph> méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> dans un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode écrit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>To write both data and schema, use one of the overloads that includes the <ph id="ph1">`mode`</ph> parameter, and set its value to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Pour écrire les données et le schéma, utilisez une des surcharges qui inclut le <ph id="ph1">`mode`</ph> paramètre et définissez sa valeur sur <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Pour lire des données XML, ou le schéma et les données dans le <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`ReadXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Pour lire uniquement le schéma, utilisez la <ph id="ph1">`ReadXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object used to write to a file.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> utilisé pour écrire dans un fichier.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">Écrit les données en cours, et éventuellement le schéma, de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide des <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> et <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> spécifiés.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">Pour écrire le schéma, affectez <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph> comme valeur du paramètre <ph id="ph1">&lt;paramref name="mode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">Le <ph id="ph1">`WriteXml`</ph> méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> dans un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode écrit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>To write both data and schema, set the <ph id="ph1">`mode`</ph> parameter to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Pour écrire les données et le schéma, définissez la <ph id="ph1">`mode`</ph> paramètre <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Pour lire des données XML, ou le schéma et les données dans le <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`ReadXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Pour lire uniquement le schéma, utilisez la <ph id="ph1">`ReadXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> object used to write the document.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> utilisé pour écrire le document.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">Écrit les données en cours, et éventuellement le schéma, de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide des <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> et <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> spécifiés.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">Pour écrire le schéma, affectez <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph> comme valeur du paramètre <ph id="ph1">&lt;paramref name="mode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">Le <ph id="ph1">`WriteXml`</ph> méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> dans un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode écrit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>To write both data and schema, set the <ph id="ph1">`mode`</ph> parameter to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Pour écrire les données et le schéma, définissez la <ph id="ph1">`mode`</ph> paramètre <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Pour lire des données XML, ou le schéma et les données dans le <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`ReadXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Pour lire uniquement le schéma, utilisez la <ph id="ph1">`ReadXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>The following example first creates a simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> with one <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, two columns, and ten rows.</source>
          <target state="translated">L’exemple suivant crée d’abord un simple <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> avec un <ph id="ph2">&lt;xref:System.Data.DataTable&gt;</ph>, deux colonnes et dix lignes.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schema and data are written to disk by invoking the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> schéma et les données sont écrites sur le disque en appelant le <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)">
          <source>A second <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> is created and the <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> method is used to fill it with schema and data.</source>
          <target state="translated">Une seconde <ph id="ph1">&lt;xref:System.Data.DataSet&gt;</ph> est créé et le <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> méthode est utilisée pour le remplir avec le schéma et les données.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>The file name (including the path) to which to write.</source>
          <target state="translated">Nom du fichier (chemin d'accès inclus) dans lequel effectuer l'écriture.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> to the specified file using the specified <ph id="ph2">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">Écrit les données en cours, et éventuellement le schéma, de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> dans le fichier spécifié à l'aide du <ph id="ph2">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">Pour écrire le schéma, affectez <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph> comme valeur du paramètre <ph id="ph1">&lt;paramref name="mode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">Le <ph id="ph1">`WriteXml`</ph> méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> dans un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode écrit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>To write both data and schema, set the <ph id="ph1">`mode`</ph> parameter to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Pour écrire les données et le schéma, définissez la <ph id="ph1">`mode`</ph> paramètre <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Pour lire des données XML, ou le schéma et les données dans le <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`ReadXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Pour lire uniquement le schéma, utilisez la <ph id="ph1">`ReadXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method to write an XML document.</source>
          <target state="translated">L’exemple suivant utilise la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> méthode pour écrire un document XML.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> n'a pas la valeur <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>for reading and writing files.</source>
          <target state="translated">Pour lire et écrire des fichiers.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> with which to write.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> à l'aide duquel effectuer l'écriture.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> values.</source>
          <target state="translated">Une des valeurs de <ph id="ph1">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>Writes the current data, and optionally the schema, for the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> and <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph>.</source>
          <target state="translated">Écrit les données en cours, et éventuellement le schéma, de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> à l'aide des <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> et <ph id="ph3">&lt;see cref="T:System.Data.XmlWriteMode" /&gt;</ph> spécifiés.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>To write the schema, set the value for the <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter to <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph>.</source>
          <target state="translated">Pour écrire le schéma, affectez <ph id="ph2">&lt;see langword="WriteSchema" /&gt;</ph> comme valeur du paramètre <ph id="ph1">&lt;paramref name="mode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">`WriteXml`</ph> method provides a way to write either data only, or both data and schema from a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> into an XML document, whereas the <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method writes only the schema.</source>
          <target state="translated">Le <ph id="ph1">`WriteXml`</ph> méthode fournit à écrire seulement les données, ou les données et le schéma à partir d’un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> dans un document XML, alors que le <ph id="ph3">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode écrit uniquement le schéma.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>To write both data and schema, set the <ph id="ph1">`mode`</ph> parameter to <ph id="ph2">`WriteSchema`</ph>.</source>
          <target state="translated">Pour écrire les données et le schéma, définissez la <ph id="ph1">`mode`</ph> paramètre <ph id="ph2">`WriteSchema`</ph>.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>Note that the same is true for the <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> methods, respectively.</source>
          <target state="translated">Notez que le même a la valeur true pour le <ph id="ph1">&lt;xref:System.Data.DataSet.ReadXml%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Data.DataSet.ReadXmlSchema%2A&gt;</ph> méthodes, respectivement.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>To read XML data, or both schema and data into the <ph id="ph1">`DataSet`</ph>, use the <ph id="ph2">`ReadXml`</ph> method.</source>
          <target state="translated">Pour lire des données XML, ou le schéma et les données dans le <ph id="ph1">`DataSet`</ph>, utilisez le <ph id="ph2">`ReadXml`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>To read just the schema, use the <ph id="ph1">`ReadXmlSchema`</ph> method.</source>
          <target state="translated">Pour lire uniquement le schéma, utilisez la <ph id="ph1">`ReadXmlSchema`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>An <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown if a column type in the <ph id="ph2">`DataRow`</ph> being read from or written to implements <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> and does not implement <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> sera levée si un type de colonne dans la <ph id="ph2">`DataRow`</ph> en cours de lecture ou d’écriture implémente <ph id="ph3">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> et n’implémente pas <ph id="ph4">&lt;xref:System.Xml.Serialization.IXmlSerializable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> object that is used to create a new <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph>.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> objet qui est utilisé pour créer un nouveau <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)">
          <source>The <ph id="ph1">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> object is used with the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method to write an XML document.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> objet est utilisé avec le <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> méthode pour écrire un document XML.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="T:System.Data.DataSet">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema.</source>
          <target state="translated">Écrit la structure <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> sous la forme d'un schéma XML.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object used to write to a file.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> utilisé pour écrire dans un fichier.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object.</source>
          <target state="translated">Écrit la structure <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en tant que schéma XML dans l’objet <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> to an XML document.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode pour écrire le schéma pour un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à un document XML.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">Le schéma inclut des définitions de table, des relations et des contraintes.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Pour écrire un schéma dans un document XML, utilisez la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">Le schéma XML est écrite à l’aide de la norme XSD.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Pour écrire les données dans un document XML, utilisez la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>Classes that derive from the <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> class include <ph id="ph2">&lt;xref:System.IO.BufferedStream&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream&gt;</ph>, and <ph id="ph5">&lt;xref:System.Net.Sockets.NetworkStream&gt;</ph>.</source>
          <target state="translated">Classes dérivées de la <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> classe inclure <ph id="ph2">&lt;xref:System.IO.BufferedStream&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream&gt;</ph>, et <ph id="ph5">&lt;xref:System.Net.Sockets.NetworkStream&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object that is passed to the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method to write the schema to disk.</source>
          <target state="translated">L’exemple suivant crée un nouveau <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objet est passé à la <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode pour écrire le schéma sur le disque.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> object with which to write.</source>
          <target state="translated">Objet<ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> avec lequel écrire.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> object.</source>
          <target state="translated">Écrit la structure <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en tant que schéma XML dans l’objet <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> to an XML document.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode pour écrire le schéma pour un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à un document XML.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">Le schéma inclut des définitions de table, des relations et des contraintes.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Pour écrire un schéma dans un document XML, utilisez la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">Le schéma XML est écrite à l’aide de la norme XSD.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Pour écrire les données dans un document XML, utilisez la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>Classes the derive from the <ph id="ph1">&lt;xref:System.IO.TextWriter?displayProperty=nameWithType&gt;</ph> class include the <ph id="ph2">&lt;xref:System.Web.HttpWriter?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.StreamWriter?displayProperty=nameWithType&gt;</ph>, and <ph id="ph6">&lt;xref:System.IO.StringWriter?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Classes qui dérivent de la <ph id="ph1">&lt;xref:System.IO.TextWriter?displayProperty=nameWithType&gt;</ph> classe incluent le <ph id="ph2">&lt;xref:System.Web.HttpWriter?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.StreamWriter?displayProperty=nameWithType&gt;</ph>, et <ph id="ph6">&lt;xref:System.IO.StringWriter?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=nameWithType&gt;</ph> object to that is used to create a new <ph id="ph2">&lt;xref:System.IO.StringWriter?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">L’exemple suivant crée un <ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=nameWithType&gt;</ph> objet qui est utilisé pour créer un nouveau <ph id="ph2">&lt;xref:System.IO.StringWriter?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)">
          <source>The <ph id="ph1">&lt;xref:System.IO.StringWriter&gt;</ph> is passed to the <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method, and the resulting string is printed to the console window.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.StringWriter&gt;</ph> est passé à la <ph id="ph2">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> (méthode) et la chaîne résultante est écrit dans la fenêtre de console.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>The file name (including the path) to which to write.</source>
          <target state="translated">Nom du fichier (chemin d'accès inclus) dans lequel effectuer l'écriture.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to a file.</source>
          <target state="translated">Écrit la structure <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> sous la forme d'un schéma XML dans un fichier.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> to an XML document.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode pour écrire le schéma pour un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à un document XML.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">Le schéma inclut des définitions de table, des relations et des contraintes.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Pour écrire un schéma dans un document XML, utilisez la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">Le schéma XML est écrite à l’aide de la norme XSD.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Pour écrire les données dans un document XML, utilisez la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> is not set to <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermission" /&gt;</ph> n'a pas la valeur <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>for reading and writing files.</source>
          <target state="translated">Pour lire et écrire des fichiers.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></source>
          <target state="translated">Énumération associée : <ph id="ph1">&lt;see cref="T:System.Security.Permissions.FileIOPermissionAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> to write to.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> dans lequel écrire.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to an <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> object.</source>
          <target state="translated">Écrit la structure <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> sous la forme d'un schéma XML dans un objet <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>Use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method to write the schema for a <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> to an XML document.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode pour écrire le schéma pour un <ph id="ph2">&lt;xref:System.Data.DataSet&gt;</ph> à un document XML.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The schema includes table, relation, and constraint definitions.</source>
          <target state="translated">Le schéma inclut des définitions de table, des relations et des contraintes.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>To write a schema to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method.</source>
          <target state="translated">Pour écrire un schéma dans un document XML, utilisez la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The XML schema is written using the XSD standard.</source>
          <target state="translated">Le schéma XML est écrite à l’aide de la norme XSD.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>To write the data to an XML document, use the <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> method.</source>
          <target state="translated">Pour écrire les données dans un document XML, utilisez la <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXml%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>One class that inherits from the <ph id="ph1">&lt;xref:System.Xml.XmlWriter?displayProperty=nameWithType&gt;</ph> class is the <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> class.</source>
          <target state="translated">Une classe qui hérite de la <ph id="ph1">&lt;xref:System.Xml.XmlWriter?displayProperty=nameWithType&gt;</ph> classe est la <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> object with the specified path.</source>
          <target state="translated">L’exemple suivant crée un nouveau <ph id="ph1">&lt;xref:System.IO.FileStream?displayProperty=nameWithType&gt;</ph> objet avec le chemin d’accès spécifié.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object is used to create an <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> object.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objet est utilisé pour créer un <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> objet.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)">
          <source>The <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> method is then invoked with the <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> object to write the schema to the disk.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Data.DataSet.WriteXmlSchema%2A&gt;</ph> méthode est ensuite appelée avec le <ph id="ph2">&lt;xref:System.Xml.XmlTextWriter&gt;</ph> objet à écrire le schéma sur le disque.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object to write to.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> dans lequel écrire.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})">
          <source>A delegate used to convert <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to string.</source>
          <target state="translated">Délégué servant à convertir <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> en une chaîne.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to the specified <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object.</source>
          <target state="translated">Écrit la structure <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> en tant que schéma XML dans l’objet <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> object to write to.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> dans lequel écrire.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})">
          <source>A delegate used to convert <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to string.</source>
          <target state="translated">Délégué servant à convertir <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> en une chaîne.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to the specified <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph>.</source>
          <target state="translated">Écrit la structure de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> sous la forme d'un schéma XML dans le <ph id="ph2">&lt;see cref="T:System.IO.TextWriter" /&gt;</ph> spécifié.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})">
          <source>The name of the file to write to.</source>
          <target state="translated">Nom du fichier dans lequel écrire.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})">
          <source>A delegate used to convert <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to string.</source>
          <target state="translated">Délégué servant à convertir <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> en une chaîne.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to a file.</source>
          <target state="translated">Écrit la structure <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> sous la forme d'un schéma XML dans un fichier.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> object to write to.</source>
          <target state="translated">Objet <ph id="ph1">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> dans lequel écrire.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})">
          <source>A delegate used to convert <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to string.</source>
          <target state="translated">Délégué servant à convertir <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> en une chaîne.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})">
          <source>Writes the <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> structure as an XML schema to the specified <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph>.</source>
          <target state="translated">Écrit la structure de <ph id="ph1">&lt;see cref="T:System.Data.DataSet" /&gt;</ph> sous la forme d'un schéma XML dans le <ph id="ph2">&lt;see cref="T:System.Xml.XmlWriter" /&gt;</ph> spécifié.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>