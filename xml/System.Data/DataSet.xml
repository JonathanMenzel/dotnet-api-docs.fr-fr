<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ef0d9acfa4885b80ad56b84f78c5821d8d5cae5f" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52734966" /></Metadata><TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataSet = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un cache de données en mémoire.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet>, qui est un cache en mémoire des données récupérées à partir d’une source de données est un composant majeur de l’architecture ADO.NET. Le <xref:System.Data.DataSet> se compose d’une collection de <xref:System.Data.DataTable> les objets que vous pouvez associer à l’autre avec <xref:System.Data.DataRelation> objets. Vous pouvez également appliquer l’intégrité des données dans le <xref:System.Data.DataSet> à l’aide de la <xref:System.Data.UniqueConstraint> et <xref:System.Data.ForeignKeyConstraint> objets. Pour plus d’informations sur l’utilisation de <xref:System.Data.DataSet> , consultez [DataSets, DataTables et DataViews](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md).  
  
 Tandis que <xref:System.Data.DataTable> objets contiennent les données, le <xref:System.Data.DataRelationCollection> vous permet de naviguer au sein de la hiérarchie de la table. Les tables sont contenus dans un <xref:System.Data.DataTableCollection> accessibles via le <xref:System.Data.DataSet.Tables%2A> propriété. Lors de l’accès <xref:System.Data.DataTable> objets, notez qu’ils sont conditionnelle respectant la casse. Par exemple, si un <xref:System.Data.DataTable> est appelé « mydatatable » et un autre nommé « Mydatatable », une chaîne utilisée pour rechercher une des tables est considérée comme respectant la casse. Cependant, si « mydatatable » existe et n’est pas le cas de « Mydatatable », la chaîne de recherche est considérée comme respectent pas la casse. Pour plus d’informations sur l’utilisation de <xref:System.Data.DataTable> , consultez [création d’un DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Un <xref:System.Data.DataSet> peuvent lire et écrire des données et le schéma en tant que documents XML. Les données et le schéma peuvent ensuite être traversent HTTP et utilisés par n’importe quelle application, sur n’importe quelle plateforme qui prend en charge de XML. Vous pouvez enregistrer le schéma comme un schéma XML avec la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode) et le schéma et les données peuvent être enregistrées à l’aide de la <xref:System.Data.DataSet.WriteXml%2A> (méthode). Pour lire un document XML qui inclut le schéma et les données, utilisez le <xref:System.Data.DataSet.ReadXml%2A> (méthode).  
  
 Dans une implémentation classique à plusieurs niveaux, les étapes de création et d’actualisation un <xref:System.Data.DataSet>, et à son tour, la mise à jour les données d’origine :  
  
1.  Générer et remplir chaque <xref:System.Data.DataTable> dans un <xref:System.Data.DataSet> avec des données à partir d’une source de données à l’aide un <xref:System.Data.Common.DataAdapter>.  
  
2.  Modifier les données dans les <xref:System.Data.DataTable> les objets par ajout, la mise à jour ou la suppression <xref:System.Data.DataRow> objets.  
  
3.  Appeler le <xref:System.Data.DataSet.GetChanges%2A> méthode pour créer un second <xref:System.Data.DataSet> qui propose uniquement les modifications aux données.  
  
4.  Appelez le <xref:System.Data.Common.DataAdapter.Update%2A> méthode de la <xref:System.Data.Common.DataAdapter>, en passant le deuxième <xref:System.Data.DataSet> en tant qu’argument.  
  
5.  Appeler le <xref:System.Data.DataSet.Merge%2A> méthode pour fusionner les modifications de la seconde <xref:System.Data.DataSet> dans la première.  
  
6.  Appeler le <xref:System.Data.DataSet.AcceptChanges%2A> sur le <xref:System.Data.DataSet>. Vous pouvez également appeler <xref:System.Data.DataSet.RejectChanges%2A> pour annuler les modifications.  
  
> [!NOTE]
>  Le <xref:System.Data.DataSet> et <xref:System.Data.DataTable> objets héritent <xref:System.ComponentModel.MarshalByValueComponent>et prennent en charge la <xref:System.Runtime.Serialization.ISerializable> interface pour la communication à distance. Ce sont les seuls objets ADO.NET qui peuvent être exécutés à distance.  
  
> [!NOTE]
>  Classes héritées de <xref:System.Data.DataSet> ne sont pas finalisés par le garbage collector, car le finaliseur a été supprimé dans <xref:System.Data.DataSet>. La classe dérivée peut appeler le <xref:System.GC.ReRegisterForFinalize%2A> méthode dans son constructeur pour permettre à la classe de finalisation par le garbage collector.  
  
   
  
## Examples  
 L’exemple suivant se compose de plusieurs méthodes qui, combinées, créer et remplir un <xref:System.Data.DataSet> à partir de la **Northwind** base de données.  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est sécurisé pour les opérations de lecture multithreads. Vous devez synchroniser des opérations d’écriture.</threadsafe>
    <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation de la <xref:System.Data.DataSet> constructeur n’accepte aucun paramètre et crée un nom par défaut, « NewDataSet », pour la nouvelle instance.  
  
 Un nom pour le <xref:System.Data.DataSet> est nécessaire pour vérifier que la représentation XML de le <xref:System.Data.DataSet> a toujours un nom pour l’élément de document, qui est l’élément apparaissant dans une définition de schéma.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Data.DataSet>et ajoute deux <xref:System.Data.DataTable> objets à ce dernier.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : string -&gt; System.Data.DataSet" Usage="new System.Data.DataSet dataSetName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName">Nom du <see cref="T:System.Data.DataSet" />.</param>
        <summary>Initialise une nouvelle instance d’un <see cref="T:System.Data.DataSet" /> classe portant le nom spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nom pour le <xref:System.Data.DataSet> est nécessaire pour vérifier que la représentation XML de le <xref:System.Data.DataSet> a toujours un nom pour l’élément de document, qui est l’élément au niveau le plus élevé dans une définition de schéma.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Data.DataSet>, pour les deux <xref:System.Data.DataTable> objets sont ajoutés.  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Données nécessaires à la sérialisation et à la désérialisation d’un objet.</param>
        <param name="context">Source et destination d’un flux sérialisé donné.</param>
        <summary>Initialise une nouvelle instance d’un <see cref="T:System.Data.DataSet" /> classe qui contient les informations de sérialisation donné et le contexte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext * bool -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context, ConstructSchema)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <param name="ConstructSchema">La valeur booléenne.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataSet.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Valide toutes les modifications apportées à ce <see cref="T:System.Data.DataSet" /> depuis son chargement ou depuis le dernier <see cref="M:System.Data.DataSet.AcceptChanges" /> a été appelée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À la fois le <xref:System.Data.DataRow> et <xref:System.Data.DataTable> classes ont <xref:System.Data.DataSet.AcceptChanges%2A> méthodes. Appelant <xref:System.Data.DataTable.AcceptChanges%2A> à la <xref:System.Data.DataTable> niveau entraîne la <xref:System.Data.DataRow.AcceptChanges%2A> méthode pour chaque <xref:System.Data.DataRow> à appeler. De même, l’appel <xref:System.Data.DataSet.AcceptChanges%2A> sur le <xref:System.Data.DataSet> provoque <xref:System.Data.DataTable.AcceptChanges%2A> à appeler sur chaque table dans le <xref:System.Data.DataSet>. De cette manière, vous disposez de plusieurs niveaux à laquelle la méthode peut être appelée. Appel de la <xref:System.Data.DataSet.AcceptChanges%2A> de la <xref:System.Data.DataSet> afin de pouvoir appeler la méthode sur tous les objets subordonnés (par exemple, les tables et les lignes) avec un seul appel.  
  
 Lorsque vous appelez `AcceptChanges` sur le `DataSet`, n’importe quel <xref:System.Data.DataRow> objets toujours en mode édition achève correctement ses modifications. Le <xref:System.Data.DataRow.RowState%2A> propriété de chaque <xref:System.Data.DataRow> change également ; `Added` et `Modified` lignes deviennent `Unchanged`, et `Deleted` lignes sont supprimées.  
  
 Si le `DataSet` contient <xref:System.Data.ForeignKeyConstraint> objets, appelant le `AcceptChanges` méthode provoque également la <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> soient appliquées.  
  
> [!NOTE]
>  `AcceptChanges` et `RejectChanges` s’appliquent uniquement aux `DataRow` (autrement dit, ajouter, supprimer, supprimer et modifier) les modifications associées. Ils ne sont pas applicables au schéma ou des modifications structurelles.  
>   
>  Appelant AcceptChanges ne répliquera pas ces modifications à la source de données si le jeu de données a été passée à l’aide d’un DataAdapter. Dans ce cas, appelez <xref:System.Data.Common.DataAdapter.Update%2A> à la place. Consultez [la mise à jour des Sources de données avec des DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md) pour plus d’informations.  
  
   
  
## Examples  
 L’exemple suivant ajoute un <xref:System.Data.DataRow> à un <xref:System.Data.DataTable> dans un <xref:System.Data.DataSet>. Le <xref:System.Data.DataSet.AcceptChanges%2A> méthode est ensuite appelée sur le <xref:System.Data.DataSet>, les cascades à tous les <xref:System.Data.DataTable> les objets qu’il contient.  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataSet.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commence l'initialisation d'un <see cref="T:System.Data.DataSet" /> qui est utilisé dans un formulaire ou par un autre composant. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’environnement de conception de Visual Studio .NET utilise cette méthode pour démarrer l’initialisation d’un composant qui est utilisé sur un formulaire ou par un autre composant. Le <xref:System.Data.DataSet.EndInit%2A> méthode termine l’initialisation. À l’aide de la <xref:System.Data.DataSet.BeginInit%2A> et <xref:System.Data.DataSet.EndInit%2A> méthodes empêche le contrôle de l’utilisation avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si des comparaisons au sein de chaînes <see cref="T:System.Data.DataTable" /> objets respectent la casse.</summary>
        <value><see langword="true" /> Si les comparaisons de chaînes respectent la casse ; sinon <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.CaseSensitive%2A> propriété affecte comment le tri, recherche et filtrage des opérations sont effectuées sur chaque <xref:System.Data.DataTable> objet contenu dans un <xref:System.Data.DataSet> lorsque vous utilisez le <xref:System.Data.DataTable.Select%2A> (méthode).  
  
 Par le paramètre par défaut, le <xref:System.Data.DataSet.CaseSensitive%2A> propriété pour un <xref:System.Data.DataSet> définit également la <xref:System.Data.DataTable.CaseSensitive%2A> propriété de chacun associés <xref:System.Data.DataTable> sur la même valeur.  
  
   
  
## Examples  
 L’exemple suivant active ou désactive le <xref:System.Data.DataSet.CaseSensitive%2A> propriété.  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface le <see cref="T:System.Data.DataSet" /> de toutes les données en supprimant toutes les lignes dans toutes les tables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Data.DataSet> est lié à un <xref:System.Xml.XmlDataDocument>, l’appel <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> ou <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> déclenche le <xref:System.NotSupportedException>. Pour éviter cette situation, parcourez chaque table et supprimez les lignes une à la fois.  
  
   
  
## Examples  
 L’exemple suivant efface le <xref:System.Data.DataSet> de toutes les lignes de toutes les tables.  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataSet&#xA;override this.Clone : unit -&gt; System.Data.DataSet" Usage="dataSet.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie l’arborescence de la <see cref="T:System.Data.DataSet" />, y compris tous <see cref="T:System.Data.DataTable" /> schémas, relations et contraintes. Ne copie pas toutes les données.</summary>
        <returns>Un nouveau <see cref="T:System.Data.DataSet" /> avec le même schéma que l’actuel <see cref="T:System.Data.DataSet" />, mais aucune des données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si ces classes ont été sous-classées, le clone sera également aux mêmes sous-classes.  
  
   
  
## Examples  
 L’exemple suivant crée un clone d’un <xref:System.Data.DataSet> schéma de l’objet.  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataSet" Usage="dataSet.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie la structure et les données pour ce <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Un nouveau <see cref="T:System.Data.DataSet" /> avec la même structure (schémas de table, relations et contraintes) et les mêmes données que ce <see cref="T:System.Data.DataSet" />.  
  
 <block subset="none" type="note"><para>  
 Si ces classes ont été sous-classées, la copie sera également aux mêmes sous-classes.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataSet.Copy%2A> méthode pour créer une copie de l’original <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un <see cref="T:System.Data.DataTableReader" /> avec un jeu de résultats par <see cref="T:System.Data.DataTable" />, dans la même séquence que les tables apparaissent dans le <see cref="P:System.Data.DataSet.Tables" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Afin de garantir l’ordre des jeux de résultats dans la liste retournée <xref:System.Data.DataTableReader>, si un <xref:System.Data.DataTable> au sein de la <xref:System.Data.DataSet> est vide, il sera représenté par un résultat vide au sein de retourné `DataTableReader`.  
  
   
  
## Examples  
 Cet exemple, une application Console, crée trois <xref:System.Data.DataTable> instances et les ajoute à un <xref:System.Data.DataSet>. L’exemple appelle la <xref:System.Data.DataSet.CreateDataReader%2A> (méthode) et affiche le contenu de retourné <xref:System.Data.DataTableReader>. Notez que l’ordre du résultat définit dans le `DataTableReader` est contrôlé par l’ordre de la `DataTable` instances passés comme paramètres.  
  
> [!NOTE]
>  Cet exemple montre comment utiliser une des versions surchargées de `CreateDataReader`. Pour obtenir des exemples qui peuvent être disponibles, consultez les rubriques de surcharges individuelles.  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 L’exemple affiche le code suivant dans la fenêtre de Console :  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Data.DataTableReader" /> avec un jeu de résultats par <see cref="T:System.Data.DataTable" />, dans la même séquence que les tables apparaissent dans le <see cref="P:System.Data.DataSet.Tables" /> collection.</summary>
        <returns>Un <see cref="T:System.Data.DataTableReader" /> contenant un ou plusieurs jeux de résultats, correspondant à la <see cref="T:System.Data.DataTable" /> instances contenues dans la source <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Afin de garantir l’ordre des jeux de résultats dans la liste retournée <xref:System.Data.DataTableReader>, si un <xref:System.Data.DataTable> au sein de la <xref:System.Data.DataSet> est vide, il est représenté par un résultat vide au sein de retourné `DataTableReader`.  
  
   
  
## Examples  
 L’exemple suivant crée trois <xref:System.Data.DataTable> instances et ajoute chacun d’eux à un <xref:System.Data.DataSet>. Cet exemple passe ensuite le plein `DataSet` à une procédure qui appelle le <xref:System.Data.DataSet.CreateDataReader%2A> (méthode) et continue à effectuer une itération dans tous les jeux de résultats contenus dans le <xref:System.Data.DataTableReader>. L’exemple affiche les résultats dans la fenêtre de Console.  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader dataTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">Définit par un tableau de DataTables qui fournit l’ordre du résultat à retourner dans le <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Retourne un <see cref="T:System.Data.DataTableReader" /> avec un jeu de résultats par <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Un <see cref="T:System.Data.DataTableReader" /> contenant un ou plusieurs jeux de résultats, correspondant à la <see cref="T:System.Data.DataTable" /> instances contenues dans la source <see cref="T:System.Data.DataSet" />. Les jeux de résultats retournés sont dans l’ordre spécifié par le <paramref name="dataTables" /> paramètre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Afin de garantir que l’ordre du résultat définit dans retourné <xref:System.Data.DataTableReader>, si un <xref:System.Data.DataTable> au sein de la <xref:System.Data.DataSet> est vide, il est représenté par un résultat vide au sein de retourné `DataTableReader`. Étant donné que cette version surchargée vous permet de fournir une liste de `DataTable` instances en tant que paramètres, vous pouvez spécifier l’ordre dans lequel les jeux de résultats apparaissent dans la liste retournée `DataTableReader`.  
  
   
  
## Examples  
 Cet exemple, une application Console, crée trois <xref:System.Data.DataTable> instances et les ajoute à un <xref:System.Data.DataSet>. L’exemple appelle la <xref:System.Data.DataSet.CreateDataReader%2A> (méthode) et affiche le contenu de retourné <xref:System.Data.DataTableReader>. Notez que l’ordre du résultat définit dans le `DataTableReader` est contrôlé par l’ordre de la `DataTable` instances passés comme paramètres. L’exemple affiche les résultats dans la fenêtre de Console.  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSetName : string with get, set" Usage="System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDataSetNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de l’actuel <see cref="T:System.Data.DataSet" />.</summary>
        <value>Nom du <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Data.DataSet> avec la donnée <xref:System.Data.DataSet.DataSetName%2A>.  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultViewManager : System.Data.DataViewManager" Usage="System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une vue personnalisée des données contenues dans le <see cref="T:System.Data.DataSet" /> pour permettre le filtrage, la recherche et la navigation à l’aide d’un personnalisé <see cref="T:System.Data.DataViewManager" />.</summary>
        <value>Objet <see cref="T:System.Data.DataViewManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataViewManager> retourné par la <xref:System.Data.DataSet.DefaultViewManager%2A> propriété vous permet de créer des paramètres personnalisés pour chaque <xref:System.Data.DataTable> dans le <xref:System.Data.DataSet>.  
  
 Lorsque vous obtenez un <xref:System.Data.DataView> à partir d’un <xref:System.Data.DataTable>, l’ordre de tri, filtrage, et <xref:System.Data.DataViewRowState> sont configurés conformément aux paramètres dans le <xref:System.Data.DataSet.DefaultViewManager%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant obtient la valeur par défaut <xref:System.Data.DataViewManager> pour un <xref:System.Data.DataSet>et ajoute un <xref:System.Data.DataTable> à la <xref:System.Data.DataTableCollection>.  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine le <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> pour un <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lors de la désérialisation typé <xref:System.Data.DataSet> pour déterminer son <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Xml.XmlReader -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Le <see cref="T:System.Xml.XmlReader" /> instance qui est passée pendant la désérialisation de la <see cref="T:System.Data.DataSet" />.</param>
        <summary>Détermine le <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> pour un <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Un <see cref="T:System.Data.SchemaSerializationMode" /> énumération qui indique si les informations de schéma ont été omises de la charge utile.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lors de la désérialisation typé <xref:System.Data.DataSet> pour déterminer son <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> avec lequel le <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> du constructeur protégé d’un <see langword="DataSet" /> est appelé durant la désérialisation, dans les scénarios de communication à distance.</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> avec lequel le <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> du constructeur protégé d’un <see langword="DataSet" /> est appelé durant la désérialisation, dans les scénarios de communication à distance.</param>
        <summary>Détermine le <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> pour un <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Un <see cref="T:System.Data.SchemaSerializationMode" /> énumération qui indique si les informations de schéma ont été omises de la charge utile.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lors de la désérialisation typé <xref:System.Data.DataSet> pour déterminer son <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataSet.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termine l'initialisation d'un <see cref="T:System.Data.DataSet" /> qui est utilisé dans un formulaire ou par un autre composant. L'initialisation se produit au moment de l'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’environnement de conception de Visual Studio .NET utilise cette méthode pour terminer l’initialisation d’un composant qui est utilisé sur un formulaire ou par un autre composant. Le <xref:System.Data.DataSet.BeginInit%2A> méthode démarre l’initialisation. À l’aide de la <xref:System.Data.DataSet.BeginInit%2A> et <xref:System.Data.DataSet.EndInit%2A> méthodes empêche le contrôle de l’utilisation avant son initialisation complète.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnforceConstraints : bool with get, set" Usage="System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetEnforceConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si les règles de contrainte sont respectées lorsque vous tentez de toute opération de mise à jour.</summary>
        <value><see langword="true" /> Si les règles sont appliquées ; sinon <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les contraintes sont définies au <xref:System.Data.DataTable> niveau (<xref:System.Data.DataTable.Constraints%2A> propriété). Pour plus d’informations sur la création de contraintes, consultez [contraintes de DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataSet> avec une table, une colonne, cinq lignes et l’autre <xref:System.Data.UniqueConstraint>. Le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété est définie sur `false` et les valeurs de chaque ligne sont définis sur la même valeur. Lorsque le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété est réinitialisée à `true`, un <xref:System.Data.ConstraintException> est généré.  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Une ou plusieurs contraintes ne peuvent pas être appliquées.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection d’informations utilisateur personnalisées associées le <see langword="DataSet" />.</summary>
        <value>Un <see cref="T:System.Data.PropertyCollection" /> avec toutes les informations utilisateur personnalisées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ExtendedProperties%2A> propriété permet de stocker des informations personnalisées avec le `DataSet`. Par exemple, vous pouvez stocker une heure à laquelle les données doivent être actualisées.  
  
 Les propriétés étendues doivent être de type <xref:System.String> si vous souhaitez les rendues persistantes lorsque le <xref:System.Data.DataSet> est écrit au format XML.  
  
   
  
## Examples  
 L’exemple suivant ajoute une propriété personnalisée à la <xref:System.Data.PropertyCollection> retourné par la <xref:System.Data.DataColumn.ExtendedProperties%2A> propriété. Le deuxième exemple récupère la propriété personnalisée.  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une copie de la <see cref="T:System.Data.DataSet" /> contenant toutes les modifications apportées depuis son dernier chargement ou depuis <see cref="M:System.Data.DataSet.AcceptChanges" /> a été appelée.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataSet" Usage="dataSet.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une copie de la <see cref="T:System.Data.DataSet" /> qui contient toutes les modifications apportées depuis son chargement ou depuis <see cref="M:System.Data.DataSet.AcceptChanges" /> dernier appel.</summary>
        <returns>Une copie des modifications à partir de ce <see cref="T:System.Data.DataSet" /> qui actions peuvent être exécutées et ensuite refusionnées à l’aide de <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Si aucune ligne modifiée n’est trouvée, la méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crée un <xref:System.Data.DataSet> qui contient une copie de toutes les lignes dans la version d’origine <xref:System.Data.DataSet> ayant des modifications en attente. Les contraintes de relation peuvent entraîner des lignes inchangées supplémentaires à ajouter à la nouvelle <xref:System.Data.DataSet> si les lignes inchangées contiennent des clés primaires correspondant aux clés étrangères dans les lignes modifiées. La méthode retourne `null` s’il n’existe aucune ligne dans la version d’origine <xref:System.Data.DataSet> ayant des modifications en attente.  
  
   
  
## Examples  
 L’exemple suivant crée un simple <xref:System.Data.DataSet> avec une table, deux colonnes et dix lignes. Deux valeurs sont modifiées, et une ligne est ajoutée. Un sous-ensemble des données modifiées est créé à l’aide de la <xref:System.Data.DataSet.GetChanges%2A> (méthode). Après la réconciliation des erreurs, une nouvelle colonne est ajoutée au sous-ensemble, modification du schéma. Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée avec le `missingSchemaAction` définie sur `MissingSchemaAction.Add`, la nouvelle colonne est ajoutée à l’original <xref:System.Data.DataSet> schéma de l’objet.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataSet" Usage="dataSet.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Une des valeurs de <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Obtient une copie de la <see cref="T:System.Data.DataSet" /> contenant toutes les modifications apportées depuis son dernier chargement ou depuis <see cref="M:System.Data.DataSet.AcceptChanges" /> a été appelée, filtrés par <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Copie filtrée du <see cref="T:System.Data.DataSet" /> qui actions peuvent être exécutées sur celui-ci et ensuite refusionnées à l’aide de <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Si aucune ligne de souhaité <see cref="T:System.Data.DataRowState" /> sont trouvés, la méthode retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.GetChanges%2A> méthode est utilisée pour générer un deuxième <xref:System.Data.DataSet> objet qui contient uniquement les modifications introduites dans la version d’origine. Utilisez le `rowStates` argument pour spécifier le type de l’objet nouveau doit inclure des modifications.  
  
 Cette copie retournée est conçue pour être refusionnée dans ce d’origine <xref:System.Data.DataSet>. Les contraintes de relation peuvent entraîner des lignes parentes marquées `Unchanged` à inclure. Si aucune ligne de souhaité <xref:System.Data.DataRowState> sont trouvés, le <xref:System.Data.DataSet.GetChanges%2A> retourne de la méthode `null`.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataSet.GetChanges%2A> méthode pour créer un second <xref:System.Data.DataSet> objet, qui est ensuite utilisé pour mettre à jour une source de données.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataSetSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataSet.GetDataSetSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Le jeu de schémas spécifié.</param>
        <summary>Obtient une copie de <see cref="T:System.Xml.Schema.XmlSchemaSet" /> pour le jeu de données.</summary>
        <returns>Copie de l'objet <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> qui contient les données sérialisées associées à l'<see cref="T:System.Data.DataSet" />.</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> qui contient la source et la destination du flux sérialisé associé à l'<see cref="T:System.Data.DataSet" />.</param>
        <summary>Remplit un objet d’informations de sérialisation avec les données nécessaires pour sérialiser <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="info" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberSignature Language="F#" Value="abstract member GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataSet.GetSchemaSerializable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un sérialisable <see cref="T:System.Xml.Schema.XmlSchema" /> instance.</summary>
        <returns>Instance <see cref="T:System.Xml.Schema.XmlSchema" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.GetSerializationData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetSerializationData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Instance <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Contexte de diffusion en continu.</param>
        <summary>Désérialise les données de table à partir du flux binaire ou XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberSignature Language="F#" Value="member this.GetXml : unit -&gt; string" Usage="dataSet.GetXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne la représentation XML des données stockées dans le <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Une chaîne qui est une représentation des données stockées dans le <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode est identique à l’appel <xref:System.Data.DataSet.WriteXml%2A> avec <xref:System.Data.XmlWriteMode> défini sur <xref:System.Data.XmlWriteMode.IgnoreSchema>.  
  
 <xref:System.Data.DataSet.GetXml%2A> Retourne des données XML sous forme de chaîne et nécessite donc une charge plus importante que <xref:System.Data.DataSet.WriteXml%2A> à écrire du code XML dans un fichier.  
  
 Si vous générez un <xref:System.Data.DataSet> à l’aide de l’inférence de schéma et sérialiser à l’aide de XML ou des services Web, le classement de colonne peut changer.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataSet> et <xref:System.Data.DataTable>, ajoute les exemples de données, puis affiche les données au format XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 Cet exemple montre comment écrire des données dans un fichier XML à partir d’un jeu de données et lire les données dans le jeu de données à partir de XML. Cet exemple sera créer un jeu de données avec deux tables, utilisez deux façons d’exporter un jeu de données dans les fichiers XML (WriteXml et GetXml) et utiliser deux façons (ReadXml et InferXmlSchema) pour importer un jeu de données à partir des fichiers XML.  
  
 Avant de compiler et exécuter l’exemple, vous devez créer quatre fichiers XML dans le répertoire d’exemple. Tout d’abord, créez ElementsWithAttributes.xml :  
  
```xml  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 Ensuite, créez ElementsWithChildElementsxml.xml :  
  
```xml  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 Créez maintenant ElementsWithOnlyAttributes.xml :  
  
```xml
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 Et enfin, créez RepeatingElements.xml :  
  
```xml
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 Vous pouvez maintenant compiler et exécuter le code source suivant.  [Comment Store données de jeu de données dans le fichier XML](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) a des projets Visual Basic et c# de cet exemple.  
  
```csharp
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberSignature Language="F#" Value="member this.GetXmlSchema : unit -&gt; string" Usage="dataSet.GetXmlSchema " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le schéma XML de la représentation XML des données stockées dans le <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Chaîne qui définit le schéma XML de la représentation XML des données stockées dans le <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode est identique à l’appel <xref:System.Data.DataSet.WriteXmlSchema%2A>, sauf que seul le schéma principal est écrit.  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> Retourne des données XML sous forme de chaîne et nécessite donc une charge plus importante que <xref:System.Data.DataSet.WriteXmlSchema%2A> à écrire du code XML dans un fichier.  
  
 Si vous générez un <xref:System.Data.DataSet> à l’aide de l’inférence de schéma et sérialiser à l’aide de XML ou des services Web, le classement de colonne peut changer.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Data.DataSet> et <xref:System.Data.DataTable>, puis affiche le schéma au format XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Data.DataSet" /> a des modifications, notamment des lignes nouvelles, supprimées ou modifiées.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberSignature Language="F#" Value="member this.HasChanges : unit -&gt; bool" Usage="dataSet.HasChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Data.DataSet" /> a des modifications, notamment des lignes nouvelles, supprimées ou modifiées.</summary>
        <returns><see langword="true" /> Si le <see cref="T:System.Data.DataSet" /> comporte des modifications ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataSet.GetChanges%2A> méthode pour créer un second <xref:System.Data.DataSet> objet qui est ensuite utilisé pour mettre à jour une source de données.  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.HasChanges : System.Data.DataRowState -&gt; bool" Usage="dataSet.HasChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Une des valeurs de <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Data.DataSet" /> contient des modifications, notamment des lignes nouvelles, supprimées ou modifiées, filtrées par <see cref="T:System.Data.DataRowState" />.</summary>
        <returns><see langword="true" /> Si le <see cref="T:System.Data.DataSet" /> comporte des modifications ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Examiner le <xref:System.Data.DataSet.HasChanges%2A> propriété de la `DataSet` avant d’appeler le <xref:System.Data.DataSet.GetChanges%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataSet.GetChanges%2A> méthode pour créer un second <xref:System.Data.DataSet> objet, qui est ensuite utilisé pour mettre à jour une source de données.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant s’il existe des erreurs dans un de le <see cref="T:System.Data.DataTable" /> objets dans cet <see cref="T:System.Data.DataSet" />.</summary>
        <value><see langword="true" /> Si une table contient une erreur ; sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque <xref:System.Data.DataTable> dans un <xref:System.Data.DataSet> a également un <xref:System.Data.DataTable.HasErrors%2A> propriété. Utilisez le `HasErrors` propriété de la `DataSet` tout d’abord, pour déterminer si une table comporte des erreurs, avant de vérifier individuels <xref:System.Data.DataTable> objets. Si un `DataTable` comporte des erreurs, le <xref:System.Data.DataTable.GetErrors%2A> méthode retourne un tableau de <xref:System.Data.DataRow> objets contenant les erreurs.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataSet.HasErrors%2A> propriété afin de déterminer si un <xref:System.Data.DataSet> objet contient des erreurs. Dans ce cas, les erreurs pour chaque <xref:System.Data.DataRow> dans chaque <xref:System.Data.DataTable> sont imprimés.  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Applique le schéma XML le <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.Stream * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (stream, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream"><see langword="Stream" /> à partir duquel lire le schéma.</param>
        <param name="nsArray">Tableau des chaînes d'URI (Uniform Resource Identifier) d'espace de noms à exclure de l'inférence de schéma.</param>
        <summary>Applique le schéma XML à partir du spécifié <see cref="T:System.IO.Stream" /> à la <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.TextReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader"><see langword="TextReader" /> à partir duquel lire le schéma.</param>
        <param name="nsArray">Tableau des chaînes d'URI (Uniform Resource Identifier) d'espace de noms à exclure de l'inférence de schéma.</param>
        <summary>Applique le schéma XML à partir du spécifié <see cref="T:System.IO.TextReader" /> à la <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : string * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (fileName, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">Le nom du fichier (y compris le chemin d’accès) à partir duquel lire le schéma.</param>
        <param name="nsArray">Tableau des chaînes d'URI (Uniform Resource Identifier) d'espace de noms à exclure de l'inférence de schéma.</param>
        <summary>Applique le schéma XML à partir du fichier spécifié pour le <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> n’a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.Xml.XmlReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader"><see langword="XMLReader" /> à partir duquel lire le schéma.</param>
        <param name="nsArray">Tableau des chaînes d'URI (Uniform Resource Identifier) d'espace de noms à exclure de l'inférence de schéma.</param>
        <summary>Applique le schéma XML à partir du spécifié <see cref="T:System.Xml.XmlReader" /> à la <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après le <see cref="T:System.Data.DataSet" /> est initialisé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations, consultez <xref:System.Data.DataSet.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberSignature Language="F#" Value="abstract member InitializeDerivedDataSet : unit -&gt; unit&#xA;override this.InitializeDerivedDataSet : unit -&gt; unit" Usage="dataSet.InitializeDerivedDataSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Désérialisez toutes les données de tables du jeu de données à partir du flux binaire ou XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.IsBinarySerialized : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; bool" Usage="dataSet.IsBinarySerialized (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objet <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Objet <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <summary>Inspecte le format de la représentation sérialisée de la <see langword="DataSet" />.</summary>
        <returns><see langword="true" /> Si spécifié <see cref="T:System.Runtime.Serialization.SerializationInfo" /> représente un <see langword="DataSet" /> sérialisé dans son format binaire, <see langword="false" /> dans le cas contraire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre prend en charge l'infrastructure .NET Framework et n'est pas destiné à être utilisé directement à partir de votre code.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le <see cref="T:System.Data.DataSet" /> est initialisé.</summary>
        <value><see langword="true" /> pour indiquer que le composant a terminé l’initialisation ; sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retourne l’état de la <xref:System.Data.DataSet> pendant qu’il est en cours de construction, par exemple par Visual Studio. Le <xref:System.Data.DataSet.BeginInit%2A> méthode lui affecte `false` et <xref:System.Data.DataSet.EndInit%2A> méthode lui affecte `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remplit un <see cref="T:System.Data.DataSet" /> avec des valeurs à partir d’une source de données à l’aide de fourni <see cref="T:System.Data.IDataReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.Load%2A> méthode fournit une technique de remplissage d’un seul <xref:System.Data.DataTable> avec les données récupérées à partir d’un <xref:System.Data.IDataReader> instance. Cette méthode fournit les mêmes fonctionnalités, mais vous permet de charger plusieurs jeux de résultats à partir d’un `IDataReader` dans plusieurs tables d’un `DataSet`.  
  
 Si le `DataSet` contient déjà des lignes, les données entrantes à partir de la source de données sont fusionnées avec les lignes existantes.  
  
 Le `Load` méthode peut être utilisée dans plusieurs scénarios courants, tous centrés sur l’obtention de données à partir d’une source de données spécifiée et en l’ajoutant au conteneur de données actuel (dans ce cas, un `DataSet`). Les scénarios suivants décrivent l’utilisation standard pour un `DataSet`, décrivant sa mise à jour et le comportement de la fusion.  
  
 Un `DataSet` synchronise ou met à jour avec une source de données primaire. Le `DataSet` effectue le suivi des modifications, autorisant la synchronisation avec la source de données primaire. En outre, un `DataSet` peut accepter des données incrémentielles à partir d’une ou plusieurs sources de données secondaires. Le `DataSet` n’est pas responsable du suivi des modifications afin de permettre la synchronisation avec la source de données secondaire.  
  
 Étant donné ces deux sources de données hypothétiques, un utilisateur est susceptible de demander un des comportements suivants :  
  
-   Initialiser `DataSet` à partir d’une source de données principale. Dans ce scénario, l’utilisateur souhaite initialiser vide `DataSet` avec les valeurs de la source de données primaire. Un ou plusieurs de contenu du DataTable est modifiées. Plus tard l’utilisateur envisage de propager les modifications à la source de données primaire.  
  
-   Conserver les modifications et ré-synchroniser à partir de la source de données primaire. Dans ce scénario, l’utilisateur souhaite prendre le `DataSet` rempli dans le scénario précédent et exécuter une synchronisation incrémentielle avec la source de données principale, en conservant les modifications apportées dans le `DataSet`.  
  
-   Flux de données incrémentielles à partir de sources de données secondaires. Dans ce scénario, l’utilisateur souhaite fusionner les modifications à partir d’une ou plusieurs sources de données secondaires et propager ces modifications à la source de données primaire.  
  
 Le `Load` méthode rend tous ces scénarios possibles. Cette méthode vous permet de spécifier un paramètre d’option de chargement, indiquant comment les lignes déjà présentes dans un <xref:System.Data.DataTable> associées aux lignes en cours de chargement. Le tableau suivant décrit les trois options de chargement fournies par le <xref:System.Data.LoadOption> énumération. Dans chaque cas, la description indique le comportement lorsque la clé primaire d’une ligne dans les données entrantes correspond à la clé primaire d’une ligne existante.  
  
|Option de chargement|Description|  
|-----------------|-----------------|  
|`PreserveChanges` (par défaut)|Met à jour la version d’origine de la ligne avec la valeur de la ligne entrante.|  
|`OverwriteChanges`|Met à jour les versions actuelles et d’origine de la ligne avec la valeur de la ligne entrante.|  
|`Upsert`|Met à jour la version actuelle de la ligne avec la valeur de la ligne entrante.|  
  
 En règle générale, le `PreserveChanges` et `OverwriteChanges` options sont destinées aux scénarios dans lesquels l’utilisateur doit synchroniser le `DataSet` et ses modifications avec la source de données primaire. Le `Upsert` option facilite l’agrégation des modifications à partir d’une ou plusieurs sources de données secondaires.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Un <see cref="T:System.Data.IDataReader" /> qui fournit un ou plusieurs jeux de résultats.</param>
        <param name="loadOption">Une valeur comprise entre le <see cref="T:System.Data.LoadOption" /> énumération qui indique comment lignes déjà présentes dans le <see cref="T:System.Data.DataTable" /> instances dans le <see cref="T:System.Data.DataSet" /> à combiner avec les lignes entrantes qui partagent la même clé primaire.</param>
        <param name="tables">Un tableau de <see cref="T:System.Data.DataTable" /> instances, à partir duquel le <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> méthode récupère les informations de nom et espace de noms. Chacune de ces tables doit être un membre de la <see cref="T:System.Data.DataTableCollection" /> contenues par ce <see cref="T:System.Data.DataSet" />.</param>
        <summary>Remplit un <see cref="T:System.Data.DataSet" /> avec des valeurs à partir d’une source de données à l’aide de fourni <see cref="T:System.Data.IDataReader" />, à l’aide d’un tableau de <see cref="T:System.Data.DataTable" /> instances pour fournir les informations de schéma et d’espace de noms.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.Load%2A> méthode fournit une technique de remplissage d’un seul <xref:System.Data.DataTable> avec les données récupérées à partir d’un <xref:System.Data.IDataReader> instance. Cette méthode fournit les mêmes fonctionnalités, mais vous permet de charger plusieurs jeux de résultats à partir d’un <xref:System.Data.IDataReader> dans plusieurs tables d’un <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  L’opération de chargement échoue avec un <xref:System.InvalidOperationException> si les colonnes de données source en entrant `reader` sont des colonnes calculées.  
  
 Le `loadOption` paramètre vous permet de spécifier comment les données importées pour interagir avec des données existantes et peut prendre l’une des valeurs à partir de la <xref:System.Data.LoadOption> énumération. Consultez la documentation de la <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> (méthode) pour plus d’informations sur l’utilisation de ce paramètre.  
  
 Le `tables` paramètre vous permet de spécifier un tableau de <xref:System.Data.DataTable> instances, indiquant l’ordre des tables correspondant à chaque jeux de résultats chargés à partir du lecteur. Le <xref:System.Data.DataSet.Load%2A> méthode remplit chaque fourni <xref:System.Data.DataTable> instance avec les données en un seul jeu de résultats à partir du lecteur de données source. Après chaque jeu de résultats, le <xref:System.Data.DataSet.Load%2A> méthode passe au prochain jeu dans le lecteur, jusqu'à ce qu’il existe des jeux de résultats n’est plus de résultats.  
  
 Le schéma de résolution de noms de cette méthode est identique à celui suivi par le <xref:System.Data.Common.DbDataAdapter.Fill%2A> méthode de la <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Data.DataSet>, ajoute deux <xref:System.Data.DataTable> instances à la <xref:System.Data.DataSet>, puis remplit le <xref:System.Data.DataSet> à l’aide de la <xref:System.Data.DataSet.Load%2A> méthode, la récupération des données à partir d’un <xref:System.Data.DataTableReader> qui contient deux jeux de résultats. Enfin, l’exemple affiche le contenu des tables dans la fenêtre de console.  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * string[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Un <see cref="T:System.Data.IDataReader" /> qui fournit un ou plusieurs jeux de résultats.</param>
        <param name="loadOption">Une valeur comprise entre le <see cref="T:System.Data.LoadOption" /> énumération qui indique comment lignes déjà présentes dans le <see cref="T:System.Data.DataTable" /> instances dans le <see langword="DataSet" /> à combiner avec les lignes entrantes qui partagent la même clé primaire.</param>
        <param name="tables">Un tableau de chaînes, à partir duquel le <see langword="Load" /> méthode récupère les informations de nom de table.</param>
        <summary>Remplit un <see cref="T:System.Data.DataSet" /> avec des valeurs à partir d’une source de données à l’aide de fourni <see cref="T:System.Data.IDataReader" />, à l’aide d’un tableau de chaînes pour fournir les noms des tables dans le <see langword="DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.Load%2A> méthode fournit une technique de remplissage d’un seul <xref:System.Data.DataTable> avec les données récupérées à partir d’un <xref:System.Data.IDataReader> instance. Cette méthode fournit les mêmes fonctionnalités, mais vous permet de charger plusieurs jeux de résultats à partir d’un `IDataReader` dans plusieurs tables d’un `DataSet`.  
  
> [!NOTE]
>  L’opération de chargement échoue avec un <xref:System.InvalidOperationException> si les colonnes de données source en entrant `reader` sont des colonnes calculées.  
  
 Le `loadOption` paramètre vous permet de spécifier comment les données importées pour interagir avec des données existantes et peut prendre l’une des valeurs à partir de la <xref:System.Data.LoadOption> énumération. Consultez la documentation de la <xref:System.Data.DataTable.Load%2A> méthode pour plus d’informations sur l’utilisation de ce paramètre.  
  
 Le `tables` paramètre vous permet de spécifier un tableau de noms de table, indiquant l’ordre des tables correspondant à chaque jeux de résultats chargés à partir du lecteur. Le `Load` méthode essaie de rechercher une table dans le `DataSet` correspondant au nom trouvé dans le tableau de noms de table, dans l’ordre. Si une table de correspondance est trouvée, cette table est chargée avec le contenu du jeu de résultats actuel. Si aucune table correspondante n’est trouvée, une table est créée en utilisant le nom fourni dans le tableau de noms de table et schéma de la nouvelle table est déduit du jeu de résultats. Après chaque jeu de résultats, le `Load` méthode passe au prochain jeu dans le lecteur, jusqu'à ce qu’il existe des jeux de résultats n’est plus de résultats.  
  
 L’espace de noms par défaut associé `DataSet`, le cas échéant, est associé à chaque nouvellement créé `DataTable`. Le schéma de résolution de noms de cette méthode est identique à celui suivi par le <xref:System.Data.Common.DbDataAdapter.Fill%2A> méthode de la <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 Tout d’abord, l’exemple d’application Console suivant crée les tables et charge les données à partir d’un lecteur dans un <xref:System.Data.DataSet>, en utilisant le `Load` (méthode). L’exemple ajoute ensuite les tables à une <xref:System.Data.DataSet> et tente de se remplir les tables de données à partir d’un <xref:System.Data.DataTableReader>. Dans cet exemple, étant donné que les paramètres passés à la `Load` méthode indiquer un nom de table qui n’existe pas, le `Load` méthode crée une nouvelle table pour correspondre au nom passé comme paramètre. Une fois que les données ont été chargées, l’exemple affiche le contenu de toutes ses tables dans la fenêtre de Console.  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, errorHandler, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Un <see cref="T:System.Data.IDataReader" /> qui fournit un ou plusieurs jeux de résultats.</param>
        <param name="loadOption">Une valeur comprise entre le <see cref="T:System.Data.LoadOption" /> énumération qui indique comment lignes déjà présentes dans le <see cref="T:System.Data.DataTable" /> instances dans le <see cref="T:System.Data.DataSet" /> à combiner avec les lignes entrantes qui partagent la même clé primaire.</param>
        <param name="errorHandler">Un <see cref="T:System.Data.FillErrorEventHandler" /> délégué à appeler lorsqu’une erreur se produit lors du chargement des données.</param>
        <param name="tables">Un tableau de <see cref="T:System.Data.DataTable" /> instances, à partir duquel le <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> méthode récupère les informations de nom et espace de noms.</param>
        <summary>Remplit un <see cref="T:System.Data.DataSet" /> avec des valeurs à partir d’une source de données à l’aide de fourni <see cref="T:System.Data.IDataReader" />, à l’aide d’un tableau de <see cref="T:System.Data.DataTable" /> instances pour fournir les informations de schéma et d’espace de noms.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataTable.Load%2A> méthode fournit une technique de remplissage d’un seul <xref:System.Data.DataTable> avec les données récupérées à partir d’un <xref:System.Data.IDataReader> instance. Cette méthode fournit les mêmes fonctionnalités, mais vous permet de charger plusieurs jeux de résultats à partir d’un <xref:System.Data.IDataReader> dans plusieurs tables d’un <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  L’opération de chargement échoue avec un <xref:System.InvalidOperationException> si les colonnes de données source en entrant `reader` sont des colonnes calculées.  
  
 Le `loadOption` paramètre vous permet de spécifier comment les données importées pour interagir avec des données existantes et peut prendre l’une des valeurs à partir de la <xref:System.Data.LoadOption> énumération. Consultez la documentation de la <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> (méthode) pour plus d’informations sur l’utilisation de ce paramètre.  
  
 Le `errorHandler` paramètre est un <xref:System.Data.FillErrorEventHandler> délégué qui fait référence à une procédure qui est appelée lorsqu’une erreur se produit lors du chargement des données. Le <xref:System.Data.FillErrorEventArgs> paramètre transmis à la procédure fournit des propriétés qui vous permettent de récupérer des informations sur l’erreur qui s’est produite, la ligne actuelle de données, et le <xref:System.Data.DataTable> remplie. À l’aide de ce mécanisme de délégué, au lieu d’un bloc try/catch plus simple, vous permet de déterminer l’erreur, gérer la situation et continuer le traitement si vous le souhaitez. Le <xref:System.Data.FillErrorEventArgs> paramètre fournit un <xref:System.Data.FillErrorEventArgs.Continue%2A> propriété : définissez cette propriété sur `true` pour indiquer que vous avez géré l’erreur et souhaitez continuer le traitement ; affectez à la propriété `false` pour indiquer que vous souhaitez arrêter le traitement. N’oubliez pas que la définition de la propriété `false` provoque le code qui a déclenché le problème pour lever une exception.  
  
 Le `tables` paramètre vous permet de spécifier un tableau de <xref:System.Data.DataTable> instances, indiquant l’ordre des tables correspondant à chaque jeux de résultats chargés à partir du lecteur. Le <xref:System.Data.DataSet.Load%2A> méthode remplit chaque fourni <xref:System.Data.DataTable> instance avec les données en un seul jeu de résultats à partir du lecteur de données source. Après chaque jeu de résultats, le <xref:System.Data.DataSet.Load%2A> méthode passe au prochain jeu dans le lecteur, jusqu'à ce qu’il existe des jeux de résultats n’est plus de résultats.  
  
 Le schéma de résolution de noms de cette méthode est identique à celui suivi par le <xref:System.Data.Common.DbDataAdapter.Fill%2A> méthode de la <xref:System.Data.Common.DbDataAdapter> classe.  
  
   
  
## Examples  
 L’exemple suivant ajoute une table à une <xref:System.Data.DataSet>, puis tente d’utiliser le <xref:System.Data.DataSet.Load%2A> méthode pour charger des données à partir d’un <xref:System.Data.DataTableReader> qui contient un schéma incompatible. Au lieu d’intercepter l’erreur, cet exemple utilise un <xref:System.Data.FillErrorEventHandler> délégué pour examiner et gérer l’erreur. La sortie s’affiche dans la fenêtre de console.  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les informations de paramètres régionaux utilisées pour comparer des chaînes dans la table.</summary>
        <value>Un <see cref="T:System.Globalization.CultureInfo" /> qui contient les données relatives aux paramètres régionaux de la machine de l’utilisateur. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Locale%2A> propriété spécifie les paramètres régionaux auxquels le tri s’applique.  
  
 Par le paramètre par défaut, le <xref:System.Data.DataSet.Locale%2A> pour un <xref:System.Data.DataSet> définit également la <xref:System.Data.DataSet.Locale%2A> pour chaque <xref:System.Data.DataTable> objet dans qui `DataSet` sur la même valeur.  
  
> [!NOTE]
>  Dans les colonnes qui contiennent des expressions, le <xref:System.StringComparison.InvariantCulture> est utilisé. Le <xref:System.StringComparison.CurrentCulture> est ignoré.  
  
   
  
## Examples  
 L’exemple suivant obtient le <xref:System.Globalization.CultureInfo> pour un <xref:System.Data.DataSet> et imprime la <xref:System.Globalization.CultureInfo.DisplayName%2A> et <xref:System.Globalization.CultureInfo.EnglishName%2A> propriétés.  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fusionne un <see cref="T:System.Data.DataSet" />, <see cref="T:System.Data.DataTable" />, ou un tableau de <see cref="T:System.Data.DataRow" /> objets dans la zone actuelle <see langword="DataSet" /> ou <see langword="DataTable" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] -&gt; unit" Usage="dataSet.Merge rows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">Le tableau de <see langword="DataRow" /> objets à fusionner dans le <see langword="DataSet" />.</param>
        <summary>Fusionne un tableau de <see cref="T:System.Data.DataRow" /> objets dans la zone actuelle <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée sur une application cliente pour incorporer les dernières modifications à partir d’une source de données dans une existante <xref:System.Data.DataSet>. Cela permet à l’application cliente avoir un actualisé <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, harmonisation des erreurs, la mise à jour de la source de données avec les modifications et enfin l’actualisation existant <xref:System.Data.DataSet>.  
  
 Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de les envoyer à un composant de couche intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet contient uniquement le <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, ce qui entraîne un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit et donc être passé plus efficacement à un composant de couche intermédiaire. Le composant de couche intermédiaire puis met à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications qui ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées à l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changés. Par exemple, dans un scénario business-to-business, nouvelles colonnes peuvent ont été ajoutées à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après avoir fusionné les schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaires. Source des lignes avec un <xref:System.Data.DataRowState> valeur `Added` sont mis en correspondance avec les nouvelles lignes cible avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes de code source.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin d’une fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de réinitialiser le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet -&gt; unit" Usage="dataSet.Merge dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">Le <see langword="DataSet" /> dont les données et schéma va être fusionnées.</param>
        <summary>Fusionne un <see cref="T:System.Data.DataSet" /> et son schéma dans actuel <see langword="DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée sur une application cliente pour incorporer les dernières modifications à partir d’une source de données dans une existante <xref:System.Data.DataSet>. Cela permet à l’application cliente avoir un actualisé <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, harmonisation des erreurs, la mise à jour de la source de données avec les modifications et enfin l’actualisation existant <xref:System.Data.DataSet>.  
  
 Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de les envoyer à un composant de couche intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet contient uniquement le <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, ce qui entraîne un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit, et donc passé plus efficacement à un composant de couche intermédiaire. Le composant de couche intermédiaire puis met à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications qui ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées à l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changés. Par exemple, dans un scénario business-to-business, nouvelles colonnes peuvent ont été ajoutées à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après avoir fusionné les schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaires. Source des lignes avec un `DataRowState` valeur `Added` sont mis en correspondance avec les nouvelles lignes cible avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes de code source.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de réinitialiser le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Data.DataSet.GetChanges%2A>, mise à jour, et <xref:System.Data.DataSet.Merge%2A> méthodes sur un <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Une ou plusieurs contraintes ne peut pas être activées.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataSet.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Le <see cref="T:System.Data.DataTable" /> dont les données et schéma va être fusionnées.</param>
        <summary>Fusionne un <see cref="T:System.Data.DataTable" /> et son schéma dans actuel <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée sur une application cliente pour incorporer les dernières modifications à partir d’une source de données dans une existante <xref:System.Data.DataSet>. Cela permet à l’application cliente avoir un actualisé <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, harmonisation des erreurs, la mise à jour de la source de données avec les modifications et enfin l’actualisation existant <xref:System.Data.DataSet>.  
  
 Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de les envoyer à un composant de couche intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet contient uniquement le <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, ce qui entraîne un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit, et donc passé plus efficacement à un composant de couche intermédiaire. Le composant de couche intermédiaire puis met à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications qui ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées à l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changés. Par exemple, dans un scénario business-to-business, nouvelles colonnes peuvent ont été ajoutées à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après avoir fusionné les schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaires. Source des lignes avec un `DataRowState` valeur `Added` sont mis en correspondance avec les nouvelles lignes cible avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes de code source.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de réinitialiser le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un simple <xref:System.Data.DataSet> avec une table, deux colonnes et dix lignes. Une seconde <xref:System.Data.DataTable> est créé, qui est identique à la première. Deux lignes sont ajoutées à la deuxième table, qui est ensuite fusionnée dans la <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="table" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">Le <see langword="DataSet" /> dont les données et schéma va être fusionnées.</param>
        <param name="preserveChanges"><see langword="true" /> Pour conserver les modifications en cours <see langword="DataSet" />; sinon <see langword="false" />.</param>
        <summary>Fusionne un <see cref="T:System.Data.DataSet" /> et son schéma dans actuel <see langword="DataSet" />, en préservant ou en ignorant les modifications dans ce <see langword="DataSet" /> en fonction de l’argument donné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée sur une application cliente pour incorporer les dernières modifications à partir d’une source de données dans une existante <xref:System.Data.DataSet>. Cela permet à l’application cliente avoir un actualisé <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, harmonisation des erreurs, la mise à jour de la source de données avec les modifications et enfin l’actualisation existant <xref:System.Data.DataSet>.  
  
 Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de les envoyer à un composant de couche intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet contient uniquement le <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, ce qui entraîne un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit, et donc passé plus efficacement à un composant de couche intermédiaire. Le composant de couche intermédiaire puis met à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications qui ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées à l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changés. Par exemple, dans un scénario business-to-business, nouvelles colonnes peuvent ont été ajoutées à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après avoir fusionné les schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaires. Source des lignes avec un `DataRowState` valeur `Added` sont mis en correspondance avec les nouvelles lignes cible avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes de code source.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de réinitialiser le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un simple <xref:System.Data.DataSet> avec une table, deux colonnes et dix lignes. Après avoir ajouté les dix lignes, deux valeurs sont modifiées, et une ligne est ajoutée. Un sous-ensemble des données modifiées est créé à l’aide de la <xref:System.Data.DataSet.GetChanges%2A> (méthode). Réconciliation des erreurs, les données du sous-ensemble sont fusionnées dans la version d’origine <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (rows, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">Le tableau de <see cref="T:System.Data.DataRow" /> objets à fusionner dans le <see langword="DataSet" />.</param>
        <param name="preserveChanges"><see langword="true" /> Pour conserver les modifications dans le <see langword="DataSet" />; sinon <see langword="false" />.</param>
        <param name="missingSchemaAction">Une des valeurs de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Fusionne un tableau de <see cref="T:System.Data.DataRow" /> objets dans la zone actuelle <see cref="T:System.Data.DataSet" />, en préservant ou en supprimant les modifications dans le <see langword="DataSet" /> et traitant un schéma incompatible conformément aux arguments donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée sur une application cliente pour incorporer les dernières modifications à partir d’une source de données dans une existante <xref:System.Data.DataSet>. Cela permet à l’application cliente avoir un actualisé <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, harmonisation des erreurs, la mise à jour de la source de données avec les modifications et enfin l’actualisation existant <xref:System.Data.DataSet>.  
  
 Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de les envoyer à un composant de couche intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet contient uniquement le <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, ce qui entraîne un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit, et donc passé plus efficacement à un composant de couche intermédiaire. Le composant de couche intermédiaire puis met à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications qui ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées à l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Pour faciliter l’explication de la <xref:System.Data.DataSet.Merge%2A> (méthode), nous utilisons « cible » pour signifier actuel <xref:System.Data.DataSet>et « source » pour le deuxième (paramètre) <xref:System.Data.DataSet>. La cible <xref:System.Data.DataSet> est nommée ainsi car c’est l’objet sur lequel une action (la fusion) se produit. La seconde <xref:System.Data.DataSet> est appelée une « source », car les informations qu’il contient ne changent pas, mais au lieu de cela sont fusionnées dans actuel <xref:System.Data.DataSet>.  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changés. Par exemple, dans un scénario business-to-business, nouvelles colonnes peuvent ont été ajoutées à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après avoir fusionné les schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaires. Source des lignes avec un `DataRowState` valeur `Added` sont mis en correspondance avec les nouvelles lignes cible avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes de code source.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de réinitialiser le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">Le <see langword="DataSet" /> dont les données et schéma va être fusionnées.</param>
        <param name="preserveChanges"><see langword="true" /> Pour conserver les modifications en cours <see langword="DataSet" />; sinon <see langword="false" />.</param>
        <param name="missingSchemaAction">Une des valeurs de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Fusionne un <see cref="T:System.Data.DataSet" /> et son schéma avec actuel <see langword="DataSet" />, en préservant ou en supprimant les modifications en cours <see langword="DataSet" /> et traitant un schéma incompatible conformément aux arguments donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée sur une application cliente pour incorporer les dernières modifications à partir d’une source de données dans une existante <xref:System.Data.DataSet>. Cela permet à l’application cliente avoir un actualisé <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, harmonisation des erreurs, la mise à jour de la source de données avec les modifications et enfin l’actualisation existant <xref:System.Data.DataSet>.  
  
 Dans une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de les envoyer à un composant de couche intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet contient uniquement le <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, ce qui entraîne un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit, et donc passé plus efficacement à un composant de couche intermédiaire. Le composant de couche intermédiaire puis met à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications qui ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées à l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Pour faciliter l’explication de la <xref:System.Data.DataSet.Merge%2A> (méthode), nous utilisons « cible » pour signifier actuel <xref:System.Data.DataSet>et « source » pour le deuxième (paramètre) <xref:System.Data.DataSet>. La cible <xref:System.Data.DataSet> est nommée ainsi car c’est l’objet sur lequel une action (la fusion) se produit. La seconde <xref:System.Data.DataSet> est appelée une « source », car les informations qu’il contient ne changent pas, mais au lieu de cela sont fusionnées dans actuel <xref:System.Data.DataSet>.  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changés. Par exemple, dans un scénario business-to-business, nouvelles colonnes peuvent ont été ajoutées à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après avoir fusionné les schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaires. Source des lignes avec un `DataRowState` valeur `Added` sont mis en correspondance avec les nouvelles lignes cible avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes de code source.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de réinitialiser le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un simple <xref:System.Data.DataSet> avec une table, deux colonnes et dix lignes. Deux valeurs sont modifiées, et une ligne est ajoutée. Un sous-ensemble des données modifiées est créé à l’aide de la <xref:System.Data.DataSet.GetChanges%2A> (méthode). Après la réconciliation des erreurs, une nouvelle colonne est ajoutée au sous-ensemble, modification du schéma. Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée avec le `missingSchemaAction` définie sur `MissingSchemaAction.Add`, la nouvelle colonne est ajoutée à l’original <xref:System.Data.DataSet> schéma de l’objet.  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">Le <see langword="DataTable" /> dont les données et schéma va être fusionnées.</param>
        <param name="preserveChanges">Une des valeurs de <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <param name="missingSchemaAction"><see langword="true" /> Pour conserver les modifications dans le <see langword="DataSet" />; sinon <see langword="false" />.</param>
        <summary>Fusionne un <see cref="T:System.Data.DataTable" /> et son schéma dans actuel <see langword="DataSet" />, en préservant ou en supprimant les modifications dans le <see langword="DataSet" /> et traitant un schéma incompatible conformément aux arguments donnés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est utilisée pour fusionner deux <xref:System.Data.DataSet> objets qui ont des schémas très similaires. Une fusion est généralement utilisée sur une application cliente pour incorporer les dernières modifications à partir d’une source de données dans une existante <xref:System.Data.DataSet>. Cela permet à l’application cliente avoir un actualisé <xref:System.Data.DataSet> avec les données les plus récentes à partir de la source de données.  
  
 Le <xref:System.Data.DataSet.Merge%2A> méthode est généralement appelée à la fin d’une série de procédures qui impliquent la validation des modifications, harmonisation des erreurs, la mise à jour de la source de données avec les modifications et enfin l’actualisation existant <xref:System.Data.DataSet>.  
  
 une application cliente, il est courant d’avoir un seul bouton l’utilisateur peut cliquer qui rassemble les données modifiées et le valide avant de les envoyer à un composant de couche intermédiaire. Dans ce scénario, le <xref:System.Data.DataSet.GetChanges%2A> méthode est appelée en premier. Cette méthode retourne un deuxième <xref:System.Data.DataSet> optimisé pour la validation et la fusion. Cette seconde <xref:System.Data.DataSet> objet contient uniquement le <xref:System.Data.DataTable> et <xref:System.Data.DataRow> les objets qui ont été modifiés, ce qui entraîne un sous-ensemble de l’original <xref:System.Data.DataSet>. Ce sous-ensemble est généralement plus petit, et donc passé plus efficacement à un composant de couche intermédiaire. Le composant de couche intermédiaire puis met à jour la source de données d’origine avec les modifications apportées par le biais des procédures stockées. La couche intermédiaire renvoie alors un nouveau <xref:System.Data.DataSet> qui inclut des données d’origine et les données les plus récentes à partir de la source de données (en exécutant à nouveau la requête d’origine), ou il peut envoyer le sous-ensemble avec toutes les modifications qui ont été apportées à partir de la source de données. (Par exemple, si la source de données crée automatiquement des valeurs de clé primaire uniques, ces valeurs peuvent être propagées à l’application cliente.) Dans les deux cas, retourné <xref:System.Data.DataSet> peuvent être fusionnées dans d’origine de l’application cliente <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.Merge%2A> (méthode).  
  
 Lorsque le <xref:System.Data.DataSet.Merge%2A> méthode est appelée, les schémas des deux <xref:System.Data.DataSet> objets sont comparées, car il est possible que les schémas peuvent avoir été changés. Par exemple, dans un scénario business-to-business, nouvelles colonnes peuvent ont été ajoutées à un schéma XML par un processus automatisé. Si la source de <xref:System.Data.DataSet> contient les éléments de schéma (ajouté <xref:System.Data.DataColumn> objets) qui sont manquants dans la cible, les éléments de schéma peuvent être ajoutés à la cible en définissant le `missingSchemaAction` argument `MissingSchemaAction.Add`. Dans ce cas, les données fusionné <xref:System.Data.DataSet> contient les données et le schéma ajouté.  
  
 Après avoir fusionné les schémas, les données sont fusionnées.  
  
 Lors de la fusion d’une nouvelle source de <xref:System.Data.DataSet> dans la cible, toutes les lignes sources avec un <xref:System.Data.DataRowState> valeur `Unchanged`, `Modified`, ou `Deleted` sont mis en correspondance avec les lignes cibles ayant les mêmes valeurs de clé primaires. Source des lignes avec un `DataRowState` valeur `Added` sont mis en correspondance avec les nouvelles lignes cible avec les mêmes valeurs de clé primaires en tant que les nouvelles lignes de code source.  
  
 Pendant une fusion, les contraintes sont désactivées. Si toutes les contraintes ne peuvent pas être activés à la fin de la fusion, un <xref:System.Data.ConstraintException> est généré et les données fusionnées sont conservées alors que les contraintes sont désactivées. Dans ce cas, le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété est définie sur `false`, et toutes les lignes qui ne sont pas valides sont marquées comme erreur. Les erreurs doivent être résolues avant de tenter de réinitialiser le <xref:System.Data.DataSet.EnforceConstraints%2A> propriété `true`.  
  
   
  
## Examples  
 L’exemple suivant crée un simple <xref:System.Data.DataSet> avec une table, deux colonnes et dix lignes. Une seconde <xref:System.Data.DataTable> est créé, qui est presque identique à la première, sauf qu’un nouveau `DataColumn` est ajouté à la table. Deux lignes sont ajoutées à la deuxième table, qui est ensuite fusionnée avec la <xref:System.Data.DataSet> avec la `preserveChanges` affectée à l’argument `false`et le `missingSchemaAction` affectée à l’argument `MissingSchemaAction.Add`.  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" /> a la valeur <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberSignature Language="F#" Value="member this.MergeFailed : System.Data.MergeFailedEventHandler " Usage="member this.MergeFailed : System.Data.MergeFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetMergeFailedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la cible et source <see cref="T:System.Data.DataRow" /> ont la même valeur de clé primaire et <see cref="P:System.Data.DataSet.EnforceConstraints" /> est définie sur true.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.Data.DataSet.MergeFailed> événement.  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l’espace de noms de la <see cref="T:System.Data.DataSet" />.</summary>
        <value>L’espace de noms du <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Namespace%2A> propriété est utilisée lors de la lecture et écriture d’un document XML document dans le <xref:System.Data.DataSet> à l’aide de la <xref:System.Data.DataSet.ReadXml%2A>, <xref:System.Data.DataSet.WriteXml%2A>, <xref:System.Data.DataSet.ReadXmlSchema%2A>, ou <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes.  
  
 L’espace de noms d’un document XML est utilisé pour définir la portée des attributs XML et les éléments lors de la lecture dans un <xref:System.Data.DataSet>. Par exemple, si un <xref:System.Data.DataSet> contient un schéma qui a été lu à partir d’un document avec l’espace de noms « myCompany » et une tentative est effectuée pour lire des données uniquement à partir d’un document avec un espace de noms différent, les données qui ne correspondant pas au schéma existant sont ignorées.  
  
   
  
## Examples  
 L’exemple suivant définit la <xref:System.Data.DataSet.Prefix%2A> avant d’appeler le <xref:System.Data.DataSet.ReadXml%2A> (méthode).  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’espace de noms comporte déjà des données.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataSet.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent"><see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour une vue d’ensemble, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> (méthode).</para></block>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveRelation : System.Data.DataRelation -&gt; unit&#xA;override this.OnRemoveRelation : System.Data.DataRelation -&gt; unit" Usage="dataSet.OnRemoveRelation relation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">Le <see cref="T:System.Data.DataRelation" /> en cours de suppression.</param>
        <summary>Se produit lorsqu’un <see cref="T:System.Data.DataRelation" /> objet est supprimé à partir d’un <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit être substituée par les sous-classes pour restreindre les tables en cours de suppression  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveTable : System.Data.DataTable -&gt; unit&#xA;override this.OnRemoveTable : System.Data.DataTable -&gt; unit" Usage="dataSet.OnRemoveTable table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Le <see cref="T:System.Data.DataTable" /> en cours de suppression.</param>
        <summary>Se produit lorsqu’un <see cref="T:System.Data.DataTable" /> est supprimé à partir d’un <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par les sous-classes pour restreindre les tables d’être supprimé.  
  
   
  
## Examples  
 L’exemple suivant montre une classe dérivée de la <xref:System.Data.DataSet> avec la <xref:System.Data.DataSet.OnRemoveTable%2A> méthode substituée.  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetPrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un document XML qui associe un alias de préfixe l’espace de noms de la <see cref="T:System.Data.DataSet" />.</summary>
        <value>Le préfixe XML pour le <see cref="T:System.Data.DataSet" /> espace de noms.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.Prefix%2A> propriété est utilisée tout au long d’un document XML pour identifier les éléments qui appartiennent à l’espace de noms de la <xref:System.Data.DataSet> objet (tels que définis par le <xref:System.Data.DataSet.Namespace%2A> propriété).  
  
   
  
## Examples  
 L’exemple suivant définit la <xref:System.Data.DataSet.Prefix%2A> avant d’appeler le <xref:System.Data.DataSet.ReadXml%2A> (méthode).  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RaisePropertyChanging : string -&gt; unit" Usage="dataSet.RaisePropertyChanging name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Le nom de la propriété qui va être modifiée.</param>
        <summary>Envoie une notification qui spécifié <see cref="T:System.Data.DataSet" /> propriété est va être modifiée.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit le schéma XML et les données dans le <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Un objet qui dérive de <see cref="T:System.IO.Stream" />.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataSet" /> à l'aide du <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <returns>Le <see cref="T:System.Data.XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, tandis que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma inline est utilisé pour étendre la structure relationnelle existante avant de charger les données. S’il existe des conflits (par exemple, la même colonne dans la même table définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma inline est spécifié, la structure relationnelle est étendue par inférence, en fonction des besoins, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML légaux comme (« _ ») sont ignorés dans le code XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lorsque les caractères valides dans le nom d’élément XML sont ignorés, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut `targetNamespace`, les données ne peuvent pas être lues et vous pouvez rencontrer des exceptions lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> avec XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML, comme le montre l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient les éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée d’abord une simple <xref:System.Data.DataSet> avec un <xref:System.Data.DataTable>, deux colonnes et dix lignes. Le <xref:System.Data.DataSet> schéma et les données sont écrites sur le disque en appelant le <xref:System.Data.DataSet.WriteXml%2A> (méthode). Une seconde <xref:System.Data.DataSet> est créé et le <xref:System.Data.DataSet.ReadXml%2A> méthode sert à remplir avec le schéma et données.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see langword="TextReader" /> à partir duquel lire le schéma et les données.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataSet" /> à l'aide du <see cref="T:System.IO.TextReader" /> spécifié.</summary>
        <returns>Le <see cref="T:System.Data.XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, tandis que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma inline est utilisé pour étendre la structure relationnelle existante avant de charger les données. S’il existe des conflits (par exemple, la même colonne dans la même table définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma inline est spécifié, la structure relationnelle est étendue par inférence, en fonction des besoins, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML légaux comme (« _ ») sont ignorés dans le code XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lorsque les caractères valides dans le nom d’élément XML sont ignorés, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut `targetNamespace`, les données ne peuvent pas être lues et vous pouvez rencontrer des exceptions lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> avec XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme le montre l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 Les classes qui héritent de la <xref:System.IO.TextReader> classe incluent le <xref:System.IO.StreamReader> et <xref:System.IO.StringReader> classes.  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient les éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée d’abord une simple <xref:System.Data.DataSet> avec un <xref:System.Data.DataTable>, deux colonnes et dix lignes. Le <xref:System.Data.DataSet> schéma et les données sont écrites sur le disque en appelant le <xref:System.Data.DataSet.WriteXml%2A> (méthode). Une seconde <xref:System.Data.DataSet> est créé et le <xref:System.Data.DataSet.ReadXml%2A> méthode sert à remplir avec le schéma et données.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Le nom de fichier (y compris le chemin d’accès) à partir duquel lire.</param>
        <summary>Lit le schéma XML et les données dans le <see cref="T:System.Data.DataSet" /> à l’aide du fichier spécifié.</summary>
        <returns>Le <see langword="XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, tandis que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma inline est utilisé pour étendre la structure relationnelle existante avant de charger les données. S’il existe des conflits (par exemple, la même colonne dans la même table définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma inline est spécifié, la structure relationnelle est étendue par inférence, en fonction des besoins, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML légaux comme (« _ ») sont ignorés dans le code XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lorsque les caractères valides dans le nom d’élément XML sont ignorés, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut un `targetNamespace`, les données ne peuvent pas être lues et vous pouvez rencontrer des exceptions lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> avec XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme le montre l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient les éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée d’abord une simple <xref:System.Data.DataSet> avec un <xref:System.Data.DataTable>, deux colonnes et dix lignes. Le <xref:System.Data.DataSet> schéma et les données sont écrites sur le disque en appelant le <xref:System.Data.DataSet.WriteXml%2A> (méthode). Une seconde <xref:System.Data.DataSet> est créé et le <xref:System.Data.DataSet.ReadXml%2A> méthode sert à remplir avec le schéma et données.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> n’a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Le <see cref="T:System.Xml.XmlReader" /> à partir duquel lire.</param>
        <summary>Lit le schéma et les données XML dans le <see cref="T:System.Data.DataSet" /> à l'aide du <see cref="T:System.Xml.XmlReader" /> spécifié.</summary>
        <returns>Le <see langword="XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, tandis que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma inline est utilisé pour étendre la structure relationnelle existante avant de charger les données. S’il existe des conflits (par exemple, la même colonne dans la même table définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma inline est spécifié, la structure relationnelle est étendue par inférence, en fonction des besoins, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML légaux comme (« _ ») sont ignorés dans le code XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lorsque les caractères valides dans le nom d’élément XML sont ignorés, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut un `targetNamespace`, les données ne peuvent pas être lues et vous pouvez rencontrer des exceptions lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> avec XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme le montre l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> hérite de <xref:System.Xml.XmlReader>.  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient les éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée d’abord une simple <xref:System.Data.DataSet> avec un <xref:System.Data.DataTable>, deux colonnes et dix lignes. Le <xref:System.Data.DataSet> schéma et les données sont écrites sur le disque en appelant le <xref:System.Data.DataSet.WriteXml%2A> (méthode). Une seconde <xref:System.Data.DataSet> est créé et le <xref:System.Data.DataSet.ReadXml%2A> méthode sert à remplir avec le schéma et données.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">Le <see cref="T:System.IO.Stream" /> à partir duquel lire.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lit le schéma XML et les données dans le <see cref="T:System.Data.DataSet" /> à l’aide de la <see cref="T:System.IO.Stream" /> et <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>Le <see langword="XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, tandis que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Vaut également pour le <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Lorsque vous utilisez <xref:System.Data.DataSet.ReadXml%2A> et que vous définissez <xref:System.Data.XmlReadMode> à `Diffgram`, le contenu de la cible `DataSet` et la version d’origine `DataSet` peuvent différer en raison de la façon dont le diffgram est généré et traité. Pour plus d’informations sur diffgrams, voir [DiffGrams](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma inline est utilisé pour étendre la structure relationnelle existante avant de charger les données. S’il existe des conflits (par exemple, la même colonne dans la même table définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma inline est spécifié, la structure relationnelle est étendue par inférence, en fonction des besoins, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML légaux comme (« _ ») sont ignorés dans le code XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lorsque les caractères valides dans le nom d’élément XML sont ignorés, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut `targetNamespace`, les données ne peuvent pas être lues et vous pouvez rencontrer des exceptions lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> avec XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme le montre l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient les éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">Le <see cref="T:System.IO.TextReader" /> à partir duquel lire.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lit le schéma XML et les données dans le <see cref="T:System.Data.DataSet" /> à l’aide de la <see cref="T:System.IO.TextReader" /> et <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>Le <see langword="XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, tandis que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma inline est utilisé pour étendre la structure relationnelle existante avant de charger les données. S’il existe des conflits (par exemple, la même colonne dans la même table définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma inline est spécifié, la structure relationnelle est étendue par inférence, en fonction des besoins, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML légaux comme (« _ ») sont ignorés dans le code XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lorsque les caractères valides dans le nom d’élément XML sont ignorés, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut `targetNamespace`, les données ne peuvent pas être lues et vous pouvez rencontrer des exceptions lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> avec XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme le montre l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient les éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Le nom de fichier (y compris le chemin d’accès) à partir duquel lire.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lit le schéma XML et les données dans le <see cref="T:System.Data.DataSet" /> à l’aide du fichier spécifié et <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>Le <see langword="XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, tandis que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma inline est utilisé pour étendre la structure relationnelle existante avant de charger les données. S’il existe des conflits (par exemple, la même colonne dans la même table définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma inline est spécifié, la structure relationnelle est étendue par inférence, en fonction des besoins, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML légaux comme (« _ ») sont ignorés dans le code XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lorsque les caractères valides dans le nom d’élément XML sont ignorés, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut un `targetNamespace`, les données ne peuvent pas être lues et vous pouvez rencontrer des exceptions lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> avec XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme le montre l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient les éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> n’a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">Le <see cref="T:System.Xml.XmlReader" /> à partir duquel lire.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Lit le schéma XML et les données dans le <see cref="T:System.Data.DataSet" /> à l’aide de la <see cref="T:System.Xml.XmlReader" /> et <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>Le <see langword="XmlReadMode" /> utilisé pour lire les données.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Data.DataSet.ReadXml%2A> méthode fournit un moyen de lire seulement les données, ou schéma et les données dans un <xref:System.Data.DataSet> à partir d’un document XML, tandis que le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode lit uniquement le schéma. Pour lire les données et le schéma, utilisez une de la `ReadXML` surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `ReadSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.WriteXml%2A> et <xref:System.Data.DataSet.WriteXmlSchema%2A> méthodes, respectivement. Pour écrire des données XML, ou le schéma et les données à partir de la `DataSet`, utilisez le `WriteXml` (méthode). Pour écrire uniquement le schéma, utilisez la `WriteXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Si un schéma en ligne est spécifié, le schéma inline est utilisé pour étendre la structure relationnelle existante avant de charger les données. S’il existe des conflits (par exemple, la même colonne dans la même table définie avec différents types de données), une exception est levée.  
  
 Si aucun schéma inline est spécifié, la structure relationnelle est étendue par inférence, en fonction des besoins, en fonction de la structure du document XML. Si le schéma ne peut pas être étendu par inférence afin d’exposer toutes les données, une exception est levée.  
  
> [!NOTE]
>  Le `DataSet` n’associe pas un élément XML avec ses correspondant `DataColumn` ou `DataTable` lorsque les caractères XML légaux comme (« _ ») sont ignorés dans le code XML sérialisé. Le `DataSet` lui-même ignore uniquement les caractères XML non conformes dans les noms d’élément XML et peut donc uniquement utiliser les mêmes. Lorsque les caractères valides dans le nom d’élément XML sont ignorés, l’élément est ignoré lors du traitement.  
  
 Si le schéma XML pour un <xref:System.Data.DataSet> inclut un `targetNamespace`, les données ne peuvent pas être lues et vous pouvez rencontrer des exceptions lors de l’appel <xref:System.Data.DataSet.ReadXml%2A> pour charger le <xref:System.Data.DataSet> avec XML qui contient des éléments sans espace de noms qualifiant. Pour lire des éléments non qualifiés, définissez `elementFormDefault` égale à « qualified » dans votre schéma XML comme le montre l’exemple suivant.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient les éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXml%2A> en spécifiant `XmlReadMode.ReadSchema`. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit un schéma XML dans le <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Le <see cref="T:System.IO.Stream" /> à partir duquel lire.</param>
        <summary>Lit le schéma XML à partir du spécifié <see cref="T:System.IO.Stream" /> dans le <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode pour créer le schéma pour un <xref:System.Data.DataSet>. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
> [!NOTE]
>  Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas. Aucune exception n’est levée.  
  
 Le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode est généralement appelée avant la <xref:System.Data.DataSet.ReadXml%2A> méthode qui est utilisée pour remplir le <xref:System.Data.DataSet>.  
  
 Les classes qui dérivent de la <xref:System.IO.Stream> classe inclure <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, et <xref:System.Net.Sockets.NetworkStream>.  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient les éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXmlSchema%2A>. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.IO.FileStream> permettant de lire un schéma XML de l’objet et appelle le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode avec l’objet.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Le <see cref="T:System.IO.TextReader" /> à partir duquel lire.</param>
        <summary>Lit le schéma XML à partir du spécifié <see cref="T:System.IO.TextReader" /> dans le <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode pour créer le schéma pour un <xref:System.Data.DataSet>. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
> [!NOTE]
>  Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas. Aucune exception n’est levée.  
  
 Le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode est généralement appelée avant la <xref:System.Data.DataSet.ReadXml%2A> méthode qui est utilisée pour remplir le <xref:System.Data.DataSet>.  
  
 Les classes qui héritent de la <xref:System.IO.TextReader> classe incluent le <xref:System.IO.StreamReader> et <xref:System.IO.StringReader> classes.  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient les éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXmlSchema%2A>. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.IO.StreamReader> permettant de lire un schéma de l’objet et appelle le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode avec l’objet.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataSet.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Le fichier de nom (y compris le chemin d’accès) à partir duquel lire.</param>
        <summary>Lit le schéma XML à partir du fichier spécifié dans le <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode pour créer le schéma pour un <xref:System.Data.DataSet>. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
> [!NOTE]
>  Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas. Aucune exception n’est levée.  
  
 Le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode est généralement appelée avant la <xref:System.Data.DataSet.ReadXml%2A> méthode qui est utilisée pour remplir le <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient les éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXmlSchema%2A>. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> n’a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Le <see cref="T:System.Xml.XmlReader" /> à partir duquel lire.</param>
        <summary>Lit le schéma XML à partir du spécifié <see cref="T:System.Xml.XmlReader" /> dans le <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode pour créer le schéma pour un <xref:System.Data.DataSet>. Le schéma inclut des définitions de table, des relations et des contraintes.  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
> [!NOTE]
>  Une altération des données peut se produire si l’être et les types xs : type ne correspondent pas. Aucune exception n’est levée.  
  
 Le <xref:System.Data.DataSet.ReadXmlSchema%2A> méthode est généralement appelée avant la <xref:System.Data.DataSet.ReadXml%2A> méthode qui est utilisée pour remplir le <xref:System.Data.DataSet>.  
  
 Le <xref:System.Xml.XmlReader?displayProperty=nameWithType> classe est abstraite. Une classe qui hérite de la `XmlReader` est la <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> classe.  
  
> [!NOTE]
>  Si le schéma pour votre <xref:System.Data.DataSet> contient les éléments du même nom, mais un type différent, dans le même espace de noms, une exception est levée lorsque vous tentez de lire le schéma dans le <xref:System.Data.DataSet> avec <xref:System.Data.DataSet.ReadXmlSchema%2A>. Cette exception ne se produit pas si vous utilisez .NET Framework version 1.0.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.Data.DataSet> et <xref:System.IO.FileStream?displayProperty=nameWithType> objet. Le <xref:System.IO.FileStream> objet, créé avec un chemin d’accès de fichier et le nom de fichier, est utilisé pour créer un <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> qui est passé en tant qu’argument à la <xref:System.Data.DataSet.ReadXmlSchema%2A> (méthode).  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Lecteur XML spécifié.</param>
        <summary>Ignore les attributs et retourne un jeu de données vide.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberSignature Language="F#" Value="abstract member RejectChanges : unit -&gt; unit&#xA;override this.RejectChanges : unit -&gt; unit" Usage="dataSet.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restaure toutes les modifications apportées à la <see cref="T:System.Data.DataSet" /> , car elle a été créée, ou depuis la dernière fois <see cref="M:System.Data.DataSet.AcceptChanges" /> a été appelée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appeler le <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType> pour appeler le <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> (méthode) sur tous les <xref:System.Data.DataTable> les objets contenus dans le <xref:System.Data.DataSet>.  
  
 <xref:System.Data.DataRow> les objets contenus dans le <xref:System.Data.DataSet> peuvent tous être définis en mode édition en appelant le <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType> (méthode). Après avoir appelé la <xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType> (méthode), modifications peuvent être refusées en appelant le <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> sur le <xref:System.Data.DataTable> auquel le <xref:System.Data.DataRow> objets appartiennent.  
  
 Lorsque le <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> est appelée, toutes les lignes en mode édition annulent ses modifications. Nouvelles lignes sont supprimées. Retournent des lignes modifiées et supprimées à leur état d’origine (`DataRowState.Unchanged`).  
  
 AcceptChanges et RejectChanges s’appliquent uniquement aux <xref:System.Data.DataRow> les modifications associées (autrement dit, `Add`, `Remove`, `Delete`, et `Modify`). Ils ne sont pas applicables au schéma ou des modifications structurelles.  
  
   
  
## Examples  
 L’exemple suivant montre une classe dérivée de la <xref:System.Data.DataSet> classe. Le <xref:System.Data.DataSet.RejectChanges%2A> événement est appelé à partir d’une fonction.  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Relations : System.Data.DataRelationCollection" Usage="System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de relations qui relient des tables et de permettre la navigation à partir du parent tables vers les tables enfants.</summary>
        <value><see cref="T:System.Data.DataRelationCollection" /> qui contient une collection d’objets <see cref="T:System.Data.DataRelation" />. Une collection vide est retournée si aucun <see cref="T:System.Data.DataRelation" /> objets existent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant imprime le nom de colonne de toutes les tables enfants via la <xref:System.Data.DataSet.Relations%2A> propriété.  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un <see cref="T:System.Data.SerializationFormat" /> pour le <see cref="T:System.Data.DataSet" /> utilisé pendant la communication à distance.</summary>
        <value>Objet <see cref="T:System.Data.SerializationFormat" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataSet.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface toutes les tables et supprime toutes les relations, contraintes étrangères et tables à partir de la <see cref="T:System.Data.DataSet" />. Les sous-classes doivent substituer <see cref="M:System.Data.DataSet.Reset" /> pour restaurer un <see cref="T:System.Data.DataSet" /> à son état d’origine.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSerializationMode : System.Data.SchemaSerializationMode with get, set" Usage="System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un <see cref="T:System.Data.SchemaSerializationMode" /> pour un <see cref="T:System.Data.DataSet" />.</summary>
        <value>Obtient ou définit un <see cref="T:System.Data.SchemaSerializationMode" /> pour un <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Data.DataSet> sérialise ses données de schéma et d’instance par défaut dans les scénarios de communication à distance et de services Web. Définition de la <xref:System.Data.DataSet.SchemaSerializationMode%2A> propriété d’un typé `DataSet` à <xref:System.Data.SchemaSerializationMode.ExcludeSchema> , les informations de schéma doit être exclu de la charge utile de sérialisation.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> est pris en charge uniquement pour un typé `DataSet`. Pour un non typé `DataSet` cette propriété peut uniquement être définie sur <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> doit uniquement être utilisé dans les cas où les informations de schéma de sous-jacent tapées `DataTables`, `DataRelations` et `Constraints` n’a pas été modifié. Si les modifications doivent les informations de schéma s’est produite, complète doivent être sérialisées avec <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> est pris en charge dans la version 2.0 du .NET Framework ou une version ultérieure.  
  
 Lorsque <xref:System.Data.SchemaSerializationMode.ExcludeSchema> est défini, seules les propriétés d’exécution de niveau supérieur présentes sur le <xref:System.Data.DataSet> sont sérialisés. En outre, elles sont sérialisées uniquement s’ils sont différents des valeurs par défaut. Aucun de la `Tables`, `Relations` ou `Constraints` sont sérialisés. Les propriétés d’exécution sérialisées incluent <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Namespace%2A>, <xref:System.Data.DataSet.Prefix%2A>, <xref:System.Data.DataSet.Locale%2A>, <xref:System.Data.DataSet.EnforceConstraints%2A>, et <xref:System.Data.DataSet.CaseSensitive%2A>. Ces propriétés sont sérialisées pour vous assurer que l’intégrité des données de runtime général sont conservé.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeRelations : unit -&gt; bool&#xA;override this.ShouldSerializeRelations : unit -&gt; bool" Usage="dataSet.ShouldSerializeRelations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="P:System.Data.DataSet.Relations" /> propriété doit être persistante.</summary>
        <returns><see langword="true" /> Si la valeur de propriété a été modifiée à partir de sa valeur par défaut ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez généralement cette méthode si vous créez un concepteur pour le <xref:System.Data.DataSet>, ou en créant votre propre contrôle incorporant la <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 Les exemples suivants montrent une classe dérivée de la <xref:System.Data.DataSet> classe. Le <xref:System.Data.DataSet.Reset%2A> et <xref:System.Data.DataSet.ShouldSerializeRelations%2A> méthodes sont appelées à partir de fonctions dans la classe dérivée.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeTables : unit -&gt; bool&#xA;override this.ShouldSerializeTables : unit -&gt; bool" Usage="dataSet.ShouldSerializeTables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="P:System.Data.DataSet.Tables" /> propriété doit être persistante.</summary>
        <returns><see langword="true" /> Si la valeur de propriété a été modifiée à partir de sa valeur par défaut ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez généralement cette méthode uniquement si vous créez un concepteur pour le <xref:System.Data.DataSet>, ou en créant votre propre contrôle incorporant la <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 L’exemple suivant montre une classe dérivée de la <xref:System.Data.DataSet> classe. Le <xref:System.Data.DataSet.ShouldSerializeTables%2A> méthode est appelée depuis l’intérieur de fonctions dans la classe dérivée.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un élément <see cref="T:System.ComponentModel.ISite" /> pour l'élément <see cref="T:System.Data.DataSet" />.</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> pour <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites lient un <xref:System.ComponentModel.Component> à un <xref:System.ComponentModel.Container> et activer la communication entre eux, ainsi que fournir un moyen pour le conteneur gérer ses composants.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>Pour obtenir une description de ce membre, consultez <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut être utilisé uniquement lorsqu'un cast de l'instance de <xref:System.Data.DataSet> est effectué en une interface <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Pour obtenir une description de ce membre, consultez <see cref="M:System.ComponentModel.IListSource.GetList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut être utilisé uniquement lorsqu'un cast de l'instance de <xref:System.Data.DataSet> est effectué en une interface <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> à remplir de données.</param>
        <param name="context">Destination (voir <see cref="T:System.Runtime.Serialization.StreamingContext" />) de cette sérialisation.</param>
        <summary>Remplit un objet d’informations de sérialisation avec les données nécessaires pour sérialiser <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Pour obtenir une description de ce membre, consultez <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut être utilisé uniquement lorsqu'un cast de l'instance de <xref:System.Data.DataSet> est effectué en une interface <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" /></param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut être utilisé uniquement lorsqu'un cast de l'instance de <xref:System.Data.DataSet> est effectué en une interface <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /></param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut être utilisé uniquement lorsqu'un cast de l'instance de <xref:System.Data.DataSet> est effectué en une interface <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Tables : System.Data.DataTableCollection" Usage="System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetTablesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection des tables contenues dans le <see cref="T:System.Data.DataSet" />.</summary>
        <value>Le <see cref="T:System.Data.DataTableCollection" /> contenues par ce <see cref="T:System.Data.DataSet" />. Une collection vide est retournée si aucun <see cref="T:System.Data.DataTable" /> objets existent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour ajouter des tables à la collection, utilisez <xref:System.Data.DataTableCollection.Add%2A> méthode de la <xref:System.Data.DataTableCollection>. Pour supprimer des tables, utilisez le <xref:System.Data.DataTableCollection.Remove%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant retourne le <xref:System.Data.DataSet> l’objet <xref:System.Data.DataTableCollection>et imprime les colonnes et lignes dans chaque table.  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit des données XML et éventuellement le schéma, à partir de la <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Un <see cref="T:System.IO.Stream" /> objet utilisé pour écrire dans un fichier.</param>
        <summary>Écrit les données actuelles pour le <see cref="T:System.Data.DataSet" /> à l’aide de la <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, tandis que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L'exemple suivant crée un objet <xref:System.IO.FileStream?displayProperty=nameWithType>. L’objet est ensuite utilisé avec la <xref:System.Data.DataSet.WriteXml%2A> méthode pour écrire un document XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objet<see cref="T:System.IO.TextWriter" /> avec lequel écrire.</param>
        <summary>Écrit les données actuelles pour le <see cref="T:System.Data.DataSet" /> à l’aide de la <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, tandis que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataSet.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Le fichier de nom (y compris le chemin d’accès) dans lequel écrire.</param>
        <summary>Écrit les données actuelles pour le <see cref="T:System.Data.DataSet" /> dans le fichier spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, tandis que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> n’a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Le <see cref="T:System.Xml.XmlWriter" /> avec lequel écrire.</param>
        <summary>Écrit les données actuelles pour le <see cref="T:System.Data.DataSet" /> spécifié <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, tandis que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire des données et le schéma, utilisez une des surcharges qui inclut le `mode` paramètre et définissez sa valeur sur `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Un <see cref="T:System.IO.Stream" /> objet utilisé pour écrire dans un fichier.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Écrit les données actuelles et éventuellement le schéma, pour le <see cref="T:System.Data.DataSet" /> à l’aide de la <see cref="T:System.IO.Stream" /> et <see cref="T:System.Data.XmlWriteMode" />. Pour écrire le schéma, définissez la valeur de la <paramref name="mode" /> paramètre <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, tandis que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire les données et le schéma, définissez la `mode` paramètre `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Un <see cref="T:System.IO.TextWriter" /> objet utilisé pour écrire le document.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Écrit les données actuelles et éventuellement le schéma, pour le <see cref="T:System.Data.DataSet" /> à l’aide de la <see cref="T:System.IO.TextWriter" /> et <see cref="T:System.Data.XmlWriteMode" />. Pour écrire le schéma, définissez la valeur de la <paramref name="mode" /> paramètre <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, tandis que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire les données et le schéma, définissez la `mode` paramètre `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L’exemple suivant crée d’abord une simple <xref:System.Data.DataSet> avec un <xref:System.Data.DataTable>, deux colonnes et dix lignes. Le <xref:System.Data.DataSet> schéma et les données sont écrites sur le disque en appelant le <xref:System.Data.DataSet.WriteXml%2A> (méthode). Une seconde <xref:System.Data.DataSet> est créé et le <xref:System.Data.DataSet.ReadXml%2A> méthode sert à remplir avec le schéma et données.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Le fichier de nom (y compris le chemin d’accès) dans lequel écrire.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Écrit les données actuelles et éventuellement le schéma, pour le <see cref="T:System.Data.DataSet" /> dans le fichier spécifié à l’aide de la <see cref="T:System.Data.XmlWriteMode" />. Pour écrire le schéma, définissez la valeur de la <paramref name="mode" /> paramètre <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, tandis que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire les données et le schéma, définissez la `mode` paramètre `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Data.DataSet.WriteXml%2A> méthode pour écrire un document XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> n’a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Le <see cref="T:System.Xml.XmlWriter" /> avec lequel écrire.</param>
        <param name="mode">Une des valeurs de <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Écrit les données actuelles et éventuellement le schéma, pour le <see cref="T:System.Data.DataSet" /> à l’aide de la <see cref="T:System.Xml.XmlWriter" /> et <see cref="T:System.Data.XmlWriteMode" />. Pour écrire le schéma, définissez la valeur de la <paramref name="mode" /> paramètre <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `WriteXml` méthode fournit écrire seulement les données, ou les données et le schéma à partir d’un <xref:System.Data.DataSet> dans un document XML, tandis que le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode écrit uniquement le schéma. Pour écrire les données et le schéma, définissez la `mode` paramètre `WriteSchema`.  
  
 Notez que cela vaut pour la <xref:System.Data.DataSet.ReadXml%2A> et <xref:System.Data.DataSet.ReadXmlSchema%2A> méthodes, respectivement. Pour lire des données XML, ou le schéma et les données dans le `DataSet`, utilisez le `ReadXml` (méthode). Pour lire uniquement le schéma, utilisez la `ReadXmlSchema` (méthode).  
  
> [!NOTE]
>  Un <xref:System.InvalidOperationException> sera levée si un type de colonne dans la `DataRow` qui est lu ou écrit à implémente <xref:System.Dynamic.IDynamicMetaObjectProvider> et n’implémente pas <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.IO.FileStream?displayProperty=nameWithType> objet qui est utilisé pour créer un nouveau <xref:System.Xml.XmlTextWriter>. Le <xref:System.Xml.XmlTextWriter> objet est utilisé avec le <xref:System.Data.DataSet.WriteXml%2A> méthode pour écrire un document XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit le <see cref="T:System.Data.DataSet" /> structure comme un schéma XML.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Un <see cref="T:System.IO.Stream" /> objet utilisé pour écrire dans un fichier.</param>
        <summary>Écrit la structure <see cref="T:System.Data.DataSet" /> en tant que schéma XML dans l’objet <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataSet> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXml%2A> (méthode).  
  
 Les classes qui dérivent de la <xref:System.IO.Stream> classe inclure <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, et <xref:System.Net.Sockets.NetworkStream>.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.IO.FileStream> objet qui est passé à la <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode pour écrire le schéma sur le disque.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objet<see cref="T:System.IO.TextWriter" /> avec lequel écrire.</param>
        <summary>Écrit la structure <see cref="T:System.Data.DataSet" /> en tant que schéma XML dans l’objet <see cref="T:System.IO.TextWriter" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataSet> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXml%2A> (méthode).  
  
 Classes qui dérivent du <xref:System.IO.TextWriter?displayProperty=nameWithType> classe incluent le <xref:System.Web.HttpWriter?displayProperty=nameWithType>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>, <xref:System.IO.StreamWriter?displayProperty=nameWithType>, et <xref:System.IO.StringWriter?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Text.StringBuilder?displayProperty=nameWithType> objet qui est utilisé pour créer un nouveau <xref:System.IO.StringWriter?displayProperty=nameWithType>. Le <xref:System.IO.StringWriter> est passé à la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode) et la chaîne résultante est imprimé sur la fenêtre de console.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataSet.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Le fichier de nom (y compris le chemin d’accès) dans lequel écrire.</param>
        <summary>Écrit le <see cref="T:System.Data.DataSet" /> structure comme un schéma XML dans un fichier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataSet> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXml%2A> (méthode).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> n’a pas la valeur <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour lire et écrire des fichiers. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /> dans lequel écrire.</param>
        <summary>Écrit le <see cref="T:System.Data.DataSet" /> structure comme un schéma XML dans un <see cref="T:System.Xml.XmlWriter" /> objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode pour écrire le schéma pour un <xref:System.Data.DataSet> à un document XML. Le schéma inclut des définitions de table, des relations et des contraintes. Pour écrire un schéma dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXmlSchema%2A> (méthode).  
  
 Le schéma XML est écrit à l’aide de la norme XSD.  
  
 Pour écrire les données dans un document XML, utilisez la <xref:System.Data.DataSet.WriteXml%2A> (méthode).  
  
 Une classe qui hérite de la <xref:System.Xml.XmlWriter?displayProperty=nameWithType> classe est la <xref:System.Xml.XmlTextWriter> classe.  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau <xref:System.IO.FileStream?displayProperty=nameWithType> objet avec le chemin d’accès spécifié. Le <xref:System.IO.FileStream> objet est utilisé pour créer un <xref:System.Xml.XmlTextWriter> objet. Le <xref:System.Data.DataSet.WriteXmlSchema%2A> méthode est ensuite appelée avec le <xref:System.Xml.XmlTextWriter> objet à écrire le schéma sur le disque.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">À l’aide de jeux de données dans ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (stream, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">Un <see cref="T:System.IO.Stream" /> objet à écrire dans.</param>
        <param name="multipleTargetConverter">Un délégué utilisé pour convertir <see cref="T:System.Type" /> en chaîne.</param>
        <summary>Écrit la structure <see cref="T:System.Data.DataSet" /> en tant que schéma XML dans l’objet <see cref="T:System.IO.Stream" /> spécifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">Un <see cref="T:System.IO.TextWriter" /> objet à écrire dans.</param>
        <param name="multipleTargetConverter">Un délégué utilisé pour convertir <see cref="T:System.Type" /> en chaîne.</param>
        <summary>Écrit le <see cref="T:System.Data.DataSet" /> structure comme un schéma XML spécifié <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (fileName, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">Le nom du fichier à écrire.</param>
        <param name="multipleTargetConverter">Un délégué utilisé pour convertir <see cref="T:System.Type" /> en chaîne.</param>
        <summary>Écrit le <see cref="T:System.Data.DataSet" /> structure comme un schéma XML dans un fichier.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">Un <see cref="T:System.Xml.XmlWriter" /> objet à écrire dans.</param>
        <param name="multipleTargetConverter">Un délégué utilisé pour convertir <see cref="T:System.Type" /> en chaîne.</param>
        <summary>Écrit le <see cref="T:System.Data.DataSet" /> structure comme un schéma XML spécifié <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>