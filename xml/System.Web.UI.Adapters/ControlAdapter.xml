<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0f6fed664b044da1885a7b85efbbbf8911c7ce56" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="58875565" /></Metadata><TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Personnalise le rendu pour le contrôle dérivé auquel l'adaptateur est joint, afin de modifier le balisage par défaut ou le comportement de navigateurs spécifiques, et constitue la classe de base à partir de laquelle sont hérités tous les adaptateurs de contrôles.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Adaptateurs de contrôle sont des composants qui substituent certaines <xref:System.Web.UI.Control> classe les méthodes et événements dans son cycle de vie de l’exécution pour permettre la gestion du navigateur ou spécifique au balisage. Le .NET Framework mappe un adaptateur de contrôles dérivés seul à un <xref:System.Web.UI.Control> objet pour chaque demande du client.  
  
 Un adaptateur modifie le contrôle d’un navigateur spécifique ou une classe de navigateurs ou agit comme un filtre arbitraire sur certaines fonctions. En règle générale, l’adaptateur est défini par le langage de balisage par le navigateur (par exemple, XHTML ou HTML 3.2). Une grande partie de l’adaptabilité dans le comportement de rendu peut être encapsulée dans les classes spécialisées dérivées de la <xref:System.Web.UI.HtmlTextWriter> classe. Par conséquent, il est probable qu’une seule carte peut être utilisée pour un nombre de comportements de classe de navigateur ou que cette inclusion de l’adaptabilité dans le <xref:System.Web.UI.HtmlTextWriter> classes peuvent rendre l’utilisation d’un adaptateur de contrôle inutiles.  
  
 Un adaptateur pour une classe de contrôle s’applique à tous les contrôles qui héritent de cette classe, à moins que des adaptateurs plus spécialisés sont présents. Par exemple, un adaptateur pour le <xref:System.Web.UI.WebControls.BaseValidator> classe peut être utilisée pour tous les `Validator` objets.  
  
 Adaptateurs n’héritent généralement pas directement à partir de la <xref:System.Web.UI.Adapters.ControlAdapter> classe, mais de l’une de l’adaptateur spécifique à la cible les classes de base qui fournissent des fonctionnalités supplémentaires spécifiques au navigateur contrôle type et la cible ou au rendu particulier.  
  
 Les contrôles eux-mêmes ne nécessitent pas nécessairement un adaptateur. Si les contrôles sont étendus via la composition, les adaptateurs de contrôles enfants sont généralement suffisantes.  
  
 Chaque contrôle possède des mappages explicites aux adaptateurs les fichiers de définition browser. Ainsi, tout accès à la <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> propriété utilise le <xref:System.Web.HttpBrowserCapabilities> objet extrait à partir de fichiers de définition de navigateur pour rechercher le mappage de l’adaptateur à contrôler.  
  
 Pendant le traitement, le .NET Framework intercepte les appels aux méthodes substituables d’un contrôle qui peut être spécifique à la cible. Si un adaptateur de contrôles est attaché, le .NET Framework appelle les méthodes de l’adaptateur associé.  
  
 L’adaptateur effectue le rendu du contrôle via le <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> (méthode). Si la substitution, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> potentiellement ne doivent pas appeler l’implémentation de classe de base car qui effectue un appel sur le <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> (méthode). Cela peut entraîner le rendu se produise à deux reprises, une fois par l’adaptateur et une fois par le contrôle.  
  
 Le <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> les appels de méthode de base sur la <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> méthode du contrôle. Par conséquent, si vous substituez <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, vous ne devez pas appeler l’implémentation de classe de base, sauf si le rendu que vous implémentez est en plus de celles fourni par <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> du contrôle.  
  
 Vous devez vous assurer que le .NET Framework exécute l’interception pour les adaptateurs des contrôles enfants. Vous pouvez le faire en appelant le <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> de base (méthode), qui appelle le <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> méthode du contrôle, à partir de votre <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> remplacer.  
  
 Le <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> et <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> méthodes sont appelées par le contrôle immédiatement avant et après (respectivement) les appels de contrôle le <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> (méthode). Si les pré- et post-rendu est la seule spécifique au navigateur tâches de traitement requis, à l’aide <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> et <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> rendent inutiles remplacer <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>. Le comportement par défaut de la <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> et <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> méthodes consiste à appeler les méthodes correspondantes de la <xref:System.Web.UI.HtmlTextWriter>.  
  
 Pour maintenir ses propres informations d’état, un adaptateur de contrôles peut substituer le <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, et <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> méthodes. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, et <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> sont appelées lorsque les États de contrôle et d’affichage privés sont enregistrés et chargés, respectivement.  
  
 Le <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, et <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> méthodes de base sur le correspondant <xref:System.Web.UI.Control> méthodes de la classe. Par conséquent, aucune de ces <xref:System.Web.UI.Adapters.ControlAdapter> les méthodes qui sont substituées doivent appeler ses méthodes de base ; sinon, l’événement associé le <xref:System.Web.UI.Control> méthode de classe ne sera pas déclenchée.  
  
 Contrôles et adaptateurs implémentent éventuellement le <xref:System.Web.UI.IPostBackDataHandler> et <xref:System.Web.UI.IPostBackEventHandler> interfaces. Le .NET Framework détermine si un adaptateur existe et si l’adaptateur implémente ces interfaces. Le cas échéant, l’adaptateur doit substituer la <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, et <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> méthodes, en fonction des besoins. Si les données de publication (postback) ne sont pas reconnues dans l’adaptateur, il doit le rappeler sur le contrôle pour le traiter. Gestionnaires d’événements suivants doivent également appeler revenir sur le contrôle.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Lorsque vous héritez de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (classe), un contrôle qui requiert des fonctionnalités d’adaptateur générales doit avoir un adaptateur correspondant nommé dans le modèle de classe de base <paramref name="ControlType" /> <see langword="Adapter" /> (par exemple, <see langword="TextBoxAdapter" />). L’adaptateur doit retourner au minimum une instance fortement typée du contrôle via son <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> propriété.  
  
1.  Adaptateurs de contrôle pour un langage de type et le balisage du contrôle donné doit être nommé dans le modèle <paramref name="MarkupControlType" /> <see langword="Adapter" /> (par exemple, <see langword="XhtmlTextBoxAdapter" />). Adaptateurs d’un contrôle doivent être implémentées dans un <see langword="Adapters" /> sous-espace de noms.  
  
Adaptateurs de contrôle doivent hériter de la classe de base appropriée et suivez le même modèle d’héritage que le contrôle. Par exemple, un adaptateur pour un contrôle héritant de la <see cref="T:System.Web.UI.Control" /> doit hériter de la classe de base à partir de le le <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe ou l’appropriées <paramref name="ControlType" /> <see langword="Adapter" /> classe.  
  
Tous les adaptateurs spécialisés doivent être définis pour le contrôle spécialisé, sous tous les nœuds de périphérique dans les fichiers de configuration Browser.  
  
Un contrôle implémenté correctement ne doit pas supposer qu’un adaptateur est joint, ou que l’adaptateur attaché implémente une interface spécifique. Au lieu de cela, elle doit vérifier ces avant d’appeler.  
  
Il est possible de simuler la substitution de méthodes d’événement protégées dans le contrôle, tel que le <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> méthode de la <see cref="T:System.Web.UI.WebControls.LinkButton" />. Tout d’abord, créez une classe d’adaptateur avec une <c>OnClick</c> (méthode). Puis créez un nouveau contrôle dérivé <see cref="T:System.Web.UI.WebControls.LinkButton" /> et remplacer le <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> (méthode). Substituées <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> les appels de méthode le <c>OnClick</c> méthode de l’adaptateur. L’objet d’adaptateur est disponible via l’élément protégé <see cref="P:System.Web.UI.Control.Adapter" /> propriété de la <see cref="T:System.Web.UI.Control" /> classe. Le <see cref="P:System.Web.UI.Control.Adapter" /> propriété du contrôle est <see langword="null" /> lorsqu’il n’existe pas d’adaptateur associé, par conséquent, tout code doit vérifier cette condition avant d’appeler les méthodes de l’adaptateur.</para></block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Web.UI.Adapters.ControlAdapter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le .NET Framework construit en interne cette carte lorsqu’il crée le correspondantes <xref:System.Web.UI.Control> objet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" /> contenant les méthodes qui restituent la sortie spécifique à la cible.</param>
        <summary>Appelé avant le rendu d'un contrôle. Dans une classe d'adaptateur dérivée, génère des balises d'ouverture requises par une cible spécifique mais pas par les navigateurs HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> méthode est appelée juste avant le <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> (méthode) et est utilisé pour effectuer le prétraitement de spécifique à la cible avant le rendu du contrôle.  
  
 Utilisez le <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> méthode en combinaison avec la <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> méthode pour garantir l’ouverture et de la cohérence des balises de fermeture.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lorsque vous héritez de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (classe), le <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> les appels de méthode de base le <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> (méthode). Par conséquent, les remplacements de la <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> méthode doit appeler la <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> méthode de base uniquement si son traitement est en plus, et non à la place de la <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> (méthode).</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reçoit une référence aux fonctionnalités de navigation du client effectuant la demande HTTP en cours.</summary>
        <value><see cref="T:System.Web.HttpBrowserCapabilities" /> qui spécifie le navigateur client et les fonctions de balise.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Web.UI.Adapters.ControlAdapter> objet détermine les fonctionnalités du navigateur client à partir de la <xref:System.Web.HttpBrowserCapabilities> objet qui est retourné par la <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> propriété. Cela permet la <xref:System.Web.UI.Adapters.ControlAdapter> objet restituer le balisage de navigateur spécifiques ou de modifier le comportement de la <xref:System.Web.UI.Control>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> propriété pour accéder aux détails du navigateur demandeur. Dans cet exemple, le code vérifie pour déterminer si le navigateur est compatible avec JavaScript et puis permet au développeur de restituer la sortie personnalisée dans ce cas.  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reçoit une référence au contrôle auquel cet adaptateur de contrôles est joint.</summary>
        <value><see cref="T:System.Web.UI.Control" /> auquel <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> est attaché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un adaptateur de contrôle dérivé est attaché à un contrôle, le .NET Framework appelle certains membres de l’adaptateur au lieu des membres du contrôle.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment dériver un contrôle personnalisé à partir de la <xref:System.Web.UI.Control> classe et ensuite créer un adaptateur correspondant qui hérite de la <xref:System.Web.UI.Adapters.ControlAdapter> classe. L’adaptateur remplace le <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> propriété et retourne une référence fortement typée au contrôle.  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lorsque vous héritez de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (classe), au minimum, vous devez implémenter un <see langword="Control" /> propriété pour retourner une instance fortement typée du contrôle, comme indiqué dans la section exemple.</para></block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée les contrôles enfants spécifiques à la cible pour un contrôle composite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il existe un adaptateur de contrôle dérivé est attaché à un <xref:System.Web.UI.Control> objet et le <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> méthode est substituée, la substitution est appelée au lieu du <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> (méthode). Par conséquent, <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> peut être utilisé pour créer un jeu de contrôle enfant spécifique à la cible.  
  
 Pour plus d’informations sur la combinaison de contrôles pour créer un nouveau contrôle, consultez [contrôles composites](https://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si vous créez une classe qui hérite et substituez la <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> (méthode), n’appelez pas la méthode de base, sauf si vous souhaitez ajouter des contrôles à ceux créée par la méthode de base. Sinon, vous pouvez créer deux jeux d’enfant contrôles.</para></block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" /> contenant les méthodes qui restituent la sortie spécifique à la cible.</param>
        <summary>Appelé après le rendu d'un contrôle. Dans une classe d'adaptateur dérivée, génère des balises de fermeture requises par une cible spécifique mais pas par les navigateurs HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> méthode est appelée juste après le <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> (méthode) et est utilisé pour effectuer le traitement des résultats spécifiques à la cible après le rendu du contrôle.  
  
 Utilisez le <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> méthode en combinaison avec la <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> méthode pour garantir l’ouverture et de la cohérence des balises de fermeture.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lorsque vous héritez de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (classe), le <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> les appels de méthode de base le <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> (méthode). Par conséquent, les remplacements de la <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> méthode doit appeler la <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> méthode de base uniquement si son traitement est en plus, et non à la place de la <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> (méthode).</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Object" /> contenant les informations d'état du contrôle de la carte sous forme de <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Charge des informations sur l'état du contrôle d'adaptateur qui ont été enregistrées par <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />, lors d'une demande antérieure, sur la page sur laquelle réside le contrôle associé à cet adaptateur de contrôles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 État du contrôle est les informations d’état essentielles nécessaires même si l’état d’affichage est désactivé. Lorsqu’un adaptateur doit gérer ses propres informations d’état de contrôle, il peut remplacer le <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> et <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> méthodes.  
  
 Un adaptateur peut avoir besoin gérer les informations d’état de contrôle lorsque des fonctionnalités qui nécessitent des état maintenu entre les demandes, indépendamment de l’état du contrôle associé. Par exemple, un contrôle composite constitué d’un grand affichage textuel et un groupe de <xref:System.Web.UI.WebControls.RadioButton> contrôles peut être restitué comme une vue unique sur les navigateurs d’ordinateur de bureau. Sur d’autres navigateurs, il peut fractionner son rendu - une vue pour l’affichage de texte et l’autre pour le groupe de cases d’option. L’adaptateur devrait gérer ses propres informations spécifiques à la cible sur la vue actuellement active.  
  
 Le <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> méthode est appelée immédiatement après la <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> (méthode), dans le `LoadState` phase du cycle de vie. L’état de contrôle de carte est distinct et en plus de l’état du contrôle du contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Un <see cref="T:System.Object" /> qui contient les informations sur l'état d'affichage de l'adaptateur comme <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Charge des informations sur l'état d'affichage de l'adaptateur qui ont été enregistrées par <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />, lors d'une demande antérieure, sur la page sur laquelle réside le contrôle associé à cet adaptateur de contrôles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un adaptateur doit gérer ses propres informations d’état de vue, il peut remplacer le <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> et <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> méthodes.  
  
 Un adaptateur doit gérer les informations d’état de vue de données qui doivent être maintenues dans des demandes, indépendamment de l’état d’affichage du contrôle associé. Par exemple, un contrôle de grille sur les navigateurs d’ordinateur de bureau peut être restitué comme une vue unique des lignes et colonnes de valeurs. Sur d’autres navigateurs, il peut fractionner son rendu en plusieurs vues distinctes, telles qu’une liste de lignes et les détails d’une ligne unique. L’adaptateur devrait maintenir les données pour les vues qui ne sont pas actuellement actifs dans l’état d’affichage.  
  
 Le <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> méthode est appelée immédiatement avant le <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> méthode dans le `LoadState` phase du cycle de vie. L’état d’affichage de l’adaptateur est distinct et en plus de l’état d’affichage du contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Substitue la méthode <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> au contrôle associé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il existe un adaptateur est joint à un <xref:System.Web.UI.Control> objet et le <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> méthode est substituée, la méthode de substitution est appelée au lieu du <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> (méthode).  
  
 Substituer <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> pour exécuter le traitement spécifique à la cible dans le `Initialize` phase du cycle de vie de contrôle. En règle générale, ce sont des fonctions qui sont effectuées lorsqu’un contrôle est créé.  
  
   
  
## Examples  
 L’exemple de code suivant illustre un adaptateur de contrôle personnalisé à partir de la <xref:System.Web.UI.Adapters.ControlAdapter> classe. Il remplace ensuite le <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> méthode pour définir une propriété sur le contrôle associé et appeler la méthode de base pour terminer l’initialisation du contrôle.  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lorsque vous héritez de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe et l’adaptateur substitue la <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> (méthode), l’adaptateur doit appeler la méthode correspondante de la classe de base, qui à son tour appelle la <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> (méthode). Si le <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> méthode n’est pas appelée, le <see cref="E:System.Web.UI.Control.Init" /> événement n’est pas déclenché.</para></block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Substitue la méthode <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> au contrôle associé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il existe un adaptateur est joint à un <xref:System.Web.UI.Control> objet et le <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> méthode est substituée, la méthode de substitution est appelée au lieu du <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> (méthode).  
  
 Remplacer le <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> méthode pour effectuer le traitement spécifique à la cible dans le `Load` phase du cycle de vie de contrôle. En règle générale, ce sont des fonctions qui doivent être effectuées pour chaque demande du client.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lorsque vous héritez de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe et l’adaptateur substitue la <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> (méthode), l’adaptateur doit appeler la méthode correspondante de la classe de base, qui à son tour appelle la <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> (méthode). Si <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> n’est pas appelée, le <see cref="E:System.Web.UI.Control.Load" /> événement n’est pas déclenché.</para></block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Substitue la méthode <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> au contrôle associé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il existe un adaptateur est joint à un <xref:System.Web.UI.Control> objet et le <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> méthode est substituée, la méthode de substitution est appelée au lieu du <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> (méthode).  
  
 Remplacer le <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> méthode pour effectuer le traitement spécifique à la cible dans le `PreRender` phase du cycle de vie de contrôle. En règle générale, ce sont des fonctions qui précèdent immédiatement le rendu de la sortie du contrôle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lorsque vous héritez de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe et l’adaptateur substitue la <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> (méthode), l’adaptateur doit appeler la méthode correspondante de la classe de base, qui à son tour appelle la <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> (méthode). Si le <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> méthode n’est pas appelée, le <see cref="E:System.Web.UI.Control.PreRender" /> événement n’est pas déclenché.</para></block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Substitue la méthode <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> au contrôle associé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il existe un adaptateur est joint à un <xref:System.Web.UI.Control> objet et le <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> méthode est substituée, la méthode de substitution est appelée au lieu du <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> (méthode).  
  
 Remplacer le <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> méthode pour effectuer un traitement spécifique à la cible le `Unload` phase du cycle de vie de contrôle. En règle générale, ce sont des fonctions de nettoyage qui précèdent la disposition du contrôle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lorsque vous héritez de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> classe et l’adaptateur substitue la <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> (méthode), l’adaptateur doit appeler la méthode correspondante de la classe de base, qui à son tour appelle la <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> (méthode). Si <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> n’est pas appelée, le <see cref="E:System.Web.UI.Control.Unload" /> événement n’est pas déclenché.</para></block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reçoit une référence à la page sur laquelle réside le contrôle associé à cet adaptateur.</summary>
        <value>Un <see cref="T:System.Web.UI.Page" /> qui fournit l'accès à l'instance de page sur laquelle est situé le contrôle associé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> propriété fournit l’accès à la <xref:System.Web.UI.Page?displayProperty=nameWithType> objet où est situé le contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reçoit une référence à l'adaptateur de page pour la page sur laquelle réside le contrôle associé.</summary>
        <value><see cref="T:System.Web.UI.Adapters.PageAdapter" /> pour la page sur laquelle est situé le contrôle associé au <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> propriété fournit l’accès à la <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> de l’objet pour le <xref:System.Web.UI.Page> objet où le <xref:System.Web.UI.Control> objet associé en cours <xref:System.Web.UI.Adapters.ControlAdapter> objet est situé.  
  
 Le <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> propriété peut être utilisée pour accéder aux autres éléments au niveau de l’adaptateur de page, tels que des fonctions spécifiques à la cible communes qui peuvent s’appliquer à plusieurs types de contrôle sur la page.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" /> permettant de restituer la sortie spécifique à la cible.</param>
        <summary>Génère le balisage spécifique à la cible pour le contrôle auquel l’adaptateur de contrôle est attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Remplacer le <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> méthode permettant de générer le balisage spécifique à la cible à envoyer au navigateur client. Le <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> méthode est appelée à la place de la <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> méthode si une <xref:System.Web.UI.Adapters.ControlAdapter> objet est attaché à un <xref:System.Web.UI.Control> objet.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lorsque vous héritez de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (classe), le <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> les appels de méthode de base le <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> (méthode). Par conséquent, les remplacements de la <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> méthode doit appeler la <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> méthode de base uniquement si son traitement est en plus, et non à la place de la <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> (méthode).  
  
Pour un contrôle composite, le développeur d’adaptateur doit garantir que les contrôles enfants sont affichés. Si le <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> méthode restitue les enfants contrôles mais ne génère pas de balise, il peut être approprié pour le <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> méthode à appeler sa méthode de base. Si le rendu des contrôles enfants spécifiques à la cible est nécessaire, l’adaptateur doit implémenter la <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> (méthode) et appelez le <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> méthode à partir de la <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> (méthode).</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Web.UI.HtmlTextWriter" /> permettant de restituer la sortie spécifique à la cible.</param>
        <summary>Génère la balise spécifique à la cible pour les contrôles enfants dans un contrôle composite auquel l'adaptateur de contrôles est joint.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Remplacer le <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> méthode lorsqu’il est nécessaire de générer un balisage spécifique à la cible pour l’ensemble du contrôle enfant d’un contrôle composite, en outre à la balise pour les contrôles enfants individuels.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lorsque vous héritez de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (classe), pour un contrôle composite, le développeur d’adaptateur doit garantir que les contrôles enfants sont affichés. Si l’adaptateur remplace le <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> (méthode), elle doit appeler la <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> méthode à partir d’une substitution de la <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> (méthode).  
  
Si le <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> méthode restitue les enfants contrôles mais lui-même ne génère pas de balise, il peut être approprié pour le <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> méthode à appeler sa méthode de base, qui appelle le <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> méthode, au lieu d’implémenter une substitution pour le <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> (méthode).</para></block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enregistre les informations sur l'état de contrôle pour l'adaptateur de contrôles.</summary>
        <returns><see cref="T:System.Object" /> contenant les informations d'état du contrôle de la carte sous forme de <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 État du contrôle est les informations d’état essentielles nécessaires même si l’état d’affichage est désactivé. Lorsqu’un adaptateur doit gérer ses propres informations d’état de contrôle, il peut remplacer le <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> et <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> méthodes.  
  
 Un adaptateur peut avoir besoin gérer les informations d’état de contrôle lorsque des fonctionnalités qui nécessitent des état maintenu entre les demandes, indépendamment de l’état du contrôle associé. Par exemple, un contrôle composite constitué d’un grand affichage textuel et un groupe de <xref:System.Web.UI.WebControls.RadioButton> contrôles peut être restitué comme une vue unique sur les navigateurs d’ordinateur de bureau. Sur d’autres navigateurs, il peut fractionner son rendu - une vue pour l’affichage de texte et l’autre pour le groupe de cases d’option. L’adaptateur devrait gérer ses propres informations spécifiques à la cible sur la vue actuellement active.  
  
 Le <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> méthode est appelée immédiatement après la <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> méthode dans le `SaveState` phase du cycle de vie. L’état de contrôle de carte est distinct et en plus de l’état du contrôle du contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enregistre les informations sur l'état d'affichage pour l'adaptateur de contrôles.</summary>
        <returns>Un <see cref="T:System.Object" /> qui contient les informations sur l'état d'affichage de l'adaptateur comme <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’un adaptateur doit gérer ses propres informations d’état de vue, il peut remplacer le <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> et <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> méthodes.  
  
 Un adaptateur doit gérer les informations d’état de vue de données qui doivent être conservées entre les demandes, indépendamment de l’état de la vue associée du contrôle. Par exemple, un contrôle de grille sur les navigateurs d’ordinateur de bureau peut être restitué comme une vue unique des lignes et colonnes de valeurs. Sur d’autres navigateurs, il peut fractionner son rendu en plusieurs vues distinctes, telles qu’une liste de lignes et les détails d’une ligne unique. L’adaptateur devrait maintenir les données pour les vues qui ne sont pas actuellement actifs dans l’état d’affichage.  
  
 Le <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> méthode est appelée immédiatement avant le <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> méthode dans le `SaveState` phase du cycle de vie. L’état d’affichage de l’adaptateur est distinct et en plus de l’état d’affichage du contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>