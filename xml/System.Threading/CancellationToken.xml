<Type Name="CancellationToken" FullName="System.Threading.CancellationToken">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="19b22c264e9da195fc5b91af5de567dc3b839021" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061441" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct CancellationToken" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit CancellationToken extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Threading.CancellationToken" />
  <TypeSignature Language="VB.NET" Value="Public Structure CancellationToken" />
  <TypeSignature Language="C++ CLI" Value="public value class CancellationToken" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("IsCancellationRequested = {IsCancellationRequested}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Propage une notification indiquant que des opérations doivent être annulées.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Threading.CancellationToken> permet l’annulation coopérative entre les threads, les éléments de travail du pool de threads, ou <xref:System.Threading.Tasks.Task> objets. Vous créez un jeton d’annulation en instanciant une <xref:System.Threading.CancellationTokenSource> de récupérer l’objet, qui gère les jetons d’annulation à partir de son <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> propriété. Vous passez ensuite le jeton d’annulation à n’importe quel nombre de threads, des tâches ou des opérations qui doivent recevoir une notification d’annulation. Le jeton ne peut pas être utilisé pour initialiser l’annulation. Lorsque l’objet propriétaire appelle <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>, le <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> sur chaque copie du jeton d’annulation est définie sur `true`. Les objets qui reçoivent la notification peuvent répondre de quelque manière appropriée.  
  
 Pour plus d’informations et du code des exemples, consultez [l’annulation dans les Threads managés](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 L’exemple suivant utilise un générateur de nombres aléatoires pour émuler une application de collecte de données qui lit les valeurs intégrales 10 onze instruments différents. La valeur zéro indique que la mesure a échoué pour un instrument, auquel cas l’opération doit être annulée et aucune globale moyenne doivent être calculées.  
  
 Pour gérer l’annulation possible de l’opération, l’exemple instancie un <xref:System.Threading.CancellationTokenSource> objet qui génère un jeton d’annulation qui est passé à un <xref:System.Threading.Tasks.TaskFactory> objet. Le <xref:System.Threading.Tasks.TaskFactory> objet à son tour transmet le jeton d’annulation à chacune des tâches chargée de collecter les lectures d’un instrument particulier. Le <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%60%602%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2CSystem.Func%7BSystem.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2C%60%601%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> méthode est appelée pour vous assurer que la moyenne est calculée uniquement une fois toutes les valeurs ont été collectées avec succès. Si une tâche ne comporte pas, car elle a été annulée, l’appel à la <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> méthode lève une exception.  
  
 [!code-csharp[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/cs/cancel1.cs#1)]
 [!code-vb[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/vb/cancel1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tous les membres publics et protégés de <see cref="T:System.Threading.CancellationToken" /> sont thread-safe et peuvent être utilisés simultanément à partir de plusieurs threads.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CancellationToken (bool canceled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool canceled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (canceled As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CancellationToken(bool canceled);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="canceled" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="canceled">État d'annulation du jeton.</param>
        <summary>Initialise la <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les jetons créés avec ce constructeur resteront dans l’état annulé spécifié par le `canceled` paramètre. Si `canceled` est `false`, à la fois <xref:System.Threading.CancellationToken.CanBeCanceled%2A> et <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> sera `false`.  
  
 Si `canceled` est `true`, à la fois <xref:System.Threading.CancellationToken.CanBeCanceled%2A> et <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> sera `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBeCanceled">
      <MemberSignature Language="C#" Value="public bool CanBeCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanBeCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.CanBeCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanBeCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanBeCanceled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine si ce jeton peut être à l'état Annulé.</summary>
        <value>
          <see langword="true" /> si ce jeton peut être dans l’état Annulé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Threading.CancellationToken.CanBeCanceled%2A> retourne `false`, il est garanti que le jeton ne passera jamais dans un état annulé, ce qui signifie que <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> ne retourne jamais `true`. Un jeton d’annulation qui ne peut pas être annulé est retourné par la méthode statique <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType> propriété.  
  
 Vous pouvez éventuellement utiliser cette propriété pour déterminer si un jeton d’annulation peut être annulée avant l’examen de le, la valeur de la <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propriété pour déterminer si elle a été annulée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si l'instance actuelle de <see cref="T:System.Threading.CancellationToken" /> est égale au jeton spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (other As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="other">Autre objet à comparer avec cette instance.</param>
        <summary>Détermine si l'instance actuelle de <see cref="T:System.Threading.CancellationToken" /> est égale au <see cref="T:System.Object" /> spécifié.</summary>
        <returns>
          <see langword="true" /> si <paramref name="other" /> est un <see cref="T:System.Threading.CancellationToken" /> et si les deux instances sont égales ; sinon, <see langword="false" />. Pour plus d'informations, consultez la section Notes. </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Deux jetons d’annulation sont égales si l’une des conditions suivantes est remplie : 

- Ils sont associés au même <xref:System.Threading.CancellationTokenSource>.

- Les deux été construits public <xref:System.Threading.CancellationToken> constructeurs, ainsi que leurs <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> valeurs sont égales.

- La valeur de deux jetons d’annulation est <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.

       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Une <see cref="T:System.Threading.CancellationTokenSource" /> associée a été supprimée.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Threading.CancellationToken other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.Threading.CancellationToken other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Equals(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Threading::CancellationToken other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="other">Autre <see cref="T:System.Threading.CancellationToken" /> à comparer avec cette instance.</param>
        <summary>Détermine si l'instance actuelle de <see cref="T:System.Threading.CancellationToken" /> est égale au jeton spécifié.</summary>
        <returns>
          <see langword="true" /> si les instances sont égales ; sinon, <see langword="false" />. Pour plus d'informations, consultez la section Notes. </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Deux jetons d’annulation sont égales si l’une des conditions suivantes est remplie : 

- Ils sont associés au même <xref:System.Threading.CancellationTokenSource>.

- Les deux été construits public <xref:System.Threading.CancellationToken> constructeurs, ainsi que leurs <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> valeurs sont égales.

- La valeur de deux jetons d’annulation est <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sert de fonction de hachage pour un <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Code de hachage pour l'instance actuelle de <see cref="T:System.Threading.CancellationToken" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCancellationRequested">
      <MemberSignature Language="C#" Value="public bool IsCancellationRequested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCancellationRequested" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.IsCancellationRequested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCancellationRequested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCancellationRequested { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine si l'annulation a été demandée pour ce jeton.</summary>
        <value>
          <see langword="true" /> Si l’annulation a été demandée pour ce jeton ; dans le cas contraire, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété indique si l’annulation a été demandée pour ce jeton, via le jeton initialement construit dans un état annulé ou via l’appel <xref:System.Threading.CancellationTokenSource.Cancel%2A> sur le jeton associé à <xref:System.Threading.CancellationTokenSource>.  
  
 Si cette propriété est `true`, elle garantit uniquement que l’annulation a été demandée. Il ne garantit pas que l’exécution de chaque gestionnaire inscrit est terminée, ni que les demandes d’annulation ont été propagées à tous les gestionnaires inscrits. Synchronisation supplémentaire peut être requise, notamment dans des situations où les objets connexes sont annulés simultanément.  
  
   
  
## Examples  
 Voici un exemple simple qui exécute un processus serveur jusqu'à ce que le <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propriété renvoie `true`.  
  
 [!code-csharp[System.Threading.Tasks.CancellationToken.IsCancellationRequested#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.CancellationToken.IsCancellationRequested/cs/cancellation.cs#12)]
 [!code-vb[System.Threading.Tasks.CancellationToken.IsCancellationRequested#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.CancellationToken.IsCancellationRequested/vb/cancelthreads.vb#12)]  
  
 L’exemple instancie un <xref:System.Threading.CancellationTokenSource> objet, qui contrôle l’accès au jeton d’annulation. Il définit ensuite deux procédures de thread. La première est définie comme une expression lambda qui regroupe le clavier et, lorsque la touche « C », appelle <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> pour définir le jeton d’annulation à l’état annulé. La deuxième est une méthode paramétrable, `ServerClass.StaticMethod`, qui exécute une boucle jusqu'à ce que le <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propriété est `true`.  
  
 Le thread principal démarre ensuite les blocs et deux threads jusqu'à ce que le thread qui exécute le `ServerClass.StaticMethod` méthode se termine.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static System.Threading.CancellationToken None { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Threading.CancellationToken None" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property None As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::CancellationToken None { System::Threading::CancellationToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne une valeur <see cref="T:System.Threading.CancellationToken" /> vide.</summary>
        <value>Jeton d'annulation vide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeton d’annulation retourné par cette propriété ne peut pas être annulé ; Autrement dit, son <xref:System.Threading.CancellationToken.CanBeCanceled%2A> propriété est `false`.  
  
 Vous pouvez également utiliser le langage c# [default(CancellationToken)](~/docs/csharp/language-reference/keywords/default.md) instruction pour créer un jeton d’annulation vide. 

 Deux jetons d’annulation vide sont toujours égales.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Threading.CancellationToken left, System.Threading.CancellationToken right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Threading.CancellationToken left, valuetype System.Threading.CancellationToken right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.op_Equality(System.Threading.CancellationToken,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As CancellationToken, right As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Threading::CancellationToken left, System::Threading::CancellationToken right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Threading.CancellationToken" />
        <Parameter Name="right" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="left">Première instance.</param>
        <param name="right">Deuxième instance.</param>
        <summary>Détermine si deux instances <see cref="T:System.Threading.CancellationToken" /> sont égales.</summary>
        <returns>
          <see langword="true" /> si les instances sont égales ; sinon, <see langword="false" />. Consultez la section Notes pour plus d’informations.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Deux jetons d’annulation sont égales si l’une des conditions suivantes est remplie : 

- Ils sont associés au même <xref:System.Threading.CancellationTokenSource>.

- Les deux été construits public <xref:System.Threading.CancellationToken> constructeurs, ainsi que leurs <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> valeurs sont égales.

- La valeur de deux jetons d’annulation est <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.
       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Une <see cref="T:System.Threading.CancellationTokenSource" /> associée a été supprimée.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Threading.CancellationToken left, System.Threading.CancellationToken right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Threading.CancellationToken left, valuetype System.Threading.CancellationToken right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.op_Inequality(System.Threading.CancellationToken,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As CancellationToken, right As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Threading::CancellationToken left, System::Threading::CancellationToken right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Threading.CancellationToken" />
        <Parameter Name="right" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="left">Première instance.</param>
        <param name="right">Deuxième instance.</param>
        <summary>Détermine si les deux instances de <see cref="T:System.Threading.CancellationToken" /> ne sont pas égales.</summary>
        <returns>
          <see langword="true" /> si les instances ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Pour la définition de l’égalité des valeurs, consultez le <xref:System.Threading.CancellationToken.Equals%2A> (méthode). 
       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Une <see cref="T:System.Threading.CancellationTokenSource" /> associée a été supprimée.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit un délégué qui sera appelé lors de l'annulation du <see cref="T:System.Threading.CancellationToken" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué à exécuter lorsque <see cref="T:System.Threading.CancellationToken" /> est annulé.</param>
        <summary>Inscrit un délégué qui sera appelé lors de l'annulation du <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Instance de <see cref="T:System.Threading.CancellationTokenRegistration" /> qui peut être utilisée pour désinscrire le rappel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ce jeton est déjà dans l’état annulé, le délégué est exécuté immédiatement et de manière synchrone. Toute exception que le délégué sera propagée hors de cet appel de méthode.  
  
 En cours <xref:System.Threading.ExecutionContext> est capturée, ainsi que le délégué et sera utilisé lors de son exécution. 

 En cours <xref:System.Threading.SynchronizationContext> n’est pas capturée.
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action callback, bool useSynchronizationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action callback, bool useSynchronizationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action, useSynchronizationContext As Boolean) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action ^ callback, bool useSynchronizationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="useSynchronizationContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué à exécuter lorsque <see cref="T:System.Threading.CancellationToken" /> est annulé.</param>
        <param name="useSynchronizationContext">Valeur qui indique s’il faut capturer le <see cref="T:System.Threading.SynchronizationContext" /> actuel et l’utiliser au moment de l’appel de <c>callback</c>.</param>
        <summary>Inscrit un délégué qui sera appelé lors de l'annulation du <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Instance de <see cref="T:System.Threading.CancellationTokenRegistration" /> qui peut être utilisée pour désinscrire le rappel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ce jeton est déjà dans l’état annulé, le délégué est exécuté immédiatement et de manière synchrone. Toute exception que le délégué sera propagée hors de cet appel de méthode.  
  
 En cours <xref:System.Threading.ExecutionContext> est capturée, ainsi que le délégué et sera utilisé lors de son exécution. 

 Si `useSynchronizationContext` est `true`, actuel <xref:System.Threading.SynchronizationContext>, s’il en existe, est également capturé avec le délégué et sera utilisé lors de son exécution. Dans le cas contraire, <xref:System.Threading.SynchronizationContext> n’est pas capturée.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action&lt;object&gt; callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action`1&lt;object&gt; callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action(Of Object), state As Object) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action&lt;System::Object ^&gt; ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué à exécuter lorsque <see cref="T:System.Threading.CancellationToken" /> est annulé.</param>
        <param name="state">État à passer à <c>callback</c> quand le délégué est appelé. Il peut s'agir d'une valeur null.</param>
        <summary>Inscrit un délégué qui sera appelé lors de l'annulation du <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Instance de <see cref="T:System.Threading.CancellationTokenRegistration" /> qui peut être utilisée pour désinscrire le rappel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ce jeton est déjà dans l’état annulé, le délégué est exécuté immédiatement et de manière synchrone. Toute exception que le délégué sera propagée hors de cet appel de méthode.  
  
 En cours <xref:System.Threading.ExecutionContext> est capturée, ainsi que le délégué et sera utilisé lors de son exécution. 

 En cours <xref:System.Threading.SynchronizationContext> n’est pas capturée.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action&lt;object&gt; callback, object state, bool useSynchronizationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action`1&lt;object&gt; callback, object state, bool useSynchronizationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action(Of Object), state As Object, useSynchronizationContext As Boolean) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action&lt;System::Object ^&gt; ^ callback, System::Object ^ state, bool useSynchronizationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="useSynchronizationContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué à exécuter lorsque <see cref="T:System.Threading.CancellationToken" /> est annulé.</param>
        <param name="state">État à passer à <c>callback</c> quand le délégué est appelé. Il peut s'agir d'une valeur null.</param>
        <param name="useSynchronizationContext">Valeur booléenne qui indique s’il faut capturer le <see cref="T:System.Threading.SynchronizationContext" /> actuel et l’utiliser au moment de l’appel de <c>callback</c>.</param>
        <summary>Inscrit un délégué qui sera appelé lors de l'annulation du <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Instance de <see cref="T:System.Threading.CancellationTokenRegistration" /> qui peut être utilisée pour désinscrire le rappel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ce jeton est déjà dans l’état annulé, le délégué est exécuté immédiatement et de manière synchrone. Toute exception que le délégué sera propagée hors de cet appel de méthode.  
  
 En cours <xref:System.Threading.ExecutionContext> est capturée, ainsi que le délégué et sera utilisé lors de son exécution. 

 Si `useSynchronizationContext` est `true`, actuel <xref:System.Threading.SynchronizationContext>, s’il en existe, est également capturé avec le délégué et sera utilisé lors de son exécution. Dans le cas contraire, <xref:System.Threading.SynchronizationContext> n’est pas capturée.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfCancellationRequested">
      <MemberSignature Language="C#" Value="public void ThrowIfCancellationRequested ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ThrowIfCancellationRequested() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.ThrowIfCancellationRequested" />
      <MemberSignature Language="VB.NET" Value="Public Sub ThrowIfCancellationRequested ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ThrowIfCancellationRequested();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lève une <see cref="T:System.OperationCanceledException" /> si l'annulation de ce jeton a été demandée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des fonctionnalités équivalentes à :  
  
 C#  
  
```csharp  
if (token.IsCancellationRequested)   
    throw new OperationCanceledException(token);  
```  
  
```vb  
If token.IsCancellationRequested Then  
    Throw New OperationCanceledException(token)  
End If  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L’annulation du jeton a été demandée.</exception>
        <exception cref="T:System.ObjectDisposedException">L’élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle WaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle WaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.WaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::WaitHandle ^ WaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Threading.WaitHandle" /> qui est signalé lors de l'annulation du jeton.</summary>
        <value>
          <see cref="T:System.Threading.WaitHandle" /> signalé lors de l'annulation du jeton.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’accès à cette propriété provoque un <xref:System.Threading.WaitHandle> pour être instancié. Il est préférable d’utiliser uniquement cette propriété lorsque cela est nécessaire et supprimer ensuite associé <xref:System.Threading.CancellationTokenSource> instance (en supprimant la source supprimera ce handle alloué) dès que possible. Le handle n’a pas doit être fermé ou supprimé directement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
      </Docs>
    </Member>
  </Members>
</Type>