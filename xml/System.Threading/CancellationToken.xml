<Type Name="CancellationToken" FullName="System.Threading.CancellationToken">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ae895847a53ec18e5d0fe22ae6c844d3db840024" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58734521" /></Metadata><TypeSignature Language="C#" Value="public struct CancellationToken" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit CancellationToken extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Threading.CancellationToken" />
  <TypeSignature Language="VB.NET" Value="Public Structure CancellationToken" />
  <TypeSignature Language="C++ CLI" Value="public value class CancellationToken" />
  <TypeSignature Language="F#" Value="type CancellationToken = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("IsCancellationRequested = {IsCancellationRequested}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Propage une notification indiquant que des opérations doivent être annulées.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Threading.CancellationToken> permet l’annulation coopérative entre les threads, les éléments de travail du pool de threads, ou <xref:System.Threading.Tasks.Task> objets. Vous créez un jeton d’annulation en instanciant un <xref:System.Threading.CancellationTokenSource> objet, qui gère les jetons d’annulation récupéré à partir de son <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> propriété. Vous transmettez ensuite le jeton d’annulation à n’importe quel nombre de threads, les tâches ou opérations qui doivent être informés de l’annulation. Le jeton ne peut pas être utilisé pour initier l’annulation. Lorsque l’objet propriétaire appelle <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>, le <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propriété sur chaque copie du jeton d’annulation est définie sur `true`. Les objets qui reçoivent la notification peuvent répondre de quelque manière appropriée.  
  
 Pour plus d’informations et le code des exemples, consultez [l’annulation dans les Threads managés](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 L’exemple suivant utilise un générateur de nombres aléatoires pour émuler une application de collecte de données qui lit les 10 valeurs intégrales d’onze instruments différents. La valeur zéro indique que la mesure a échoué pour un instrument, auquel cas l’opération doit être annulée et aucune moyenne globale doivent être calculées.  
  
 Pour gérer l’annulation possible de l’opération, l’exemple instancie un <xref:System.Threading.CancellationTokenSource> objet qui génère un jeton d’annulation qui est transmis à un <xref:System.Threading.Tasks.TaskFactory> objet. Le <xref:System.Threading.Tasks.TaskFactory> objet à son tour transmet le jeton d’annulation à chacune des tâches chargée de collecter des relevés d’un instrument particulier. Le <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%60%602%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2CSystem.Func%7BSystem.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2C%60%601%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> méthode est appelée pour s’assurer que la moyenne est calculée uniquement une fois que toutes les lectures ont été collectées avec succès. Si une tâche n’a pas, car elle a été annulée, l’appel à la <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> méthode lève une exception.  
  
 [!code-csharp[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/cs/cancel1.cs#1)]
 [!code-vb[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/vb/cancel1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tous les membres publics et protégés de <see cref="T:System.Threading.CancellationToken" /> sont thread-safe et peuvent être utilisés simultanément par plusieurs threads.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CancellationToken (bool canceled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool canceled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (canceled As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CancellationToken(bool canceled);" />
      <MemberSignature Language="F#" Value="new System.Threading.CancellationToken : bool -&gt; System.Threading.CancellationToken" Usage="new System.Threading.CancellationToken canceled" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="canceled" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="canceled">État d'annulation du jeton.</param>
        <summary>Initialise la <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les jetons créés avec ce constructeur resteront dans l’état annulé spécifié par le `canceled` paramètre. Si `canceled` est `false`, à la fois <xref:System.Threading.CancellationToken.CanBeCanceled%2A> et <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> sera `false`.  
  
 Si `canceled` est `true`, à la fois <xref:System.Threading.CancellationToken.CanBeCanceled%2A> et <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> sera `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="CanBeCanceled">
      <MemberSignature Language="C#" Value="public bool CanBeCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanBeCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.CanBeCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanBeCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanBeCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanBeCanceled : bool" Usage="System.Threading.CancellationToken.CanBeCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine si ce jeton peut être à l'état Annulé.</summary>
        <value><see langword="true" /> si ce jeton peut être dans l’état Annulé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Threading.CancellationToken.CanBeCanceled%2A> retourne `false`, il est garanti que le jeton ne passera jamais dans un état annulé, ce qui signifie que <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> ne retournent jamais `true`. Un jeton d’annulation qui ne peut pas être annulé est retourné par la méthode statique <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType> propriété.  
  
 Vous pouvez éventuellement utiliser cette propriété pour déterminer si un jeton d’annulation peut être annulée avant l’examen de le, la valeur de la <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propriété afin de déterminer si elle a été annulée.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si l'instance actuelle de <see cref="T:System.Threading.CancellationToken" /> est égale au jeton spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (other As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="cancellationToken.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="other">Autre objet à comparer avec cette instance.</param>
        <summary>Détermine si l'instance actuelle de <see cref="T:System.Threading.CancellationToken" /> est égale au <see cref="T:System.Object" /> spécifié.</summary>
        <returns><see langword="true" /> si <paramref name="other" /> est un <see cref="T:System.Threading.CancellationToken" /> et si les deux instances sont égales ; sinon, <see langword="false" />. Pour plus d'informations, consultez la section Notes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Deux jetons d’annulation sont égales si l’une des conditions suivantes est vraie : 

- Ils sont associés au même <xref:System.Threading.CancellationTokenSource>.

- Les deux ont été construits à partir de public <xref:System.Threading.CancellationToken> constructeurs, ainsi que leurs <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> valeurs sont égales.

- La valeur de ces deux jetons d’annulation est <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.

       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Threading.CancellationToken other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.Threading.CancellationToken other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Equals(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Threading::CancellationToken other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Threading.CancellationToken -&gt; bool" Usage="cancellationToken.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="other">Autre <see cref="T:System.Threading.CancellationToken" /> à comparer avec cette instance.</param>
        <summary>Détermine si l'instance actuelle de <see cref="T:System.Threading.CancellationToken" /> est égale au jeton spécifié.</summary>
        <returns><see langword="true" /> si les instances sont égales ; sinon, <see langword="false" />. Pour plus d'informations, consultez la section Notes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Deux jetons d’annulation sont égales si l’une des conditions suivantes est vraie : 

- Ils sont associés au même <xref:System.Threading.CancellationTokenSource>.

- Les deux ont été construits à partir de public <xref:System.Threading.CancellationToken> constructeurs, ainsi que leurs <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> valeurs sont égales.

- La valeur de ces deux jetons d’annulation est <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.

       ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="cancellationToken.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sert de fonction de hachage pour un <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Code de hachage pour l'instance actuelle de <see cref="T:System.Threading.CancellationToken" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCancellationRequested">
      <MemberSignature Language="C#" Value="public bool IsCancellationRequested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCancellationRequested" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.IsCancellationRequested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCancellationRequested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCancellationRequested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCancellationRequested : bool" Usage="System.Threading.CancellationToken.IsCancellationRequested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine si l'annulation a été demandée pour ce jeton.</summary>
        <value><see langword="true" /> si l’annulation a été demandée pour ce jeton ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété indique si l’annulation a été demandée pour ce jeton, via le jeton initialement construit dans un état annulé ou via l’appel <xref:System.Threading.CancellationTokenSource.Cancel%2A> sur le jeton associé au <xref:System.Threading.CancellationTokenSource>.  
  
 Si cette propriété est `true`, elle garantit uniquement que l’annulation a été demandée. Il ne garantit pas que l’exécution de chaque gestionnaire inscrit a terminée, ni que les demandes d’annulation ont été propagées à tous les gestionnaires inscrits. Une synchronisation supplémentaire peut être nécessaire, en particulier dans les situations où les objets connexes sont annulés simultanément.  
  
   
  
## Examples  
 Voici un exemple simple qui exécute un processus serveur jusqu'à ce que le <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> retourne de la propriété `true`.  
  
 [!code-csharp[System.Threading.Tasks.CancellationToken.IsCancellationRequested#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.CancellationToken.IsCancellationRequested/cs/cancellation.cs#12)]
 [!code-vb[System.Threading.Tasks.CancellationToken.IsCancellationRequested#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.CancellationToken.IsCancellationRequested/vb/cancelthreads.vb#12)]  
  
 L’exemple instancie un <xref:System.Threading.CancellationTokenSource> objet qui contrôle l’accès au jeton d’annulation. Il définit ensuite deux procédures de thread. La première est définie comme une expression lambda qui regroupe le clavier et, lorsque la touche « C », appelle <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> pour définir le jeton d’annulation à l’état annulé. Le second est une méthode paramétrée, `ServerClass.StaticMethod`, qui exécute une boucle jusqu'à ce que le <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propriété est `true`.  
  
 Le thread principal démarre ensuite les deux threads et les blocs jusqu'à ce que le thread qui exécute le `ServerClass.StaticMethod` méthode se termine.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static System.Threading.CancellationToken None { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Threading.CancellationToken None" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property None As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::CancellationToken None { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.None : System.Threading.CancellationToken" Usage="System.Threading.CancellationToken.None" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retourne une valeur <see cref="T:System.Threading.CancellationToken" /> vide.</summary>
        <value>Jeton d'annulation vide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le jeton d’annulation retourné par cette propriété ne peut pas être annulé ; Autrement dit, son <xref:System.Threading.CancellationToken.CanBeCanceled%2A> propriété est `false`.  
  
 Vous pouvez également utiliser le langage c# [default(CancellationToken)](~/docs/csharp/language-reference/keywords/default.md) instruction pour créer un jeton d’annulation vide. 

 Deux jetons d’annulation vide sont toujours égaux.
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Threading.CancellationToken left, System.Threading.CancellationToken right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Threading.CancellationToken left, valuetype System.Threading.CancellationToken right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.op_Equality(System.Threading.CancellationToken,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As CancellationToken, right As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Threading::CancellationToken left, System::Threading::CancellationToken right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Threading.CancellationToken * System.Threading.CancellationToken -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Threading.CancellationToken" />
        <Parameter Name="right" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="left">Première instance.</param>
        <param name="right">Deuxième instance.</param>
        <summary>Détermine si deux instances <see cref="T:System.Threading.CancellationToken" /> sont égales.</summary>
        <returns><see langword="true" /> si les instances sont égales ; sinon, <see langword="false" />. Consultez la section Notes pour plus d’informations.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Deux jetons d’annulation sont égales si l’une des conditions suivantes est vraie : 

- Ils sont associés au même <xref:System.Threading.CancellationTokenSource>.

- Les deux ont été construits à partir de public <xref:System.Threading.CancellationToken> constructeurs, ainsi que leurs <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> valeurs sont égales.

- La valeur de ces deux jetons d’annulation est <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.
       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Threading.CancellationToken left, System.Threading.CancellationToken right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Threading.CancellationToken left, valuetype System.Threading.CancellationToken right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.op_Inequality(System.Threading.CancellationToken,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As CancellationToken, right As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Threading::CancellationToken left, System::Threading::CancellationToken right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Threading.CancellationToken * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.CancellationToken.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Threading.CancellationToken" />
        <Parameter Name="right" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="left">Première instance.</param>
        <param name="right">Deuxième instance.</param>
        <summary>Détermine si les deux instances de <see cref="T:System.Threading.CancellationToken" /> ne sont pas égales.</summary>
        <returns><see langword="true" /> si les instances ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Pour la définition de l’égalité, consultez le <xref:System.Threading.CancellationToken.Equals%2A> (méthode). 
       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Un élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit un délégué qui sera appelé lors de l'annulation du <see cref="T:System.Threading.CancellationToken" />.</summary>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Register : Action -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.Register callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué à exécuter lorsque <see cref="T:System.Threading.CancellationToken" /> est annulé.</param>
        <summary>Inscrit un délégué qui sera appelé lors de l'annulation du <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Instance de <see cref="T:System.Threading.CancellationTokenRegistration" /> qui peut être utilisée pour désinscrire le rappel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ce jeton est déjà dans l’état annulé, le délégué est exécuté immédiatement et de manière synchrone. Toute exception que génère le délégué sera propagée hors de cet appel de méthode.  
  
 Actuel <xref:System.Threading.ExecutionContext> est capturée en même temps que le délégué et sera utilisé lors de son exécution. 

 Actuel <xref:System.Threading.SynchronizationContext> n’est pas capturée.
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
        <related type="Article" href="https://msdn.microsoft.com/library/8838dd75-18ed-4b8b-b322-cd4531faac64">Comment : enregistrer des rappels pour les demandes d'annulation</related>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action callback, bool useSynchronizationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action callback, bool useSynchronizationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action, useSynchronizationContext As Boolean) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action ^ callback, bool useSynchronizationContext);" />
      <MemberSignature Language="F#" Value="member this.Register : Action * bool -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.Register (callback, useSynchronizationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="useSynchronizationContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué à exécuter lorsque <see cref="T:System.Threading.CancellationToken" /> est annulé.</param>
        <param name="useSynchronizationContext">Valeur qui indique s'il faut capturer le <see cref="T:System.Threading.SynchronizationContext" /> actuel et l'utiliser lors de l'appel de <paramref name="callback" />.</param>
        <summary>Inscrit un délégué qui sera appelé lors de l'annulation du <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Instance de <see cref="T:System.Threading.CancellationTokenRegistration" /> qui peut être utilisée pour désinscrire le rappel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ce jeton est déjà dans l’état annulé, le délégué est exécuté immédiatement et de manière synchrone. Toute exception que génère le délégué sera propagée hors de cet appel de méthode.  
  
 Actuel <xref:System.Threading.ExecutionContext> est capturée en même temps que le délégué et sera utilisé lors de son exécution. 

 Si `useSynchronizationContext` est `true`, actuel <xref:System.Threading.SynchronizationContext>, s’il en existe, est également capturé avec le délégué et sera utilisé lors de son exécution. Sinon, <xref:System.Threading.SynchronizationContext> n’est pas capturée.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
        <related type="Article" href="https://msdn.microsoft.com/library/8838dd75-18ed-4b8b-b322-cd4531faac64">Comment : enregistrer des rappels pour les demandes d'annulation</related>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action&lt;object&gt; callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action`1&lt;object&gt; callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action(Of Object), state As Object) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action&lt;System::Object ^&gt; ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.Register : Action&lt;obj&gt; * obj -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.Register (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué à exécuter lorsque <see cref="T:System.Threading.CancellationToken" /> est annulé.</param>
        <param name="state">État à passer à <paramref name="callback" /> lorsque le délégué est appelé. Il peut s'agir d'une valeur null.</param>
        <summary>Inscrit un délégué qui sera appelé lors de l'annulation du <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Instance de <see cref="T:System.Threading.CancellationTokenRegistration" /> qui peut être utilisée pour désinscrire le rappel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ce jeton est déjà dans l’état annulé, le délégué est exécuté immédiatement et de manière synchrone. Toute exception que génère le délégué sera propagée hors de cet appel de méthode.  
  
 Actuel <xref:System.Threading.ExecutionContext> est capturée en même temps que le délégué et sera utilisé lors de son exécution. 

 Actuel <xref:System.Threading.SynchronizationContext> n’est pas capturée.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
        <related type="Article" href="https://msdn.microsoft.com/library/8838dd75-18ed-4b8b-b322-cd4531faac64">Comment : enregistrer des rappels pour les demandes d'annulation</related>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action&lt;object&gt; callback, object state, bool useSynchronizationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action`1&lt;object&gt; callback, object state, bool useSynchronizationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action(Of Object), state As Object, useSynchronizationContext As Boolean) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action&lt;System::Object ^&gt; ^ callback, System::Object ^ state, bool useSynchronizationContext);" />
      <MemberSignature Language="F#" Value="member this.Register : Action&lt;obj&gt; * obj * bool -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.Register (callback, state, useSynchronizationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="useSynchronizationContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="callback">Délégué à exécuter lorsque <see cref="T:System.Threading.CancellationToken" /> est annulé.</param>
        <param name="state">État à passer à <paramref name="callback" /> lorsque le délégué est appelé. Il peut s'agir d'une valeur null.</param>
        <param name="useSynchronizationContext">Valeur booléenne qui indique s'il faut capturer le <see cref="T:System.Threading.SynchronizationContext" /> actuel et l'utiliser lors de l'appel de <paramref name="callback" />.</param>
        <summary>Inscrit un délégué qui sera appelé lors de l'annulation du <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Instance de <see cref="T:System.Threading.CancellationTokenRegistration" /> qui peut être utilisée pour désinscrire le rappel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ce jeton est déjà dans l’état annulé, le délégué est exécuté immédiatement et de manière synchrone. Toute exception que génère le délégué sera propagée hors de cet appel de méthode.  
  
 Actuel <xref:System.Threading.ExecutionContext> est capturée en même temps que le délégué et sera utilisé lors de son exécution. 

 Si `useSynchronizationContext` est `true`, actuel <xref:System.Threading.SynchronizationContext>, s’il en existe, est également capturé avec le délégué et sera utilisé lors de son exécution. Sinon, <xref:System.Threading.SynchronizationContext> n’est pas capturée.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> a la valeur null.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
        <related type="Article" href="https://msdn.microsoft.com/library/8838dd75-18ed-4b8b-b322-cd4531faac64">Comment : enregistrer des rappels pour les demandes d'annulation</related>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfCancellationRequested">
      <MemberSignature Language="C#" Value="public void ThrowIfCancellationRequested ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ThrowIfCancellationRequested() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.ThrowIfCancellationRequested" />
      <MemberSignature Language="VB.NET" Value="Public Sub ThrowIfCancellationRequested ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ThrowIfCancellationRequested();" />
      <MemberSignature Language="F#" Value="member this.ThrowIfCancellationRequested : unit -&gt; unit" Usage="cancellationToken.ThrowIfCancellationRequested " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lève une <see cref="T:System.OperationCanceledException" /> si l'annulation de ce jeton a été demandée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit des fonctionnalités équivalentes à :  
  
 C#  
  
```csharp  
if (token.IsCancellationRequested)   
    throw new OperationCanceledException(token);  
```  
  
```vb  
If token.IsCancellationRequested Then  
    Throw New OperationCanceledException(token)  
End If  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">L’annulation du jeton a été demandée.</exception>
        <exception cref="T:System.ObjectDisposedException">L’élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md">Comment : annuler une tâche et ses enfants</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegister">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration UnsafeRegister (Action&lt;object&gt; callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration UnsafeRegister(class System.Action`1&lt;object&gt; callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.UnsafeRegister(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function UnsafeRegister (callback As Action(Of Object), state As Object) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration UnsafeRegister(Action&lt;System::Object ^&gt; ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.UnsafeRegister : Action&lt;obj&gt; * obj -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.UnsafeRegister (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Object&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle WaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle WaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.WaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::WaitHandle ^ WaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitHandle : System.Threading.WaitHandle" Usage="System.Threading.CancellationToken.WaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Threading.WaitHandle" /> qui est signalé lors de l'annulation du jeton.</summary>
        <value><see cref="T:System.Threading.WaitHandle" /> signalé lors de l'annulation du jeton.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’accès à cette propriété provoque une <xref:System.Threading.WaitHandle> à instancier. Il est préférable d’utiliser uniquement cette propriété lorsque cela est nécessaire et supprimer ensuite associé <xref:System.Threading.CancellationTokenSource> instance dès que possible (disposing supprime la source de ce handle alloué). Le handle n’a pas doit être fermé ou supprimé directement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L’élément <see cref="T:System.Threading.CancellationTokenSource" /> associé a été supprimé.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Annulation</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Annulation de tâches</related>
        <related type="Article" href="https://msdn.microsoft.com/library/6e2aa49b-fc84-4bcf-962b-17db98b7edcb">Comment : écouter les demandes d'annulation avec des handles d'attente</related>
      </Docs>
    </Member>
  </Members>
</Type>