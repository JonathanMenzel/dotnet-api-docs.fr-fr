<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e87fa180884985d655430f6614104ea2d1020256" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39804425" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="3308a-101">Limite le nombre de threads qui peuvent accéder simultanément à une ressource ou à un pool de ressources.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3308a-101">Limits the number of threads that can access a resource or pool of resources concurrently.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-102">Utilisez la <xref:System.Threading.Semaphore> classe pour contrôler l’accès à un pool de ressources.</span><span class="sxs-lookup"><span data-stu-id="3308a-102">Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources.</span></span> <span data-ttu-id="3308a-103">Threads entrent dans le sémaphore en appelant le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode), qui est hérité de la <xref:System.Threading.WaitHandle> classe et de libérer le sémaphore en appelant le <xref:System.Threading.Semaphore.Release%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-103">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="3308a-104">Le nombre sur un sémaphore est décrémenté à chaque fois qu’un thread entre dans le sémaphore et incrémenté lorsqu’un thread libère le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-104">The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</span></span> <span data-ttu-id="3308a-105">Lorsque le nombre est zéro, les demandes suivantes bloquent jusqu'à ce que les autres threads libèrent le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-105">When the count is zero, subsequent requests block until other threads release the semaphore.</span></span> <span data-ttu-id="3308a-106">Lorsque tous les threads ont libéré le sémaphore, le nombre est à la valeur maximale spécifié lors de la création du sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-106">When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</span></span>  
  
 <span data-ttu-id="3308a-107">Il n’existe aucun ordre garanti, telles que FIFO ou LIFO, dans lequel les threads bloqués entrent dans le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-107">There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</span></span>  
  
 <span data-ttu-id="3308a-108">Un thread peut entrer le sémaphore plusieurs fois, en appelant le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode à plusieurs reprises.</span><span class="sxs-lookup"><span data-stu-id="3308a-108">A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly.</span></span> <span data-ttu-id="3308a-109">Pour libérer certaines ou toutes ces entrées, le thread peut appeler sans paramètre <xref:System.Threading.Semaphore.Release> plusieurs fois, ou il peut appeler la surcharge de méthode le <xref:System.Threading.Semaphore.Release%28System.Int32%29> surcharge de méthode qui spécifie le nombre d’entrées à libérer.</span><span class="sxs-lookup"><span data-stu-id="3308a-109">To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.</span></span>  
  
 <span data-ttu-id="3308a-110">Le <xref:System.Threading.Semaphore> classe n’applique pas l’identité du thread sur les appels à <xref:System.Threading.WaitHandle.WaitOne%2A> ou <xref:System.Threading.Semaphore.Release%2A>.</span><span class="sxs-lookup"><span data-stu-id="3308a-110">The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>.</span></span> <span data-ttu-id="3308a-111">Il est la responsabilité du programmeur pour vous assurer que threads ne libèrent pas le sémaphore trop souvent.</span><span class="sxs-lookup"><span data-stu-id="3308a-111">It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</span></span> <span data-ttu-id="3308a-112">Supposons, par exemple, qu'un sémaphore ait un nombre maximal égal à deux et que le thread A et le thread B entrent dans le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-112">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="3308a-113">Si une erreur de programmation dans le thread B le conduit à appeler <xref:System.Threading.Semaphore.Release%2A> à deux reprises, les deux appels aboutiront.</span><span class="sxs-lookup"><span data-stu-id="3308a-113">If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed.</span></span> <span data-ttu-id="3308a-114">Le nombre maximal du sémaphore sera alors atteint, et quand le thread A appellera <xref:System.Threading.Semaphore.Release%2A>, une exception <xref:System.Threading.SemaphoreFullException> sera levée.</span><span class="sxs-lookup"><span data-stu-id="3308a-114">The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
 <span data-ttu-id="3308a-115">Les sémaphores sont de deux types : local et les sémaphores de système nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-115">Semaphores are of two types: local semaphores and named system semaphores.</span></span> <span data-ttu-id="3308a-116">Si vous créez un <xref:System.Threading.Semaphore> de l’objet à l’aide d’un constructeur qui accepte un nom, il est associé à un sémaphore système d’exploitation portant ce nom.</span><span class="sxs-lookup"><span data-stu-id="3308a-116">If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</span></span> <span data-ttu-id="3308a-117">Système nommé sémaphores sont visibles dans tout le système d’exploitation, peuvent être utilisés pour synchroniser les activités de processus.</span><span class="sxs-lookup"><span data-stu-id="3308a-117">Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="3308a-118">Vous pouvez créer plusieurs <xref:System.Threading.Semaphore> les objets qui représentent le même de sémaphore système nommé, et vous pouvez utiliser le <xref:System.Threading.Semaphore.OpenExisting%2A> sémaphore système nommé de méthode pour ouvrir un existant.</span><span class="sxs-lookup"><span data-stu-id="3308a-118">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.</span></span>  
  
 <span data-ttu-id="3308a-119">Un sémaphore local existe uniquement dans votre processus.</span><span class="sxs-lookup"><span data-stu-id="3308a-119">A local semaphore exists only within your process.</span></span> <span data-ttu-id="3308a-120">Il peut être utilisé par tout thread de votre processus qui a une référence à l’objet <xref:System.Threading.Semaphore> local.</span><span class="sxs-lookup"><span data-stu-id="3308a-120">It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="3308a-121">Chaque <xref:System.Threading.Semaphore> objet est un sémaphore local distinct.</span><span class="sxs-lookup"><span data-stu-id="3308a-121">Each <xref:System.Threading.Semaphore> object is a separate local semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3308a-122">L’exemple de code suivant crée un sémaphore avec un nombre maximal de trois et un nombre initial de zéro.</span><span class="sxs-lookup"><span data-stu-id="3308a-122">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="3308a-123">L’exemple démarre cinq threads, qui bloquent en attendant le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-123">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="3308a-124">Le thread principal utilise le <xref:System.Threading.Semaphore.Release%28System.Int32%29> surcharge de méthode pour augmenter le compteur du sémaphore à sa valeur maximale, en autorisant trois threads à entrer dans le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-124">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="3308a-125">Chaque thread utilise la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> méthode pour attendre une seconde, pour simuler le travail, puis appelle le <xref:System.Threading.Semaphore.Release> surcharge de méthode pour libérer le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-125">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="3308a-126">Chaque fois que le sémaphore est libéré, le compteur du sémaphore précédent s’affiche.</span><span class="sxs-lookup"><span data-stu-id="3308a-126">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="3308a-127">Console messages suivre l’utilisation sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-127">Console messages track semaphore use.</span></span> <span data-ttu-id="3308a-128">L’intervalle de travail simulé augmente légèrement à chaque thread, pour faciliter la lecture de la sortie.</span><span class="sxs-lookup"><span data-stu-id="3308a-128">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="3308a-129">Ce type est thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="3308a-129">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3308a-130">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-130">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="3308a-131">Nombre initial de demandes pour le sémaphore qui peuvent être accordées simultanément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-131">The initial number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="3308a-132">Nombre maximal de demandes pour le sémaphore qui peuvent être accordées simultanément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-132">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3308a-133">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" /> en spécifiant le nombre initial d'entrées et le nombre maximal d'entrées simultanées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-133">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-134">Ce constructeur initialise un sémaphore sans nom.</span><span class="sxs-lookup"><span data-stu-id="3308a-134">This constructor initializes an unnamed semaphore.</span></span> <span data-ttu-id="3308a-135">Tous les threads qui utilisent une instance de ce sémaphore doivent disposer de références à l’instance.</span><span class="sxs-lookup"><span data-stu-id="3308a-135">All threads that use an instance of such a semaphore must have references to the instance.</span></span>  
  
 <span data-ttu-id="3308a-136">Si `initialCount` est inférieure à `maximumCount`, l’effet est le même que si le thread actuel avait appelé <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` moins `initialCount`) fois.</span><span class="sxs-lookup"><span data-stu-id="3308a-136">If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="3308a-137">Si vous ne souhaitez pas réserver d’entrées pour le thread qui crée le sémaphore, utilisez le même nombre de `maximumCount` et `initialCount`.</span><span class="sxs-lookup"><span data-stu-id="3308a-137">If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3308a-138">L’exemple suivant crée un sémaphore avec un nombre maximal de trois et un nombre initial de zéro.</span><span class="sxs-lookup"><span data-stu-id="3308a-138">The following example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="3308a-139">L’exemple démarre cinq threads, qui bloquent en attendant le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-139">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="3308a-140">Le thread principal utilise le <xref:System.Threading.Semaphore.Release%28System.Int32%29> surcharge de méthode pour augmenter le compteur du sémaphore à sa valeur maximale, en autorisant trois threads à entrer dans le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-140">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="3308a-141">Chaque thread utilise la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> méthode pour attendre une seconde, pour simuler le travail, puis appelle le <xref:System.Threading.Semaphore.Release> surcharge de méthode pour libérer le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-141">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="3308a-142">Chaque fois que le sémaphore est libéré, le compteur du sémaphore précédent s’affiche.</span><span class="sxs-lookup"><span data-stu-id="3308a-142">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="3308a-143">Console messages suivre l’utilisation sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-143">Console messages track semaphore use.</span></span> <span data-ttu-id="3308a-144">L’intervalle de travail simulé augmente légèrement à chaque thread, pour faciliter la lecture de la sortie.</span><span class="sxs-lookup"><span data-stu-id="3308a-144">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3308a-145">
            <paramref name="initialCount" /> est supérieur à <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-145">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3308a-146">
            <paramref name="maximumCount" /> est inférieur à 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-146">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="3308a-147">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-147">-or-</span>
          </span>
          <span data-ttu-id="3308a-148">
            <paramref name="initialCount" /> est inférieur à 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-148">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="3308a-149">Nombre initial de demandes pour le sémaphore qui peuvent être accordées simultanément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-149">The initial number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="3308a-150">Nombre maximal de demandes pour le sémaphore qui peuvent être accordées simultanément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-150">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="3308a-151">Nom d'un objet de sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-151">The name of a named system semaphore object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3308a-152">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" /> en spécifiant le nombre initial d'entrées et le nombre maximal d'entrées simultanées, et en spécifiant en option le nom d'un objet sémaphore système.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-152">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-153">Ce constructeur initialise un <xref:System.Threading.Semaphore> objet qui représente un sémaphore système nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-153">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="3308a-154">Vous pouvez créer plusieurs <xref:System.Threading.Semaphore> objets qui représentent le même de sémaphore système nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-154">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="3308a-155">Si le sémaphore système nommé n’existe pas, il est créé avec le nombre initial et le nombre maximal spécifié par `initialCount` et `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="3308a-155">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="3308a-156">Si le sémaphore système nommé existe déjà, `initialCount` et `maximumCount` ne sont pas utilisés, bien que les valeurs non valides provoquent encore des exceptions.</span><span class="sxs-lookup"><span data-stu-id="3308a-156">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="3308a-157">Si vous avez besoin déterminer si un sémaphore système nommé a été créé, utilisez la <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> plutôt la surcharge de constructeur.</span><span class="sxs-lookup"><span data-stu-id="3308a-157">If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3308a-158">Lorsque vous utilisez cette surcharge de constructeur, la pratique recommandée consiste à spécifier le même nombre de `initialCount` et `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="3308a-158">When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="3308a-159">Si `initialCount` est inférieure à `maximumCount`et un sémaphore système nommé est créé, l’effet est le même que si le thread actuel avait appelé <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` moins `initialCount`) fois.</span><span class="sxs-lookup"><span data-stu-id="3308a-159">If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="3308a-160">Toutefois, avec cette surcharge de constructeur il n’existe aucun moyen pour déterminer si un sémaphore système nommé a été créé.</span><span class="sxs-lookup"><span data-stu-id="3308a-160">However, with this constructor overload there is no way to determine whether a named system semaphore was created.</span></span>  
  
 <span data-ttu-id="3308a-161">Si vous spécifiez `null` ou une chaîne vide pour `name`, un sémaphore local est créé, comme si vous aviez appelé le <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> surcharge de constructeur.</span><span class="sxs-lookup"><span data-stu-id="3308a-161">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span>  
  
 <span data-ttu-id="3308a-162">Étant donné que les sémaphores nommés sont visibles dans le système d’exploitation, elles peuvent servir pour coordonner l’utilisation des ressources au-delà des limites de processus.</span><span class="sxs-lookup"><span data-stu-id="3308a-162">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
 <span data-ttu-id="3308a-163">Si vous souhaitez savoir si un sémaphore système nommé existe, utilisez le <xref:System.Threading.Semaphore.OpenExisting%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-163">If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method.</span></span> <span data-ttu-id="3308a-164">Le <xref:System.Threading.Semaphore.OpenExisting%2A> méthode tente d’ouvrir un sémaphore nommé existant et lève une exception si le sémaphore système n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="3308a-164">The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3308a-165">L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-165">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="3308a-166">L’exemple crée un sémaphore nommé avec un nombre maximal de cinq et un nombre initial de cinq.</span><span class="sxs-lookup"><span data-stu-id="3308a-166">The example creates a named semaphore with a maximum count of five and an initial count of five.</span></span> <span data-ttu-id="3308a-167">Le programme fait trois appels à la <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-167">The program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="3308a-168">Par conséquent, si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie bloquera le troisième appel à <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="3308a-168">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="3308a-169">Libérer une ou plusieurs entrées dans la première copie du programme pour débloquer la deuxième.</span><span class="sxs-lookup"><span data-stu-id="3308a-169">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3308a-170">
            <paramref name="initialCount" /> est supérieur à <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-170">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="3308a-171">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-171">-or-</span>
          </span>
          <span data-ttu-id="3308a-172">
            <paramref name="name" /> fait plus de 260 caractères.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-172">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3308a-173">
            <paramref name="maximumCount" /> est inférieur à 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-173">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="3308a-174">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-174">-or-</span>
          </span>
          <span data-ttu-id="3308a-175">
            <paramref name="initialCount" /> est inférieur à 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-175">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="3308a-176">Une erreur Win32 s’est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-176">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="3308a-177">Le sémaphore nommé existe et a la sécurité de contrôle d’accès, et l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-177">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="3308a-178">Le sémaphore nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-178">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="3308a-179">pour appeler du code non managé pour créer un sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-179">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="3308a-180">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-180">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="3308a-181">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-181">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="3308a-182">Nombre initial de demandes pour le sémaphore qui peut être satisfait simultanément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-182">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="3308a-183">Nombre maximal de demandes pour le sémaphore qui peut être satisfait simultanément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-183">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="3308a-184">Nom d'un objet de sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-184">The name of a named system semaphore object.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="3308a-185">Cette méthode retourne <see langword="true" /> si un sémaphore local a été créé (en d’autres termes, si <c>name</c> est <see langword="null" /> ou une chaîne vide) ou si le sémaphore système nommé spécifié a été créé ; <see langword="false" /> si le sémaphore système nommé spécifié existait déjà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-185">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          </span>
          <span data-ttu-id="3308a-186">Ce paramètre est passé sans être initialisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-186">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3308a-187">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" /> en spécifiant le nombre initial d'entrées et le nombre maximal d'entrées simultanées, en spécifiant en option le nom d'un objet sémaphore système et en spécifiant une variable qui reçoit une valeur indiquant si un sémaphore système a été créé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-187">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-188">Ce constructeur initialise un <xref:System.Threading.Semaphore> objet qui représente un sémaphore système nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-188">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="3308a-189">Vous pouvez créer plusieurs <xref:System.Threading.Semaphore> objets qui représentent le même de sémaphore système nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-189">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="3308a-190">Si le sémaphore système nommé n’existe pas, il est créé avec le nombre initial et le nombre maximal spécifié par `initialCount` et `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="3308a-190">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="3308a-191">Si le sémaphore système nommé existe déjà, `initialCount` et `maximumCount` ne sont pas utilisés, bien que les valeurs non valides provoquent encore des exceptions.</span><span class="sxs-lookup"><span data-stu-id="3308a-191">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="3308a-192">Utilisez `createdNew` pour déterminer si le sémaphore système a été créé.</span><span class="sxs-lookup"><span data-stu-id="3308a-192">Use `createdNew` to determine whether the system semaphore was created.</span></span>  
  
 <span data-ttu-id="3308a-193">Si `initialCount` est inférieure à `maximumCount`, et `createdNew` est `true`, l’effet est le même que si le thread actuel avait appelé <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` moins `initialCount`) fois.</span><span class="sxs-lookup"><span data-stu-id="3308a-193">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="3308a-194">Si vous spécifiez `null` ou une chaîne vide pour `name`, un sémaphore local est créé, comme si vous aviez appelé le <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> surcharge de constructeur.</span><span class="sxs-lookup"><span data-stu-id="3308a-194">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="3308a-195">Dans ce cas, `createdNew` est toujours `true`.</span><span class="sxs-lookup"><span data-stu-id="3308a-195">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="3308a-196">Étant donné que les sémaphores nommés sont visibles dans le système d’exploitation, elles peuvent servir pour coordonner l’utilisation des ressources au-delà des limites de processus.</span><span class="sxs-lookup"><span data-stu-id="3308a-196">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3308a-197">L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-197">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="3308a-198">L’exemple crée un sémaphore nommé avec un nombre maximal de cinq et un nombre initial de deux.</span><span class="sxs-lookup"><span data-stu-id="3308a-198">The example creates a named semaphore with a maximum count of five and an initial count of two.</span></span> <span data-ttu-id="3308a-199">Autrement dit, il réserve trois entrées pour le thread qui appelle le constructeur.</span><span class="sxs-lookup"><span data-stu-id="3308a-199">That is, it reserves three entries for the thread that calls the constructor.</span></span> <span data-ttu-id="3308a-200">Si `createNew` est `false`, le programme fait trois appels à la <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-200">If `createNew` is `false`, the program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="3308a-201">Par conséquent, si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie bloquera le troisième appel à <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="3308a-201">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="3308a-202">Libérer une ou plusieurs entrées dans la première copie du programme pour débloquer la deuxième.</span><span class="sxs-lookup"><span data-stu-id="3308a-202">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3308a-203">
            <paramref name="initialCount" /> est supérieur à <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-203">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="3308a-204">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-204">-or-</span>
          </span>
          <span data-ttu-id="3308a-205">
            <paramref name="name" /> fait plus de 260 caractères.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-205">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3308a-206">
            <paramref name="maximumCount" /> est inférieur à 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-206">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="3308a-207">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-207">-or-</span>
          </span>
          <span data-ttu-id="3308a-208">
            <paramref name="initialCount" /> est inférieur à 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-208">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="3308a-209">Une erreur Win32 s’est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-209">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="3308a-210">Le sémaphore nommé existe et a la sécurité de contrôle d’accès, et l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-210">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="3308a-211">Le sémaphore nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-211">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="3308a-212">pour appeler du code non managé pour créer un sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-212">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="3308a-213">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-213">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="3308a-214">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-214">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="3308a-215">Nombre initial de demandes pour le sémaphore qui peut être satisfait simultanément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-215">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="3308a-216">Nombre maximal de demandes pour le sémaphore qui peut être satisfait simultanément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-216">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="3308a-217">Nom d'un objet de sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-217">The name of a named system semaphore object.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="3308a-218">Cette méthode retourne <see langword="true" /> si un sémaphore local a été créé (en d’autres termes, si <c>name</c> est <see langword="null" /> ou une chaîne vide) ou si le sémaphore système nommé spécifié a été créé ; <see langword="false" /> si le sémaphore système nommé spécifié existait déjà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-218">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          </span>
          <span data-ttu-id="3308a-219">Ce paramètre est passé sans être initialisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-219">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="semaphoreSecurity">
          <span data-ttu-id="3308a-220">Objet <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> qui représente la sécurité de contrôle d'accès à appliquer au sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-220">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3308a-221">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" /> en spécifiant le nombre initial d'entrées et le nombre maximal d'entrées simultanées, en spécifiant en option le nom d'un objet sémaphore système et en spécifiant une variable qui reçoit une valeur indiquant si un nouveau sémaphore système a été créé et spécifiant le contrôle d'accès de sécurité pour le sémaphore système.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-221">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-222">Utilisez ce constructeur pour appliquer la sécurité de contrôle d’accès pour un sémaphore système nommé lors de sa création, en empêchant l’autre code de prendre le contrôle du sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-222">Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</span></span>  
  
 <span data-ttu-id="3308a-223">Ce constructeur initialise un <xref:System.Threading.Semaphore> objet qui représente un sémaphore système nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-223">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="3308a-224">Vous pouvez créer plusieurs <xref:System.Threading.Semaphore> objets qui représentent le même de sémaphore système nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-224">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="3308a-225">Si le sémaphore système nommé n’existe pas, il est créé avec la sécurité de contrôle d’accès spécifié.</span><span class="sxs-lookup"><span data-stu-id="3308a-225">If the named system semaphore does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="3308a-226">Si le sémaphore nommé existe, la sécurité de contrôle d’accès spécifié est ignorée.</span><span class="sxs-lookup"><span data-stu-id="3308a-226">If the named semaphore exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3308a-227">L’appelant a un contrôle total sur nouvellement créé <xref:System.Threading.Semaphore> objet voire si `semaphoreSecurity` refuse ou ne parvient pas à accorder des droits d’accès à l’utilisateur actuel.</span><span class="sxs-lookup"><span data-stu-id="3308a-227">The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="3308a-228">Toutefois, si l’utilisateur actuel tente d’obtenir un autre <xref:System.Threading.Semaphore> pour représenter le même nommé sémaphore, en utilisant un constructeur de l’objet ou le <xref:System.Threading.Semaphore.OpenExisting%2A> (méthode), Windows sécurité de contrôle d’accès est appliquée.</span><span class="sxs-lookup"><span data-stu-id="3308a-228">However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="3308a-229">Si le sémaphore système nommé n’existe pas, il est créé avec le nombre initial et le nombre maximal spécifié par `initialCount` et `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="3308a-229">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="3308a-230">Si le sémaphore système nommé existe déjà, `initialCount` et `maximumCount` ne sont pas utilisés, bien que les valeurs non valides provoquent encore des exceptions.</span><span class="sxs-lookup"><span data-stu-id="3308a-230">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="3308a-231">Utilisez le `createdNew` paramètre pour déterminer si le sémaphore système a été créé par ce constructeur.</span><span class="sxs-lookup"><span data-stu-id="3308a-231">Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.</span></span>  
  
 <span data-ttu-id="3308a-232">Si `initialCount` est inférieure à `maximumCount`, et `createdNew` est `true`, l’effet est le même que si le thread actuel avait appelé <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` moins `initialCount`) fois.</span><span class="sxs-lookup"><span data-stu-id="3308a-232">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="3308a-233">Si vous spécifiez `null` ou une chaîne vide pour `name`, un sémaphore local est créé, comme si vous aviez appelé le <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> surcharge de constructeur.</span><span class="sxs-lookup"><span data-stu-id="3308a-233">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="3308a-234">Dans ce cas, `createdNew` est toujours `true`.</span><span class="sxs-lookup"><span data-stu-id="3308a-234">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="3308a-235">Étant donné que les sémaphores nommés sont visibles dans le système d’exploitation, elles peuvent servir pour coordonner l’utilisation des ressources au-delà des limites de processus.</span><span class="sxs-lookup"><span data-stu-id="3308a-235">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3308a-236">L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé avec une sécurité de contrôle d’accès.</span><span class="sxs-lookup"><span data-stu-id="3308a-236">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="3308a-237">L’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un sémaphore nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-237">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span> <span data-ttu-id="3308a-238">Si le sémaphore n’existe pas, il est créé avec un nombre maximal de deux et avec la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le sémaphore mais accorde le droit de lire et modifier les autorisations sur le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-238">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span> <span data-ttu-id="3308a-239">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-239">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="3308a-240">L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> surcharge de méthode pour ouvrir le sémaphore avec les droits nécessaires pour lire et modifier les autorisations.</span><span class="sxs-lookup"><span data-stu-id="3308a-240">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="3308a-241">Une fois que les autorisations sont modifiées, le sémaphore est ouvert avec les droits nécessaires à l’entrée et de libération.</span><span class="sxs-lookup"><span data-stu-id="3308a-241">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="3308a-242">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.</span><span class="sxs-lookup"><span data-stu-id="3308a-242">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3308a-243">
            <paramref name="initialCount" /> est supérieur à <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-243">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="3308a-244">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-244">-or-</span>
          </span>
          <span data-ttu-id="3308a-245">
            <paramref name="name" /> fait plus de 260 caractères.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-245">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3308a-246">
            <paramref name="maximumCount" /> est inférieur à 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-246">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="3308a-247">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-247">-or-</span>
          </span>
          <span data-ttu-id="3308a-248">
            <paramref name="initialCount" /> est inférieur à 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-248">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="3308a-249">Le sémaphore nommé existe et a la sécurité de contrôle d’accès, et l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-249">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="3308a-250">Une erreur Win32 s’est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-250">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="3308a-251">Le sémaphore nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-251">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="3308a-252">pour appeler du code non managé pour créer un sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-252">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="3308a-253">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-253">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="3308a-254">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-254">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3308a-255">Reçoit la sécurité de contrôle d'accès pour un sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-255">Gets the access control security for a named system semaphore.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3308a-256">Objet <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> qui représente la sécurité de contrôle d'accès pour le sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-256">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-257">Le <xref:System.Threading.Semaphore.GetAccessControl%2A> méthode utilise la combinaison d’indicateurs (combinées à l’aide de l’opération OR au niveau du bit) suivante pour rechercher des autorisations : <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, et <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3308a-257">The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3308a-258">L’utilisateur doit avoir <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> droits pour appeler cette méthode et le sémaphore doivent avoir été ouvert avec <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> droits.</span><span class="sxs-lookup"><span data-stu-id="3308a-258">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights.</span></span>  
  
 <span data-ttu-id="3308a-259">Sur un sémaphore local, la sécurité de contrôle d’accès est sans importance.</span><span class="sxs-lookup"><span data-stu-id="3308a-259">On a local semaphore, access control security is irrelevant.</span></span> <span data-ttu-id="3308a-260">Si le <xref:System.Threading.Semaphore> objet ne représente pas un sémaphore système nommé, cette méthode retourne un <xref:System.Security.AccessControl.SemaphoreSecurity> objet qui accorde tous les droits à tout utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3308a-260">If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3308a-261">L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé avec une sécurité de contrôle d’accès.</span><span class="sxs-lookup"><span data-stu-id="3308a-261">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="3308a-262">L’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un sémaphore nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-262">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="3308a-263">Si le sémaphore n’existe pas, il est créé avec un nombre maximal de deux et avec la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le sémaphore, mais qui accorde le droit de lire et modifier les autorisations sur le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-263">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="3308a-264">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-264">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="3308a-265">L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> surcharge de méthode pour ouvrir le sémaphore avec les droits nécessaires pour lire et modifier les autorisations.</span><span class="sxs-lookup"><span data-stu-id="3308a-265">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span> <span data-ttu-id="3308a-266">La sécurité de contrôle d’accès pour le sémaphore système est obtenue en utilisant la <xref:System.Threading.Semaphore.GetAccessControl%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-266">The access control security for the system semaphore is obtained using the <xref:System.Threading.Semaphore.GetAccessControl%2A> method.</span></span>  
  
 <span data-ttu-id="3308a-267">Une fois que les autorisations sont modifiées, le sémaphore est ouvert avec les droits nécessaires à l’entrée et de libération.</span><span class="sxs-lookup"><span data-stu-id="3308a-267">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="3308a-268">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.</span><span class="sxs-lookup"><span data-stu-id="3308a-268">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="3308a-269">L’objet <see cref="T:System.Threading.Semaphore" /> actif représente un sémaphore système nommé, et l’utilisateur ne dispose pas des droits <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-269">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          </span>
          <span data-ttu-id="3308a-270">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-270">-or-</span>
          </span>
          <span data-ttu-id="3308a-271">L’objet <see cref="T:System.Threading.Semaphore" /> actif représente un sémaphore système nommé, mais il n’a pas été ouvert avec les droits <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-271">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3308a-272">Non pris en charge par Windows 98 ou Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-272">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3308a-273">Ouvre un sémaphore nommé spécifié s'il existe déjà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-273">Opens a specified named semaphore, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3308a-274">Nom du sémaphore système à ouvrir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-274">The name of the system semaphore to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3308a-275">Ouvre le sémaphore nommé spécifié s'il existe déjà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-275">Opens the specified named semaphore, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3308a-276">Objet qui représente le sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-276">An object that represents the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-277">Le <xref:System.Threading.Semaphore.OpenExisting%2A> méthode tente d’ouvrir le sémaphore nommé spécifié.</span><span class="sxs-lookup"><span data-stu-id="3308a-277">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore.</span></span> <span data-ttu-id="3308a-278">Si le sémaphore système n’existe pas, cette méthode lève une exception au lieu de créer le sémaphore système.</span><span class="sxs-lookup"><span data-stu-id="3308a-278">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="3308a-279">Pour créer le sémaphore système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.Semaphore.%23ctor%2A> constructeurs qui a un `name` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3308a-279">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="3308a-280">Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.Semaphore> de l’objet, même si les objets retournés représentent le même sémaphore système nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-280">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="3308a-281">Cette surcharge de méthode revient à appeler le <xref:System.Threading.Semaphore.OpenExisting%2A> surcharge de méthode et en spécifiant <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> et <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> droits, combinés à l’aide de l’opération OR au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="3308a-281">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="3308a-282">En spécifiant le <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> indicateur permet d’entrer dans le sémaphore, un thread et en spécifiant le <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> indicateur permet à un thread d’appeler le <xref:System.Threading.Semaphore.Release%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-282">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3308a-283">L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé avec une sécurité de contrôle d’accès.</span><span class="sxs-lookup"><span data-stu-id="3308a-283">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="3308a-284">L’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un sémaphore nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-284">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="3308a-285">Si le sémaphore n’existe pas, il est créé avec un nombre maximal de deux et avec la sécurité de contrôle d’accès qui refuse à l’utilisateur actuel le droit d’utiliser le sémaphore, mais qui accorde le droit de lire et modifier les autorisations sur le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-285">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="3308a-286">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="3308a-286">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload.</span></span> <span data-ttu-id="3308a-287">L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> surcharge de méthode pour ouvrir le sémaphore avec les droits nécessaires pour lire et modifier les autorisations.</span><span class="sxs-lookup"><span data-stu-id="3308a-287">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="3308a-288">Une fois que les autorisations sont modifiées, le sémaphore est ouvert avec les droits nécessaires à l’entrée et de libération.</span><span class="sxs-lookup"><span data-stu-id="3308a-288">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="3308a-289">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.</span><span class="sxs-lookup"><span data-stu-id="3308a-289">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3308a-290">
            <paramref name="name" /> est une chaîne vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-290">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="3308a-291">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-291">-or-</span>
          </span>
          <span data-ttu-id="3308a-292">
            <paramref name="name" /> fait plus de 260 caractères.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-292">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3308a-293">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-293">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="3308a-294">Le sémaphore nommé n'existe pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-294">The named semaphore does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="3308a-295">Une erreur Win32 s’est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-295">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="3308a-296">Le sémaphore nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-296">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="3308a-297">pour appeler du code non managé pour ouvrir un sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-297">for calling unmanaged code to open a named system semaphore.</span>
          </span>
          <span data-ttu-id="3308a-298">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-298">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="3308a-299">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-299">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3308a-300">Nom du sémaphore système à ouvrir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-300">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="3308a-301">Combinaison d'opérations de bits des valeurs d'énumération qui représentent l'accès de sécurité voulu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-301">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3308a-302">Ouvre le sémaphore nommé spécifié, s'il existe déjà, avec l'accès de sécurité souhaité.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-302">Opens the specified named semaphore, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3308a-303">Objet qui représente le sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-303">An object that represents the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-304">Le `rights` paramètre doit inclure le <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> indicateur pour permettre aux threads d’entrer dans le sémaphore et le <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> indicateur pour permettre d’appeler le <xref:System.Threading.Semaphore.Release%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-304">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="3308a-305">Le <xref:System.Threading.Semaphore.OpenExisting%2A> méthode tente d’ouvrir un sémaphore nommé existant.</span><span class="sxs-lookup"><span data-stu-id="3308a-305">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore.</span></span> <span data-ttu-id="3308a-306">Si le sémaphore système n’existe pas, cette méthode lève une exception au lieu de créer le sémaphore système.</span><span class="sxs-lookup"><span data-stu-id="3308a-306">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="3308a-307">Pour créer le sémaphore système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.Semaphore.%23ctor%2A> constructeurs qui a un `name` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3308a-307">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="3308a-308">Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.Semaphore> de l’objet, même si les objets retournés représentent le même sémaphore système nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-308">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3308a-309">L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé avec une sécurité de contrôle d’accès.</span><span class="sxs-lookup"><span data-stu-id="3308a-309">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="3308a-310">L’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un sémaphore nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-310">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="3308a-311">Si le sémaphore n’existe pas, il est créé avec un nombre maximal de deux et avec la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le sémaphore, mais qui accorde le droit de lire et modifier les autorisations sur le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-311">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="3308a-312">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-312">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="3308a-313">L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> surcharge de méthode pour ouvrir le sémaphore avec les droits nécessaires pour lire et modifier les autorisations.</span><span class="sxs-lookup"><span data-stu-id="3308a-313">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="3308a-314">Une fois que les autorisations sont modifiées, le sémaphore est ouvert avec les droits nécessaires à l’entrée et de libération.</span><span class="sxs-lookup"><span data-stu-id="3308a-314">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="3308a-315">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.</span><span class="sxs-lookup"><span data-stu-id="3308a-315">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3308a-316">
            <paramref name="name" /> est une chaîne vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-316">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="3308a-317">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-317">-or-</span>
          </span>
          <span data-ttu-id="3308a-318">
            <paramref name="name" /> fait plus de 260 caractères.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-318">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3308a-319">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-319">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="3308a-320">Le sémaphore nommé n'existe pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-320">The named semaphore does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="3308a-321">Une erreur Win32 s’est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-321">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="3308a-322">Le sémaphore nommé existe, mais l'utilisateur n'a pas les droits d'accès de sécurité voulus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-322">The named semaphore exists, but the user does not have the desired security access rights.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="3308a-323">pour appeler du code non managé pour créer un sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-323">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="3308a-324">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-324">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="3308a-325">Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-325">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3308a-326">Quitte le sémaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-326">Exits the semaphore.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3308a-327">Quitte le sémaphore et retourne le compteur antérieur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-327">Exits the semaphore and returns the previous count.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3308a-328">Compteur du sémaphore avant appel de la méthode <see cref="Overload:System.Threading.Semaphore.Release" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-328">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-329">Les threads utilisent généralement le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode permet d’entrer le sémaphore et ils généralement utiliser cette surcharge de méthode pour quitter.</span><span class="sxs-lookup"><span data-stu-id="3308a-329">Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.</span></span>  
  
 <span data-ttu-id="3308a-330">Si un <xref:System.Threading.SemaphoreFullException> est levée par le <xref:System.Threading.Semaphore.Release%2A> (méthode), il n’indique pas nécessairement un problème avec le thread appelant.</span><span class="sxs-lookup"><span data-stu-id="3308a-330">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="3308a-331">Une erreur de programmation dans un autre thread peut avoir provoqué ce thread quitte le sémaphore fois plus important qu’il a entré.</span><span class="sxs-lookup"><span data-stu-id="3308a-331">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="3308a-332">Si actuel <xref:System.Threading.Semaphore> objet représente un sémaphore système nommé, l’utilisateur doit avoir <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> droits et le sémaphore doivent avoir été ouvert avec <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> droits.</span><span class="sxs-lookup"><span data-stu-id="3308a-332">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3308a-333">L’exemple de code suivant crée un sémaphore avec un nombre maximal de trois et un nombre initial de zéro.</span><span class="sxs-lookup"><span data-stu-id="3308a-333">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="3308a-334">L’exemple démarre cinq threads, qui bloquent en attendant le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-334">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="3308a-335">Le thread principal utilise le <xref:System.Threading.Semaphore.Release%28System.Int32%29> surcharge de méthode pour augmenter le compteur du sémaphore à sa valeur maximale, en autorisant trois threads à entrer dans le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-335">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="3308a-336">Chaque thread utilise la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> méthode pour attendre une seconde, pour simuler le travail, puis appelle le <xref:System.Threading.Semaphore.Release> surcharge de méthode pour libérer le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-336">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="3308a-337">Chaque fois que le sémaphore est libéré, le compteur du sémaphore précédent s’affiche.</span><span class="sxs-lookup"><span data-stu-id="3308a-337">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="3308a-338">Console messages suivre l’utilisation sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-338">Console messages track semaphore use.</span></span> <span data-ttu-id="3308a-339">L’intervalle de travail simulé augmente légèrement à chaque thread, pour faciliter la lecture de la sortie.</span><span class="sxs-lookup"><span data-stu-id="3308a-339">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <span data-ttu-id="3308a-340">Le compteur du sémaphore est déjà à la valeur maximale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-340">The semaphore count is already at the maximum value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="3308a-341">Une erreur Win32 s'est produite avec un sémaphore nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-341">A Win32 error occurred with a named semaphore.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="3308a-342">Le sémaphore actuel représente un sémaphore système nommé, mais l'utilisateur ne détient pas de droits <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-342">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          </span>
          <span data-ttu-id="3308a-343">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-343">-or-</span>
          </span>
          <span data-ttu-id="3308a-344">Le sémaphore actuel représente un sémaphore système nommé, mais il n'a pas été ouvert avec des droits <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-344">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">
          <span data-ttu-id="3308a-345">Nombre de fois où quitter le sémaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-345">The number of times to exit the semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3308a-346">Quitte le sémaphore un nombre spécifié de fois et retourne le compteur précédent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-346">Exits the semaphore a specified number of times and returns the previous count.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3308a-347">Compteur du sémaphore avant appel de la méthode <see cref="Overload:System.Threading.Semaphore.Release" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-347">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-348">Si un thread a entré le sémaphore plusieurs fois, cette surcharge de méthode permet le compteur du sémaphore entière à être restaurée avec un seul appel.</span><span class="sxs-lookup"><span data-stu-id="3308a-348">If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</span></span>  
  
 <span data-ttu-id="3308a-349">Si un <xref:System.Threading.SemaphoreFullException> est levée par le <xref:System.Threading.Semaphore.Release%2A> (méthode), il n’indique pas nécessairement un problème avec le thread appelant.</span><span class="sxs-lookup"><span data-stu-id="3308a-349">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="3308a-350">Une erreur de programmation dans un autre thread peut avoir provoqué ce thread quitte le sémaphore fois plus important qu’il a entré.</span><span class="sxs-lookup"><span data-stu-id="3308a-350">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="3308a-351">Si actuel <xref:System.Threading.Semaphore> objet représente un sémaphore système nommé, l’utilisateur doit avoir <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> droits et le sémaphore doivent avoir été ouvert avec <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> droits.</span><span class="sxs-lookup"><span data-stu-id="3308a-351">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3308a-352">L’exemple de code suivant crée un sémaphore avec un nombre maximal de trois et un nombre initial de zéro.</span><span class="sxs-lookup"><span data-stu-id="3308a-352">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="3308a-353">L’exemple démarre cinq threads, qui bloquent en attendant le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-353">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="3308a-354">Le thread principal utilise le <xref:System.Threading.Semaphore.Release%28System.Int32%29> surcharge de méthode pour augmenter le compteur du sémaphore à sa valeur maximale, en autorisant trois threads à entrer dans le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-354">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="3308a-355">Chaque thread utilise la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> méthode pour attendre une seconde, pour simuler le travail, puis appelle le <xref:System.Threading.Semaphore.Release> surcharge de méthode pour libérer le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-355">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="3308a-356">Chaque fois que le sémaphore est libéré, le compteur du sémaphore précédent s’affiche.</span><span class="sxs-lookup"><span data-stu-id="3308a-356">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="3308a-357">Console messages suivre l’utilisation sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-357">Console messages track semaphore use.</span></span> <span data-ttu-id="3308a-358">L’intervalle de travail simulé augmente légèrement à chaque thread, pour faciliter la lecture de la sortie.</span><span class="sxs-lookup"><span data-stu-id="3308a-358">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3308a-359">
            <paramref name="releaseCount" /> est inférieur à 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-359">
              <paramref name="releaseCount" /> is less than 1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <span data-ttu-id="3308a-360">Le compteur du sémaphore est déjà à la valeur maximale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-360">The semaphore count is already at the maximum value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="3308a-361">Une erreur Win32 s'est produite avec un sémaphore nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-361">A Win32 error occurred with a named semaphore.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="3308a-362">Le sémaphore actuel représente un sémaphore système nommé, mais l'utilisateur ne détient pas de droits <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-362">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          </span>
          <span data-ttu-id="3308a-363">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-363">-or-</span>
          </span>
          <span data-ttu-id="3308a-364">Le sémaphore actuel représente un sémaphore système nommé, mais il n'a pas été ouvert avec des droits <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-364">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">
          <span data-ttu-id="3308a-365">Objet <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> qui représente la sécurité de contrôle d'accès à appliquer au sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-365">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3308a-366">Définit la sécurité de contrôle d'accès pour un sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-366">Sets the access control security for a named system semaphore.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-367">Vous pouvez définir la sécurité de contrôle d’accès uniquement sur <xref:System.Threading.Semaphore> objets qui représentent des sémaphores de système nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-367">You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.</span></span>  
  
 <span data-ttu-id="3308a-368">L’utilisateur doit avoir <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> droits pour appeler cette méthode et le sémaphore doivent avoir été ouvert avec <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> droits.</span><span class="sxs-lookup"><span data-stu-id="3308a-368">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3308a-369">L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé avec une sécurité de contrôle d’accès.</span><span class="sxs-lookup"><span data-stu-id="3308a-369">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="3308a-370">L’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un sémaphore nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-370">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="3308a-371">Si le sémaphore n’existe pas, il est créé avec un nombre maximal de deux et avec la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le sémaphore mais accorde le droit de lire et modifier les autorisations sur le sémaphore.</span><span class="sxs-lookup"><span data-stu-id="3308a-371">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="3308a-372">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-372">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="3308a-373">L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> surcharge de méthode pour ouvrir le sémaphore avec les droits nécessaires pour lire et modifier les autorisations.</span><span class="sxs-lookup"><span data-stu-id="3308a-373">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="3308a-374">Une fois que les autorisations sont modifiées, à l’aide de la <xref:System.Threading.Semaphore.SetAccessControl%2A> (méthode), le sémaphore est ouvert avec les droits nécessaires à l’entrée et de libération.</span><span class="sxs-lookup"><span data-stu-id="3308a-374">After the permissions are changed, using the <xref:System.Threading.Semaphore.SetAccessControl%2A> method, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="3308a-375">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.</span><span class="sxs-lookup"><span data-stu-id="3308a-375">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3308a-376">
            <paramref name="semaphoreSecurity" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-376">
              <paramref name="semaphoreSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="3308a-377">L'utilisateur ne détient pas d'autorisations <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-377">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          </span>
          <span data-ttu-id="3308a-378">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-378">-or-</span>
          </span>
          <span data-ttu-id="3308a-379">Le sémaphore n'a pas été ouvert avec les droits <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-379">The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3308a-380">L'objet <see cref="T:System.Threading.Semaphore" /> actuel ne représente pas de sémaphore système nommé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-380">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3308a-381">Ouvre un sémaphore nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-381">Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3308a-382">Nom du sémaphore système à ouvrir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-382">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="3308a-383">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.Semaphore" /> qui représente le sémaphore nommé si l'appel a réussi, ou <see langword="null" /> si l'appel a échoué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-383">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="3308a-384">Ce paramètre est traité comme étant non initialisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-384">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3308a-385">Ouvre le sémaphore nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-385">Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3308a-386">
            <see langword="true" /> si le sémaphore nommé a été ouvert ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-386">
              <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-387">Si le sémaphore nommé n’existe pas, cette méthode ne le crée pas.</span><span class="sxs-lookup"><span data-stu-id="3308a-387">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="3308a-388">Pour créer le sémaphore système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.Semaphore.%23ctor%2A> constructeurs qui a un `name` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3308a-388">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="3308a-389">Si vous ne savez pas si un sémaphore nommé existe, utilisez cette surcharge de méthode au lieu du <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode qui lève une exception si le sémaphore n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="3308a-389">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="3308a-390">Cette surcharge de méthode revient à appeler le <xref:System.Threading.Semaphore.TryOpenExisting%2A> surcharge de méthode et en spécifiant <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> et <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> droits, combinés à l’aide de l’opération OR au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="3308a-390">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="3308a-391">En spécifiant le <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> indicateur permet d’entrer dans le sémaphore, un thread et en spécifiant le <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> indicateur permet à un thread d’appeler le <xref:System.Threading.Semaphore.Release%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-391">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3308a-392">
            <paramref name="name" /> est une chaîne vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-392">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="3308a-393">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-393">-or-</span>
          </span>
          <span data-ttu-id="3308a-394">
            <paramref name="name" /> fait plus de 260 caractères.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-394">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3308a-395">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-395">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="3308a-396">Une erreur Win32 s’est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-396">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="3308a-397">Le sémaphore nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-397">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3308a-398">Nom du sémaphore système à ouvrir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-398">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="3308a-399">Combinaison d'opérations de bits des valeurs d'énumération qui représentent l'accès de sécurité voulu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-399">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="3308a-400">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.Semaphore" /> qui représente le sémaphore nommé si l'appel a réussi, ou <see langword="null" /> si l'appel a échoué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-400">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="3308a-401">Ce paramètre est traité comme étant non initialisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-401">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3308a-402">Ouvre le sémaphore nommé spécifié, s'il existe déjà, avec l'accès de sécurité souhaité, puis retourne une valeur indiquant si l'opération a réussi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-402">Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3308a-403">
            <see langword="true" /> si le sémaphore nommé a été ouvert ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-403">
              <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3308a-404">Si le sémaphore nommé n’existe pas, cette méthode ne le crée pas.</span><span class="sxs-lookup"><span data-stu-id="3308a-404">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="3308a-405">Pour créer le sémaphore système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.Semaphore.%23ctor%2A> constructeurs qui a un `name` paramètre.</span><span class="sxs-lookup"><span data-stu-id="3308a-405">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="3308a-406">Si vous ne savez pas si un sémaphore nommé existe, utilisez cette surcharge de méthode au lieu du <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> surcharge de méthode qui lève une exception si le sémaphore n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="3308a-406">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="3308a-407">Le `rights` paramètre doit inclure le <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> indicateur pour permettre aux threads d’entrer dans le sémaphore et le <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> indicateur pour permettre d’appeler le <xref:System.Threading.Semaphore.Release%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="3308a-407">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="3308a-408">Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.Semaphore> de l’objet, même si les objets retournés représentent le même sémaphore système nommé.</span><span class="sxs-lookup"><span data-stu-id="3308a-408">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3308a-409">
            <paramref name="name" /> est une chaîne vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-409">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="3308a-410">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-410">-or-</span>
          </span>
          <span data-ttu-id="3308a-411">
            <paramref name="name" /> fait plus de 260 caractères.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-411">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3308a-412">
            <paramref name="name" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-412">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="3308a-413">Une erreur Win32 s’est produite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-413">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="3308a-414">Le sémaphore nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="3308a-414">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>