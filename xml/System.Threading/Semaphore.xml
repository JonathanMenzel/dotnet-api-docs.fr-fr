<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dfd4af5a6146da7c3a1e0bf3e9198f1ae1ef7404" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52214168" /></Metadata><TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Limite le nombre de threads qui peuvent accéder simultanément à une ressource ou à un pool de ressources.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Threading.Semaphore> classe pour contrôler l’accès à un pool de ressources. Threads entrent dans le sémaphore en appelant le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode), qui est hérité de la <xref:System.Threading.WaitHandle> classe et de libérer le sémaphore en appelant le <xref:System.Threading.Semaphore.Release%2A> (méthode).  
  
 Le nombre sur un sémaphore est décrémenté à chaque fois qu’un thread entre dans le sémaphore et incrémenté lorsqu’un thread libère le sémaphore. Lorsque le nombre est zéro, les demandes suivantes bloquent jusqu'à ce que les autres threads libèrent le sémaphore. Lorsque tous les threads ont libéré le sémaphore, le nombre est à la valeur maximale spécifié lors de la création du sémaphore.  
  
 Il n’existe aucun ordre garanti, telles que FIFO ou LIFO, dans lequel les threads bloqués entrent dans le sémaphore.  
  
 Un thread peut entrer le sémaphore plusieurs fois, en appelant le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode à plusieurs reprises. Pour libérer certaines ou toutes ces entrées, le thread peut appeler sans paramètre <xref:System.Threading.Semaphore.Release> plusieurs fois, ou il peut appeler la surcharge de méthode le <xref:System.Threading.Semaphore.Release%28System.Int32%29> surcharge de méthode qui spécifie le nombre d’entrées à libérer.  
  
 Le <xref:System.Threading.Semaphore> classe n’applique pas l’identité du thread sur les appels à <xref:System.Threading.WaitHandle.WaitOne%2A> ou <xref:System.Threading.Semaphore.Release%2A>. Il est la responsabilité du programmeur pour vous assurer que threads ne libèrent pas le sémaphore trop souvent. Supposons, par exemple, qu'un sémaphore ait un nombre maximal égal à deux et que le thread A et le thread B entrent dans le sémaphore. Si une erreur de programmation dans le thread B le conduit à appeler <xref:System.Threading.Semaphore.Release%2A> à deux reprises, les deux appels aboutiront. Le nombre maximal du sémaphore sera alors atteint, et quand le thread A appellera <xref:System.Threading.Semaphore.Release%2A>, une exception <xref:System.Threading.SemaphoreFullException> sera levée.  
  
 Les sémaphores sont de deux types : local et les sémaphores de système nommé. Si vous créez un <xref:System.Threading.Semaphore> de l’objet à l’aide d’un constructeur qui accepte un nom, il est associé à un sémaphore système d’exploitation portant ce nom. Système nommé sémaphores sont visibles dans tout le système d’exploitation, peuvent être utilisés pour synchroniser les activités de processus. Vous pouvez créer plusieurs <xref:System.Threading.Semaphore> les objets qui représentent le même de sémaphore système nommé, et vous pouvez utiliser le <xref:System.Threading.Semaphore.OpenExisting%2A> sémaphore système nommé de méthode pour ouvrir un existant.  
  
 Un sémaphore local existe uniquement dans votre processus. Il peut être utilisé par tout thread de votre processus qui a une référence à l’objet <xref:System.Threading.Semaphore> local. Chaque <xref:System.Threading.Semaphore> objet est un sémaphore local distinct.  
  
   
  
## Examples  
 L’exemple de code suivant crée un sémaphore avec un nombre maximal de trois et un nombre initial de zéro. L’exemple démarre cinq threads, qui bloquent en attendant le sémaphore. Le thread principal utilise le <xref:System.Threading.Semaphore.Release%28System.Int32%29> surcharge de méthode pour augmenter le compteur du sémaphore à sa valeur maximale, en autorisant trois threads à entrer dans le sémaphore. Chaque thread utilise la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> méthode pour attendre une seconde, pour simuler le travail, puis appelle le <xref:System.Threading.Semaphore.Release> surcharge de méthode pour libérer le sémaphore. Chaque fois que le sémaphore est libéré, le compteur du sémaphore précédent s’affiche. Console messages suivre l’utilisation sémaphore. L’intervalle de travail simulé augmente légèrement à chaque thread, pour faciliter la lecture de la sortie.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Nombre initial de demandes pour le sémaphore qui peuvent être accordées simultanément.</param>
        <param name="maximumCount">Nombre maximal de demandes pour le sémaphore qui peuvent être accordées simultanément.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" /> en spécifiant le nombre initial d'entrées et le nombre maximal d'entrées simultanées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise un sémaphore sans nom. Tous les threads qui utilisent une instance de ce sémaphore doivent disposer de références à l’instance.  
  
 Si `initialCount` est inférieure à `maximumCount`, l’effet est le même que si le thread actuel avait appelé <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` moins `initialCount`) fois. Si vous ne souhaitez pas réserver d’entrées pour le thread qui crée le sémaphore, utilisez le même nombre de `maximumCount` et `initialCount`.  
  
   
  
## Examples  
 L’exemple suivant crée un sémaphore avec un nombre maximal de trois et un nombre initial de zéro. L’exemple démarre cinq threads, qui bloquent en attendant le sémaphore. Le thread principal utilise le <xref:System.Threading.Semaphore.Release%28System.Int32%29> surcharge de méthode pour augmenter le compteur du sémaphore à sa valeur maximale, en autorisant trois threads à entrer dans le sémaphore. Chaque thread utilise la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> méthode pour attendre une seconde, pour simuler le travail, puis appelle le <xref:System.Threading.Semaphore.Release> surcharge de méthode pour libérer le sémaphore. Chaque fois que le sémaphore est libéré, le compteur du sémaphore précédent s’affiche. Console messages suivre l’utilisation sémaphore. L’intervalle de travail simulé augmente légèrement à chaque thread, pour faciliter la lecture de la sortie.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" /> est supérieur à <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" /> est inférieur à 1.  
  
- ou - 
 <paramref name="initialCount" /> est inférieur à 0.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">Nombre initial de demandes pour le sémaphore qui peuvent être accordées simultanément.</param>
        <param name="maximumCount">Nombre maximal de demandes pour le sémaphore qui peuvent être accordées simultanément.</param>
        <param name="name">Nom d'un objet de sémaphore système nommé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" /> en spécifiant le nombre initial d'entrées et le nombre maximal d'entrées simultanées, et en spécifiant en option le nom d'un objet sémaphore système.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise un <xref:System.Threading.Semaphore> objet qui représente un sémaphore système nommé. Vous pouvez créer plusieurs <xref:System.Threading.Semaphore> objets qui représentent le même de sémaphore système nommé.  
  
 Si le sémaphore système nommé n’existe pas, il est créé avec le nombre initial et le nombre maximal spécifié par `initialCount` et `maximumCount`. Si le sémaphore système nommé existe déjà, `initialCount` et `maximumCount` ne sont pas utilisés, bien que les valeurs non valides provoquent encore des exceptions. Si vous avez besoin déterminer si un sémaphore système nommé a été créé, utilisez la <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> plutôt la surcharge de constructeur.  
  
> [!IMPORTANT]
>  Lorsque vous utilisez cette surcharge de constructeur, la pratique recommandée consiste à spécifier le même nombre de `initialCount` et `maximumCount`. Si `initialCount` est inférieure à `maximumCount`et un sémaphore système nommé est créé, l’effet est le même que si le thread actuel avait appelé <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` moins `initialCount`) fois. Toutefois, avec cette surcharge de constructeur il n’existe aucun moyen pour déterminer si un sémaphore système nommé a été créé.  
  
 Si vous spécifiez `null` ou une chaîne vide pour `name`, un sémaphore local est créé, comme si vous aviez appelé le <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> surcharge de constructeur.  
  
 Étant donné que les sémaphores nommés sont visibles dans le système d’exploitation, elles peuvent servir pour coordonner l’utilisation des ressources au-delà des limites de processus.  
  
 Si vous souhaitez savoir si un sémaphore système nommé existe, utilisez le <xref:System.Threading.Semaphore.OpenExisting%2A> (méthode). Le <xref:System.Threading.Semaphore.OpenExisting%2A> méthode tente d’ouvrir un sémaphore nommé existant et lève une exception si le sémaphore système n’existe pas.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé. L’exemple crée un sémaphore nommé avec un nombre maximal de cinq et un nombre initial de cinq. Le programme fait trois appels à la <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Par conséquent, si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie bloquera le troisième appel à <xref:System.Threading.WaitHandle.WaitOne%2A>. Libérer une ou plusieurs entrées dans la première copie du programme pour débloquer la deuxième.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" /> est supérieur à <paramref name="maximumCount" />.  
  
- ou - 
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" /> est inférieur à 1.  
  
- ou - 
 <paramref name="initialCount" /> est inférieur à 0.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le sémaphore nommé existe et a la sécurité de contrôle d’accès, et l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le sémaphore nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé pour créer un sémaphore système nommé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">Nombre initial de demandes pour le sémaphore qui peut être satisfait simultanément.</param>
        <param name="maximumCount">Nombre maximal de demandes pour le sémaphore qui peut être satisfait simultanément.</param>
        <param name="name">Nom d'un objet de sémaphore système nommé.</param>
        <param name="createdNew">Cette méthode retourne <see langword="true" /> si un sémaphore local a été créé (en d'autres termes, si <paramref name="name" /> est <see langword="null" /> ou une chaîne vide) ou si le sémaphore système nommé spécifié a été créé ; <see langword="false" /> si le sémaphore système nommé spécifié existait déjà. Ce paramètre est passé sans être initialisé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" /> en spécifiant le nombre initial d'entrées et le nombre maximal d'entrées simultanées, en spécifiant en option le nom d'un objet sémaphore système et en spécifiant une variable qui reçoit une valeur indiquant si un sémaphore système a été créé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise un <xref:System.Threading.Semaphore> objet qui représente un sémaphore système nommé. Vous pouvez créer plusieurs <xref:System.Threading.Semaphore> objets qui représentent le même de sémaphore système nommé.  
  
 Si le sémaphore système nommé n’existe pas, il est créé avec le nombre initial et le nombre maximal spécifié par `initialCount` et `maximumCount`. Si le sémaphore système nommé existe déjà, `initialCount` et `maximumCount` ne sont pas utilisés, bien que les valeurs non valides provoquent encore des exceptions. Utilisez `createdNew` pour déterminer si le sémaphore système a été créé.  
  
 Si `initialCount` est inférieure à `maximumCount`, et `createdNew` est `true`, l’effet est le même que si le thread actuel avait appelé <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` moins `initialCount`) fois.  
  
 Si vous spécifiez `null` ou une chaîne vide pour `name`, un sémaphore local est créé, comme si vous aviez appelé le <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> surcharge de constructeur. Dans ce cas, `createdNew` est toujours `true`.  
  
 Étant donné que les sémaphores nommés sont visibles dans le système d’exploitation, elles peuvent servir pour coordonner l’utilisation des ressources au-delà des limites de processus.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé. L’exemple crée un sémaphore nommé avec un nombre maximal de cinq et un nombre initial de deux. Autrement dit, il réserve trois entrées pour le thread qui appelle le constructeur. Si `createNew` est `false`, le programme fait trois appels à la <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode). Par conséquent, si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie bloquera le troisième appel à <xref:System.Threading.WaitHandle.WaitOne%2A>. Libérer une ou plusieurs entrées dans la première copie du programme pour débloquer la deuxième.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" /> est supérieur à <paramref name="maximumCount" />.  
  
- ou - 
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" /> est inférieur à 1.  
  
- ou - 
 <paramref name="initialCount" /> est inférieur à 0.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le sémaphore nommé existe et a la sécurité de contrôle d’accès, et l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le sémaphore nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé pour créer un sémaphore système nommé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">Nombre initial de demandes pour le sémaphore qui peut être satisfait simultanément.</param>
        <param name="maximumCount">Nombre maximal de demandes pour le sémaphore qui peut être satisfait simultanément.</param>
        <param name="name">Nom d'un objet de sémaphore système nommé.</param>
        <param name="createdNew">Cette méthode retourne <see langword="true" /> si un sémaphore local a été créé (en d'autres termes, si <paramref name="name" /> est <see langword="null" /> ou une chaîne vide) ou si le sémaphore système nommé spécifié a été créé ; <see langword="false" /> si le sémaphore système nommé spécifié existait déjà. Ce paramètre est passé sans être initialisé.</param>
        <param name="semaphoreSecurity">Objet <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> qui représente la sécurité de contrôle d'accès à appliquer au sémaphore système nommé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Semaphore" /> en spécifiant le nombre initial d'entrées et le nombre maximal d'entrées simultanées, en spécifiant en option le nom d'un objet sémaphore système et en spécifiant une variable qui reçoit une valeur indiquant si un nouveau sémaphore système a été créé et spécifiant le contrôle d'accès de sécurité pour le sémaphore système.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur pour appliquer la sécurité de contrôle d’accès pour un sémaphore système nommé lors de sa création, en empêchant l’autre code de prendre le contrôle du sémaphore.  
  
 Ce constructeur initialise un <xref:System.Threading.Semaphore> objet qui représente un sémaphore système nommé. Vous pouvez créer plusieurs <xref:System.Threading.Semaphore> objets qui représentent le même de sémaphore système nommé.  
  
 Si le sémaphore système nommé n’existe pas, il est créé avec la sécurité de contrôle d’accès spécifié. Si le sémaphore nommé existe, la sécurité de contrôle d’accès spécifié est ignorée.  
  
> [!NOTE]
>  L’appelant a un contrôle total sur nouvellement créé <xref:System.Threading.Semaphore> objet voire si `semaphoreSecurity` refuse ou ne parvient pas à accorder des droits d’accès à l’utilisateur actuel. Toutefois, si l’utilisateur actuel tente d’obtenir un autre <xref:System.Threading.Semaphore> pour représenter le même nommé sémaphore, en utilisant un constructeur de l’objet ou le <xref:System.Threading.Semaphore.OpenExisting%2A> (méthode), Windows sécurité de contrôle d’accès est appliquée.  
  
 Si le sémaphore système nommé n’existe pas, il est créé avec le nombre initial et le nombre maximal spécifié par `initialCount` et `maximumCount`. Si le sémaphore système nommé existe déjà, `initialCount` et `maximumCount` ne sont pas utilisés, bien que les valeurs non valides provoquent encore des exceptions. Utilisez le `createdNew` paramètre pour déterminer si le sémaphore système a été créé par ce constructeur.  
  
 Si `initialCount` est inférieure à `maximumCount`, et `createdNew` est `true`, l’effet est le même que si le thread actuel avait appelé <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` moins `initialCount`) fois.  
  
 Si vous spécifiez `null` ou une chaîne vide pour `name`, un sémaphore local est créé, comme si vous aviez appelé le <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> surcharge de constructeur. Dans ce cas, `createdNew` est toujours `true`.  
  
 Étant donné que les sémaphores nommés sont visibles dans le système d’exploitation, elles peuvent servir pour coordonner l’utilisation des ressources au-delà des limites de processus.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé avec une sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un sémaphore nommé. Si le sémaphore n’existe pas, il est créé avec un nombre maximal de deux et avec la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le sémaphore mais accorde le droit de lire et modifier les autorisations sur le sémaphore. Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (méthode). L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> surcharge de méthode pour ouvrir le sémaphore avec les droits nécessaires pour lire et modifier les autorisations.  
  
 Une fois que les autorisations sont modifiées, le sémaphore est ouvert avec les droits nécessaires à l’entrée et de libération. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" /> est supérieur à <paramref name="maximumCount" />.  
  
- ou - 
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" /> est inférieur à 1.  
  
- ou - 
 <paramref name="initialCount" /> est inférieur à 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le sémaphore nommé existe et a la sécurité de contrôle d’accès, et l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le sémaphore nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé pour créer un sémaphore système nommé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reçoit la sécurité de contrôle d'accès pour un sémaphore système nommé.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> qui représente la sécurité de contrôle d'accès pour le sémaphore système nommé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Semaphore.GetAccessControl%2A> méthode utilise la combinaison d’indicateurs (combinées à l’aide de l’opération OR au niveau du bit) suivante pour rechercher des autorisations : <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, et <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 L’utilisateur doit avoir <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> droits pour appeler cette méthode et le sémaphore doivent avoir été ouvert avec <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> droits.  
  
 Sur un sémaphore local, la sécurité de contrôle d’accès est sans importance. Si le <xref:System.Threading.Semaphore> objet ne représente pas un sémaphore système nommé, cette méthode retourne un <xref:System.Security.AccessControl.SemaphoreSecurity> objet qui accorde tous les droits à tout utilisateur.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé avec une sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un sémaphore nommé.  
  
 Si le sémaphore n’existe pas, il est créé avec un nombre maximal de deux et avec la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le sémaphore, mais qui accorde le droit de lire et modifier les autorisations sur le sémaphore.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (méthode). L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> surcharge de méthode pour ouvrir le sémaphore avec les droits nécessaires pour lire et modifier les autorisations. La sécurité de contrôle d’accès pour le sémaphore système est obtenue en utilisant la <xref:System.Threading.Semaphore.GetAccessControl%2A> (méthode).  
  
 Une fois que les autorisations sont modifiées, le sémaphore est ouvert avec les droits nécessaires à l’entrée et de libération. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L’objet <see cref="T:System.Threading.Semaphore" /> actif représente un sémaphore système nommé, et l’utilisateur ne dispose pas des droits <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.  
  
- ou - 
L’objet <see cref="T:System.Threading.Semaphore" /> actif représente un sémaphore système nommé, mais il n’a pas été ouvert avec les droits <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Non pris en charge par Windows 98 ou Windows Millennium Edition.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un sémaphore nommé spécifié s'il existe déjà.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom du sémaphore système à ouvrir.</param>
        <summary>Ouvre le sémaphore nommé spécifié s'il existe déjà.</summary>
        <returns>Objet qui représente le sémaphore système nommé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Semaphore.OpenExisting%2A> méthode tente d’ouvrir le sémaphore nommé spécifié. Si le sémaphore système n’existe pas, cette méthode lève une exception au lieu de créer le sémaphore système. Pour créer le sémaphore système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.Semaphore.%23ctor%2A> constructeurs qui a un `name` paramètre.  
  
 Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.Semaphore> de l’objet, même si les objets retournés représentent le même sémaphore système nommé.  
  
 Cette surcharge de méthode revient à appeler le <xref:System.Threading.Semaphore.OpenExisting%2A> surcharge de méthode et en spécifiant <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> et <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> droits, combinés à l’aide de l’opération OR au niveau du bit.  
  
 En spécifiant le <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> indicateur permet d’entrer dans le sémaphore, un thread et en spécifiant le <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> indicateur permet à un thread d’appeler le <xref:System.Threading.Semaphore.Release%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé avec une sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un sémaphore nommé.  
  
 Si le sémaphore n’existe pas, il est créé avec un nombre maximal de deux et avec la sécurité de contrôle d’accès qui refuse à l’utilisateur actuel le droit d’utiliser le sémaphore, mais qui accorde le droit de lire et modifier les autorisations sur le sémaphore.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode. L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> surcharge de méthode pour ouvrir le sémaphore avec les droits nécessaires pour lire et modifier les autorisations.  
  
 Une fois que les autorisations sont modifiées, le sémaphore est ouvert avec les droits nécessaires à l’entrée et de libération. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> est une chaîne vide.  
  
- ou - 
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le sémaphore nommé n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le sémaphore nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé pour ouvrir un sémaphore système nommé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">Nom du sémaphore système à ouvrir.</param>
        <param name="rights">Combinaison d'opérations de bits des valeurs d'énumération qui représentent l'accès de sécurité voulu.</param>
        <summary>Ouvre le sémaphore nommé spécifié, s'il existe déjà, avec l'accès de sécurité souhaité.</summary>
        <returns>Objet qui représente le sémaphore système nommé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `rights` paramètre doit inclure le <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> indicateur pour permettre aux threads d’entrer dans le sémaphore et le <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> indicateur pour permettre d’appeler le <xref:System.Threading.Semaphore.Release%2A> (méthode).  
  
 Le <xref:System.Threading.Semaphore.OpenExisting%2A> méthode tente d’ouvrir un sémaphore nommé existant. Si le sémaphore système n’existe pas, cette méthode lève une exception au lieu de créer le sémaphore système. Pour créer le sémaphore système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.Semaphore.%23ctor%2A> constructeurs qui a un `name` paramètre.  
  
 Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.Semaphore> de l’objet, même si les objets retournés représentent le même sémaphore système nommé.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé avec une sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un sémaphore nommé.  
  
 Si le sémaphore n’existe pas, il est créé avec un nombre maximal de deux et avec la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le sémaphore, mais qui accorde le droit de lire et modifier les autorisations sur le sémaphore.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (méthode). L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> surcharge de méthode pour ouvrir le sémaphore avec les droits nécessaires pour lire et modifier les autorisations.  
  
 Une fois que les autorisations sont modifiées, le sémaphore est ouvert avec les droits nécessaires à l’entrée et de libération. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> est une chaîne vide.  
  
- ou - 
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le sémaphore nommé n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le sémaphore nommé existe, mais l'utilisateur n'a pas les droits d'accès de sécurité voulus.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé pour créer un sémaphore système nommé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quitte le sémaphore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quitte le sémaphore et retourne le compteur antérieur.</summary>
        <returns>Compteur du sémaphore avant appel de la méthode <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les threads utilisent généralement le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode permet d’entrer le sémaphore et ils généralement utiliser cette surcharge de méthode pour quitter.  
  
 Si un <xref:System.Threading.SemaphoreFullException> est levée par le <xref:System.Threading.Semaphore.Release%2A> (méthode), il n’indique pas nécessairement un problème avec le thread appelant. Une erreur de programmation dans un autre thread peut avoir provoqué ce thread quitte le sémaphore fois plus important qu’il a entré.  
  
 Si actuel <xref:System.Threading.Semaphore> objet représente un sémaphore système nommé, l’utilisateur doit avoir <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> droits et le sémaphore doivent avoir été ouvert avec <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> droits.  
  
   
  
## Examples  
 L’exemple de code suivant crée un sémaphore avec un nombre maximal de trois et un nombre initial de zéro. L’exemple démarre cinq threads, qui bloquent en attendant le sémaphore. Le thread principal utilise le <xref:System.Threading.Semaphore.Release%28System.Int32%29> surcharge de méthode pour augmenter le compteur du sémaphore à sa valeur maximale, en autorisant trois threads à entrer dans le sémaphore. Chaque thread utilise la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> méthode pour attendre une seconde, pour simuler le travail, puis appelle le <xref:System.Threading.Semaphore.Release> surcharge de méthode pour libérer le sémaphore.  
  
 Chaque fois que le sémaphore est libéré, le compteur du sémaphore précédent s’affiche. Console messages suivre l’utilisation sémaphore. L’intervalle de travail simulé augmente légèrement à chaque thread, pour faciliter la lecture de la sortie.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">Le compteur du sémaphore est déjà à la valeur maximale.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s'est produite avec un sémaphore nommé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le sémaphore actuel représente un sémaphore système nommé, mais l'utilisateur ne détient pas de droits <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
- ou - 
Le sémaphore actuel représente un sémaphore système nommé, mais il n'a pas été ouvert avec des droits <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Nombre de fois où quitter le sémaphore.</param>
        <summary>Quitte le sémaphore un nombre spécifié de fois et retourne le compteur précédent.</summary>
        <returns>Compteur du sémaphore avant appel de la méthode <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un thread a entré le sémaphore plusieurs fois, cette surcharge de méthode permet le compteur du sémaphore entière à être restaurée avec un seul appel.  
  
 Si un <xref:System.Threading.SemaphoreFullException> est levée par le <xref:System.Threading.Semaphore.Release%2A> (méthode), il n’indique pas nécessairement un problème avec le thread appelant. Une erreur de programmation dans un autre thread peut avoir provoqué ce thread quitte le sémaphore fois plus important qu’il a entré.  
  
 Si actuel <xref:System.Threading.Semaphore> objet représente un sémaphore système nommé, l’utilisateur doit avoir <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> droits et le sémaphore doivent avoir été ouvert avec <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> droits.  
  
   
  
## Examples  
 L’exemple de code suivant crée un sémaphore avec un nombre maximal de trois et un nombre initial de zéro. L’exemple démarre cinq threads, qui bloquent en attendant le sémaphore. Le thread principal utilise le <xref:System.Threading.Semaphore.Release%28System.Int32%29> surcharge de méthode pour augmenter le compteur du sémaphore à sa valeur maximale, en autorisant trois threads à entrer dans le sémaphore. Chaque thread utilise la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> méthode pour attendre une seconde, pour simuler le travail, puis appelle le <xref:System.Threading.Semaphore.Release> surcharge de méthode pour libérer le sémaphore.  
  
 Chaque fois que le sémaphore est libéré, le compteur du sémaphore précédent s’affiche. Console messages suivre l’utilisation sémaphore. L’intervalle de travail simulé augmente légèrement à chaque thread, pour faciliter la lecture de la sortie.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="releaseCount" /> est inférieur à 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">Le compteur du sémaphore est déjà à la valeur maximale.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s'est produite avec un sémaphore nommé.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le sémaphore actuel représente un sémaphore système nommé, mais l'utilisateur ne détient pas de droits <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
- ou - 
Le sémaphore actuel représente un sémaphore système nommé, mais il n'a pas été ouvert avec des droits <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">Objet <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> qui représente la sécurité de contrôle d'accès à appliquer au sémaphore système nommé.</param>
        <summary>Définit la sécurité de contrôle d'accès pour un sémaphore système nommé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez définir la sécurité de contrôle d’accès uniquement sur <xref:System.Threading.Semaphore> objets qui représentent des sémaphores de système nommé.  
  
 L’utilisateur doit avoir <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> droits pour appeler cette méthode et le sémaphore doivent avoir été ouvert avec <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> droits.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un sémaphore nommé avec une sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un sémaphore nommé.  
  
 Si le sémaphore n’existe pas, il est créé avec un nombre maximal de deux et avec la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le sémaphore mais accorde le droit de lire et modifier les autorisations sur le sémaphore.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (méthode). L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> surcharge de méthode pour ouvrir le sémaphore avec les droits nécessaires pour lire et modifier les autorisations.  
  
 Une fois que les autorisations sont modifiées, à l’aide de la <xref:System.Threading.Semaphore.SetAccessControl%2A> (méthode), le sémaphore est ouvert avec les droits nécessaires à l’entrée et de libération. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="semaphoreSecurity" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne détient pas d'autorisations <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.  
  
- ou - 
Le sémaphore n'a pas été ouvert avec les droits <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">L'objet <see cref="T:System.Threading.Semaphore" /> actuel ne représente pas de sémaphore système nommé.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un sémaphore nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nom du sémaphore système à ouvrir.</param>
        <param name="result">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.Semaphore" /> qui représente le sémaphore nommé si l'appel a réussi, ou <see langword="null" /> si l'appel a échoué. Ce paramètre est traité comme étant non initialisé.</param>
        <summary>Ouvre le sémaphore nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</summary>
        <returns><see langword="true" /> si le sémaphore nommé a été ouvert ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le sémaphore nommé n’existe pas, cette méthode ne le crée pas. Pour créer le sémaphore système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.Semaphore.%23ctor%2A> constructeurs qui a un `name` paramètre.  
  
 Si vous ne savez pas si un sémaphore nommé existe, utilisez cette surcharge de méthode au lieu du <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> surcharge de méthode qui lève une exception si le sémaphore n’existe pas.  
  
 Cette surcharge de méthode revient à appeler le <xref:System.Threading.Semaphore.TryOpenExisting%2A> surcharge de méthode et en spécifiant <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> et <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> droits, combinés à l’aide de l’opération OR au niveau du bit. En spécifiant le <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> indicateur permet d’entrer dans le sémaphore, un thread et en spécifiant le <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> indicateur permet à un thread d’appeler le <xref:System.Threading.Semaphore.Release%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> est une chaîne vide.  
  
- ou - 
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le sémaphore nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nom du sémaphore système à ouvrir.</param>
        <param name="rights">Combinaison d'opérations de bits des valeurs d'énumération qui représentent l'accès de sécurité voulu.</param>
        <param name="result">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.Semaphore" /> qui représente le sémaphore nommé si l'appel a réussi, ou <see langword="null" /> si l'appel a échoué. Ce paramètre est traité comme étant non initialisé.</param>
        <summary>Ouvre le sémaphore nommé spécifié, s'il existe déjà, avec l'accès de sécurité souhaité, puis retourne une valeur indiquant si l'opération a réussi.</summary>
        <returns><see langword="true" /> si le sémaphore nommé a été ouvert ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le sémaphore nommé n’existe pas, cette méthode ne le crée pas. Pour créer le sémaphore système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.Semaphore.%23ctor%2A> constructeurs qui a un `name` paramètre.  
  
 Si vous ne savez pas si un sémaphore nommé existe, utilisez cette surcharge de méthode au lieu du <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> surcharge de méthode qui lève une exception si le sémaphore n’existe pas.  
  
 Le `rights` paramètre doit inclure le <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> indicateur pour permettre aux threads d’entrer dans le sémaphore et le <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> indicateur pour permettre d’appeler le <xref:System.Threading.Semaphore.Release%2A> (méthode).  
  
 Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.Semaphore> de l’objet, même si les objets retournés représentent le même sémaphore système nommé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> est une chaîne vide.  
  
- ou - 
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le sémaphore nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</exception>
      </Docs>
    </Member>
  </Members>
</Type>