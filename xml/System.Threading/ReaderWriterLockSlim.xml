<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2ff770bb9446d6ebe71649784ebe115f60734cc0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="718a1-101">Représente un verrou utilisé pour gérer l'accès à une ressource, en autorisant plusieurs threads pour la lecture ou un accès exclusif en écriture.</span>
      <span class="sxs-lookup">
        <span data-stu-id="718a1-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-102">Utilisez <xref:System.Threading.ReaderWriterLockSlim> pour protéger une ressource qui est lu par plusieurs threads et écrite par un seul thread à la fois.</span><span class="sxs-lookup"><span data-stu-id="718a1-102">Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time.</span></span> <span data-ttu-id="718a1-103"><xref:System.Threading.ReaderWriterLockSlim> permet à plusieurs threads être en mode lecture, un thread d’être en mode écriture avec la propriété exclusive du verrou et permet à un thread qui a accès en lecture dans la mise à niveau en mode lecture, à partir de laquelle le thread peut mettre à niveau en mode écriture sans devoir annuler il s l’accès en lecture à la ressource.</span><span class="sxs-lookup"><span data-stu-id="718a1-103"><xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-104"><xref:System.Threading.ReaderWriterLockSlim> est similaire à <xref:System.Threading.ReaderWriterLock>, mais a des règles simplifiées pour la récursivité ainsi que la mise à niveau et la rétrogradation de l’état de verrou.</span><span class="sxs-lookup"><span data-stu-id="718a1-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="718a1-105"><xref:System.Threading.ReaderWriterLockSlim> évite de nombreux cas d’interblocage potentiel.</span><span class="sxs-lookup"><span data-stu-id="718a1-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="718a1-106">En outre, les performances de <xref:System.Threading.ReaderWriterLockSlim> sont considérablement meilleures que celles de <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="718a1-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="718a1-107"><xref:System.Threading.ReaderWriterLockSlim> est recommandé pour tout nouveau développement.</span><span class="sxs-lookup"><span data-stu-id="718a1-107"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span>  
  
 <span data-ttu-id="718a1-108">Par défaut, les nouvelles instances de <xref:System.Threading.ReaderWriterLockSlim> sont créés avec le <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> indicateur et ne permettent pas de récursivité.</span><span class="sxs-lookup"><span data-stu-id="718a1-108">By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag and do not allow recursion.</span></span> <span data-ttu-id="718a1-109">Cette stratégie par défaut est recommandée pour tout nouveau développement, étant donné que la récurrence introduit des complications inutiles et rend votre code risque d’interblocage.</span><span class="sxs-lookup"><span data-stu-id="718a1-109">This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</span></span> <span data-ttu-id="718a1-110">Pour simplifier la migration à partir d’existante des projets qui utilisent <xref:System.Threading.Monitor> ou <xref:System.Threading.ReaderWriterLock>, vous pouvez utiliser la <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> indicateur permettant de créer des instances de <xref:System.Threading.ReaderWriterLockSlim> qui autorise la récurrence.</span><span class="sxs-lookup"><span data-stu-id="718a1-110">To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.</span></span>  
  
 <span data-ttu-id="718a1-111">Un thread peut entrer le verrou en trois modes : verrou en mode lecture, mode écriture et mode de lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-111">A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</span></span> <span data-ttu-id="718a1-112">(Dans le reste de cette rubrique, « verrou en mode lecture » est appelé « mode de mise à niveau » et l’expression « entrez `x` mode » est utilisée, plutôt que l’expression complète « entrer le verrou en `x` mode ».)</span><span class="sxs-lookup"><span data-stu-id="718a1-112">(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter `x` mode" is used in preference to the longer phrase "enter the lock in `x` mode".)</span></span>  
  
 <span data-ttu-id="718a1-113">Quelle que soit la stratégie de récurrence, un seul thread peut être en mode écriture à tout moment.</span><span class="sxs-lookup"><span data-stu-id="718a1-113">Regardless of recursion policy, only one thread can be in write mode at any time.</span></span> <span data-ttu-id="718a1-114">Lorsqu’un thread est en mode écriture, aucun autre thread ne peut entrer le verrou dans n’importe quel mode.</span><span class="sxs-lookup"><span data-stu-id="718a1-114">When a thread is in write mode, no other thread can enter the lock in any mode.</span></span> <span data-ttu-id="718a1-115">Un seul thread peut être en mode de mise à niveau à tout moment.</span><span class="sxs-lookup"><span data-stu-id="718a1-115">Only one thread can be in upgradeable mode at any time.</span></span> <span data-ttu-id="718a1-116">N’importe quel nombre de threads peut être en mode lecture, et il peut y avoir un thread en mode de mise à niveau alors que les autres threads sont en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-116">Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="718a1-117">Ce type implémente le <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="718a1-117">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="718a1-118">Lorsque vous avez fini d’utiliser le type, vous devez la supprimer directement ou indirectement.</span><span class="sxs-lookup"><span data-stu-id="718a1-118">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="718a1-119">Pour supprimer le type directement, vous devez appeler sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc.</span><span class="sxs-lookup"><span data-stu-id="718a1-119">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="718a1-120">Pour la supprimer indirectement, utiliser une construction de langage telles que `using` (en c#) ou `Using` (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="718a1-120">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="718a1-121">Pour plus d’informations, consultez la section « Utilisant un objet qui implémente IDisposable » dans la <xref:System.IDisposable> rubrique de l’interface.</span><span class="sxs-lookup"><span data-stu-id="718a1-121">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="718a1-122"><xref:System.Threading.ReaderWriterLockSlim> a géré l’affinité de thread ; Autrement dit, chaque <xref:System.Threading.Thread> objet doit appeler sa propre méthode pour entrer et sortir des modes de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="718a1-122"><xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes.</span></span> <span data-ttu-id="718a1-123">Aucun thread ne peut modifier le mode d’un autre thread.</span><span class="sxs-lookup"><span data-stu-id="718a1-123">No thread can change the mode of another thread.</span></span>  
  
 <span data-ttu-id="718a1-124">Si un <xref:System.Threading.ReaderWriterLockSlim> n’autorise pas la récurrence, un thread qui essaie d’entrer le verrou peut bloquer pour plusieurs raisons :</span><span class="sxs-lookup"><span data-stu-id="718a1-124">If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</span></span>  
  
-   <span data-ttu-id="718a1-125">Un thread qui essaie d’entrer en mode lecture bloque si des threads attendent pour entrer en mode écriture ou si un thread unique est en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-125">A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="718a1-126">Bloquer les nouveaux lecteurs writers sont en file d’attente est une stratégie de respect de verrou qui favorise les écritures.</span><span class="sxs-lookup"><span data-stu-id="718a1-126">Blocking new readers when writers are queued is a lock fairness policy that favors writers.</span></span> <span data-ttu-id="718a1-127">La stratégie équité équilibre équité pour les lecteurs et writers, pour favoriser le débit dans les scénarios les plus courants.</span><span class="sxs-lookup"><span data-stu-id="718a1-127">The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</span></span> <span data-ttu-id="718a1-128">Les versions ultérieures de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] peut introduire de nouvelles stratégies d’équité.</span><span class="sxs-lookup"><span data-stu-id="718a1-128">Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.</span></span>  
  
-   <span data-ttu-id="718a1-129">Un thread qui essaie d’entrer des blocs de verrou en mode s’il existe déjà un thread en mode de mise à niveau, s’il existe des threads qui attendent pour entrer en mode écriture, ou s’il existe un thread unique en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-129">A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</span></span>  
  
-   <span data-ttu-id="718a1-130">Un thread qui essaie d’entrer en mode écriture bloque si un autre thread est dans un des trois modes.</span><span class="sxs-lookup"><span data-stu-id="718a1-130">A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</span></span>  
  
## <a name="upgrading-and-downgrading-locks"></a><span data-ttu-id="718a1-131">La mise à niveau et la rétrogradation des verrous</span><span class="sxs-lookup"><span data-stu-id="718a1-131">Upgrading and Downgrading Locks</span></span>  
 <span data-ttu-id="718a1-132">Mode de mise à niveau est prévu pour les cas où un thread lit habituellement à partir de la ressource protégée, mais vous devrez peut-être en écriture si une condition est remplie.</span><span class="sxs-lookup"><span data-stu-id="718a1-132">Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</span></span> <span data-ttu-id="718a1-133">Un thread a entré un <xref:System.Threading.ReaderWriterLockSlim> en mode de mise à niveau dispose d’un accès en lecture à la ressource protégée et peut mettre à niveau en mode écriture en appelant le <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> ou <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="718a1-133">A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods.</span></span> <span data-ttu-id="718a1-134">Étant donné que peut contenir qu’un seul thread en mode de mise à niveau à la fois, la mise à niveau en mode écriture ne peut pas se bloquer mutuellement lors la récursivité n’est pas autorisée, qui est la stratégie par défaut.</span><span class="sxs-lookup"><span data-stu-id="718a1-134">Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="718a1-135">Quelle que soit la stratégie de récurrence, un thread entré à l’origine de lecture mode n’est pas autorisé à mettre à niveau vers le verrou en mode ou en mode écriture, car ce modèle crée une forte probabilité de blocages.</span><span class="sxs-lookup"><span data-stu-id="718a1-135">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span> <span data-ttu-id="718a1-136">Par exemple, si deux threads en mode lecture qu'essaient d’entrer en mode écrivent, ils se bloqueront.</span><span class="sxs-lookup"><span data-stu-id="718a1-136">For example, if two threads in read mode both try to enter write mode, they will deadlock.</span></span> <span data-ttu-id="718a1-137">Mode de mise à niveau est conçu pour éviter ces blocages.</span><span class="sxs-lookup"><span data-stu-id="718a1-137">Upgradeable mode is designed to avoid such deadlocks.</span></span>  
  
 <span data-ttu-id="718a1-138">S’il existe des autres threads en mode lecture, le thread qui est la mise à niveau des blocs.</span><span class="sxs-lookup"><span data-stu-id="718a1-138">If there are other threads in read mode, the thread that is upgrading blocks.</span></span> <span data-ttu-id="718a1-139">Pendant que le thread est bloqué, les autres threads qui essaient d’entrer en mode lecture sont bloqués.</span><span class="sxs-lookup"><span data-stu-id="718a1-139">While the thread is blocked, other threads that try to enter read mode are blocked.</span></span> <span data-ttu-id="718a1-140">Lorsque tous les threads ont quitté le mode lecture, le thread de mise à niveau bloqué entre en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-140">When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</span></span> <span data-ttu-id="718a1-141">S’il existe d’autres threads qui attendent pour entrer en mode écriture, ils restent bloqués, car le thread unique qui est en mode de mise à niveau les empêche d’obtenir l’accès exclusif à la ressource.</span><span class="sxs-lookup"><span data-stu-id="718a1-141">If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</span></span>  
  
 <span data-ttu-id="718a1-142">Lorsque le thread en mode de mise à niveau quitte le mode écriture, d’autres threads qui attendent pour entrer en mode lecture peuvent faire, sauf si des threads attendent pour entrer en mode écrivent.</span><span class="sxs-lookup"><span data-stu-id="718a1-142">When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</span></span> <span data-ttu-id="718a1-143">Le thread en mode de mise à niveau peut mettre à niveau et rétrograder indéfiniment, tant que c’est le seul thread qui écrit dans la ressource protégée.</span><span class="sxs-lookup"><span data-stu-id="718a1-143">The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="718a1-144">Si vous permettez à plusieurs threads d’entrer le mode écriture ou en mode de mise à niveau, que vous ne devez pas autoriser un thread à monopoliser le verrou en mode.</span><span class="sxs-lookup"><span data-stu-id="718a1-144">If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</span></span> <span data-ttu-id="718a1-145">Sinon, les threads qui essaient d’entrer écrivent mode directement sera bloqué indéfiniment, et pendant qu’ils sont bloqués, les autres threads ne pourront pas entrer en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-145">Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</span></span>  
  
 <span data-ttu-id="718a1-146">Un thread en mode de mise à niveau peut rétrograder en mode lecture en appelant d’abord la <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> (méthode), puis en appelant le <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="718a1-146">A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method.</span></span> <span data-ttu-id="718a1-147">Ce modèle de rétrogradation est autorisé pour toutes les stratégies de récurrence du verrou, même <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span><span class="sxs-lookup"><span data-stu-id="718a1-147">This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span></span>  
  
 <span data-ttu-id="718a1-148">Après avoir rétrogradé en mode lecture, un thread ne peut pas entrer le verrou en mode jusqu'à ce qu’il a quitté le mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-148">After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</span></span>  
  
## <a name="entering-the-lock-recursively"></a><span data-ttu-id="718a1-149">Entrer le verrou de manière récursive</span><span class="sxs-lookup"><span data-stu-id="718a1-149">Entering the Lock Recursively</span></span>  
 <span data-ttu-id="718a1-150">Vous pouvez créer un <xref:System.Threading.ReaderWriterLockSlim> qui prend en charge l’entrée récursive de verrou à l’aide de la <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructeur qui spécifie la stratégie de verrou et en spécifiant <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="718a1-150">You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-151">L’utilisation de la récursivité n’est pas recommandée pour tout nouveau développement, car elle introduit des complications inutiles et rend votre code risque d’interblocage.</span><span class="sxs-lookup"><span data-stu-id="718a1-151">The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</span></span>  
  
 <span data-ttu-id="718a1-152">Pour un <xref:System.Threading.ReaderWriterLockSlim> qui autorise la récurrence, ce qui suit peut être désignée sur les modes d’un thread peut entrer :</span><span class="sxs-lookup"><span data-stu-id="718a1-152">For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:</span></span>  
  
-   <span data-ttu-id="718a1-153">Un thread en mode lecture peut entrer en mode lecture de manière récursive, mais ne peut pas entrer en mode écriture ou en mode de mise à niveau.</span><span class="sxs-lookup"><span data-stu-id="718a1-153">A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</span></span> <span data-ttu-id="718a1-154">Si elle tente de pour ce faire, un <xref:System.Threading.LockRecursionException> est levée.</span><span class="sxs-lookup"><span data-stu-id="718a1-154">If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown.</span></span> <span data-ttu-id="718a1-155">Saisie de lecture mode et entrer en mode écrivent ou en mode de mise à niveau est un modèle avec une forte probabilité de blocages, donc il n’est pas autorisée.</span><span class="sxs-lookup"><span data-stu-id="718a1-155">Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</span></span> <span data-ttu-id="718a1-156">Comme indiqué précédemment, le verrou en mode est fournie pour les cas où il n’est nécessaire mettre à niveau un verrou.</span><span class="sxs-lookup"><span data-stu-id="718a1-156">As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</span></span>  
  
-   <span data-ttu-id="718a1-157">Un thread en mode de mise à niveau peut entrer en mode écriture et/ou en mode lecture et pouvez entrer des trois modes de manière récursive.</span><span class="sxs-lookup"><span data-stu-id="718a1-157">A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</span></span> <span data-ttu-id="718a1-158">Toutefois, une tentative d’entrer en mode écriture bloque s’il existe des autres threads en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-158">However, an attempt to enter write mode blocks if there are other threads in read mode.</span></span>  
  
-   <span data-ttu-id="718a1-159">Un thread en mode écriture peut entrer en mode lecture et/ou en mode de mise à niveau et pouvez entrer des trois modes de manière récursive.</span><span class="sxs-lookup"><span data-stu-id="718a1-159">A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</span></span>  
  
-   <span data-ttu-id="718a1-160">Un thread qui n’a pas entré le verrou peut entrer n’importe quel mode.</span><span class="sxs-lookup"><span data-stu-id="718a1-160">A thread that has not entered the lock can enter any mode.</span></span> <span data-ttu-id="718a1-161">Cette tentative peut bloquer pour les mêmes raisons qu’une tentative d’entrer un verrou non récursive.</span><span class="sxs-lookup"><span data-stu-id="718a1-161">This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</span></span>  
  
 <span data-ttu-id="718a1-162">Un thread peut quitter les modes qu’il a entré dans n’importe quel ordre, tant qu’il quitte chaque mode exactement autant de fois qu’elle entrée que le mode.</span><span class="sxs-lookup"><span data-stu-id="718a1-162">A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</span></span> <span data-ttu-id="718a1-163">Si un thread essaie de quitter un mode trop de fois, ou de quitter un mode, il n’a pas été entrée, un <xref:System.Threading.SynchronizationLockException> est levée.</span><span class="sxs-lookup"><span data-stu-id="718a1-163">If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.</span></span>  
  
## <a name="lock-states"></a><span data-ttu-id="718a1-164">États de verrou</span><span class="sxs-lookup"><span data-stu-id="718a1-164">Lock States</span></span>  
 <span data-ttu-id="718a1-165">Vous pouvez s’avérer utile de considérer le verrou en termes de ses États.</span><span class="sxs-lookup"><span data-stu-id="718a1-165">You may find it useful to think of the lock in terms of its states.</span></span> <span data-ttu-id="718a1-166">Un <xref:System.Threading.ReaderWriterLockSlim> peut être l’un des quatre états : non entré, lecture, mise à niveau et d’écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-166">A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.</span></span>  
  
-   <span data-ttu-id="718a1-167">Ne pas d’entrée : dans cet état, aucun thread n’a entré le verrou (ou tous les threads ont quitté le verrou).</span><span class="sxs-lookup"><span data-stu-id="718a1-167">Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</span></span>  
  
-   <span data-ttu-id="718a1-168">Lecture : Un ou plusieurs threads ont entré le verrou pour l’accès en lecture à la ressource protégée.</span><span class="sxs-lookup"><span data-stu-id="718a1-168">Read: In this state, one or more threads have entered the lock for read access to the protected resource.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="718a1-169">Un thread peut entrer le verrou en mode lecture à l’aide de la <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> ou <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> méthodes, ou en passant du mode de mise à niveau.</span><span class="sxs-lookup"><span data-stu-id="718a1-169">A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.</span></span>  
  
-   <span data-ttu-id="718a1-170">Mise à niveau : Dans cet état, un thread a entré le verrou pour l’accès en lecture avec l’option de mise à niveau pour l’accès en écriture (autrement dit, en verrou en mode), et zéro ou plusieurs threads ont entré le verrou pour l’accès en lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-170">Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</span></span> <span data-ttu-id="718a1-171">Pas plus d’un thread à la fois peut entrer le verrou avec l’option de mise à niveau ; autres threads qui essaient d’entrer en mode de mise à niveau sont bloquées.</span><span class="sxs-lookup"><span data-stu-id="718a1-171">No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</span></span>  
  
-   <span data-ttu-id="718a1-172">Écriture : Un thread a entré le verrou pour l’accès en écriture à la ressource protégée.</span><span class="sxs-lookup"><span data-stu-id="718a1-172">Write: In this state, one thread has entered the lock for write access to the protected resource.</span></span> <span data-ttu-id="718a1-173">Ce thread a la propriété exclusive du verrou.</span><span class="sxs-lookup"><span data-stu-id="718a1-173">That thread has exclusive possession of the lock.</span></span> <span data-ttu-id="718a1-174">Aucun autre thread qui essaie d’entrer le verrou pour une raison quelconque est bloqué.</span><span class="sxs-lookup"><span data-stu-id="718a1-174">Any other thread that tries to enter the lock for any reason is blocked.</span></span>  
  
 <span data-ttu-id="718a1-175">Le tableau suivant décrit les transitions entre États de verrou, pour les verrous qui n’autorisent pas la récurrence, lorsqu’un thread `t` exécute l’action décrite dans la colonne de gauche.</span><span class="sxs-lookup"><span data-stu-id="718a1-175">The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column.</span></span> <span data-ttu-id="718a1-176">Au moment où il entreprend les mesures, `t` n’a aucun mode.</span><span class="sxs-lookup"><span data-stu-id="718a1-176">At the time it takes the action, `t` has no mode.</span></span> <span data-ttu-id="718a1-177">(Le cas spécial où `t` est en mode de mise à niveau est décrit dans les notes de la table.) La ligne supérieure décrit l’état initial du verrou.</span><span class="sxs-lookup"><span data-stu-id="718a1-177">(The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</span></span> <span data-ttu-id="718a1-178">Les cellules décrivent ce qui se passe au thread et affichent les modifications apportées à l’état du verrou entre parenthèses.</span><span class="sxs-lookup"><span data-stu-id="718a1-178">The cells describe what happens to the thread, and show changes to the lock state in parentheses.</span></span>  
  
||<span data-ttu-id="718a1-179">Non entré (N)</span><span class="sxs-lookup"><span data-stu-id="718a1-179">Not entered (N)</span></span>|<span data-ttu-id="718a1-180">Read (R)</span><span class="sxs-lookup"><span data-stu-id="718a1-180">Read (R)</span></span>|<span data-ttu-id="718a1-181">Mise à niveau (U)</span><span class="sxs-lookup"><span data-stu-id="718a1-181">Upgrade (U)</span></span>|<span data-ttu-id="718a1-182">Écriture (W)</span><span class="sxs-lookup"><span data-stu-id="718a1-182">Write (W)</span></span>|  
|-|-----------------------|----------------|-------------------|-----------------|  
|<span data-ttu-id="718a1-183">`t` passe en mode lecture</span><span class="sxs-lookup"><span data-stu-id="718a1-183">`t` enters read mode</span></span>|<span data-ttu-id="718a1-184">`t` entre (R).</span><span class="sxs-lookup"><span data-stu-id="718a1-184">`t` enters (R).</span></span>|<span data-ttu-id="718a1-185">`t` bloque si les threads sont en attente pour le mode écriture ; dans le cas contraire, `t` passe.</span><span class="sxs-lookup"><span data-stu-id="718a1-185">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.</span></span>|<span data-ttu-id="718a1-186">`t` bloque si les threads sont en attente pour le mode écriture ; dans le cas contraire, `t` saisit.<sup> 1</sup></span><span class="sxs-lookup"><span data-stu-id="718a1-186">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup></span></span>|<span data-ttu-id="718a1-187">`t` blocs.</span><span class="sxs-lookup"><span data-stu-id="718a1-187">`t` blocks.</span></span>|  
|<span data-ttu-id="718a1-188">`t` passe en mode de mise à niveau</span><span class="sxs-lookup"><span data-stu-id="718a1-188">`t` enters upgradeable mode</span></span>|<span data-ttu-id="718a1-189">`t` entre (U).</span><span class="sxs-lookup"><span data-stu-id="718a1-189">`t` enters (U).</span></span>|<span data-ttu-id="718a1-190">`t` bloque si les threads attendent le mode écriture ou en mode de mise à niveau ; dans le cas contraire, `t` entre (U).</span><span class="sxs-lookup"><span data-stu-id="718a1-190">`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).</span></span>|<span data-ttu-id="718a1-191">`t` blocs.</span><span class="sxs-lookup"><span data-stu-id="718a1-191">`t` blocks.</span></span>|<span data-ttu-id="718a1-192">`t` blocs.</span><span class="sxs-lookup"><span data-stu-id="718a1-192">`t` blocks.</span></span>|  
|<span data-ttu-id="718a1-193">`t` entre en mode écriture</span><span class="sxs-lookup"><span data-stu-id="718a1-193">`t` enters write mode</span></span>|<span data-ttu-id="718a1-194">`t` Insère (W).</span><span class="sxs-lookup"><span data-stu-id="718a1-194">`t` enters (W).</span></span>|<span data-ttu-id="718a1-195">`t` blocs.</span><span class="sxs-lookup"><span data-stu-id="718a1-195">`t` blocks.</span></span>|<span data-ttu-id="718a1-196">`t` blocs. <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="718a1-196">`t` blocks.<sup>2</sup></span></span>|<span data-ttu-id="718a1-197">`t` blocs.</span><span class="sxs-lookup"><span data-stu-id="718a1-197">`t` blocks.</span></span>|  
  
 <span data-ttu-id="718a1-198"><sup>1</sup> si `t` démarre arrière en mode de mise à niveau, il entre en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-198"><sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode.</span></span> <span data-ttu-id="718a1-199">Cette action ne bloque jamais.</span><span class="sxs-lookup"><span data-stu-id="718a1-199">This action never blocks.</span></span> <span data-ttu-id="718a1-200">L’état du verrou ne change pas.</span><span class="sxs-lookup"><span data-stu-id="718a1-200">The lock state does not change.</span></span> <span data-ttu-id="718a1-201">(Le thread peut ensuite terminer une rétrogradation vers le mode lecture en quittant le mode de mise à niveau.)</span><span class="sxs-lookup"><span data-stu-id="718a1-201">(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</span></span>  
  
 <span data-ttu-id="718a1-202"><sup>2</sup> si `t` démarre en mode de mise à niveau, elle demeure bloquée s’il existe des threads en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-202"><sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode.</span></span> <span data-ttu-id="718a1-203">Sinon, il met à niveau en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-203">Otherwise it upgrades to write mode.</span></span> <span data-ttu-id="718a1-204">Les modifications d’état de verrou à écriture (W).</span><span class="sxs-lookup"><span data-stu-id="718a1-204">The lock state changes to Write (W).</span></span> <span data-ttu-id="718a1-205">Si `t` se bloque, car il existe des threads en mode lecture, il entre en mode écriture dès que le dernier thread quitte le mode lecture, même si les threads qui attendent pour entrer en mode écrivent.</span><span class="sxs-lookup"><span data-stu-id="718a1-205">If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="718a1-206">Lorsqu’un changement d’état se produit, car un thread quitte le verrou, le thread suivant à être mis en éveil est sélectionné comme suit :</span><span class="sxs-lookup"><span data-stu-id="718a1-206">When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</span></span>  
  
-   <span data-ttu-id="718a1-207">Tout d’abord, un thread qui attend de mode écriture et est déjà en mode de mise à niveau (il peut y avoir au plus un seul).</span><span class="sxs-lookup"><span data-stu-id="718a1-207">First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</span></span>  
  
-   <span data-ttu-id="718a1-208">Cas d’échec, un thread est en attente pour le mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-208">Failing that, a thread that is waiting for write mode.</span></span>  
  
-   <span data-ttu-id="718a1-209">Cas d’échec, un thread est en attente pour le mode de mise à niveau.</span><span class="sxs-lookup"><span data-stu-id="718a1-209">Failing that, a thread that is waiting for upgradeable mode.</span></span>  
  
-   <span data-ttu-id="718a1-210">Cas d’échec, tous les threads qui sont en attente pour le mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-210">Failing that, all threads that are waiting for read mode.</span></span>  
  
 <span data-ttu-id="718a1-211">L’état suivant du verrou est toujours écriture (W) dans les deux premiers cas et mise à niveau (U) dans le troisième cas, quelle que soit l’état du verrou lorsque le thread sortant a déclenché la modification d’état.</span><span class="sxs-lookup"><span data-stu-id="718a1-211">The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</span></span> <span data-ttu-id="718a1-212">Dans le dernier cas, l’état du verrou est mise à niveau (U) si un thread en mode de mise à niveau après le changement d’état et Read (R) dans le cas contraire, quel que soit l’état antérieur.</span><span class="sxs-lookup"><span data-stu-id="718a1-212">In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-213">L’exemple suivant montre un cache synchronisé simple qui stocke des chaînes avec des clés de type entier.</span><span class="sxs-lookup"><span data-stu-id="718a1-213">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="718a1-214">Une instance de <xref:System.Threading.ReaderWriterLockSlim> est utilisé pour synchroniser l’accès à la <xref:System.Collections.Generic.Dictionary%602> qui sert de cache interne.</span><span class="sxs-lookup"><span data-stu-id="718a1-214">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span>  
  
 <span data-ttu-id="718a1-215">L’exemple inclut des méthodes simples pour ajouter au cache, supprimer du cache et lire à partir du cache.</span><span class="sxs-lookup"><span data-stu-id="718a1-215">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="718a1-216">Pour illustrer les délais d’expiration, l’exemple inclut une méthode qui ajoute au cache uniquement si elle peut le faire dans un délai d’attente spécifié.</span><span class="sxs-lookup"><span data-stu-id="718a1-216">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="718a1-217">Pour démontrer le mode de mise à niveau, l’exemple inclut une méthode qui Récupère la valeur associée à une clé et la compare avec une nouvelle valeur.</span><span class="sxs-lookup"><span data-stu-id="718a1-217">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="718a1-218">Si la valeur est inchangée, la méthode retourne un état qui indique aucune modification.</span><span class="sxs-lookup"><span data-stu-id="718a1-218">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="718a1-219">Il aucune valeur n’est trouvée pour la clé, la paire clé/valeur est insérée.</span><span class="sxs-lookup"><span data-stu-id="718a1-219">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="718a1-220">Si la valeur a changé, elle est mise à jour.</span><span class="sxs-lookup"><span data-stu-id="718a1-220">If the value has changed, it is updated.</span></span> <span data-ttu-id="718a1-221">Mode de mise à niveau permet au thread mettre à niveau à partir de l’accès en lecture à l’accès en écriture si nécessaire, sans risque d’interblocage.</span><span class="sxs-lookup"><span data-stu-id="718a1-221">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="718a1-222">L’exemple inclut une énumération imbriquée qui spécifie les valeurs de retour pour la méthode qui montre le mode de mise à niveau.</span><span class="sxs-lookup"><span data-stu-id="718a1-222">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="718a1-223">L’exemple utilise le constructeur par défaut pour créer le verrou, donc la récurrence n’est pas autorisée.</span><span class="sxs-lookup"><span data-stu-id="718a1-223">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="718a1-224">Programmation du <xref:System.Threading.ReaderWriterLockSlim> est plus simple et moins sujet aux erreurs lorsque le verrou n’autorise pas la récursivité.</span><span class="sxs-lookup"><span data-stu-id="718a1-224">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="718a1-225">Le code suivant utilise ensuite le `SynchronizedCache` objet pour stocker un dictionnaire de noms légumes.</span><span class="sxs-lookup"><span data-stu-id="718a1-225">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="718a1-226">Il crée trois tâches.</span><span class="sxs-lookup"><span data-stu-id="718a1-226">It creates three tasks.</span></span> <span data-ttu-id="718a1-227">La première écrit les noms de légumes stockées dans un tableau à un `SynchronizedCache` instance.</span><span class="sxs-lookup"><span data-stu-id="718a1-227">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="718a1-228">La deuxième et troisième tâche affiche les noms des légumes, le premier dans l’ordre croissant (de faible indice à index élevé), la seconde dans l’ordre décroissant.</span><span class="sxs-lookup"><span data-stu-id="718a1-228">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="718a1-229">La dernière tâche recherche la chaîne « concombre » et, lorsqu’il en trouve, il appelle la <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> méthode pour remplacer la chaîne « bean vert ».</span><span class="sxs-lookup"><span data-stu-id="718a1-229">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="718a1-230">Ce type est thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="718a1-230">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-231">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="718a1-232">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" /> avec des valeurs de propriété par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-233">Un <xref:System.Threading.ReaderWriterLockSlim> qui est initialisé avec ce constructeur n’autorise pas la récursivité.</span><span class="sxs-lookup"><span data-stu-id="718a1-233">A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion.</span></span> <span data-ttu-id="718a1-234">Autrement dit, la propriété <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> retourne <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="718a1-234">That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="718a1-235">Pour plus d’informations sur la stratégie de récurrence et ses effets, consultez le <xref:System.Threading.LockRecursionPolicy> énumération et la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="718a1-235">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-236">L’exemple suivant montre un cache synchronisé simple qui stocke des chaînes avec des clés de type entier.</span><span class="sxs-lookup"><span data-stu-id="718a1-236">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="718a1-237">Une instance de <xref:System.Threading.ReaderWriterLockSlim> est utilisé pour synchroniser l’accès à la <xref:System.Collections.Generic.Dictionary%602> qui sert de cache interne.</span><span class="sxs-lookup"><span data-stu-id="718a1-237">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span> <span data-ttu-id="718a1-238">Le constructeur sans paramètre est utilisé pour créer le verrou.</span><span class="sxs-lookup"><span data-stu-id="718a1-238">The parameterless constructor is used to create the lock.</span></span>  
  
 <span data-ttu-id="718a1-239">L’exemple inclut des méthodes simples pour ajouter au cache, supprimer du cache et lire à partir du cache.</span><span class="sxs-lookup"><span data-stu-id="718a1-239">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="718a1-240">Pour illustrer les délais d’expiration, l’exemple inclut une méthode qui ajoute au cache uniquement si elle peut le faire dans un délai d’attente spécifié.</span><span class="sxs-lookup"><span data-stu-id="718a1-240">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="718a1-241">Pour démontrer le mode de mise à niveau, l’exemple inclut une méthode qui Récupère la valeur associée à une clé et la compare avec une nouvelle valeur.</span><span class="sxs-lookup"><span data-stu-id="718a1-241">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="718a1-242">Si la valeur est inchangée, la méthode retourne un état qui indique aucune modification.</span><span class="sxs-lookup"><span data-stu-id="718a1-242">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="718a1-243">Il aucune valeur n’est trouvée pour la clé, la paire clé/valeur est insérée.</span><span class="sxs-lookup"><span data-stu-id="718a1-243">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="718a1-244">Si la valeur a changé, elle est mise à jour.</span><span class="sxs-lookup"><span data-stu-id="718a1-244">If the value has changed, it is updated.</span></span> <span data-ttu-id="718a1-245">Mode de mise à niveau permet au thread mettre à niveau à partir de l’accès en lecture à l’accès en écriture si nécessaire, sans risque d’interblocage.</span><span class="sxs-lookup"><span data-stu-id="718a1-245">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="718a1-246">L’exemple inclut une énumération imbriquée qui spécifie les valeurs de retour pour la méthode qui montre le mode de mise à niveau.</span><span class="sxs-lookup"><span data-stu-id="718a1-246">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="718a1-247">L’exemple utilise le constructeur par défaut pour créer le verrou, donc la récurrence n’est pas autorisée.</span><span class="sxs-lookup"><span data-stu-id="718a1-247">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="718a1-248">Programmation du <xref:System.Threading.ReaderWriterLockSlim> est plus simple et moins sujet aux erreurs lorsque le verrou n’autorise pas la récursivité.</span><span class="sxs-lookup"><span data-stu-id="718a1-248">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="718a1-249">Le code suivant utilise ensuite le `SynchronizedCache` objet pour stocker un dictionnaire de noms légumes.</span><span class="sxs-lookup"><span data-stu-id="718a1-249">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="718a1-250">Il crée trois tâches.</span><span class="sxs-lookup"><span data-stu-id="718a1-250">It creates three tasks.</span></span> <span data-ttu-id="718a1-251">La première écrit les noms de légumes stockées dans un tableau à un `SynchronizedCache` instance.</span><span class="sxs-lookup"><span data-stu-id="718a1-251">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="718a1-252">La deuxième et troisième tâche affiche les noms des légumes, le premier dans l’ordre croissant (de faible indice à index élevé), la seconde dans l’ordre décroissant.</span><span class="sxs-lookup"><span data-stu-id="718a1-252">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="718a1-253">La dernière tâche recherche la chaîne « concombre » et, lorsqu’il en trouve, il appelle la <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> méthode pour remplacer la chaîne « bean vert ».</span><span class="sxs-lookup"><span data-stu-id="718a1-253">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">
          <span data-ttu-id="718a1-254">Une des valeurs d'énumération qui spécifie la stratégie de récurrence du verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-254">One of the enumeration values that specifies the lock recursion policy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="718a1-255">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" />, en spécifiant la stratégie de récurrence du verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-256">La stratégie de récurrence détermine les restrictions sur les threads qui permet d’entrer le verrou plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="718a1-256">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="718a1-257">Par exemple, si un verrou a été créé avec <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> et un thread a entré le verrou en mode lecture, <xref:System.Threading.LockRecursionException> est levée si le thread essaie de réentrer le verrou en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-257">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span> <span data-ttu-id="718a1-258">De même, si un thread a entré le verrou en mode écriture, <xref:System.Threading.LockRecursionException> est levée si le thread essaie d’entrer à nouveau le verrou dans n’importe quel mode.</span><span class="sxs-lookup"><span data-stu-id="718a1-258">Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-259">Un thread en mode de mise à niveau peut mettre à niveau en mode écriture ou rétrograder vers le pour mode quelle que soit le paramètre de stratégie de récurrence de verrou de lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-259">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="718a1-260">Quelle que soit la stratégie de récurrence, un thread entré à l’origine de lecture mode n’est pas autorisé à mettre à niveau vers le verrou en mode ou en mode écriture, car ce modèle crée une forte probabilité de blocages.</span><span class="sxs-lookup"><span data-stu-id="718a1-260">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="718a1-261">Pour plus d’informations sur la stratégie de récurrence et ses effets, consultez le <xref:System.Threading.LockRecursionPolicy> énumération et la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="718a1-261">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-262">L’exemple suivant montre deux scénarios d’exception, qui varie selon le <xref:System.Threading.LockRecursionPolicy> paramètre et l’autre pas.</span><span class="sxs-lookup"><span data-stu-id="718a1-262">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="718a1-263">Dans le premier scénario, le thread entre en mode lecture et puis essaie d’entrer en mode lecture de manière récursive.</span><span class="sxs-lookup"><span data-stu-id="718a1-263">In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="718a1-264">Si le <xref:System.Threading.ReaderWriterLockSlim> est créé en utilisant le constructeur par défaut, qui définit la stratégie de récurrence sur <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="718a1-264">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the default constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="718a1-265">Si <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> est utilisé pour créer le <xref:System.Threading.ReaderWriterLockSlim>, aucune exception n’est levée.</span><span class="sxs-lookup"><span data-stu-id="718a1-265">If <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="718a1-266">Dans le deuxième scénario, le thread entre en mode lecture, et puis essaie d’entrer en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-266">In the second scenario, the thread enters read mode and then tries to enter write mode.</span></span> <span data-ttu-id="718a1-267"><xref:System.Threading.LockRecursionException> est levée indépendamment de la stratégie de récurrence du verrou.</span><span class="sxs-lookup"><span data-stu-id="718a1-267"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 <span data-ttu-id="718a1-268">Le code suivant utilise ensuite le `SynchronizedCache` objet pour stocker un dictionnaire de noms légumes.</span><span class="sxs-lookup"><span data-stu-id="718a1-268">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="718a1-269">Il crée trois tâches.</span><span class="sxs-lookup"><span data-stu-id="718a1-269">It creates three tasks.</span></span> <span data-ttu-id="718a1-270">La première écrit les noms de légumes stockées dans un tableau à un `SynchronizedCache` instance.</span><span class="sxs-lookup"><span data-stu-id="718a1-270">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="718a1-271">La deuxième et troisième tâche affiche les noms des légumes, le premier dans l’ordre croissant (de faible indice à index élevé), la seconde dans l’ordre décroissant.</span><span class="sxs-lookup"><span data-stu-id="718a1-271">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="718a1-272">La dernière tâche recherche la chaîne « concombre » et, lorsqu’il en trouve, il appelle la <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> méthode pour remplacer la chaîne « bean vert ».</span><span class="sxs-lookup"><span data-stu-id="718a1-272">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-273">Obtient le nombre total de threads uniques qui ont entré le verrou en mode lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-273">Gets the total number of unique threads that have entered the lock in read mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="718a1-274">Nombre de threads uniques qui ont entré le verrou en mode lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-274">The number of unique threads that have entered the lock in read mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-275">Un thread est compté une seule fois, même si le verrou autorise la récurrence et le thread a entré en mode lecture plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="718a1-275">A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</span></span>  
  
 <span data-ttu-id="718a1-276">Utilisez cette propriété uniquement pour le débogage, profilage et à des fins de journalisation et non pour contrôler le comportement d’un algorithme.</span><span class="sxs-lookup"><span data-stu-id="718a1-276">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="718a1-277">Les résultats peuvent changer dès qu’ils ont été calculés.</span><span class="sxs-lookup"><span data-stu-id="718a1-277">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="718a1-278">Par conséquent, il n’est pas possible de prendre des décisions basées sur cette propriété.</span><span class="sxs-lookup"><span data-stu-id="718a1-278">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-279">L’exemple suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> propriété pour générer une entrée de journal des événements si le nombre de threads en mode lecture dépasse un seuil.</span><span class="sxs-lookup"><span data-stu-id="718a1-279">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="718a1-280">Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-281">Appelez la méthode <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> une fois que vous avez terminé d'utiliser <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="718a1-281">Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="718a1-282">La méthode <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> rend le <xref:System.Threading.ReaderWriterLockSlim> inutilisable.</span><span class="sxs-lookup"><span data-stu-id="718a1-282">The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state.</span></span> <span data-ttu-id="718a1-283">Après avoir appelé <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, vous devez libérer toutes les références à la <xref:System.Threading.ReaderWriterLockSlim> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Threading.ReaderWriterLockSlim> occupée.</span><span class="sxs-lookup"><span data-stu-id="718a1-283">After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying.</span></span> <span data-ttu-id="718a1-284">Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentant une méthode de suppression](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="718a1-284">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-285">Appelez toujours <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> avant de libérer votre dernière référence à le <xref:System.Threading.ReaderWriterLockSlim> objet.</span><span class="sxs-lookup"><span data-stu-id="718a1-285">Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="718a1-286">
            <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> est supérieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-286">
              <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span>
          </span>
          <span data-ttu-id="718a1-287">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-287">-or-</span>
          </span>
          <span data-ttu-id="718a1-288">
            <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> est supérieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-288">
              <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span>
          </span>
          <span data-ttu-id="718a1-289">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-289">-or-</span>
          </span>
          <span data-ttu-id="718a1-290">
            <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> est supérieur à zéro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-290">
              <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="718a1-291">Essaie d'entrer le verrou en mode lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-291">Tries to enter the lock in read mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-292">Cette méthode s’interrompt jusqu'à ce que le thread appelant entre le verrou et par conséquent risque de ne jamais retourne.</span><span class="sxs-lookup"><span data-stu-id="718a1-292">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="718a1-293">Utilisez la <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> méthode pour bloquer pendant un intervalle spécifié, puis retourner si le thread appelant n’a pas entré en mode lecture pendant cet intervalle.</span><span class="sxs-lookup"><span data-stu-id="718a1-293">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</span></span>  
  
 <span data-ttu-id="718a1-294">Plusieurs threads peuvent entrer en mode lecture en même temps.</span><span class="sxs-lookup"><span data-stu-id="718a1-294">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="718a1-295">Si un ou plusieurs threads attendent pour entrer en mode écriture, un thread qui appelle la <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> méthode s’interrompt jusqu'à ce que ces threads aient expiré ou est entré en mode écriture et puis s’être arrêté à partir de celui-ci.</span><span class="sxs-lookup"><span data-stu-id="718a1-295">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-296">Si un verrou autorise la récurrence, un thread qui a entré le verrou en mode lecture peut entrer en mode lecture de façon récursive, même si d’autres threads attendent pour entrer en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-296">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="718a1-297">Au plus un thread peut être en mode de mise à niveau alors que les autres threads sont en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-297">At most one thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="718a1-298">Si les autres threads attendent pour entrer en mode de mise à niveau et il n’existe aucun threads qui attendent pour entrer en mode écriture, les threads qui appellent le <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> méthode entrer en mode lecture immédiatement et ne bloquent pas.</span><span class="sxs-lookup"><span data-stu-id="718a1-298">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-299">L’exemple suivant montre comment utiliser la <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> méthode pour entrer le verrou en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-299">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode.</span></span> <span data-ttu-id="718a1-300">La méthode indiquée dans l’exemple récupère la valeur associée à une clé.</span><span class="sxs-lookup"><span data-stu-id="718a1-300">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="718a1-301">Si la clé est introuvable, l’exception levée par interne <xref:System.Collections.Generic.Dictionary%602> est autorisé à mettre fin à la méthode.</span><span class="sxs-lookup"><span data-stu-id="718a1-301">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="718a1-302">A `finally` bloc est utilisé pour exécuter le <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> méthode, en garantissant que l’appelant quitte le mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-302">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span>  
  
 <span data-ttu-id="718a1-303">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="718a1-303">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="718a1-304">Le thread actuel ne peut pas acquérir le verrou en écriture quand il détient le verrou en lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-304">The current thread cannot acquire the write lock when it holds the read lock.</span>
          </span>
          <span data-ttu-id="718a1-305">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-305">-or-</span>
          </span>
          <span data-ttu-id="718a1-306">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a tenté d’acquérir le verrou en lecture alors qu’il le détient déjà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-306">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span>
          </span>
          <span data-ttu-id="718a1-307">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-307">-or-</span>
          </span>
          <span data-ttu-id="718a1-308">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a tenté d’acquérir le verrou en lecture alors qu’il détient déjà le verrou en écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-308">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span>
          </span>
          <span data-ttu-id="718a1-309">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-309">-or-</span>
          </span>
          <span data-ttu-id="718a1-310">Le nombre de récursivités dépasserait la capacité du compteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-310">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="718a1-311">Cette limite est si élevée que les applications ne devraient normalement jamais rencontrer cette exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-311">This limit is so large that applications should never encounter this exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="718a1-312">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-312">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="718a1-313">Essaie d'entrer le verrou en mode pouvant être mis à niveau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-313">Tries to enter the lock in upgradeable mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-314">Cette méthode s’interrompt jusqu'à ce que le thread appelant entre le verrou et par conséquent risque de ne jamais retourne.</span><span class="sxs-lookup"><span data-stu-id="718a1-314">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="718a1-315">Utilisez la <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> méthode pour bloquer pendant un intervalle spécifié, puis retourner si le thread appelant n’a pas entré de verrou en mode pendant cet intervalle.</span><span class="sxs-lookup"><span data-stu-id="718a1-315">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</span></span>  
  
 <span data-ttu-id="718a1-316">Utiliser le mode de mise à niveau lorsqu’un thread accède habituellement à la ressource protégée par le <xref:System.Threading.ReaderWriterLockSlim> en mode lecture, mais devrez peut-être entrer en mode écriture si certaines conditions sont remplies.</span><span class="sxs-lookup"><span data-stu-id="718a1-316">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="718a1-317">Un thread en mode de mise à niveau peut rétrograder en mode lecture ou mise à niveau en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-317">A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</span></span>  
  
 <span data-ttu-id="718a1-318">Qu’un seul thread peut entrer le verrou en mode à un moment donné.</span><span class="sxs-lookup"><span data-stu-id="718a1-318">Only one thread can enter upgradeable mode at any given time.</span></span> <span data-ttu-id="718a1-319">Si un thread est en mode de mise à niveau et il n’existe aucun threads qui attendent pour entrer en mode écriture, un nombre quelconque d’autres threads permettre entrer en mode lecture, même si les threads qui attendent pour entrer en mode de mise à niveau.</span><span class="sxs-lookup"><span data-stu-id="718a1-319">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="718a1-320">Si un ou plusieurs threads attendent pour entrer en mode écriture, un thread qui appelle la <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> méthode s’interrompt jusqu'à ce que ces threads aient expiré ou est entré en mode écriture et puis s’être arrêté à partir de celui-ci.</span><span class="sxs-lookup"><span data-stu-id="718a1-320">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-321">Si un verrou autorise la récurrence, un thread qui a entré le verrou en mode de mise à niveau peut entrer en mode de mise à niveau de façon récursive, même si d’autres threads attendent pour entrer en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-321">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-322">L’exemple suivant montre comment utiliser la <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> méthode pour entrer le verrou en mode de mise à niveau.</span><span class="sxs-lookup"><span data-stu-id="718a1-322">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode.</span></span> <span data-ttu-id="718a1-323">A `finally` bloc est utilisé pour exécuter le <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> méthode, en garantissant que l’appelant quitte le mode de mise à niveau.</span><span class="sxs-lookup"><span data-stu-id="718a1-323">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="718a1-324">La méthode indiquée dans l’exemple récupère la valeur associée à une clé et la compare avec une nouvelle valeur.</span><span class="sxs-lookup"><span data-stu-id="718a1-324">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="718a1-325">Si la valeur est inchangée, la méthode retourne un état qui indique aucune modification.</span><span class="sxs-lookup"><span data-stu-id="718a1-325">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="718a1-326">Il aucune valeur n’est trouvée pour la clé, la paire clé/valeur est insérée.</span><span class="sxs-lookup"><span data-stu-id="718a1-326">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="718a1-327">Si la valeur a changé, elle est mise à jour.</span><span class="sxs-lookup"><span data-stu-id="718a1-327">If the value has changed, it is updated.</span></span> <span data-ttu-id="718a1-328">Mode de mise à niveau permet au thread mettre à niveau le verrou en lecture, en fonction des besoins, sans risque d’interblocage.</span><span class="sxs-lookup"><span data-stu-id="718a1-328">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="718a1-329">L’exemple utilise le constructeur par défaut pour créer le verrou, donc la récurrence n’est pas autorisée.</span><span class="sxs-lookup"><span data-stu-id="718a1-329">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="718a1-330">Programmation du <xref:System.Threading.ReaderWriterLockSlim> est plus simple et moins sujet aux erreurs lorsque le verrou n’autorise pas la récursivité.</span><span class="sxs-lookup"><span data-stu-id="718a1-330">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="718a1-331">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="718a1-331">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="718a1-332">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou dans un mode quelconque.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-332">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span>
          </span>
          <span data-ttu-id="718a1-333">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-333">-or-</span>
          </span>
          <span data-ttu-id="718a1-334">Le thread actuel est entré en mode lecture, et une tentative d'entrer en mode de mise à niveau risquerait de créer un interblocage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-334">The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="718a1-335">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-335">-or-</span>
          </span>
          <span data-ttu-id="718a1-336">Le nombre de récursivités dépasserait la capacité du compteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-336">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="718a1-337">Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-337">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="718a1-338">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-338">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="718a1-339">Essaie d'entrer le verrou en mode écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-339">Tries to enter the lock in write mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-340">Cette méthode s’interrompt jusqu'à ce que le thread appelant entre le verrou et par conséquent risque de ne jamais retourne.</span><span class="sxs-lookup"><span data-stu-id="718a1-340">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="718a1-341">Utilisez la <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> méthode pour bloquer pendant un intervalle spécifié, puis retourner si le thread appelant n’a pas entré en mode écriture pendant cet intervalle.</span><span class="sxs-lookup"><span data-stu-id="718a1-341">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</span></span>  
  
 <span data-ttu-id="718a1-342">Si d’autres threads ont entré le verrou en mode lecture, un thread qui appelle la <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> méthode s’interrompt jusqu'à ce que ces threads ont quitté le mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-342">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode.</span></span> <span data-ttu-id="718a1-343">Lorsqu’il existe des threads qui attendent pour entrer en mode écriture, autres threads qui essaient d’entrer en mode lecture ou un verrou en mode bloc jusqu'à ce que tous les threads qui attendent pour entrer en mode écriture aient expiré ou est entré en mode écriture et puis s’être arrêté à partir de celui-ci.</span><span class="sxs-lookup"><span data-stu-id="718a1-343">When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-344">Si un verrou autorise la récurrence, un thread qui a entré le verrou en mode écriture peut entrer écriture en mode de façon récursive, même si d’autres threads attendent pour entrer en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-344">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-345">L’exemple suivant montre comment utiliser la <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> méthode pour entrer le verrou en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-345">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode.</span></span> <span data-ttu-id="718a1-346">La méthode indiquée dans l’exemple ajoute une nouvelle paire clé/valeur au cache synchronisé.</span><span class="sxs-lookup"><span data-stu-id="718a1-346">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="718a1-347">Si la clé est déjà dans le cache, l’exception levée par interne <xref:System.Collections.Generic.Dictionary%602> est autorisé à mettre fin à la méthode.</span><span class="sxs-lookup"><span data-stu-id="718a1-347">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="718a1-348">A `finally` bloc est utilisé pour exécuter le <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> méthode, en garantissant que l’appelant quitte le mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-348">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span>  
  
 <span data-ttu-id="718a1-349">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="718a1-349">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="718a1-350">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou dans un mode quelconque.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-350">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span>
          </span>
          <span data-ttu-id="718a1-351">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-351">-or-</span>
          </span>
          <span data-ttu-id="718a1-352">Le thread actuel est entré en mode lecture, et une tentative d'entrer le verrou en mode écriture risquerait de créer un interblocage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-352">The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="718a1-353">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-353">-or-</span>
          </span>
          <span data-ttu-id="718a1-354">Le nombre de récursivités dépasserait la capacité du compteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-354">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="718a1-355">Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-355">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="718a1-356">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-356">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="718a1-357">Réduit le nombre de récurrences pour le mode lecture, et quitte le mode lecture si le nombre résultant est 0 (zéro).</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-357">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-358">Cette méthode n’est pas sensible à la commande de la récursivité.</span><span class="sxs-lookup"><span data-stu-id="718a1-358">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="718a1-359">Par exemple, si un thread entre un verrou en mode de mise à niveau puis entre le verrou en mode lecture, l’ordre dans lequel le thread quitte les deux modes n’a pas d’importance.</span><span class="sxs-lookup"><span data-stu-id="718a1-359">For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="718a1-360">Si un verrou autorise la récurrence, un thread peut entrer le verrou en mode écriture, puis entrez-la de manière récursive en mode lecture ; l’ordre dans lequel le thread s’arrête en mode lecture et écriture en mode n’a pas d’importance.</span><span class="sxs-lookup"><span data-stu-id="718a1-360">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="718a1-361">La fermeture du verrou peut signaler des autres threads en attente.</span><span class="sxs-lookup"><span data-stu-id="718a1-361">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-362">L’exemple suivant montre comment utiliser un `finally` exécution du bloc le <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> méthode, en garantissant que l’appelant quitte le mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-362">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span> <span data-ttu-id="718a1-363">La méthode indiquée dans l’exemple récupère la valeur associée à une clé.</span><span class="sxs-lookup"><span data-stu-id="718a1-363">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="718a1-364">Si la clé est introuvable, l’exception levée par interne <xref:System.Collections.Generic.Dictionary%602> est autorisé à mettre fin à la méthode.</span><span class="sxs-lookup"><span data-stu-id="718a1-364">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="718a1-365">Le <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> méthode est utilisée pour entrer en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-365">The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.</span></span>  
  
 <span data-ttu-id="718a1-366">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="718a1-366">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="718a1-367">Le thread actuel n'a pas entré le verrou en mode lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-367">The current thread has not entered the lock in read mode.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="718a1-368">Réduit le nombre de récurrences pour le mode pouvant être mis à niveau, et quitte le mode pouvant être mis à niveau si le nombre résultant est 0 (zéro).</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-368">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-369">Cette méthode n’est pas sensible à la commande de la récursivité.</span><span class="sxs-lookup"><span data-stu-id="718a1-369">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="718a1-370">Par exemple, si un thread entre un verrou en mode de mise à niveau puis entre le verrou en mode écriture, l’ordre dans lequel le thread quitte les deux modes n’a pas d’importance.</span><span class="sxs-lookup"><span data-stu-id="718a1-370">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="718a1-371">Si un verrou autorise la récurrence, un thread peut entrer le verrou en mode écriture, puis entrez-la de manière récursive en mode de mise à niveau ; l’ordre dans lequel le thread quitte le verrou en mode de mode et d’écriture n’a pas d’importance.</span><span class="sxs-lookup"><span data-stu-id="718a1-371">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="718a1-372">La fermeture du verrou peut signaler des autres threads en attente.</span><span class="sxs-lookup"><span data-stu-id="718a1-372">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-373">L’exemple suivant montre comment utiliser un `finally` exécution du bloc le <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> méthode, en garantissant que l’appelant quitte le mode de mise à niveau.</span><span class="sxs-lookup"><span data-stu-id="718a1-373">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="718a1-374">La méthode indiquée dans l’exemple récupère la valeur associée à une clé et la compare avec une nouvelle valeur.</span><span class="sxs-lookup"><span data-stu-id="718a1-374">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="718a1-375">Si la valeur est inchangée, la méthode retourne un état qui indique aucune modification.</span><span class="sxs-lookup"><span data-stu-id="718a1-375">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="718a1-376">Il aucune valeur n’est trouvée pour la clé, la paire clé/valeur est insérée.</span><span class="sxs-lookup"><span data-stu-id="718a1-376">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="718a1-377">Si la valeur a changé, elle est mise à jour.</span><span class="sxs-lookup"><span data-stu-id="718a1-377">If the value has changed, it is updated.</span></span> <span data-ttu-id="718a1-378">Mode de mise à niveau permet au thread mettre à niveau le verrou en lecture, en fonction des besoins, sans risque d’interblocage.</span><span class="sxs-lookup"><span data-stu-id="718a1-378">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="718a1-379">L’exemple utilise le constructeur par défaut pour créer le verrou, donc la récurrence n’est pas autorisée.</span><span class="sxs-lookup"><span data-stu-id="718a1-379">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="718a1-380">Programmation du <xref:System.Threading.ReaderWriterLockSlim> est plus simple et moins sujet aux erreurs lorsque le verrou n’autorise pas la récursivité.</span><span class="sxs-lookup"><span data-stu-id="718a1-380">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="718a1-381">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="718a1-381">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="718a1-382">Le thread actuel n'a pas entré le verrou en mode de mise à niveau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-382">The current thread has not entered the lock in upgradeable mode.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="718a1-383">Réduit le nombre de récurrences pour le mode écriture, et quitte le mode écriture si le nombre résultant est 0 (zéro).</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-383">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-384">Cette méthode n’est pas sensible à la commande de la récursivité.</span><span class="sxs-lookup"><span data-stu-id="718a1-384">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="718a1-385">Par exemple, si un thread entre un verrou en mode de mise à niveau puis entre le verrou en mode écriture, l’ordre dans lequel le thread quitte les deux modes n’a pas d’importance.</span><span class="sxs-lookup"><span data-stu-id="718a1-385">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="718a1-386">Si un verrou autorise la récurrence, un thread peut entrer le verrou en mode écriture, puis entrez-la de manière récursive en mode lecture ; l’ordre dans lequel le thread s’arrête en mode lecture et écriture en mode n’a pas d’importance.</span><span class="sxs-lookup"><span data-stu-id="718a1-386">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="718a1-387">La fermeture du verrou peut signaler des autres threads en attente.</span><span class="sxs-lookup"><span data-stu-id="718a1-387">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-388">L’exemple suivant montre comment utiliser un `finally` exécution du bloc le <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> méthode, en garantissant que l’appelant quitte le mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-388">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span> <span data-ttu-id="718a1-389">La méthode indiquée dans l’exemple ajoute une nouvelle paire clé/valeur au cache synchronisé.</span><span class="sxs-lookup"><span data-stu-id="718a1-389">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="718a1-390">Si la clé est déjà dans le cache, l’exception levée par interne <xref:System.Collections.Generic.Dictionary%602> est autorisé à mettre fin à la méthode.</span><span class="sxs-lookup"><span data-stu-id="718a1-390">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="718a1-391">Le <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> méthode est utilisée pour entrer le verrou en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-391">The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.</span></span>  
  
 <span data-ttu-id="718a1-392">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="718a1-392">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="718a1-393">Le thread actuel n'a pas entré le verrou en mode écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-393">The current thread has not entered the lock in write mode.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-394">Obtient une valeur qui indique si le thread actuel a entré le verrou en mode lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-394">Gets a value that indicates whether the current thread has entered the lock in read mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="718a1-395">
            <see langword="true" /> si le thread actuel a entré le verrou en mode lecture ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-395">
              <see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-396">Cette propriété est conçue pour utilisation dans les assertions ou à des fins de débogage.</span><span class="sxs-lookup"><span data-stu-id="718a1-396">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="718a1-397">N’utilisez pas pour contrôler le flux d’exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="718a1-397">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-398">L’exemple suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> propriété pour générer une assertion si le thread actuel a entré le verrou en mode lecture inattendu.</span><span class="sxs-lookup"><span data-stu-id="718a1-398">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-399">Obtient une valeur qui indique si le thread actuel a entré le verrou en mode pouvant être mis à niveau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-399">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="718a1-400">
            <see langword="true" /> si le thread actuel a entré le verrou en mode de mise à niveau ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-400">
              <see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-401">Cette propriété est conçue pour utilisation dans les assertions ou à des fins de débogage.</span><span class="sxs-lookup"><span data-stu-id="718a1-401">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="718a1-402">N’utilisez pas pour contrôler le flux d’exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="718a1-402">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-403">L’exemple suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> propriété pour générer une assertion si le thread actuel a entré le verrou en mode inattendu.</span><span class="sxs-lookup"><span data-stu-id="718a1-403">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-404">Obtient une valeur qui indique si le thread actuel a entré le verrou en mode écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-404">Gets a value that indicates whether the current thread has entered the lock in write mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="718a1-405">
            <see langword="true" /> si le thread actuel a entré le verrou en mode écriture ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-405">
              <see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-406">Cette propriété est conçue pour utilisation dans les assertions ou à des fins de débogage.</span><span class="sxs-lookup"><span data-stu-id="718a1-406">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="718a1-407">N’utilisez pas pour contrôler le flux d’exécution du programme.</span><span class="sxs-lookup"><span data-stu-id="718a1-407">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-408">L’exemple suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> propriété pour générer une assertion si le thread actuel a entré en mode écriture de façon inattendue.</span><span class="sxs-lookup"><span data-stu-id="718a1-408">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-409">Obtient une valeur qui indique la stratégie de récurrence pour l'objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-409">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="718a1-410">Une des valeurs d'énumération qui spécifie la stratégie de récurrence du verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-410">One of the enumeration values that specifies the lock recursion policy.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-411">La stratégie de récurrence détermine les restrictions sur les threads qui permet d’entrer le verrou plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="718a1-411">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="718a1-412">Par exemple, si un verrou a été créé avec <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> et un thread a entré le verrou en mode lecture, <xref:System.Threading.LockRecursionException> est levée si le thread essaie de réentrer le verrou en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-412">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-413">Un thread en mode de mise à niveau peut mettre à niveau en mode écriture ou rétrograder vers le pour mode quelle que soit le paramètre de stratégie de récurrence de verrou de lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-413">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="718a1-414">Quelle que soit la stratégie de récurrence, un thread entré à l’origine de lecture mode n’est pas autorisé à mettre à niveau vers le verrou en mode ou en mode écriture, car ce modèle crée une forte probabilité de blocages.</span><span class="sxs-lookup"><span data-stu-id="718a1-414">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="718a1-415">Pour plus d’informations sur la stratégie de récurrence et ses effets, consultez le <xref:System.Threading.LockRecursionPolicy> énumération et la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="718a1-415">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-416">Obtient le nombre de fois où le thread actuel a entré le verrou en mode lecture, comme une indication de récurrence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-416">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="718a1-417">0 (zéro) si le thread actuel n’a pas entré en mode lecture, 1 si le thread a entré en mode lecture mais n’a pas elle de façon récursive, ou *n* si le thread a entré le verrou de manière récursive *n* - 1 fois.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-417">0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-418">Utilisez cette propriété uniquement pour le débogage, profilage et à des fins de journalisation et non pour contrôler le comportement d’un algorithme.</span><span class="sxs-lookup"><span data-stu-id="718a1-418">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="718a1-419">Les résultats peuvent changer dès qu’ils ont été calculés.</span><span class="sxs-lookup"><span data-stu-id="718a1-419">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="718a1-420">Par conséquent, il n’est pas possible de prendre des décisions basées sur cette propriété.</span><span class="sxs-lookup"><span data-stu-id="718a1-420">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-421">Obtient le nombre de fois où le thread actuel a entré le verrou en mode pouvant être mis à niveau, comme une indication de récurrence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-421">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="718a1-422">0 si le thread actuel n’a pas entré en mode de mise à niveau, 1 si le thread a entré en mode de mise à niveau, mais n’a pas entré elle de façon récursive, ou *n* si le thread a entré le verrou en mode de manière récursive *n* - 1 fois.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-422">0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-423">Utilisez cette propriété uniquement pour le débogage, profilage et à des fins de journalisation et non pour contrôler le comportement d’un algorithme.</span><span class="sxs-lookup"><span data-stu-id="718a1-423">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="718a1-424">Les résultats peuvent changer dès qu’ils ont été calculés.</span><span class="sxs-lookup"><span data-stu-id="718a1-424">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="718a1-425">Par conséquent, il n’est pas possible de prendre des décisions basées sur cette propriété.</span><span class="sxs-lookup"><span data-stu-id="718a1-425">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-426">Obtient le nombre de fois où le thread actuel a entré le verrou en mode écriture, comme une indication de récurrence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-426">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="718a1-427">0 si le thread actuel n’a pas entré en mode, écriture 1 si le thread a entré en mode écriture, mais n’a pas entré elle de façon récursive, ou *n* si le thread a entré l’écriture de façon récursive mode *n* - 1 fois.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-427">0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-428">Utilisez cette propriété uniquement pour le débogage, profilage et à des fins de journalisation et non pour contrôler le comportement d’un algorithme.</span><span class="sxs-lookup"><span data-stu-id="718a1-428">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="718a1-429">Les résultats peuvent changer dès qu’ils ont été calculés.</span><span class="sxs-lookup"><span data-stu-id="718a1-429">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="718a1-430">Par conséquent, il n’est pas possible de prendre des décisions basées sur cette propriété.</span><span class="sxs-lookup"><span data-stu-id="718a1-430">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-431">Essaie d'entrer le verrou en mode lecture, avec un délai d'attente facultatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-431">Tries to enter the lock in read mode, with an optional time-out.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="718a1-432">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-432">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="718a1-433">Essaie d'entrer le verrou en mode lecture, avec un délai d'attente entier facultatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-433">Tries to enter the lock in read mode, with an optional integer time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="718a1-434">
            <see langword="true" /> si le thread appelant est entré en mode lecture, sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-434">
              <see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-435">Si `millisecondsTimeout` est 0 (zéro), cette méthode vérifie l’état du verrou et retourne `false` immédiatement si l’état souhaité n’est pas disponible.</span><span class="sxs-lookup"><span data-stu-id="718a1-435">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="718a1-436">Plusieurs threads peuvent entrer en mode lecture en même temps.</span><span class="sxs-lookup"><span data-stu-id="718a1-436">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="718a1-437">Si un ou plusieurs threads attendent pour entrer en mode écriture, un thread qui appelle la <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> méthode est bloquée jusqu'à ce que ces threads ont soit a expiré ou est entré en mode écriture et puis s’être arrêté à partir de celui-ci, ou jusqu'à l’expiration de l’intervalle de délai d’attente du thread appelant.</span><span class="sxs-lookup"><span data-stu-id="718a1-437">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-438">Si un verrou autorise la récurrence, un thread qui a entré le verrou en mode lecture peut entrer en mode lecture de façon récursive, même si d’autres threads attendent pour entrer en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-438">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="718a1-439">Un thread peut être en mode de mise à niveau alors que les autres threads sont en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-439">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="718a1-440">Si les autres threads attendent pour entrer en mode de mise à niveau et il n’existe aucun threads qui attendent pour entrer en mode écriture, les threads qui appellent le <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> méthode entrer en mode lecture immédiatement et ne bloquent pas.</span><span class="sxs-lookup"><span data-stu-id="718a1-440">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="718a1-441">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-441">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="718a1-442">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-442">-or-</span>
          </span>
          <span data-ttu-id="718a1-443">Le nombre de récursivités dépasserait la capacité du compteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-443">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="718a1-444">Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-444">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="718a1-445">La valeur de <paramref name="millisecondsTimeout" /> est négative, mais différente de <see cref="F:System.Threading.Timeout.Infinite" /> (-1), qui est la seule valeur négative autorisée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-445">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="718a1-446">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-446">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="718a1-447">Intervalle d'attente, ou -1 milliseconde pour un délai d'attente infini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-447">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="718a1-448">Essaie d'entrer le verrou en mode lecture, avec un délai d'attente facultatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-448">Tries to enter the lock in read mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="718a1-449">
            <see langword="true" /> si le thread appelant est entré en mode lecture, sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-449">
              <see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-450">Si `timeout` est 0 (zéro), cette méthode vérifie l’état du verrou et retourne `false` immédiatement si l’état souhaité n’est pas disponible.</span><span class="sxs-lookup"><span data-stu-id="718a1-450">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="718a1-451">Plusieurs threads peuvent entrer le verrou en mode lecture en même temps.</span><span class="sxs-lookup"><span data-stu-id="718a1-451">Multiple threads can enter the lock in read mode at the same time.</span></span>  
  
 <span data-ttu-id="718a1-452">Si un ou plusieurs threads sont en attente pour entrer en mode écriture, un thread qui appelle la <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> méthode est bloquée jusqu'à ce que ces threads ont soit a expiré ou est entré en mode écriture et puis s’être arrêté à partir de celui-ci, ou jusqu'à l’expiration de l’intervalle de délai d’attente du thread appelant.</span><span class="sxs-lookup"><span data-stu-id="718a1-452">If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-453">Si un verrou autorise la récurrence, un thread qui a entré le verrou en mode lecture peut entrer en mode lecture de façon récursive, même si d’autres threads attendent pour entrer en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-453">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="718a1-454">Un thread peut être en mode de mise à niveau alors que les autres threads sont en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-454">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="718a1-455">Si les autres threads attendent pour entrer en mode de mise à niveau et il n’existe aucun threads qui attendent pour entrer en mode écriture, les threads qui appellent le <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> méthode entrer en mode lecture immédiatement et ne bloquent pas.</span><span class="sxs-lookup"><span data-stu-id="718a1-455">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="718a1-456">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-456">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="718a1-457">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-457">-or-</span>
          </span>
          <span data-ttu-id="718a1-458">Le nombre de récursivités dépasserait la capacité du compteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-458">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="718a1-459">Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-459">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="718a1-460">La valeur de <paramref name="timeout" /> est négative, mais différente de -1 millisecondes, qui est la seule valeur négative autorisée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-460">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          </span>
          <span data-ttu-id="718a1-461">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-461">-or-</span>
          </span>
          <span data-ttu-id="718a1-462">La valeur de <paramref name="timeout" /> est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-462">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="718a1-463">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-463">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-464">Essaie d'entrer le verrou en mode pouvant être mis à niveau, avec un délai d'attente facultatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-464">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="718a1-465">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-465">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="718a1-466">Essaie d'entrer le verrou en mode pouvant être mis à niveau, avec un délai d'attente facultatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-466">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="718a1-467">
            <see langword="true" /> si le thread appelant est entré en mode de mise à niveau, sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-467">
              <see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-468">Si `millisecondsTimeout` est 0 (zéro), cette méthode vérifie l’état du verrou et retourne `false` immédiatement si l’état souhaité n’est pas disponible.</span><span class="sxs-lookup"><span data-stu-id="718a1-468">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="718a1-469">Utiliser le mode de mise à niveau lorsqu’un thread accède habituellement à la ressource protégée par le <xref:System.Threading.ReaderWriterLockSlim> en mode lecture, mais devrez peut-être entrer en mode écriture si certaines conditions sont remplies.</span><span class="sxs-lookup"><span data-stu-id="718a1-469">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="718a1-470">Un thread en mode de mise à niveau peut mettre à niveau en mode écriture ou rétrograder en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-470">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="718a1-471">Un seul thread peut entrer un verrou en mode de mise à niveau à un moment donné.</span><span class="sxs-lookup"><span data-stu-id="718a1-471">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="718a1-472">Si un thread est en mode de mise à niveau et il n’existe aucun threads qui attendent pour entrer en mode écriture, un nombre quelconque d’autres threads permettre entrer en mode lecture, même si les threads qui attendent pour entrer en mode de mise à niveau.</span><span class="sxs-lookup"><span data-stu-id="718a1-472">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="718a1-473">Si un ou plusieurs threads attendent pour entrer en mode écriture, un thread qui appelle la <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> méthode est bloquée jusqu'à ce que ces threads ont soit a expiré ou est entré en mode écriture et puis s’être arrêté à partir de celui-ci, ou jusqu'à l’expiration de l’intervalle de délai d’attente du thread appelant.</span><span class="sxs-lookup"><span data-stu-id="718a1-473">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-474">Si un verrou autorise la récurrence, un thread qui a entré le verrou en mode de mise à niveau peut entrer en mode de mise à niveau de façon récursive, même si d’autres threads attendent pour entrer en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-474">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="718a1-475">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-475">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="718a1-476">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-476">-or-</span>
          </span>
          <span data-ttu-id="718a1-477">Le thread actuel a entré à l'origine le verrou en mode lecture et par conséquent, une tentative d'entrer en mode de mise à niveau risquerait de créer un interblocage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-477">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="718a1-478">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-478">-or-</span>
          </span>
          <span data-ttu-id="718a1-479">Le nombre de récursivités dépasserait la capacité du compteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-479">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="718a1-480">Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-480">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="718a1-481">La valeur de <paramref name="millisecondsTimeout" /> est négative, mais différente de <see cref="F:System.Threading.Timeout.Infinite" /> (-1), qui est la seule valeur négative autorisée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-481">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="718a1-482">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-482">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="718a1-483">Intervalle d'attente, ou -1 milliseconde pour un délai d'attente infini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-483">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="718a1-484">Essaie d'entrer le verrou en mode pouvant être mis à niveau, avec un délai d'attente facultatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-484">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="718a1-485">
            <see langword="true" /> si le thread appelant est entré en mode de mise à niveau, sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-485">
              <see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-486">Si `timeout` est 0 (zéro), cette méthode vérifie l’état du verrou et retourne `false` immédiatement si l’état souhaité n’est pas disponible.</span><span class="sxs-lookup"><span data-stu-id="718a1-486">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="718a1-487">Utiliser le mode de mise à niveau lorsqu’un thread accède habituellement à la ressource protégée par le <xref:System.Threading.ReaderWriterLockSlim> en mode lecture, mais devrez peut-être entrer en mode écriture si certaines conditions sont remplies.</span><span class="sxs-lookup"><span data-stu-id="718a1-487">Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="718a1-488">Un thread en mode de mise à niveau peut mettre à niveau en mode écriture ou rétrograder en mode lecture.</span><span class="sxs-lookup"><span data-stu-id="718a1-488">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="718a1-489">Un seul thread peut entrer un verrou en mode de mise à niveau à un moment donné.</span><span class="sxs-lookup"><span data-stu-id="718a1-489">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="718a1-490">Si un thread est en mode de mise à niveau et il n’existe aucun threads qui attendent pour entrer en mode écriture, un nombre quelconque d’autres threads permettre entrer en mode lecture, même si les threads qui attendent pour entrer en mode de mise à niveau.</span><span class="sxs-lookup"><span data-stu-id="718a1-490">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="718a1-491">Si un ou plusieurs threads attendent pour entrer en mode écriture, un thread qui appelle la <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> méthode est bloquée jusqu'à ce que ces threads ont soit a expiré ou est entré en mode écriture et puis s’être arrêté à partir de celui-ci, ou jusqu'à l’expiration de l’intervalle de délai d’attente du thread appelant.</span><span class="sxs-lookup"><span data-stu-id="718a1-491">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-492">Si un verrou autorise la récurrence, un thread qui a entré le verrou en mode de mise à niveau peut entrer en mode de mise à niveau de façon récursive, même si d’autres threads attendent pour entrer en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-492">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="718a1-493">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-493">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="718a1-494">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-494">-or-</span>
          </span>
          <span data-ttu-id="718a1-495">Le thread actuel a entré à l'origine le verrou en mode lecture et par conséquent, une tentative d'entrer en mode de mise à niveau risquerait de créer un interblocage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-495">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="718a1-496">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-496">-or-</span>
          </span>
          <span data-ttu-id="718a1-497">Le nombre de récursivités dépasserait la capacité du compteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-497">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="718a1-498">Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-498">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="718a1-499">La valeur de <paramref name="timeout" /> est négative, mais différente de -1 millisecondes, qui est la seule valeur négative autorisée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-499">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          </span>
          <span data-ttu-id="718a1-500">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-500">-or-</span>
          </span>
          <span data-ttu-id="718a1-501">La valeur de <paramref name="timeout" /> est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-501">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="718a1-502">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-502">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-503">Essaie d'entrer le verrou en mode écriture, avec un délai d'attente facultatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-503">Tries to enter the lock in write mode, with an optional time-out.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="718a1-504">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-504">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="718a1-505">Essaie d'entrer le verrou en mode écriture, avec un délai d'attente facultatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-505">Tries to enter the lock in write mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="718a1-506">
            <see langword="true" /> si le thread appelant est entré en mode écriture, sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-506">
              <see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-507">Si `millisecondsTimeout` est 0 (zéro), cette méthode vérifie l’état du verrou et retourne `false` immédiatement si l’état souhaité n’est pas disponible.</span><span class="sxs-lookup"><span data-stu-id="718a1-507">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="718a1-508">Si d’autres threads ont entré le verrou en mode lecture, un thread qui appelle la <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> méthode est bloquée jusqu'à ce que ces threads ont quitté le mode lecture ou jusqu'à ce que l’intervalle de délai d’attente est écoulé.</span><span class="sxs-lookup"><span data-stu-id="718a1-508">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="718a1-509">Tandis que les threads sont bloqués en attente d’entrer en mode écriture, autres threads qui essaient d’entrer en mode lecture ou verrou en mode bloquent jusqu'à ce que tous les threads qui attendent pour entrer en mode écrivent ont soit a expiré ou est entré en mode écriture et puis s’être arrêté à partir de celui-ci.</span><span class="sxs-lookup"><span data-stu-id="718a1-509">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-510">Si un verrou autorise la récurrence, un thread qui a entré le verrou en mode écriture peut entrer écriture en mode de façon récursive, même si d’autres threads attendent pour entrer en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-510">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-511">L’exemple suivant montre comment utiliser la <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> méthode pour entrer le verrou en mode écriture, avec un délai d’attente. La méthode indiquée dans l’exemple ajoute une nouvelle paire clé/valeur au cache synchronisé.</span><span class="sxs-lookup"><span data-stu-id="718a1-511">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="718a1-512">Si le délai d’attente spécifié est écoulé avant que le thread n’intègre le verrou, la méthode retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="718a1-512">If the specified time-out interval elapses before the thread enters the lock, the method returns `false`.</span></span> <span data-ttu-id="718a1-513">La méthode retourne `true` si la paire clé/valeur est ajoutée.</span><span class="sxs-lookup"><span data-stu-id="718a1-513">The method returns `true` if the key/value pair is added.</span></span>  
  
 <span data-ttu-id="718a1-514">Si la clé est déjà dans le cache, l’exception levée par interne <xref:System.Collections.Generic.Dictionary%602> est autorisé à mettre fin à la méthode.</span><span class="sxs-lookup"><span data-stu-id="718a1-514">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="718a1-515">A `finally` bloc est utilisé pour exécuter le <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> méthode, en garantissant que l’appelant quitte le verrou.</span><span class="sxs-lookup"><span data-stu-id="718a1-515">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.</span></span>  
  
 <span data-ttu-id="718a1-516">Ce code fait partie d’un exemple plus complet fourni pour la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="718a1-516">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="718a1-517">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-517">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="718a1-518">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-518">-or-</span>
          </span>
          <span data-ttu-id="718a1-519">Le thread actuel a entré à l'origine le verrou en mode lecture et par conséquent, une tentative d'entrer en mode écriture risquerait de créer un interblocage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-519">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="718a1-520">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-520">-or-</span>
          </span>
          <span data-ttu-id="718a1-521">Le nombre de récursivités dépasserait la capacité du compteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-521">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="718a1-522">Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-522">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="718a1-523">La valeur de <paramref name="millisecondsTimeout" /> est négative, mais différente de <see cref="F:System.Threading.Timeout.Infinite" /> (-1), qui est la seule valeur négative autorisée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-523">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="718a1-524">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-524">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="718a1-525">Intervalle d'attente, ou -1 milliseconde pour un délai d'attente infini.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-525">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="718a1-526">Essaie d'entrer le verrou en mode écriture, avec un délai d'attente facultatif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-526">Tries to enter the lock in write mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="718a1-527">
            <see langword="true" /> si le thread appelant est entré en mode écriture, sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-527">
              <see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-528">Si `timeout` est 0 (zéro), cette méthode vérifie l’état du verrou et retourne `false` immédiatement si l’état souhaité n’est pas disponible.</span><span class="sxs-lookup"><span data-stu-id="718a1-528">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="718a1-529">Si d’autres threads ont entré le verrou en mode lecture, un thread qui appelle la <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> méthode est bloquée jusqu'à ce que ces threads ont quitté le mode lecture ou jusqu'à ce que l’intervalle de délai d’attente est écoulé.</span><span class="sxs-lookup"><span data-stu-id="718a1-529">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="718a1-530">Tandis que les threads sont bloqués en attente d’entrer en mode écriture, autres threads qui essaient d’entrer en mode lecture ou verrou en mode bloquent jusqu'à ce que tous les threads qui attendent pour entrer en mode écrivent ont soit a expiré ou est entré en mode écriture et puis s’être arrêté à partir de celui-ci.</span><span class="sxs-lookup"><span data-stu-id="718a1-530">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="718a1-531">Si un verrou autorise la récurrence, un thread qui a entré le verrou en mode écriture peut entrer écriture en mode de façon récursive, même si d’autres threads attendent pour entrer en mode écriture.</span><span class="sxs-lookup"><span data-stu-id="718a1-531">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="718a1-532">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-532">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="718a1-533">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-533">-or-</span>
          </span>
          <span data-ttu-id="718a1-534">Le thread actuel a entré à l'origine le verrou en mode lecture et par conséquent, une tentative d'entrer en mode écriture risquerait de créer un interblocage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-534">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="718a1-535">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-535">-or-</span>
          </span>
          <span data-ttu-id="718a1-536">Le nombre de récursivités dépasserait la capacité du compteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-536">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="718a1-537">Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-537">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="718a1-538">La valeur de <paramref name="timeout" /> est négative, mais différente de -1 millisecondes, qui est la seule valeur négative autorisée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-538">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          </span>
          <span data-ttu-id="718a1-539">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-539">-or-</span>
          </span>
          <span data-ttu-id="718a1-540">La valeur de <paramref name="timeout" /> est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-540">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="718a1-541">L’objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> a été supprimé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-541">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-542">Obtient le nombre total de threads qui attendent pour entrer le verrou en mode lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-542">Gets the total number of threads that are waiting to enter the lock in read mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="718a1-543">Nombre total de threads qui attendent pour entrer en mode lecture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-543">The total number of threads that are waiting to enter read mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-544">Utilisez cette propriété uniquement pour le débogage, profilage et à des fins de journalisation et non pour contrôler le comportement d’un algorithme.</span><span class="sxs-lookup"><span data-stu-id="718a1-544">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="718a1-545">Les résultats peuvent changer dès qu’ils ont été calculés.</span><span class="sxs-lookup"><span data-stu-id="718a1-545">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="718a1-546">Par conséquent, il n’est pas possible de prendre des décisions basées sur cette propriété.</span><span class="sxs-lookup"><span data-stu-id="718a1-546">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-547">L’exemple suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> propriété pour générer une entrée de journal des événements si le nombre de threads qui sont bloqués, qui attendent pour entrer en mode lecture, dépasse un seuil.</span><span class="sxs-lookup"><span data-stu-id="718a1-547">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-548">Obtient le nombre total de threads qui attendent pour entrer le verrou en mode pouvant être mis à niveau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-548">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="718a1-549">Nombre total de threads qui attendent pour entrer en mode pouvant être mis à niveau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-549">The total number of threads that are waiting to enter upgradeable mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-550">Utilisez cette propriété uniquement pour le débogage, profilage et à des fins de journalisation et non pour contrôler le comportement d’un algorithme.</span><span class="sxs-lookup"><span data-stu-id="718a1-550">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="718a1-551">Les résultats peuvent changer dès qu’ils ont été calculés.</span><span class="sxs-lookup"><span data-stu-id="718a1-551">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="718a1-552">Par conséquent, il n’est pas possible de prendre des décisions basées sur cette propriété.</span><span class="sxs-lookup"><span data-stu-id="718a1-552">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-553">L’exemple suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> propriété pour générer une entrée de journal des événements si le nombre de threads bloqués, en attente d’entrer en mode de mise à niveau, dépasse un seuil.</span><span class="sxs-lookup"><span data-stu-id="718a1-553">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="718a1-554">Obtient le nombre total de threads qui attendent pour entrer le verrou en mode écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-554">Gets the total number of threads that are waiting to enter the lock in write mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="718a1-555">Nombre total de threads qui attendent pour entrer en mode écriture.</span>
          <span class="sxs-lookup">
            <span data-stu-id="718a1-555">The total number of threads that are waiting to enter write mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="718a1-556">Utilisez cette propriété uniquement pour le débogage, profilage et à des fins de journalisation et non pour contrôler le comportement d’un algorithme.</span><span class="sxs-lookup"><span data-stu-id="718a1-556">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="718a1-557">Les résultats peuvent changer dès qu’ils ont été calculés.</span><span class="sxs-lookup"><span data-stu-id="718a1-557">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="718a1-558">Par conséquent, il n’est pas possible de prendre des décisions basées sur cette propriété.</span><span class="sxs-lookup"><span data-stu-id="718a1-558">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="718a1-559">L’exemple suivant montre comment utiliser le <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> propriété pour générer une entrée de journal des événements si le nombre de threads qui sont bloqués, qui attendent pour entrer en mode écriture, dépasse un seuil.</span><span class="sxs-lookup"><span data-stu-id="718a1-559">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>