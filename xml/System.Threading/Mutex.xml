<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="275d99adffc9c04d2d1d3561f11aa937737aa2d3" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39811877" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Primitive de synchronisation qui peut également être utilisée pour la synchronisation entre processus.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque deux ou plusieurs threads doivent accéder à une ressource partagée en même temps, le système doit s’assurer qu’un seul thread à la fois utilise la ressource, un mécanisme de synchronisation. <xref:System.Threading.Mutex> une synchronisation est primitif qui accorde un accès exclusif à la ressource partagée à un seul thread. Si un thread acquiert un mutex, le deuxième thread souhaitant acquérir ce mutex est suspendu jusqu'à ce que le premier thread libère le mutex.  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement. Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface.  
  
 Vous pouvez utiliser la <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> méthode pour demander la propriété d’un mutex. Le thread appelant se bloque jusqu'à ce qu’une des actions suivantes se produit :  
  
-   Le mutex est signalé pour indiquer qu’il n’appartient pas. Dans ce cas, le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode retourne `true`, et le thread appelant suppose que la propriété du mutex et accède à la ressource protégée par le mutex. Lorsqu’il a terminé d’accéder à la ressource, le thread doit appeler la <xref:System.Threading.Mutex.ReleaseMutex%2A> méthode pour libérer la propriété du mutex. Le premier exemple dans la section exemples illustre ce modèle.  
  
-   L’intervalle de délai d’expiration spécifié dans l’appel à une <xref:System.Threading.WaitHandle.WaitOne%2A> méthode qui a un `millisecondsTimeout` ou `timeout` paramètre s’est écoulé. Dans ce cas, le <xref:System.Threading.WaitHandle.WaitOne%2A> méthode retourne `false`, et le thread appelant n’effectue aucune tentative supplémentaire pour acquérir la propriété du mutex. Dans ce cas, vous devez structurer votre code afin que l’accès à la ressource qui est protégée par le mutex est refusé au thread appelant. Étant donné que le thread n’a jamais acquis la propriété du mutex, il ne doit pas appeler le <xref:System.Threading.Mutex.ReleaseMutex%2A> (méthode). Le deuxième exemple dans la section exemples illustre ce modèle.  
  
 Le <xref:System.Threading.Mutex> classe applique l’identité de thread, un mutex peut être libéré uniquement par le thread qui l’a obtenu. En revanche, la <xref:System.Threading.Semaphore> classe n’applique pas l’identité du thread. Un mutex également peut être passé à travers les limites du domaine d’application.  
  
 Le thread qui possède un mutex peut demander ce mutex dans des appels répétés à <xref:System.Threading.WaitHandle.WaitOne%2A> sans bloquer son exécution. Toutefois, le thread doit appeler la <xref:System.Threading.Mutex.ReleaseMutex%2A> méthode le même nombre de fois pour libérer la propriété du mutex.  
  
 Étant donné que le <xref:System.Threading.Mutex> hérite de la classe <xref:System.Threading.WaitHandle>, vous pouvez également appeler la méthode statique <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> et <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> méthodes pour synchroniser l’accès à une ressource protégée.  
  
 Si un thread se termine alors qu’il possède un mutex, le mutex est considéré comme abandonné. L’état du mutex a la valeur signalé et le thread en attente suivant obtient la propriété. Depuis la version 2.0 du .NET Framework, un <xref:System.Threading.AbandonedMutexException> est levée dans le thread suivant qui acquiert le mutex abandonné. Avant la version 2.0 du .NET Framework, aucune exception n’a été levée.  
  
> [!CAUTION]
>  Un mutex abandonné indique souvent une erreur grave dans le code. Lorsqu’un thread sort sans libérer le mutex, les structures de données protégées par le mutex ne peuvent pas être dans un état cohérent. Le thread suivant à demander la propriété du mutex peut gérer cette exception et continuer, si l’intégrité des structures de données peut être vérifiée.  
  
 Si le mutex est développé au niveau système, et qu’il est abandonné, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, à l’aide du Gestionnaire des tâches de Windows).  
  
 Il existe deux types : les mutex locaux, qui sont nommés et les mutex système nommés. Un mutex local existe uniquement dans votre processus. Il peut être utilisé par n’importe quel thread de votre processus qui a une référence à la <xref:System.Threading.Mutex> objet qui représente le mutex. Chaque sans nom <xref:System.Threading.Mutex> objet représente un mutex local séparé.  
  
 Nommé le mutex système sont visibles dans tout le système d’exploitation peuvent être utilisés pour synchroniser les activités de processus. Vous pouvez créer un <xref:System.Threading.Mutex> objet qui représente un mutex système nommé en utilisant un constructeur qui accepte un nom. L’objet de système d’exploitation peut être créé en même temps, ou il peut exister avant la création de la <xref:System.Threading.Mutex> objet. Vous pouvez créer plusieurs objets <xref:System.Threading.Mutex> qui représentent le même mutex de système nommé, et vous pouvez utiliser la méthode <xref:System.Threading.Mutex.OpenExisting%2A> pour ouvrir un mutex de système nommé existant.  
  
> [!NOTE]
>  Sur un serveur qui exécute les Services Terminal Server, un mutex système nommé peut avoir deux niveaux de visibilité. Si son nom commence par le préfixe « Global\\», le mutex est visible dans toutes les sessions terminal server. Si son nom commence par le préfixe « Local\\», le mutex est visible uniquement dans la session de serveur terminal server où il a été créé. Dans ce cas, un mutex séparé portant le même nom peut exister dans chacune des autres sessions terminal server sur le serveur. Si vous ne spécifiez pas un préfixe lorsque vous créez un mutex nommé, il prend le préfixe « Local\\». Dans une session terminal server, deux mutexes dont les noms diffèrent uniquement par leurs préfixes sont des mutexes séparés et sont tous deux visibles à tous les processus dans la session terminal server. Autrement dit, les noms des préfixes « Global\\» et « Local\\» décrivent la portée du nom de mutex par rapport aux sessions terminal server, et non pas au processus.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 Cet exemple montre comment une variable locale <xref:System.Threading.Mutex> objet est utilisé pour synchroniser l’accès à une ressource protégée. Étant donné que chaque thread d’appel est bloqué jusqu'à ce qu’il acquiert la propriété du mutex, il doit appeler la <xref:System.Threading.Mutex.ReleaseMutex%2A> méthode pour libérer la propriété du thread.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 Dans l’exemple suivant, chaque thread appelle la <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> méthode pour acquérir le mutex. Si le délai est écoulé, la méthode retourne `false`, et le thread acquiert le mutex ni parvient à accéder à la ressource que le mutex protège. Le <xref:System.Threading.Mutex.ReleaseMutex%2A> méthode est appelée uniquement par le thread qui acquiert le mutex.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec des propriétés par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette surcharge de constructeur est le même que si vous appelez le <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> surcharge de constructeur et en spécifiant `false` pour la propriété initiale du mutex. Autrement dit, le thread appelant ne possède pas le mutex.  
  
   
  
## Examples  
 Le code suivant exemple montre comment une variable locale <xref:System.Threading.Mutex> objet est utilisé pour synchroniser l’accès à une ressource protégée. Le thread qui crée le mutex ne pas appartient au départ.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> pour accorder au thread appelant la propriété initiale du mutex ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec une valeur booléenne qui indique si le thread appelant doit avoir la propriété initiale du mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant exemple montre comment une variable locale <xref:System.Threading.Mutex> objet est utilisé pour synchroniser l’accès à une ressource protégée. Le thread qui crée le <xref:System.Threading.Mutex> possède initialement.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> pour donner au thread appelant la propriété initiale du mutex système nommé si celui-ci est créé en réponse à cet appel ; sinon, <see langword="false" />.</param>
        <param name="name">Nom du <see cref="T:System.Threading.Mutex" />. Si cette valeur est <see langword="null" />, <see cref="T:System.Threading.Mutex" /> est sans nom.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec une valeur booléenne qui indique si le thread appelant doit avoir la propriété initiale du mutex, et une chaîne représentant le nom du mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `name` n’est pas `null` et `initiallyOwned` est `true`, le thread appelant possède le mutex uniquement si le mutex système nommé a été créé à la suite de cet appel. Dans la mesure où il n’existe aucun mécanisme permettant de déterminer si le mutex système nommé a été créé, il est préférable de spécifier `false` pour `initiallyOwned` lors de l’appel de cette surcharge de constructeur. Vous pouvez utiliser le <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructeur si vous avez besoin déterminer la propriété initiale.  
  
 Ce constructeur initialise un <xref:System.Threading.Mutex> objet qui représente un mutex système nommé. Vous pouvez créer plusieurs <xref:System.Threading.Mutex> objets qui représentent le même de mutex système nommé.  
  
 Si le mutex nommé a déjà été créé avec la sécurité de contrôle d’accès et l’appelant n’a pas <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, une exception est levée. Pour ouvrir un mutex nommé existant avec uniquement des autorisations nécessaires pour la synchronisation des activités des threads, consultez le <xref:System.Threading.Mutex.OpenExisting%2A> (méthode).  
  
 Si vous spécifiez `null` ou une chaîne vide pour `name`, un mutex local est créé, comme si vous aviez appelé le <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructeur. Dans ce cas, `createdNew` est toujours `true`.  
  
 Car ils sont à l’échelle du système, mutex nommés peuvent être utilisés pour coordonner l’utilisation des ressources au-delà des limites de processus.  
  
> [!NOTE]
>  Sur un serveur qui exécute les Services Terminal Server, un mutex système nommé peut avoir deux niveaux de visibilité. Si son nom commence par le préfixe « Global\\», le mutex est visible dans toutes les sessions terminal server. Si son nom commence par le préfixe « Local\\», le mutex est visible uniquement dans la session de serveur terminal server où il a été créé. Dans ce cas, un mutex séparé portant le même nom peut exister dans chacune des autres sessions terminal server sur le serveur. Si vous ne spécifiez pas un préfixe lorsque vous créez un mutex nommé, il prend le préfixe « Local\\». Dans une session terminal server, deux mutexes dont les noms diffèrent uniquement par leurs préfixes sont des mutexes séparés et sont tous deux visibles à tous les processus dans la session terminal server. Autrement dit, les noms des préfixes « Global\\» et « Local\\» décrivent la portée du nom de mutex par rapport aux sessions terminal server, et non pas au processus.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 L’exemple suivant montre comment un mutex nommé sert à signaler entre les threads en cours d’exécution dans deux processus distincts.  
  
 Exécutez ce programme à partir de deux ou plusieurs fenêtres de commande. Chaque processus crée un <xref:System.Threading.Mutex> objet qui représente le mutex nommé `MyMutex`. Le mutex nommé est un objet système dont la vie est limitée par les durées de vie de la <xref:System.Threading.Mutex> objets qui le représentent. Le mutex nommé est créé lorsque le premier processus crée son <xref:System.Threading.Mutex> objet ; dans cet exemple, le mutex nommé est détenu par le premier processus qui exécute le programme. Le mutex nommé est détruit lorsque tous les le <xref:System.Threading.Mutex> les objets qui le représentent ont été libérés.  
  
 La surcharge de constructeur utilisée dans cet exemple ne peut pas déterminer le thread appelant si la propriété initiale du mutex nommé a été accordée. Vous ne devez pas utiliser ce constructeur pour demander la propriété initiale à moins que vous pouvez être certain que le thread créera le mutex nommé.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Le mutex nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le mutex nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> fait plus de 260 caractères.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> pour donner au thread appelant la propriété initiale du mutex système nommé si celui-ci est créé en réponse à cet appel ; sinon, <see langword="false" />.</param>
        <param name="name">Nom du <see cref="T:System.Threading.Mutex" />. Si cette valeur est <see langword="null" />, <see cref="T:System.Threading.Mutex" /> est sans nom.</param>
        <param name="createdNew">Cette méthode retourne une valeur booléenne qui est <see langword="true" /> si un mutex local a été créé (en d’autres termes, si <c>name</c> est <see langword="null" /> ou une chaîne vide) ou si le mutex système nommé spécifié a été créé ; <see langword="false" /> si le mutex système nommé spécifié existait déjà. Ce paramètre est passé sans être initialisé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec une valeur booléenne qui indique si le thread appelant doit avoir la propriété initiale du mutex, une chaîne qui représente le nom du mutex et une valeur booléenne qui, quand la méthode retourne son résultat, indique si la propriété initiale du mutex a été accordée au thread appelant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `name` n’est pas `null` et `initiallyOwned` est `true`, le thread appelant possède le mutex nommé uniquement si `createdNew` est `true` après l’appel. Sinon, le thread peut demander le mutex en appelant le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode).  
  
 Ce constructeur initialise un <xref:System.Threading.Mutex> objet qui représente un mutex système nommé. Vous pouvez créer plusieurs <xref:System.Threading.Mutex> objets qui représentent le même de mutex système nommé.  
  
 Si le mutex nommé a déjà été créé avec la sécurité de contrôle d’accès et l’appelant n’a pas <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> droits, une exception est levée. Pour ouvrir un mutex nommé existant avec uniquement des autorisations nécessaires pour la synchronisation des activités des threads, consultez le <xref:System.Threading.Mutex.OpenExisting%2A> (méthode).  
  
 Si vous spécifiez `null` ou une chaîne vide pour `name`, un mutex local est créé, comme si vous aviez appelé le <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructeur. Dans ce cas, `createdNew` est toujours `true`.  
  
 Car ils sont à l’échelle du système, mutex nommés peuvent être utilisés pour coordonner l’utilisation des ressources au-delà des limites de processus.  
  
> [!NOTE]
>  Sur un serveur qui exécute les Services Terminal Server, un mutex système nommé peut avoir deux niveaux de visibilité. Si son nom commence par le préfixe « Global\\», le mutex est visible dans toutes les sessions terminal server. Si son nom commence par le préfixe « Local\\», le mutex est visible uniquement dans la session de serveur terminal server où il a été créé. Dans ce cas, un mutex séparé portant le même nom peut exister dans chacune des autres sessions terminal server sur le serveur. Si vous ne spécifiez pas un préfixe lorsque vous créez un mutex nommé, il prend le préfixe « Local\\». Dans une session terminal server, deux mutexes dont les noms diffèrent uniquement par leurs préfixes sont des mutexes séparés et sont tous deux visibles à tous les processus dans la session terminal server. Autrement dit, les noms des préfixes « Global\\» et « Local\\» décrivent la portée du nom de mutex par rapport aux sessions terminal server, et non pas au processus.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 L’exemple de code suivant montre comment un mutex nommé est utilisé pour la signalisation entre processus ou threads. Exécutez ce programme à partir de deux ou plusieurs fenêtres de commande. Chaque processus crée un <xref:System.Threading.Mutex> objet qui représente le mutex nommé appelé « MonMutex ». Le mutex nommé est un objet système. Dans cet exemple, sa durée de vie est limitée par les durées de vie de la <xref:System.Threading.Mutex> objets qui le représentent. Le mutex nommé est créé lorsque le premier processus crée son local <xref:System.Threading.Mutex> de l’objet et détruit lorsque tous les le <xref:System.Threading.Mutex> les objets qui le représentent ont été libérés. Le mutex nommé est initialement détenu par le premier processus. Le deuxième processus et tous les processus suivants attendent que des processus antérieurs libérer le mutex nommé.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Le mutex nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le mutex nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> fait plus de 260 caractères.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> pour donner au thread appelant la propriété initiale du mutex système nommé si celui-ci est créé en réponse à cet appel ; sinon, <see langword="false" />.</param>
        <param name="name">Nom du mutex système. Si cette valeur est <see langword="null" />, <see cref="T:System.Threading.Mutex" /> est sans nom.</param>
        <param name="createdNew">Cette méthode retourne une valeur booléenne qui est <see langword="true" /> si un mutex local a été créé (en d’autres termes, si <c>name</c> est <see langword="null" /> ou une chaîne vide) ou si le mutex système nommé spécifié a été créé ; <see langword="false" /> si le mutex système nommé spécifié existait déjà. Ce paramètre est passé sans être initialisé.</param>
        <param name="mutexSecurity">Objet <see cref="T:System.Security.AccessControl.MutexSecurity" /> qui représente la sécurité du contrôle d'accès à appliquer au mutex système nommé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec une valeur booléenne qui indique si le thread appelant doit avoir la propriété initiale du mutex, une chaîne qui représente le nom du mutex et une variable booléenne qui, quand la méthode retourne son résultat, indique si la propriété initiale du mutex a été accordée au thread appelant, ainsi que la sécurité de contrôle d'accès à appliquer au mutex nommé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `name` n’est pas `null` et `initiallyOwned` est `true`, le thread appelant possède le mutex nommé uniquement si `createdNew` est `true` après l’appel. Sinon, le thread peut demander le mutex en appelant le <xref:System.Threading.WaitHandle.WaitOne%2A> (méthode).  
  
 Utilisez ce constructeur pour appliquer la sécurité de contrôle d’accès à un mutex système nommé lors de sa création, en empêchant l’autre code de prendre le contrôle du mutex.  
  
 Ce constructeur initialise un <xref:System.Threading.Mutex> objet qui représente un mutex système nommé. Vous pouvez créer plusieurs <xref:System.Threading.Mutex> objets qui représentent le même de mutex système nommé.  
  
 Si le mutex système nommé n’existe pas, il est créé avec la sécurité de contrôle d’accès spécifié. Si le mutex nommé existe, la sécurité de contrôle d’accès spécifié est ignorée.  
  
> [!NOTE]
>  L’appelant a un contrôle total sur nouvellement créé <xref:System.Threading.Mutex> objet voire si `mutexSecurity` refuse ou ne parvient pas à accorder des droits d’accès à l’utilisateur actuel. Toutefois, si l’utilisateur actuel tente d’obtenir un autre <xref:System.Threading.Mutex> pour représenter le même mutex nommé, en utilisant un constructeur de l’objet ou le <xref:System.Threading.Mutex.OpenExisting%2A> (méthode), Windows sécurité de contrôle d’accès est appliquée.  
  
 Si le mutex nommé a déjà été créé avec la sécurité de contrôle d’accès et l’appelant n’a pas <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, une exception est levée. Pour ouvrir un mutex nommé existant avec uniquement des autorisations nécessaires pour la synchronisation des activités des threads, consultez le <xref:System.Threading.Mutex.OpenExisting%2A> (méthode).  
  
 Si vous spécifiez `null` ou une chaîne vide pour `name`, un mutex local est créé, comme si vous aviez appelé le <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructeur. Dans ce cas, `createdNew` est toujours `true`.  
  
 Car ils sont à l’échelle du système, mutex nommés peuvent être utilisés pour coordonner l’utilisation des ressources au-delà des limites de processus.  
  
> [!NOTE]
>  Sur un serveur qui exécute les Services Terminal Server, un mutex système nommé peut avoir deux niveaux de visibilité. Si son nom commence par le préfixe « Global\\», le mutex est visible dans toutes les sessions terminal server. Si son nom commence par le préfixe « Local\\», le mutex est visible uniquement dans la session de serveur terminal server où il a été créé. Dans ce cas, un mutex séparé portant le même nom peut exister dans chacune des autres sessions terminal server sur le serveur. Si vous ne spécifiez pas un préfixe lorsque vous créez un mutex nommé, il prend le préfixe « Local\\». Dans une session terminal server, deux mutexes dont les noms diffèrent uniquement par leurs préfixes sont des mutexes séparés et sont tous deux visibles à tous les processus dans la session terminal server. Autrement dit, les noms des préfixes « Global\\» et « Local\\» décrivent la portée du nom de mutex par rapport aux sessions terminal server, et non pas au processus.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un mutex nommé avec la sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.Mutex.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un mutex nommé.  
  
 Si le mutex n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le mutex, mais qui accorde le droit de lire et modifier les autorisations sur le mutex.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> surcharge de méthode pour ouvrir le mutex avec les droits nécessaires pour lire et modifier les autorisations.  
  
 Une fois que les autorisations sont modifiées, le mutex est ouvert avec les droits nécessaires à l’entrée et de libération. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le mutex nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le mutex nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> fait plus de 260 caractères.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.MutexSecurity" /> qui représente la sécurité de contrôle d'accès pour le mutex nommé.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.MutexSecurity" /> qui représente la sécurité de contrôle d'accès pour le mutex nommé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Mutex.GetAccessControl%2A> méthode utilise la combinaison d’indicateurs (combinées à l’aide de l’opération OR au niveau du bit) suivante pour rechercher des autorisations : <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, et <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 L’utilisateur doit avoir <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> pour appeler cette méthode et le mutex doit avoir été ouvert avec <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un mutex nommé avec la sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.Mutex.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un mutex nommé.  
  
 Si le mutex n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le mutex, mais qui accorde le droit de lire et modifier les autorisations sur le mutex.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> surcharge de méthode pour ouvrir le mutex avec les droits nécessaires pour lire et modifier les autorisations, en utilisant le <xref:System.Threading.Mutex.GetAccessControl%2A> et <xref:System.Threading.Mutex.SetAccessControl%2A> méthodes.  
  
 Une fois que les autorisations sont modifiées, le mutex est ouvert avec les droits nécessaires à l’entrée et de libération. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'objet <see cref="T:System.Threading.Mutex" /> actuel représente un mutex système nommé, mais l'utilisateur ne possède pas <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  
  
- ou - 
L'objet <see cref="T:System.Threading.Mutex" /> actuel représente un mutex système nommé ; il n'a pas été ouvert avec <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Non pris en charge par Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un mutex nommé spécifié, s'il existe déjà.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom du mutex système à ouvrir.</param>
        <summary>Ouvre le mutex nommé spécifié, s'il existe déjà.</summary>
        <returns>Objet qui représente le mutex système nommé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.Mutex.OpenExisting%2A> méthode tente d’ouvrir spécifié mutex système nommé. Si le mutex système n’existe pas, cette méthode lève une exception au lieu de créer l’objet système. Pour créer le mutex système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.Mutex.%23ctor%2A> constructeurs qui a un `name` paramètre.  
  
 Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.Mutex> de l’objet, même si les objets retournés représentent le même mutex système nommé.  
  
 Cette surcharge de méthode revient à appeler le <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> surcharge de méthode et en spécifiant <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> et <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> droits, combinés à l’aide de l’opération OR au niveau du bit.  
  
 En spécifiant le <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> indicateur permet à un thread d’attendre le mutex et en spécifiant le <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> indicateur permet à un thread d’appeler le <xref:System.Threading.Mutex.ReleaseMutex%2A> (méthode).  
  
 Cette méthode ne demande pas de la propriété du mutex.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un mutex nommé avec la sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.Mutex.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un mutex nommé.  
  
 Si le mutex n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le mutex, mais qui accorde le droit de lire et modifier les autorisations sur le mutex.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> surcharge de méthode pour ouvrir le mutex avec les droits nécessaires pour lire et modifier les autorisations.  
  
 Une fois que les autorisations sont modifiées, le mutex est ouvert avec les droits nécessaires à l’entrée et de libération. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> est une chaîne vide.  
  
- ou - 
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le mutex nommé n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le mutex nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">Nom du mutex système à ouvrir.</param>
        <param name="rights">Combinaison d'opérations de bits des valeurs d'énumération qui représentent l'accès de sécurité voulu.</param>
        <summary>Ouvre le mutex nommé spécifié, s'il existe déjà, avec l'accès de sécurité souhaité.</summary>
        <returns>Objet qui représente le mutex système nommé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `rights` paramètre doit inclure le <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> indicateur pour permettre aux threads d’attendre le mutex et le <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> indicateur pour permettre d’appeler le <xref:System.Threading.Mutex.ReleaseMutex%2A> (méthode).  
  
 Le <xref:System.Threading.Mutex.OpenExisting%2A> méthode tente d’ouvrir un mutex nommé existant. Si le mutex système n’existe pas, cette méthode lève une exception au lieu de créer l’objet système. Pour créer le mutex système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.Mutex.%23ctor%2A> constructeurs qui a un `name` paramètre.  
  
 Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.Mutex> de l’objet, même si les objets retournés représentent le même mutex système nommé.  
  
 Cette méthode ne demande pas de la propriété du mutex.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un mutex nommé avec la sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.Mutex.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un mutex nommé.  
  
 Si le mutex n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le mutex, mais qui accorde le droit de lire et modifier les autorisations sur le mutex.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> surcharge de méthode pour ouvrir le mutex avec les droits nécessaires pour lire et modifier les autorisations.  
  
 Une fois que les autorisations sont modifiées, le mutex est ouvert avec les droits nécessaires à l’entrée et de libération. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> est une chaîne vide.  
  
- ou - 
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le mutex nommé n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le mutex nommé existe mais l'utilisateur n'a pas l'accès de sécurité voulu.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère l'objet <see cref="T:System.Threading.Mutex" /> une seule fois.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque fois qu’un thread acquiert un mutex (par exemple, en appelant ses <xref:System.Threading.WaitHandle.WaitOne%2A> méthode), il doit appeler par la suite <xref:System.Threading.Mutex.ReleaseMutex%2A> abandonner la propriété du mutex et débloquer des autres threads qui essaient d’obtenir la propriété du mutex. Si la tentative d’obtention de la propriété du mutex échoue (par exemple, lorsqu’un appel à la <xref:System.Threading.WaitHandle.WaitOne%2A> méthode avec un `millisecondsTimeout` ou un `timeout` paramètre retourne `false` car la demande arrive à expiration), le thread ne doivent pas appeler <xref:System.Threading.Mutex.ReleaseMutex%2A>, dans ce cas, le thread doit également pas être autorisé à accéder à la ressource protégée par le mutex, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Un thread qui possède un mutex peut spécifier le même mutex dans les appels de fonction attente répétées sans bloquer son exécution. Le nombre d’appels est conservé par le common language runtime. Le thread doit appeler <xref:System.Threading.Mutex.ReleaseMutex%2A> le même nombre de fois pour libérer la propriété du mutex.  
  
 Si un thread se termine alors qu’il possède un mutex, le mutex est considéré comme abandonné. L’état du mutex est défini "signalé" et le thread en attente suivant obtient la propriété. Si aucune autre possède le mutex, l’état du mutex est signalé. Depuis la version 2.0 du .NET Framework, un <xref:System.Threading.AbandonedMutexException> est levée dans le thread suivant qui acquiert le mutex. Avant la version 2.0 du .NET Framework, aucune exception n’a été levée.  
  
> [!CAUTION]
>  Un mutex abandonné indique souvent une erreur grave dans le code. Lorsqu’un thread sort sans libérer le mutex, les structures de données protégées par le mutex ne peuvent pas être dans un état cohérent. Le thread suivant à demander la propriété du mutex peut gérer cette exception et continuer, si l’intégrité des structures de données peut être vérifiée.  
  
 Si le mutex est développé au niveau système, et qu’il est abandonné, cela peut indiquer qu’une application a été arrêtée soudainement (par exemple, à l’aide du Gestionnaire des tâches de Windows).  
  
   
  
## Examples  
 L’exemple suivant montre comment une variable locale <xref:System.Threading.Mutex> objet est utilisé pour synchroniser l’accès à une ressource protégée. Le thread qui crée le mutex ne pas appartient au départ. Le <xref:System.Threading.Mutex.ReleaseMutex%2A> méthode est utilisée pour libérer le mutex lorsqu’il n’est plus nécessaire.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Le thread appelant ne possède pas le mutex.</exception>
        <exception cref="T:System.ObjectDisposedException">L’instance actuelle a déjà été supprimée.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">Objet <see cref="T:System.Security.AccessControl.MutexSecurity" /> qui représente la sécurité du contrôle d'accès à appliquer au mutex système nommé.</param>
        <summary>Définit la sécurité de contrôle d'accès pour un mutex système nommé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’utilisateur doit avoir <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> droits pour appeler cette méthode et le mutex doivent avoir été ouvert avec <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un mutex nommé avec la sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.Mutex.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un mutex nommé.  
  
 Si le mutex n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser le mutex, mais qui accorde le droit de lire et modifier les autorisations sur le mutex.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L’exception est interceptée et l’exemple utilise le <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> surcharge de méthode pour ouvrir le mutex avec les droits nécessaires pour lire et modifier les autorisations, en utilisant le <xref:System.Threading.Mutex.GetAccessControl%2A> et <xref:System.Threading.Mutex.SetAccessControl%2A> méthodes.  
  
 Une fois que les autorisations sont modifiées, le mutex est ouvert avec les droits nécessaires à l’entrée et de libération. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, il s’exécute à l’aide des nouvelles autorisations.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" /> est <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne détient pas d'autorisations <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  
  
- ou - 
Le mutex n'a pas été ouvert avec <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">L'objet <see cref="T:System.Threading.Mutex" /> actuel ne représente pas de mutex système nommé.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un mutex nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nom du mutex système à ouvrir.</param>
        <param name="result">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.Mutex" /> qui représente la structure mutex nommée si l'appel a réussi, ou <see langword="null" /> si l'appel a échoué. Ce paramètre est traité comme étant non initialisé.</param>
        <summary>Ouvre le mutex nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</summary>
        <returns>
          <see langword="true" /> si le mutex nommé a été ouvert ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le mutex nommé n’existe pas, cette méthode ne le crée pas. Pour créer le mutex système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.Mutex.%23ctor%2A> constructeurs qui a un `name` paramètre.  
  
 Si vous ne savez pas si un mutex nommé existe, utilisez cette surcharge de méthode au lieu du <xref:System.Threading.Mutex.OpenExisting%28System.String%29> surcharge de méthode qui lève une exception si le mutex n’existe pas.  
  
 Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.Mutex> de l’objet, même si les objets retournés représentent le même mutex système nommé.  
  
 Cette surcharge de méthode revient à appeler le <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> surcharge de méthode et en spécifiant <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> et <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> droits, combinés à l’aide de l’opération OR au niveau du bit. En spécifiant le <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> indicateur permet à un thread d’attendre le mutex et en spécifiant le <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> indicateur permet à un thread d’appeler le <xref:System.Threading.Mutex.ReleaseMutex%2A> (méthode).  
  
 Cette méthode ne demande pas de la propriété du mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> est une chaîne vide.  
  
- ou - 
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le mutex nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nom du mutex système à ouvrir.</param>
        <param name="rights">Combinaison d'opérations de bits des valeurs d'énumération qui représentent l'accès de sécurité voulu.</param>
        <param name="result">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.Mutex" /> qui représente la structure mutex nommée si l'appel a réussi, ou <see langword="null" /> si l'appel a échoué. Ce paramètre est traité comme étant non initialisé.</param>
        <summary>Ouvre le mutex nommé spécifié, s'il existe déjà, avec l'accès de sécurité souhaité, puis retourne une valeur indiquant si l'opération a réussi.</summary>
        <returns>
          <see langword="true" /> si le mutex nommé a été ouvert ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le mutex nommé n’existe pas, cette méthode ne le crée pas. Pour créer le mutex système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.Mutex.%23ctor%2A> constructeurs qui a un `name` paramètre.  
  
 Si vous ne savez pas si un mutex nommé existe, utilisez cette surcharge de méthode au lieu du <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> surcharge de méthode qui lève une exception si le mutex n’existe pas.  
  
 Le `rights` paramètre doit inclure le <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> indicateur pour permettre aux threads d’attendre le mutex et le <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> indicateur pour permettre d’appeler le <xref:System.Threading.Mutex.ReleaseMutex%2A> (méthode).  
  
 Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.Mutex> de l’objet, même si les objets retournés représentent le même mutex système nommé.  
  
 Cette méthode ne demande pas de la propriété du mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> est une chaîne vide.  
  
- ou - 
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Le mutex nommé existe, mais l’utilisateur ne dispose pas de l’accès de sécurité nécessaire pour l’utiliser.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
  </Members>
</Type>