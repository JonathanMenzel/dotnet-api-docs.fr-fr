<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Monitor.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cfafcfe91d4ef6eba6ebbbbe6d7101119c93823a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cfafcfe91d4ef6eba6ebbbbe6d7101119c93823a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Monitor">
          <source>Provides a mechanism that synchronizes access to objects.</source>
          <target state="translated">Fournit un mécanisme qui synchronise l'accès aux objets.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> classe vous permet de synchroniser l’accès à une région de code en prenant et en libérant un verrou sur un objet particulier en appelant le <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType&gt;</ph>, et <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Object locks provide the ability to restrict access to a block of code, commonly called a critical section.</source>
          <target state="translated">Les verrous d’objets permettent de restreindre l’accès à un bloc de code, communément appelé une section critique.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>While a thread owns the lock for an object, no other thread can acquire that lock.</source>
          <target state="translated">Lors d’un thread possède le verrou d’un objet, aucun autre thread ne peut acquérir ce verrou.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</source>
          <target state="translated">Vous pouvez également utiliser le <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> pour vous assurer qu’aucun autre thread est autorisé à accéder à une section de l’application code de la classe en cours d’exécution par le propriétaire du verrou, sauf si l’autre thread exécute le code à l’aide d’un objet verrouillé différent.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>In this article:</source>
          <target state="translated">Dans cet article :</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>The Monitor class: An overview<ept id="p1">](#Overview)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>La classe Monitor : une vue d’ensemble<ept id="p1">](#Overview)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>The lock object<ept id="p1">](#Lock)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>L’objet de verrouillage<ept id="p1">](#Lock)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>The critical section<ept id="p1">](#CriticalSection)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>La section critique<ept id="p1">](#CriticalSection)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>Pulse, PulseAll, and Wait<ept id="p1">](#Pulse)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Attente Pulse et PulseAll<ept id="p1">](#Pulse)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>Monitors and wait handles<ept id="p1">](#WaitHandles)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Analyses et les handles d’attente<ept id="p1">](#WaitHandles)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The Monitor class: An overview</source>
          <target state="translated">La classe Monitor : une vue d’ensemble</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> has the following features:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> présente les caractéristiques suivantes :</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It is associated with an object on demand.</source>
          <target state="translated">Il est associé à un objet à la demande.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It is unbound, which means it can be called directly from any context.</source>
          <target state="translated">Il est indépendant, ce qui signifie qu’il peut être appelée directement à partir de n’importe quel contexte.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class cannot be created; the methods of the <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> class are all static.</source>
          <target state="translated">Une instance de la <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> classe ne peut pas être créée ; les méthodes de la <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> classe sont tous statiques.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each method is passed the synchronized object that controls access to the critical section.</source>
          <target state="translated">Chaque méthode est passé à l’objet de synchronisation qui contrôle l’accès à la section critique.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class to lock objects other than strings (that is, reference types other than <ph id="ph2">&lt;xref:System.String&gt;</ph>), not value types.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> classe pour verrouiller des objets autres que des chaînes (autrement dit, les types référence autres que <ph id="ph2">&lt;xref:System.String&gt;</ph>), pas des types valeur.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>For details, see the overloads of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> method and <bpt id="p1">[</bpt>The lock object<ept id="p1">](#Lock)</ept> section later in this article.</source>
          <target state="translated">Pour plus d’informations, consultez les surcharges de la <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> (méthode) et <bpt id="p1">[</bpt>l’objet verrou<ept id="p1">](#Lock)</ept> section plus loin dans cet article.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following table describes the actions that can be taken by threads that access synchronized objects:</source>
          <target state="translated">Le tableau suivant décrit les actions pouvant être consommées par les threads qui accèdent à des objets synchronisés :</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Action</source>
          <target state="translated">Action</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Description</source>
          <target state="translated">Description </target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Acquires a lock for an object.</source>
          <target state="translated">Acquiert un verrou d’un objet.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This action also marks the beginning of a critical section.</source>
          <target state="translated">Cette action marque également le début d’une section critique.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.</source>
          <target state="translated">Aucun autre thread ne peut entrer la section critique, sauf si elle exécute les instructions dans la section critique à l’aide d’un objet verrouillé différent.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Releases the lock on an object in order to permit other threads to lock and access the object.</source>
          <target state="translated">Libère le verrou sur un objet afin d’autoriser d’autres threads pour verrouiller et accéder à l’objet.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The calling thread waits while another thread accesses the object.</source>
          <target state="translated">Le thread appelant attend qu’un autre thread accède à l’objet.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Pulse signals are used to notify waiting threads about changes to an object's state.</source>
          <target state="translated">Signaux d’impulsion sont utilisés pour signaler des threads en attente sur les modifications apportées à l’état d’un objet.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> (signal), <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> (signal), <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Sends a signal to one or more waiting threads.</source>
          <target state="translated">Envoie un signal à un ou plusieurs threads en attente.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.</source>
          <target state="translated">Ce signal avertit un thread en attente que l’état de l’objet verrouillé a changé, et le propriétaire du verrou est prêt à libérer le verrou.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.</source>
          <target state="translated">Le thread en attente est placé dans la file d’attente opérationnelle de l’objet afin qu’il peut recevoir le verrou pour l’objet.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.</source>
          <target state="translated">Une fois que le thread a le verrou, il peut vérifier le nouvel état de l’objet pour voir si l’état requis a été atteint.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Releases the lock on an object.</source>
          <target state="translated">Libère le verrou sur un objet.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This action also marks the end of a critical section protected by the locked object.</source>
          <target state="translated">Cette action marque également la fin d’une section critique protégée par l’objet verrouillé.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, there are two sets of overloads for the <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph> methods.</source>
          <target state="translated">Compter les <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, il existe deux jeux de surcharges pour la <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> et <ph id="ph3">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>One set of overloads has a <ph id="ph1">`ref`</ph> (in C#) or <ph id="ph2">`ByRef`</ph> (in Visual Basic) <ph id="ph3">&lt;xref:System.Boolean&gt;</ph> parameter that is atomically set to <ph id="ph4">`true`</ph> if the lock is acquired, even if an exception is thrown when acquiring the lock.</source>
          <target state="translated">Un ensemble de surcharges a un <ph id="ph1">`ref`</ph> (en c#) ou <ph id="ph2">`ByRef`</ph> (en Visual Basic) <ph id="ph3">&lt;xref:System.Boolean&gt;</ph> paramètre qui est automatiquement défini sur <ph id="ph4">`true`</ph> si le verrou est acquis, même si une exception est levée lors de l’acquisition du verrou.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.</source>
          <target state="translated">Utilisez ces surcharges s’il est essentiel pour libérer le verrou dans tous les cas, même lorsque les ressources que protège le verrou ne peuvent pas être dans un état cohérent.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The lock object</source>
          <target state="translated">L’objet de verrouillage</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The Monitor class consists of <ph id="ph1">`static`</ph> (in C#) or  <ph id="ph2">`Shared`</ph> (in Visual Basic) methods that operate on an object that controls access to the critical section.</source>
          <target state="translated">La classe Monitor se compose de <ph id="ph1">`static`</ph> (en c#) ou <ph id="ph2">`Shared`</ph> (en Visual Basic) les méthodes qui fonctionnent sur un objet qui contrôle l’accès à la section critique.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following information is maintained for each synchronized object:</source>
          <target state="translated">Les informations suivantes sont conservées pour chaque objet synchronisé :</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>A reference to the thread that currently holds the lock.</source>
          <target state="translated">Une référence au thread qui détient actuellement le verrou.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>A reference to a ready queue, which contains the threads that are ready to obtain the lock.</source>
          <target state="translated">Une référence à une file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</source>
          <target state="translated">Une référence à une file d’attente, qui contient les threads en attente de notification de modification dans l’état de l’objet verrouillé.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> locks objects (that is, reference types), not value types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> verrouille des objets (c'est-à-dire des types référence), mais pas des types valeur.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>While you can pass a value type to <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, it is boxed separately for each call.</source>
          <target state="translated">Il est possible de passer un type valeur à <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> et à <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, mais il est converti (boxed) séparément pour chaque appel.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Since each call creates a separate object, <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> never blocks, and the code it is supposedly protecting is not really synchronized.</source>
          <target state="translated">Étant donné que chaque appel crée un objet distinct, <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> n'est jamais bloqué, et le code qu'il est censé protéger n'est pas correctement synchronisé.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>In addition, the object passed to <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> is different from the object passed to <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, so <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> throws <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> exception with the message "Object synchronization method was called from an unsynchronized block of code."</source>
          <target state="translated">Comme l'objet passé à <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> est en plus différent de l'objet passé à <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> lève l'exception <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> avec le message suivant : « La méthode de synchronisation de l'objet a été appelée à partir d'un bloc de code non synchronisé ».</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following example illustrates this problem.</source>
          <target state="translated">L'exemple de code suivant illustre ce problème.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It launches ten tasks, each of which just sleeps for 250 milliseconds.</source>
          <target state="translated">Il lance dix tâches, chacune d'elles restant en veille pendant 250 millisecondes seulement.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each task then updates a counter variable, <ph id="ph1">`nTasks`</ph>, which is intended to count the number of tasks that actually launched and executed.</source>
          <target state="translated">Ensuite, chaque tâche met à jour une variable de compteur, <ph id="ph1">`nTasks`</ph>, qui sert à compter le nombre de tâches ayant été lancées et exécutées.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Because <ph id="ph1">`nTasks`</ph> is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.</source>
          <target state="translated"><ph id="ph1">`nTasks`</ph> est une variable globale qui peut être modifiée par plusieurs tâches simultanément. Pour empêcher cela, un gestionnaire (monitor) est utilisé.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>However, as the output from the example shows, each of the tasks throws a <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> exception.</source>
          <target state="translated">Toutefois, chaque tâche lève une exception <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>, comme le montre le résultat de l'exemple.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each task throws a <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> exception because the <ph id="ph2">`nTasks`</ph> variable is boxed before the call to the <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> method in each task.</source>
          <target state="translated">Chaque tâche lève une exception <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>, car la variable <ph id="ph2">`nTasks`</ph> est convertie (boxed) avant l'appel à la méthode <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> dans chaque tâche.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>In other words, each method call is passed a separate variable that is independent of the others.</source>
          <target state="translated">En d'autres termes, chaque appel de méthode est passé à une variable distincte, qui est indépendante des autres variables.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">`nTasks`</ph> is boxed again in the call to the <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`nTasks`</ph> est de nouveau convertie (boxed) dans l'appel à la méthode <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Once again, this creates ten new boxed variables, which are independent of each other, <ph id="ph1">`nTasks`</ph>, and the ten boxed variables created in the call to the <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cette opération crée encore dix variables boxed qui sont indépendantes les unes des autres, <ph id="ph1">`nTasks`</ph>, et les dix variables boxed dans l'appel à la méthode <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.</source>
          <target state="translated">L'exception est levée, car le code tente de libérer un verrou sur une nouvelle variable qui n'était pas précédemment verrouillée.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Although you can box a value type variable before calling <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.</source>
          <target state="translated">Vous pouvez convertir (box) une variable de type valeur avant d'appeler <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, comme dans l'exemple suivant, et passer le même objet boxed aux deux méthodes, mais cette opération n'offre aucun avantage.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.</source>
          <target state="translated">En effet, les modifications apportées à la variable non convertie (unboxed) ne sont pas répercutées dans la copie convertie (boxed), et il n'est pas possible de modifier la valeur de cette copie.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When selecting an object on which to synchronize, you should lock only on private or internal objects.</source>
          <target state="translated">Lorsque vous sélectionnez un objet sur lequel effectuer la synchronisation, vous devez verrouiller uniquement sur les objets privés ou internes.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</source>
          <target state="translated">Verrouillage d’objets externes peut entraîner des blocages, étant donné que le code non lié peut choisir les mêmes objets à verrouiller à des fins différentes.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>.</source>
          <target state="translated">Notez que vous pouvez synchroniser sur un objet dans plusieurs domaines d’application si l’objet utilisé comme verrou dérive <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The critical section</source>
          <target state="translated">La section critique</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods to mark the beginning and end of a critical section.</source>
          <target state="translated">Utilisez le <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> méthodes pour marquer le début et la fin d’une section critique.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The functionality provided by the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods is identical to that provided by the <bpt id="p1">[</bpt>lock<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> statement in C# and the <bpt id="p2">[</bpt>SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> statement in Visual Basic, except that the language constructs wrap the <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType&gt;</ph> method overload and the <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> method in a <ph id="ph5">`try`</ph>…<ph id="ph6">`finally`</ph></source>
          <target state="translated">Les fonctionnalités fournies par le <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> méthodes est identique à celle fournie par le <bpt id="p1">[</bpt>verrou<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> instruction en c# et la <bpt id="p2">[</bpt>SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> instruction en Visual Basic, à ceci près que le constructions de langage de type wrap le <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType&gt;</ph> surcharge de méthode et la <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> méthode dans un <ph id="ph5">`try`</ph>...<ph id="ph6">`finally`</ph></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>block to ensure that the monitor is released.</source>
          <target state="translated">bloc pour garantir que le moniteur est libéré.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>If the critical section is a set of contiguous instructions, then the lock acquired by the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> method guarantees that only a single thread can execute the enclosed code with the locked object.</source>
          <target state="translated">Si la section critique est un jeu d’instructions contiguës, puis le verrou acquis par la <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> méthode ne garantit qu’un seul thread peut exécuter le code avec l’objet verrouillé.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>In this case, we recommend that you place that code in a <ph id="ph1">`try`</ph> block and place the call to the <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> method in a <ph id="ph3">`finally`</ph> block.</source>
          <target state="translated">Dans ce cas, nous vous recommandons de placer ce code dans un <ph id="ph1">`try`</ph> bloquer et de placer l’appel de la <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> méthode dans un <ph id="ph3">`finally`</ph> bloc.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This ensures that the lock is released even if an exception occurs.</source>
          <target state="translated">Cela garantit la libération du verrou même si une exception se produit.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following code fragment illustrates this pattern.</source>
          <target state="translated">Le fragment de code suivant illustre ce modèle.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This facility is typically used to synchronize access to a static or instance method of a class.</source>
          <target state="translated">Cette fonctionnalité est généralement utilisée pour synchroniser l’accès à un mappage statique ou méthode d’instance d’une classe.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>If a critical section spans an entire method, the locking facility can be achieved by placing the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType&gt;</ph> on the method, and specifying the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized&gt;</ph> value in the constructor of <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si une section critique s’étend sur la totalité de la méthode, l’outil de verrouillage peut être obtenue en plaçant le <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType&gt;</ph> sur la méthode et en spécifiant le <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized&gt;</ph> valeur dans le constructeur de <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When you use this attribute, the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> method calls are not needed.</source>
          <target state="translated">Lorsque vous utilisez cet attribut, le <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> les appels de méthode ne sont pas nécessaires.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following code fragment illustrates this pattern:</source>
          <target state="translated">Le fragment de code suivant illustre ce modèle :</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class, the C# <bpt id="p1">[</bpt>lock<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> statement, or the Visual Basic <bpt id="p2">[</bpt>SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> statement inside of the method instead of the attribute.</source>
          <target state="translated">Notez que l’attribut oblige le thread actuel détient le verrou jusqu'à ce que la méthode est retournée ; Si le verrou peut être libéré plus tôt, utilisez la <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> classe c# <bpt id="p1">[</bpt>verrou<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> instruction ou Visual Basic <bpt id="p2">[</bpt>SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> instruction à l’intérieur de la méthode au lieu de l’attribut.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>While it is possible for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</source>
          <target state="translated">S’il est possible pour le <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> les instructions qui verrouillent et libèrent un objet donné à l’intersection des membres ou des limites de classes ou les deux, cette pratique n’est pas recommandée.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Pulse, PulseAll, and Wait</source>
          <target state="translated">Attente Pulse et PulseAll</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Une fois qu’un thread possède le verrou et a entré le verrou protège la section critique, elle peut appeler le <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph>, et <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> méthodes.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> releases the lock if it is held, allows a waiting thread or threads to obtain the lock and enter the critical section,   and waits to be notified by a call to the <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Libère le verrou est maintenu, permet à un thread en attente ou threads pour obtenir le verrou et entrer dans la section critique et attend d’être averti par un appel à la <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> is notified, it returns and obtains the lock again.</source>
          <target state="translated">Quand la méthode <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> reçoit la notification, elle retourne le verrou, puis le reprend.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Both <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> signal for the next thread in the wait queue to proceed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> envoient le signal d'exécution du thread suivant dans la file d'attente.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Monitors and wait handles</source>
          <target state="translated">Analyses et les handles d’attente</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It is important to note the distinction between the use of the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class and <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> objects.</source>
          <target state="translated">Il est important de noter la distinction entre l’utilisation de la <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> classe et <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> objets.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> classe est purement managés et entièrement portables et peut être plus efficace en termes de besoins en ressources de système d’exploitation.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.</source>
          <target state="translated">Les objets <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> représentent des objets d'attente de système d'exploitation et sont utiles pour la synchronisation entre le code managé et le code non managé. Ils exposent certaines fonctionnalités avancées de système d'exploitation, comme la possibilité d'attendre plusieurs objets à la fois.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class to synchronize access to a single instance of a random number generator represented by the <ph id="ph2">&lt;xref:System.Random&gt;</ph> class.</source>
          <target state="translated">L’exemple suivant utilise le <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> classe pour synchroniser l’accès à une seule instance d’un générateur de nombres aléatoire représenté par la <ph id="ph2">&lt;xref:System.Random&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The example creates ten tasks, each of which executes asynchronously on a thread pool thread.</source>
          <target state="translated">L’exemple crée dix tâches, chacun d’eux exécute de façon asynchrone sur un thread de pool de threads.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum.</source>
          <target state="translated">Chaque tâche génère des nombres aléatoires 10 000, calcule leur moyenne et met à jour les deux variables de niveau de la procédure permettant de maintenir le total en cours d’exécution, le nombre de nombres aléatoires et leur somme.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>After all tasks have executed, these two values are then used to calculate the overall mean.</source>
          <target state="translated">Une fois que toutes les tâches ont été exécutées, ces deux valeurs sont ensuite utilisés pour calculer la moyenne globale.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Because they can be accessed from any task running on a thread pool thread, access to the variables <ph id="ph1">`total`</ph> and <ph id="ph2">`n`</ph> must also be synchronized.</source>
          <target state="translated">Car ils sont accessibles à partir de n’importe quelle tâche en cours d’exécution sur un thread de pool de threads, accéder aux variables <ph id="ph1">`total`</ph> et <ph id="ph2">`n`</ph> doivent également être synchronisées.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType&gt;</ph> method is used for this purpose.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType&gt;</ph> méthode est utilisée à cet effet.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following example demonstrates the combined use of the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class (implemented with the <ph id="ph2">`lock`</ph> or <ph id="ph3">`SyncLock`</ph> language construct), the <ph id="ph4">&lt;xref:System.Threading.Interlocked&gt;</ph> class, and the <ph id="ph5">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> class.</source>
          <target state="translated">L’exemple suivant illustre l’utilisation combinée de la <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> classe (implémentée avec les <ph id="ph2">`lock`</ph> ou <ph id="ph3">`SyncLock`</ph> construction de langage), le <ph id="ph4">&lt;xref:System.Threading.Interlocked&gt;</ph> (classe) et la <ph id="ph5">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It defines two <ph id="ph1">`internal`</ph> (in C#) or <ph id="ph2">`Friend`</ph> (in Visual Basic) classes, <ph id="ph3">`SyncResource`</ph> and <ph id="ph4">`UnSyncResource`</ph>, that respectively provide synchronized and unsynchronized access to a resource.</source>
          <target state="translated">Il définit deux <ph id="ph1">`internal`</ph> (en c#) ou <ph id="ph2">`Friend`</ph> (en Visual Basic), les classes <ph id="ph3">`SyncResource`</ph> et <ph id="ph4">`UnSyncResource`</ph>, qui fournissent respectivement un accès synchronisé et non synchronisé à une ressource.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> property is even, the method calls <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> to introduce a delay of 2,000 milliseconds.</source>
          <target state="translated">Pour garantir que l’exemple illustre la différence entre l’accès synchronisé et non synchronisé (ce qui est peut-être le cas si chaque appel de méthode se termine rapidement), la méthode inclut un délai aléatoire : pour les threads dont <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> propriété est pair, la appels de méthode <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> pour introduire un délai de 2 000 millisecondes.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Note that, because the <ph id="ph1">`SyncResource`</ph> class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock.</source>
          <target state="translated">Notez que, étant donné que la <ph id="ph1">`SyncResource`</ph> classe n’est pas public, le code client acquiert un verrou sur la ressource synchronisée ; la classe interne proprement dite est acquiert le verrou.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This prevents malicious code from taking a lock on a public object.</source>
          <target state="translated">Cela empêche que du code malveillant acquière un verrou sur un objet public.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The example defines a variable, <ph id="ph1">`numOps`</ph>, that defines the number of threads that will attempt to access the resource.</source>
          <target state="translated">L’exemple définit une variable, <ph id="ph1">`numOps`</ph>, qui définit le nombre de threads qui tente d’accéder à la ressource.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The application thread calls the <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType&gt;</ph> method for synchronized and unsynchronized access five times each.</source>
          <target state="translated">Le thread d’application appelle la <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType&gt;</ph> méthode pour synchronisé et non synchronisé à cinq reprises accès chacun.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType&gt;</ph> method has a single parameter, a delegate that accepts no parameters and returns no value.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType&gt;</ph> méthode ayant un seul paramètre, un délégué qui n’accepte aucun paramètre et ne retourne aucune valeur.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>For synchronized access, it invokes the <ph id="ph1">`SyncUpdateResource`</ph> method; for unsynchronized access, it invokes the <ph id="ph2">`UnSyncUpdateResource`</ph> method.</source>
          <target state="translated">Pour l’accès synchronisé, elle appelle la <ph id="ph1">`SyncUpdateResource`</ph> méthode ; pour l’accès non synchronisé, elle appelle la <ph id="ph2">`UnSyncUpdateResource`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>After each set of method calls, the application thread calls the <bpt id="p1">[</bpt>AutoResetEvent.WaitOne<ept id="p1">](xref:System.Threading.WaitHandle.WaitOne*)</ept> method so that it blocks until the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> instance is signaled.</source>
          <target state="translated">Après chaque ensemble d’appels de méthode, le thread de l’application appelle la <bpt id="p1">[</bpt>AutoResetEvent.WaitOne<ept id="p1">](xref:System.Threading.WaitHandle.WaitOne*)</ept> méthode afin qu’elle se bloque jusqu'à ce que le <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> instance est signalée.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each call to the <ph id="ph1">`SyncUpdateResource`</ph> method calls the internal <ph id="ph2">`SyncResource.Access`</ph> method and then calls the <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> method to decrement the <ph id="ph4">`numOps`</ph> counter.</source>
          <target state="translated">Chaque appel à la <ph id="ph1">`SyncUpdateResource`</ph> appels de méthode interne <ph id="ph2">`SyncResource.Access`</ph> (méthode), puis appelle la <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> méthode décrémente le <ph id="ph4">`numOps`</ph> compteur.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> méthode est utilisée pour décrémenter le compteur, car sinon vous ne peut pas être certain qu’un deuxième thread accéder à la valeur décrémentée d’un premier thread avant de la valeur a été stockée dans la variable.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the <ph id="ph1">`SyncUpdateResource`</ph> method calls the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> method, which signals the main thread to continue execution.</source>
          <target state="translated">Lorsque le dernier travail thread synchronisé décrémente le compteur à zéro, indiquant que tous les threads synchronisés ont terminé d’accéder à la ressource, le <ph id="ph1">`SyncUpdateResource`</ph> les appels de méthode le <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui indique le thread principal pour continuer exécution.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each call to the <ph id="ph1">`UnSyncUpdateResource`</ph> method calls the internal <ph id="ph2">`UnSyncResource.Access`</ph> method and then calls the <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> method to decrement the <ph id="ph4">`numOps`</ph> counter.</source>
          <target state="translated">Chaque appel à la <ph id="ph1">`UnSyncUpdateResource`</ph> appels de méthode interne <ph id="ph2">`UnSyncResource.Access`</ph> (méthode), puis appelle la <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> méthode décrémente le <ph id="ph4">`numOps`</ph> compteur.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Once again, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable.</source>
          <target state="translated">Une fois encore, la <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> méthode est utilisée pour décrémenter le compteur pour vous assurer qu’un deuxième thread n’accède pas à la valeur avant valeur décrémentée d’un premier thread ait été attribuée à la variable.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the <ph id="ph1">`UnSyncUpdateResource`</ph> method calls the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> method, which signals the main thread to continue execution.</source>
          <target state="translated">Lors de la dernière non synchronisé décrémente de thread de travail le compteur à zéro, indiquant que plus aucun non synchronisé threads doivent accéder à la ressource, le <ph id="ph1">`UnSyncUpdateResource`</ph> les appels de méthode le <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> (méthode), qui indique au thread principal de poursuivre l’exécution .</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor.</source>
          <target state="translated">Comme le montre la sortie de l’exemple, l’accès synchronisé garantit que le thread appelant quitte la ressource protégée avant qu’un autre thread puisse y accéder ; chaque thread attend son prédécesseur.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>On the other hand, without the lock, the <ph id="ph1">`UnSyncResource.Access`</ph> method is called in the order in which threads reach it.</source>
          <target state="translated">En revanche, sans verrou la <ph id="ph1">`UnSyncResource.Access`</ph> méthode est appelée dans l’ordre dans lequel les threads l’atteignent.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This type is thread safe.</source>
          <target state="translated">Ce type est thread-safe.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="T:System.Threading.Monitor">
          <source>Acquires an exclusive lock on a specified object.</source>
          <target state="translated">Acquiert un verrou exclusif sur l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>The object on which to acquire the monitor lock.</source>
          <target state="translated">Objet sur lequel acquérir le verrou du moniteur.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Acquires an exclusive lock on the specified object.</source>
          <target state="translated">Acquiert un verrou exclusif sur l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Use <ph id="ph1">`Enter`</ph> to acquire the <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> on the object passed as the parameter.</source>
          <target state="translated">Utilisez <ph id="ph1">`Enter`</ph> pour acquérir le <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> sur l’objet passé comme paramètre.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>If another thread has executed an <ph id="ph1">`Enter`</ph> on the object but has not yet executed the corresponding <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, the current thread will block until the other thread releases the object.</source>
          <target state="translated">Si un autre thread a exécuté une <ph id="ph1">`Enter`</ph> sur l’objet mais n’a ne pas encore exécutée correspondant <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, bloque le thread actuel jusqu'à ce que l’autre thread libère l’objet.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>It is legal for the same thread to invoke <ph id="ph1">`Enter`</ph> more than once without it blocking; however, an equal number of <ph id="ph2">`Exit`</ph> calls must be invoked before other threads waiting on the object will unblock.</source>
          <target state="translated">Il est autorisé pour le même thread à appeler <ph id="ph1">`Enter`</ph> plusieurs fois sans se bloquer ; Toutefois, un nombre égal de <ph id="ph2">`Exit`</ph> appels doivent être appelés que les autres threads en attente sur l’objet seront débloquent.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> pour verrouiller des objets (autrement dit, les types référence), pas des types valeur.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>When you pass a value type variable to <ph id="ph1">`Enter`</ph>, it is boxed as an object.</source>
          <target state="translated">Lorsque vous passez une variable de type valeur à <ph id="ph1">`Enter`</ph>, elle est convertie (boxed) en tant qu’objet.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>If you pass the same variable to <ph id="ph1">`Enter`</ph> again, it is boxed as a separate object, and the thread does not block.</source>
          <target state="translated">Si vous passez à la même variable à <ph id="ph1">`Enter`</ph> , elle est convertie (boxed) en tant qu’objet distinct et le thread ne bloque pas.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>In this case, the code that <ph id="ph1">`Monitor`</ph> is supposedly protecting is not protected.</source>
          <target state="translated">Dans ce cas, le code qui <ph id="ph1">`Monitor`</ph> est censé protéger n’est pas protégé.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Furthermore, when you pass the variable to <ph id="ph1">`Exit`</ph>, still another separate object is created.</source>
          <target state="translated">En outre, lorsque vous passez la variable à <ph id="ph1">`Exit`</ph>, toujours à un autre objet distinct est créé.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Because the object passed to <ph id="ph1">`Exit`</ph> is different from the object passed to <ph id="ph2">`Enter`</ph>, <ph id="ph3">`Monitor`</ph> throws <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</source>
          <target state="translated">Étant donné que l’objet passé à <ph id="ph1">`Exit`</ph> est différent de l’objet passé à <ph id="ph2">`Enter`</ph>, <ph id="ph3">`Monitor`</ph> lève <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>For more information, see the conceptual topic <bpt id="p1">[</bpt>Monitors<ept id="p1">](xref:System.Threading.Monitor)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez la rubrique conceptuelle <bpt id="p1">[</bpt>analyses<ept id="p1">](xref:System.Threading.Monitor)</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> can interrupt threads that are waiting to enter a <ph id="ph2">`Monitor`</ph> on an object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> peut interrompre des threads qui attendent pour entrer un <ph id="ph2">`Monitor`</ph> sur un objet.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> will be thrown.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> sera levée.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Use a C# <ph id="ph1">`try`</ph>…<ph id="ph2">`finally`</ph></source>
          <target state="translated">Utiliser le langage c# <ph id="ph1">`try`</ph>...<ph id="ph2">`finally`</ph></target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>block (<ph id="ph1">`Try`</ph>…<ph id="ph2">`Finally`</ph></source>
          <target state="translated">bloc (<ph id="ph1">`Try`</ph>...<ph id="ph2">`Finally`</ph></target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>in Visual Basic) to ensure that you release the monitor, or use the C# <ph id="ph1">`lock`</ph> statement (<ph id="ph2">`SyncLock`</ph> statement in Visual Basic), which wraps the <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods in a <ph id="ph5">`try`</ph>…<ph id="ph6">`finally`</ph></source>
          <target state="translated">en Visual Basic) pour garantir que vous libérez le moniteur ou si vous utilisez c# <ph id="ph1">`lock`</ph> instruction (<ph id="ph2">`SyncLock`</ph> instruction en Visual Basic), qui encapsule le <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> et <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> méthodes dans un <ph id="ph5">`try`</ph>...<ph id="ph6">`finally`</ph></target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>block.</source>
          <target state="translated">bloc.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">`Enter`</ph> method.</source>
          <target state="translated">L'exemple suivant décrit comment utiliser la méthode <ph id="ph1">`Enter`</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The object on which to wait.</source>
          <target state="translated">Objet sur lequel attendre.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The result of the attempt to acquire the lock, passed by reference.</source>
          <target state="translated">Résultat de la tentative d'acquisition du verrou, passé par la référence.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The input must be <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">L'entrée doit avoir la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The output is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock is acquired; otherwise, the output is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La sortie a la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si un verrou est acquis ; sinon, elle a la valeur <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The output is set even if an exception occurs during the attempt to acquire the lock.</source>
          <target state="translated">La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Note   If no exception occurs, the output of this method is always <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Remarque   Si aucune exception ne se produit, la sortie de cette méthode est toujours <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</source>
          <target state="translated">Acquiert un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Use <ph id="ph1">`Enter`</ph> to acquire the <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> on the object passed as the <ph id="ph3">`obj`</ph> parameter.</source>
          <target state="translated">Utilisez <ph id="ph1">`Enter`</ph> pour acquérir le <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> sur l’objet passé en tant que le <ph id="ph3">`obj`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>If another thread has executed an <ph id="ph1">`Enter`</ph> on the object but has not yet executed the corresponding <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, the current thread will block until the other thread releases the object.</source>
          <target state="translated">Si un autre thread a exécuté une <ph id="ph1">`Enter`</ph> sur l’objet mais n’a ne pas encore exécutée correspondant <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, bloque le thread actuel jusqu'à ce que l’autre thread libère l’objet.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>It is legal for the same thread to invoke <ph id="ph1">`Enter`</ph> more than once without it blocking; however, an equal number of <ph id="ph2">`Exit`</ph> calls must be invoked before other threads waiting on the object will unblock.</source>
          <target state="translated">Il est autorisé pour le même thread à appeler <ph id="ph1">`Enter`</ph> plusieurs fois sans se bloquer ; Toutefois, un nombre égal de <ph id="ph2">`Exit`</ph> appels doivent être appelés que les autres threads en attente sur l’objet seront débloquent.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>If the lock was not taken because an exception was thrown, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is <ph id="ph2">`false`</ph> after this method ends.</source>
          <target state="translated">Si le verrou n’a pas été appliqué, car une exception a été levée, la variable spécifiée pour le <ph id="ph1">`lockTaken`</ph> paramètre est <ph id="ph2">`false`</ph> après la fin de cette méthode.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>This allows the program to determine, in all cases, whether it is necessary to release the lock.</source>
          <target state="translated">Cela permet au programme de déterminer, dans tous les cas, s’il est nécessaire libérer le verrou.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>If this method returns without throwing an exception, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is always <ph id="ph2">`true`</ph>, and there is no need to test it.</source>
          <target state="translated">Si cette méthode est retournée sans lever d’exception, la variable spécifiée pour le <ph id="ph1">`lockTaken`</ph> paramètre est toujours <ph id="ph2">`true`</ph>, et il n’est pas nécessaire pour le tester.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> pour verrouiller des objets (autrement dit, les types référence), pas des types valeur.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>When you pass a value type variable to <ph id="ph1">`Enter`</ph>, it is boxed as an object.</source>
          <target state="translated">Lorsque vous passez une variable de type valeur à <ph id="ph1">`Enter`</ph>, elle est convertie (boxed) en tant qu’objet.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>If you pass the same variable to <ph id="ph1">`Enter`</ph> again, it is boxed as a separate object, and the thread does not block.</source>
          <target state="translated">Si vous passez à la même variable à <ph id="ph1">`Enter`</ph> , elle est convertie (boxed) en tant qu’objet distinct et le thread ne bloque pas.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>In this case, the code that <ph id="ph1">`Monitor`</ph> is supposedly protecting is not protected.</source>
          <target state="translated">Dans ce cas, le code qui <ph id="ph1">`Monitor`</ph> est censé protéger n’est pas protégé.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Furthermore, when you pass the variable to <ph id="ph1">`Exit`</ph>, another separate object is created.</source>
          <target state="translated">En outre, lorsque vous passez la variable à <ph id="ph1">`Exit`</ph>, un autre objet distinct est créé.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Because the object passed to <ph id="ph1">`Exit`</ph> is different from the object passed to <ph id="ph2">`Enter`</ph>, <ph id="ph3">`Monitor`</ph> throws <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</source>
          <target state="translated">Étant donné que l’objet passé à <ph id="ph1">`Exit`</ph> est différent de l’objet passé à <ph id="ph2">`Enter`</ph>, <ph id="ph3">`Monitor`</ph> lève <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>For more information, see the conceptual topic <bpt id="p1">[</bpt>Monitors<ept id="p1">](xref:System.Threading.Monitor)</ept>.</source>
          <target state="translated">Pour plus d’informations, consultez la rubrique conceptuelle <bpt id="p1">[</bpt>analyses<ept id="p1">](xref:System.Threading.Monitor)</ept>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> can interrupt threads that are waiting to enter a <ph id="ph2">`Monitor`</ph> on an object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> peut interrompre des threads qui attendent pour entrer un <ph id="ph2">`Monitor`</ph> sur un objet.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> will be thrown.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> sera levée.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The following code shows the basic pattern for using the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> method overload.</source>
          <target state="translated">Le code suivant illustre le modèle de base pour l’utilisation de la <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> la surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>This overload always sets the value of the variable that is passed to the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic) <ph id="ph3">`lockTaken`</ph>, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</source>
          <target state="translated">Cette surcharge définit toujours la valeur de la variable est passée à la <ph id="ph1">`ref`</ph> paramètre (<ph id="ph2">`ByRef`</ph> en Visual Basic) <ph id="ph3">`lockTaken`</ph>, même si la méthode lève une exception, la valeur de la variable est une méthode fiable pour déterminer si le verrou doit être publié.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The input to <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">L’entrée de <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> est <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The object on which to release the lock.</source>
          <target state="translated">Objet sur lequel libérer le verrou.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>Releases an exclusive lock on the specified object.</source>
          <target state="translated">Libère un verrou exclusif sur l’objet spécifié.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The calling thread must own the lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Le thread appelant doit posséder le verrou sur le <ph id="ph1">`obj`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>If the calling thread owns the lock on the specified object, and has made an equal number of <ph id="ph1">`Exit`</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> calls for the object, then the lock is released.</source>
          <target state="translated">Si le thread appelant possède le verrou sur l’objet spécifié et a effectué un nombre égal de <ph id="ph1">`Exit`</ph> et <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> appelle pour l’objet, puis la libération du verrou.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>If the calling thread has not invoked <ph id="ph1">`Exit`</ph> as many times as <ph id="ph2">`Enter`</ph>, the lock is not released.</source>
          <target state="translated">Si le thread appelant n’a pas été appelé <ph id="ph1">`Exit`</ph> autant de fois en tant que <ph id="ph2">`Enter`</ph>, le verrou n’est pas libéré.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.</source>
          <target state="translated">Si le verrou est libéré et les autres threads se trouvent dans la file d’attente opérationnelle de l’objet, un des threads acquiert le verrou.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls <ph id="ph1">`Exit`</ph>.</source>
          <target state="translated">Si d’autres threads attendent dans la file d’attente en attendant d’acquérir le verrou, ils ne sont pas déplacés automatiquement vers la file d’attente opérationnelle lorsque le propriétaire du verrou appelle <ph id="ph1">`Exit`</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>To move one or more waiting threads into the ready queue, call <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> before invoking <ph id="ph3">`Exit`</ph>.</source>
          <target state="translated">Pour déplacer un ou plusieurs threads en attente dans la file d’attente opérationnelle, appelez <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> avant d’appeler <ph id="ph3">`Exit`</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">`Exit`</ph> method.</source>
          <target state="translated">L'exemple suivant décrit comment utiliser la méthode <ph id="ph1">`Exit`</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The current thread does not own the lock for the specified object.</source>
          <target state="translated">Le thread en cours ne possède pas le verrou pour l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source>The object to test.</source>
          <target state="translated">Objet à tester.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source>Determines whether the current thread holds the lock on the specified object.</source>
          <target state="translated">Détermine si le thread actuel détient le verrou sur l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread holds the lock on <ph id="ph2">&lt;paramref name="obj" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le thread actuel détient le verrou sur <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> ; sinon, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source>This method works only for locks that are acquired by using the methods of the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class, or by using the C# <ph id="ph2">`lock`</ph> statement or the Visual Basic <ph id="ph3">`SyncLock`</ph> statement, which are implemented with <ph id="ph4">&lt;xref:System.Threading.Monitor&gt;</ph>.</source>
          <target state="translated">Cette méthode fonctionne uniquement pour les verrous acquis à l’aide des méthodes de la <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> classe ou à l’aide du langage c# <ph id="ph2">`lock`</ph> instruction ou Visual Basic <ph id="ph3">`SyncLock`</ph> instruction, qui sont implémentées avec <ph id="ph4">&lt;xref:System.Threading.Monitor&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source>Use this method with diagnostic tools, such as the <ph id="ph1">&lt;xref:System.Diagnostics.Debug.Assert%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> class, to debug locking issues that involve the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class.</source>
          <target state="translated">Utilisez cette méthode avec les outils de diagnostic, tels que les <ph id="ph1">&lt;xref:System.Diagnostics.Debug.Assert%2A&gt;</ph> (méthode) et le <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> (classe), pour déboguer les problèmes de verrouillage qui impliquent la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> est <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The object a thread is waiting for.</source>
          <target state="translated">Objet attendu par un thread.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Notifies a thread in the waiting queue of a change in the locked object's state.</source>
          <target state="translated">Avertit un thread situé dans la file d'attente en suspens d'un changement d'état de l'objet verrouillé.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Only the current owner of the lock can signal a waiting object using <ph id="ph1">`Pulse`</ph>.</source>
          <target state="translated">Seul le propriétaire actuel du verrou peut signaler un objet en attente à l’aide <ph id="ph1">`Pulse`</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.</source>
          <target state="translated">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode pour signaler au thread suivant dans la ligne pour le verrou.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Upon receiving the pulse, the waiting thread is moved to the ready queue.</source>
          <target state="translated">Lors de la réception de l’impulsion, le thread en attente est déplacé vers la file d’attente opérationnelle.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>When the thread that invoked <ph id="ph1">`Pulse`</ph> releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</source>
          <target state="translated">Lorsque le thread qui a appelé <ph id="ph1">`Pulse`</ph> libère le verrou, le thread suivant dans la file d’attente opérationnelle (qui n’est pas nécessairement le thread qui a été impulsions) acquiert le verrou.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class does not maintain state indicating that the <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method has been called.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> classe ne conserve pas l’état indiquant que la <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> méthode a été appelée.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Thus, if you call <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> when no threads are waiting, the next thread that calls <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> blocks as if <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> had never been called.</source>
          <target state="translated">Par conséquent, si vous appelez <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> lorsque aucun thread n’attend, le thread suivant qui appelle <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> blocs comme si <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> n’avait jamais été appelée.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>If two threads are using <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> to interact, this could result in a deadlock.</source>
          <target state="translated">Si vous utilisent deux threads <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> et <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> pour interagir, cela peut provoquer un interblocage.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> class: If you signal an <ph id="ph2">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> by calling its <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method, and there are no threads waiting, the <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> remains in a signaled state until a thread calls <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>.</source>
          <target state="translated">Ceci contraste avec le comportement de la <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> classe : Si vous signalez un <ph id="ph2">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> en appelant son <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> (méthode) et il n’existe aucun thread en attente, le <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> reste dans un état signalé jusqu'à ce qu’un thread appelle <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, ou <ph id="ph7">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> releases that thread and returns to the unsignaled state.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> libère ce thread et retourne à l’état non signalé.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Notez qu’un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient les threads qui attendent pour la notification d’un changement d’état de l’objet.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The <ph id="ph1">`Pulse`</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Le <ph id="ph1">`Pulse`</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, et <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthodes doivent être appelées à partir d’un bloc de code synchronisé.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>To signal multiple threads, use the <ph id="ph1">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">Pour signaler à plusieurs threads, utilisez la <ph id="ph1">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The object that sends the pulse.</source>
          <target state="translated">Objet qui envoie l'impulsion.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>Notifies all waiting threads of a change in the object's state.</source>
          <target state="translated">Avertit tous les threads en attente d'un changement d'état de l'objet.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.</source>
          <target state="translated">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode pour signaler tous les threads en attente d’acquérir le verrou sur l’objet.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>After the signal is sent, the waiting threads are moved to the ready queue.</source>
          <target state="translated">Une fois que le signal est envoyé, les threads en attente sont déplacés vers la file d’attente opérationnelle.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>When the thread that invoked <ph id="ph1">`PulseAll`</ph> releases the lock, the next thread in the ready queue acquires the lock.</source>
          <target state="translated">Lorsque le thread qui a appelé <ph id="ph1">`PulseAll`</ph> libère le verrou, le thread suivant dans la file d’attente opérationnelle acquiert le verrou.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Notez qu’un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient les threads qui attendent pour la notification d’un changement d’état de l’objet.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">`PulseAll`</ph>, and <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">`PulseAll`</ph>, et <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthodes doivent être appelées à partir d’un bloc de code synchronisé.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">La section Notes pour le <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> méthode expliquent ce qui se passe si <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> est appelé lorsque aucun thread en attente.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>To signal a single thread, use the <ph id="ph1">`Pulse`</ph> method.</source>
          <target state="translated">Pour signaler un thread unique, utilisez le <ph id="ph1">`Pulse`</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="T:System.Threading.Monitor">
          <source>Attempts to acquire an exclusive lock on the specified object.</source>
          <target state="translated">Essaie d'acquérir un verrou exclusif sur l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Objet sur lequel acquérir le verrou.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>Attempts to acquire an exclusive lock on the specified object.</source>
          <target state="translated">Essaie d'acquérir un verrou exclusif sur l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread acquires the lock; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le thread actuel acquiert le verrou ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>If successful, this method acquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Si succès, cette méthode acquiert un verrou exclusif sur la <ph id="ph1">`obj`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>This method returns immediately, whether or not the lock is available.</source>
          <target state="translated">Cette méthode retourne immédiatement, que le verrou soit disponible ou non.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>This method is similar to <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, but it will never block the current thread.</source>
          <target state="translated">Cette méthode est similaire à <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, mais il ne sera jamais bloque le thread actuel.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>If the thread cannot enter without blocking, the method returns <ph id="ph1">`false,`</ph>.</source>
          <target state="translated">Si le thread ne peut pas entrer sans se bloquer, la méthode retourne <ph id="ph1">`false,`</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> pour verrouiller des objets (autrement dit, les types référence), pas des types valeur.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>For details, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> article.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> l’article.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Pour vous assurer que le thread n’entre pas la section critique, vous devez examiner la valeur de retour et d’exécuter du code dans la section critique uniquement si sa valeur de retour est <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Notez que vous devez appeler <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> dans un <ph id="ph2">`finally`</ph> bloc pour garantir que le thread appelant libère son verrou sur la section critique si une exception se produit.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>The following code example demonstrates how to use the <ph id="ph1">`TryEnter`</ph> method.</source>
          <target state="translated">L'exemple de code suivant illustre l'utilisation de la méthode <ph id="ph1">`TryEnter`</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Objet sur lequel acquérir le verrou.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The result of the attempt to acquire the lock, passed by reference.</source>
          <target state="translated">Résultat de la tentative d'acquisition du verrou, passé par la référence.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The input must be <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">L'entrée doit avoir la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The output is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock is acquired; otherwise, the output is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La sortie a la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si un verrou est acquis ; sinon, elle a la valeur <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The output is set even if an exception occurs during the attempt to acquire the lock.</source>
          <target state="translated">La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</source>
          <target state="translated">Tente d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>If successful, this method acquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Si succès, cette méthode acquiert un verrou exclusif sur la <ph id="ph1">`obj`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>This method returns immediately, whether or not the lock is available.</source>
          <target state="translated">Cette méthode retourne immédiatement, que le verrou soit disponible ou non.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>If the lock was not taken because an exception was thrown, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is <ph id="ph2">`false`</ph> after this method ends.</source>
          <target state="translated">Si le verrou n’a pas été appliqué, car une exception a été levée, la variable spécifiée pour le <ph id="ph1">`lockTaken`</ph> paramètre est <ph id="ph2">`false`</ph> après la fin de cette méthode.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>This allows the program to determine, in all cases, whether it is necessary to release the lock.</source>
          <target state="translated">Cela permet au programme de déterminer, dans tous les cas, s’il est nécessaire libérer le verrou.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>This method is similar to <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph>, but it will never block the current thread.</source>
          <target state="translated">Cette méthode est similaire à <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph>, mais il ne sera jamais bloque le thread actuel.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>If the thread cannot enter without blocking, the <ph id="ph1">`lockTaken`</ph> argument is set to <ph id="ph2">`false`</ph> when the method returns.</source>
          <target state="translated">Si le thread ne peut pas entrer sans se bloquer, le <ph id="ph1">`lockTaken`</ph> argument a la valeur <ph id="ph2">`false`</ph> lorsque la méthode est retournée.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> pour verrouiller des objets (autrement dit, les types référence), pas des types valeur.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> article.</source>
          <target state="translated">Pour plus d'informations, voir l'article <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>To ensure that the thread does not enter the critical section, you should examine the value of <ph id="ph1">`lockTaken`</ph> and  execute code in the critical section only if its value is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Pour vous assurer que le thread n’entre pas la section critique, vous devez examiner la valeur de <ph id="ph1">`lockTaken`</ph> et exécuter du code dans la section critique uniquement si sa valeur est <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Notez que vous devez appeler <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> dans un <ph id="ph2">`finally`</ph> bloc pour garantir que le thread appelant libère son verrou sur la section critique si une exception se produit.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The following code shows the basic pattern for using the <ph id="ph1">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> method overload.</source>
          <target state="translated">Le code suivant illustre le modèle de base pour l’utilisation de la <ph id="ph1">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> la surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>This overload always sets the value of the variable that is passed to the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic) <ph id="ph3">`lockTaken`</ph>, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</source>
          <target state="translated">Cette surcharge définit toujours la valeur de la variable est passée à la <ph id="ph1">`ref`</ph> paramètre (<ph id="ph2">`ByRef`</ph> en Visual Basic) <ph id="ph3">`lockTaken`</ph>, même si la méthode lève une exception, la valeur de la variable est une méthode fiable pour déterminer si le verrou doit être publié.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The input to <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">L’entrée de <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> est <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Objet sur lequel acquérir le verrou.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>The number of milliseconds to wait for the lock.</source>
          <target state="translated">Délai d'attente du verrou en millisecondes.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</source>
          <target state="translated">Tentatives d'acquisition d'un verrou exclusif sur l'objet spécifié au cours du nombre spécifié de millisecondes.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread acquires the lock; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le thread actuel acquiert le verrou ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>If the <ph id="ph1">`millisecondsTimeout`</ph> parameter equals <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, this method is equivalent to <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.</source>
          <target state="translated">Si le <ph id="ph1">`millisecondsTimeout`</ph> paramètre est égal à <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, cette méthode est équivalente à <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> equals 0, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> est égal à 0, cette méthode équivaut à <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> pour verrouiller des objets (autrement dit, les types référence), pas des types valeur.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>For details, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> article.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> l’article.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Pour vous assurer que le thread n’entre pas la section critique, vous devez examiner la valeur de retour et d’exécuter du code dans la section critique uniquement si sa valeur de retour est <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Notez que vous devez appeler <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> dans un <ph id="ph2">`finally`</ph> bloc pour garantir que le thread appelant libère son verrou sur la section critique si une exception se produit.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, and not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est négatif et n’est pas égal à <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Objet sur lequel acquérir le verrou.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to wait for the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> représentant le délai d'attente du verrou.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>A value of –1 millisecond specifies an infinite wait.</source>
          <target state="translated">Une valeur de –1 milliseconde spécifie une attente infinie.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</source>
          <target state="translated">Tentatives d'acquisition d'un verrou exclusif sur l'objet spécifié au cours de la période spécifiée.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread acquires the lock; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le thread actuel acquiert le verrou ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>If the value of the <ph id="ph1">`timeout`</ph> parameter converted to milliseconds equals –1, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.</source>
          <target state="translated">Si la valeur de la <ph id="ph1">`timeout`</ph> paramètre converti en millisecondes est égale à – 1, cette méthode équivaut à <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>If the value of <ph id="ph1">`timeout`</ph> equals 0, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.</source>
          <target state="translated">Si la valeur de <ph id="ph1">`timeout`</ph> est égal à 0, cette méthode équivaut à <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> pour verrouiller des objets (autrement dit, les types référence), pas des types valeur.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>For details, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class topic.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> rubrique de la classe.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Pour vous assurer que le thread n’entre pas la section critique, vous devez examiner la valeur de retour et d’exécuter du code dans la section critique uniquement si sa valeur de retour est <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Notez que vous devez appeler <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> dans un <ph id="ph2">`finally`</ph> bloc pour garantir que le thread appelant libère son verrou sur la section critique si une exception se produit.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> in milliseconds is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 millisecond), or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La valeur de <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> en millisecondes est négative et n’est pas égale à <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 milliseconde), ou est supérieure à <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Objet sur lequel acquérir le verrou.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The number of milliseconds to wait for the lock.</source>
          <target state="translated">Délai d'attente du verrou en millisecondes.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The result of the attempt to acquire the lock, passed by reference.</source>
          <target state="translated">Résultat de la tentative d'acquisition du verrou, passé par la référence.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The input must be <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">L'entrée doit avoir la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The output is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock is acquired; otherwise, the output is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La sortie a la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si un verrou est acquis ; sinon, elle a la valeur <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The output is set even if an exception occurs during the attempt to acquire the lock.</source>
          <target state="translated">La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</source>
          <target state="translated">Tente, pendant le nombre spécifié de millisecondes, d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>If the <ph id="ph1">`millisecondsTimeout`</ph> parameter equals <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, this method is equivalent to <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Si le <ph id="ph1">`millisecondsTimeout`</ph> paramètre est égal à <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, cette méthode est équivalente à <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> equals 0, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> est égal à 0, cette méthode équivaut à <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>If the lock was not taken because an exception was thrown, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is <ph id="ph2">`false`</ph> after this method ends.</source>
          <target state="translated">Si le verrou n’a pas été appliqué, car une exception a été levée, la variable spécifiée pour le <ph id="ph1">`lockTaken`</ph> paramètre est <ph id="ph2">`false`</ph> après la fin de cette méthode.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>This allows the program to determine, in all cases, whether it is necessary to release the lock.</source>
          <target state="translated">Cela permet au programme de déterminer, dans tous les cas, s’il est nécessaire libérer le verrou.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> pour verrouiller des objets (autrement dit, les types référence), pas des types valeur.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class topic.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> rubrique de la classe.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>To ensure that the thread does not enter the critical section, you should examine the value of <ph id="ph1">`lockTaken`</ph> and  execute code in the critical section only if its value is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Pour vous assurer que le thread n’entre pas la section critique, vous devez examiner la valeur de <ph id="ph1">`lockTaken`</ph> et exécuter du code dans la section critique uniquement si sa valeur est <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Notez que vous devez appeler <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> dans un <ph id="ph2">`finally`</ph> bloc pour garantir que le thread appelant libère son verrou sur la section critique si une exception se produit.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The following code shows the basic pattern for using the <ph id="ph1">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> method overload.</source>
          <target state="translated">Le code suivant illustre le modèle de base pour l’utilisation de la <ph id="ph1">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> la surcharge de méthode.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>This overload always sets the value of the variable that is passed to the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic) <ph id="ph3">`lockTaken`</ph>, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</source>
          <target state="translated">Cette surcharge définit toujours la valeur de la variable est passée à la <ph id="ph1">`ref`</ph> paramètre (<ph id="ph2">`ByRef`</ph> en Visual Basic) <ph id="ph3">`lockTaken`</ph>, même si la méthode lève une exception, la valeur de la variable est une méthode fiable pour déterminer si le verrou doit être publié.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The input to <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">L’entrée de <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> est <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, and not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est négatif et n’est pas égal à <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Objet sur lequel acquérir le verrou.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The amount of time to wait for the lock.</source>
          <target state="translated">Délai d'attente du verrou.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>A value of –1 millisecond specifies an infinite wait.</source>
          <target state="translated">Une valeur de –1 milliseconde spécifie une attente infinie.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The result of the attempt to acquire the lock, passed by reference.</source>
          <target state="translated">Résultat de la tentative d'acquisition du verrou, passé par la référence.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The input must be <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">L'entrée doit avoir la valeur <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The output is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock is acquired; otherwise, the output is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La sortie a la valeur <ph id="ph1">&lt;see langword="true" /&gt;</ph> si un verrou est acquis ; sinon, elle a la valeur <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The output is set even if an exception occurs during the attempt to acquire the lock.</source>
          <target state="translated">La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</source>
          <target state="translated">Tente, pendant le délai spécifié, d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>If the value of the <ph id="ph1">`timeout`</ph> parameter converted to milliseconds equals –1, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Si la valeur de la <ph id="ph1">`timeout`</ph> paramètre converti en millisecondes est égale à – 1, cette méthode équivaut à <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>If the value of <ph id="ph1">`timeout`</ph> equals 0, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Si la valeur de <ph id="ph1">`timeout`</ph> est égal à 0, cette méthode équivaut à <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>If the lock was not taken because an exception was thrown, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is <ph id="ph2">`false`</ph> after this method ends.</source>
          <target state="translated">Si le verrou n’a pas été appliqué, car une exception a été levée, la variable spécifiée pour le <ph id="ph1">`lockTaken`</ph> paramètre est <ph id="ph2">`false`</ph> après la fin de cette méthode.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>This allows the program to determine, in all cases, whether it is necessary to release the lock.</source>
          <target state="translated">Cela permet au programme de déterminer, dans tous les cas, s’il est nécessaire libérer le verrou.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Utilisez <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> pour verrouiller des objets (autrement dit, les types référence), pas des types valeur.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class topic.</source>
          <target state="translated">Pour plus d’informations, consultez le <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> rubrique de la classe.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>To ensure that the thread does not enter the critical section, you should examine the value of <ph id="ph1">`lockTaken`</ph> and  execute code in the critical section only if its value is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Pour vous assurer que le thread n’entre pas la section critique, vous devez examiner la valeur de <ph id="ph1">`lockTaken`</ph> et exécuter du code dans la section critique uniquement si sa valeur est <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Notez que vous devez appeler <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> dans un <ph id="ph2">`finally`</ph> bloc pour garantir que le thread appelant libère son verrou sur la section critique si une exception se produit.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The input to <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">L’entrée de <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> est <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> in milliseconds is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 millisecond), or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La valeur de <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> en millisecondes est négative et n’est pas égale à <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 milliseconde), ou est supérieure à <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="T:System.Threading.Monitor">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The object on which to wait.</source>
          <target state="translated">Objet sur lequel attendre.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the call returned because the caller reacquired the lock for the specified object.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si l'appel est retourné parce que l'appelant a de nouveau acquis le verrou pour l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>This method does not return if the lock is not reacquired.</source>
          <target state="translated">Cette méthode ne retourne rien si le verrou n'est pas acquis à nouveau.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode pour libérer l’objet afin qu’un autre thread peut y accéder.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">L’appelant est bloqué en attendant l’acquérir à nouveau le verrou.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock on the object and enters the object's waiting queue.</source>
          <target state="translated">Lorsqu’un thread appelle <ph id="ph1">`Wait`</ph>, il libère le verrou sur l’objet et le passe à la file d’attente de l’objet.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</source>
          <target state="translated">Le thread suivant dans la file d’attente opérationnelle de l’objet (si elle existe) acquiert le verrou et a l’usage exclusif de l’objet.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>All threads that call <ph id="ph1">`Wait`</ph> remain in the waiting queue until they receive a signal from <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, sent by the owner of the lock.</source>
          <target state="translated">Tous les threads qui appellent <ph id="ph1">`Wait`</ph> restent dans la file d’attente jusqu'à ce qu’ils reçoivent un signal de <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, envoyé par le propriétaire du verrou.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>If <ph id="ph1">`Pulse`</ph> is sent, only the thread at the head of the waiting queue is affected.</source>
          <target state="translated">Si <ph id="ph1">`Pulse`</ph> est envoyé, seul le thread en tête de la file d’attente est affecté.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>If <ph id="ph1">`PulseAll`</ph> is sent, all threads that are waiting for the object are affected.</source>
          <target state="translated">Si <ph id="ph1">`PulseAll`</ph> est envoyé, tous les threads en attente de l’objet sont concernés.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>When the signal is received, one or more threads leave the waiting queue and enter the ready queue.</source>
          <target state="translated">Lorsque le signal est reçu, un ou plusieurs threads restent dans la file d’attente et la file d’attente opérationnelle.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>A thread in the ready queue is permitted to reacquire the lock.</source>
          <target state="translated">Un thread dans la file d’attente opérationnelle est autorisé à acquérir le verrou.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>This method returns when the calling thread reacquires the lock on the object.</source>
          <target state="translated">Cette méthode retourne quand le thread appelant acquière à nouveau le verrou sur l’objet.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Note that this method blocks indefinitely if the holder of the lock does not call <ph id="ph1">`Pulse`</ph> or <ph id="ph2">`PulseAll`</ph>.</source>
          <target state="translated">Notez que cette méthode se bloque indéfiniment si le conteneur du verrou n’appelle pas <ph id="ph1">`Pulse`</ph> ou <ph id="ph2">`PulseAll`</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">L’appelant exécute <ph id="ph1">`Wait`</ph> une seule fois, quel que soit le nombre de fois <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> a été appelée pour l’objet spécifié.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">`Enter`</ph> on the object and invokes <ph id="ph3">`Exit`</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Point de vue conceptuel, le <ph id="ph1">`Wait`</ph> méthode stocke le nombre de fois que l’appelant appelé <ph id="ph2">`Enter`</ph> sur l’objet et appelle <ph id="ph3">`Exit`</ph> autant de fois que nécessaire pour libérer complètement l’objet verrouillé.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">L’appelant se bloque en attendant l’acquérir à nouveau l’objet.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">`Enter`</ph> as many times as necessary to restore the saved <ph id="ph2">`Enter`</ph> count for the caller.</source>
          <target state="translated">Lorsque l’appelant acquiert de nouveau le verrou, le système appelle <ph id="ph1">`Enter`</ph> autant de fois que nécessaire pour restaurer les <ph id="ph2">`Enter`</ph> nombre pour l’appelant.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Appel de <ph id="ph1">`Wait`</ph> libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Notez qu’un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient les threads qui attendent pour la notification d’un changement d’état de l’objet.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, et <ph id="ph3">`Wait`</ph> méthodes doivent être appelées à partir d’un bloc de code synchronisé.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">La section Notes pour le <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> méthode expliquent ce qui se passe si <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> est appelé lorsque aucun thread en attente.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The thread that invokes <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is later interrupted from the waiting state.</source>
          <target state="translated">Le thread qui appelle <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> quitte ensuite l'état d'attente.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Cela se produit lorsqu’un autre thread appelle la méthode <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> de ce thread.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The object on which to wait.</source>
          <target state="translated">Objet sur lequel attendre.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The number of milliseconds to wait before the thread enters the ready queue.</source>
          <target state="translated">Nombre de millisecondes à attendre avant que le thread intègre la file d'attente opérationnelle.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>If the specified time-out interval elapses, the thread enters the ready queue.</source>
          <target state="translated">Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was reacquired before the specified time elapsed; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the lock was reacquired after the specified time elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The method does not return until the lock is reacquired.</source>
          <target state="translated">La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>This method does not return until it reacquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Cette méthode ne retourne pas jusqu'à ce qu’il acquière à nouveau un verrou exclusif sur la <ph id="ph1">`obj`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode pour libérer l’objet afin qu’un autre thread peut y accéder.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">L’appelant est bloqué en attendant l’acquérir à nouveau le verrou.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">Le délai d’attente garantit que le thread actuel ne se bloque pas indéfiniment si un autre thread libère le verrou sans appeler d’abord la <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</source>
          <target state="translated">Il déplace également le thread à la file d’attente opérationnelle, en ignorant les autres threads sont en avance dans la file d’attente, afin qu’il peut acquérir à nouveau le verrou plus tôt.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The thread can test the return value of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.</source>
          <target state="translated">Le thread peut tester la valeur de retour de la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode pour déterminer si elle a de nouveau acquis le verrou avant le délai d’attente. Le thread peut évaluer les conditions qui a causé l’attente, et si nécessaire, appeler le <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode à nouveau.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock on the object and enters the object's waiting queue.</source>
          <target state="translated">Lorsqu’un thread appelle <ph id="ph1">`Wait`</ph>, il libère le verrou sur l’objet et le passe à la file d’attente de l’objet.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</source>
          <target state="translated">Le thread suivant dans la file d’attente opérationnelle de l’objet (si elle existe) acquiert le verrou et a l’usage exclusif de l’objet.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The thread that invoked <ph id="ph1">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</source>
          <target state="translated">Le thread qui a appelé <ph id="ph1">`Wait`</ph> reste dans la file d’attente jusqu'à ce qu’un thread qui détient le verrou appelle <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, ou il est le suivant dans la file d’attente et un thread qui détient le verrou appelle <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>However, if <ph id="ph1">`millisecondsTimeout`</ph> elapses before another thread invokes this object's <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.</source>
          <target state="translated">Toutefois, si <ph id="ph1">`millisecondsTimeout`</ph> s’écoule avant qu’un autre thread appelle l’objet <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> (méthode), le thread d’origine est déplacé vers la file d’attente opérationnelle pour récupérer le verrou.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> is specified for the <ph id="ph2">`millisecondsTimeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> est spécifié pour le <ph id="ph2">`millisecondsTimeout`</ph> paramètre, cette méthode bloque indéfiniment, sauf si le détenteur du verrou appelle <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> equals 0, the thread that calls <ph id="ph2">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> est égal à 0, le thread qui appelle <ph id="ph2">`Wait`</ph> libère le verrou et intègre immédiatement la file d’attente opérationnelle pour récupérer le verrou.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">L’appelant exécute <ph id="ph1">`Wait`</ph> une seule fois, quel que soit le nombre de fois <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> a été appelée pour l’objet spécifié.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Point de vue conceptuel, le <ph id="ph1">`Wait`</ph> méthode stocke le nombre de fois que l’appelant appelé <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> sur l’objet et appelle <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> autant de fois que nécessaire pour libérer complètement l’objet verrouillé.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">L’appelant se bloque en attendant l’acquérir à nouveau l’objet.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.</source>
          <target state="translated">Lorsque l’appelant acquiert de nouveau le verrou, le système appelle <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> autant de fois que nécessaire pour restaurer les <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> nombre pour l’appelant.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Appel de <ph id="ph1">`Wait`</ph> libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient le threads qui attendent pour la notification d’un changement d’état de l’objet.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, et <ph id="ph3">`Wait`</ph> méthodes doivent être appelées à partir d’un bloc de code synchronisé.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">La section Notes pour le <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> méthode expliquent ce qui se passe si <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> est appelé lorsque aucun thread en attente.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The thread that invokes <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is later interrupted from the waiting state.</source>
          <target state="translated">Le thread qui appelle <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> quitte ensuite l'état d'attente.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Cela se produit lorsqu’un autre thread appelle la méthode <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> de ce thread.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The value of the <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> parameter is negative, and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">La valeur du paramètre <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est négative et différente de <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The object on which to wait.</source>
          <target state="translated">Objet sur lequel attendre.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to wait before the thread enters the ready queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente le temps à attendre avant que le thread n'intègre la file d'attente opérationnelle.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>If the specified time-out interval elapses, the thread enters the ready queue.</source>
          <target state="translated">Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was reacquired before the specified time elapsed; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the lock was reacquired after the specified time elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The method does not return until the lock is reacquired.</source>
          <target state="translated">La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>This method does not return until it reacquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Cette méthode ne retourne pas jusqu'à ce qu’il acquière à nouveau un verrou exclusif sur la <ph id="ph1">`obj`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode pour libérer l’objet afin qu’un autre thread peut y accéder.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">L’appelant est bloqué en attendant l’acquérir à nouveau le verrou.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">Le délai d’attente garantit que le thread actuel ne se bloque pas indéfiniment si un autre thread libère le verrou sans appeler d’abord la <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</source>
          <target state="translated">Il déplace également le thread à la file d’attente opérationnelle, en ignorant les autres threads sont en avance dans la file d’attente, afin qu’il peut acquérir à nouveau le verrou plus tôt.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The thread can test the return value of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.</source>
          <target state="translated">Le thread peut tester la valeur de retour de la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode pour déterminer si elle a de nouveau acquis le verrou avant le délai d’attente. Le thread peut évaluer les conditions qui a causé l’attente, et si nécessaire, appeler le <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode à nouveau.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock on the object and enters the object's waiting queue.</source>
          <target state="translated">Lorsqu’un thread appelle <ph id="ph1">`Wait`</ph>, il libère le verrou sur l’objet et le passe à la file d’attente de l’objet.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</source>
          <target state="translated">Le thread suivant dans la file d’attente opérationnelle de l’objet (si elle existe) acquiert le verrou et a l’usage exclusif de l’objet.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The thread that invoked <ph id="ph1">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</source>
          <target state="translated">Le thread qui a appelé <ph id="ph1">`Wait`</ph> reste dans la file d’attente jusqu'à ce qu’un thread qui détient le verrou appelle <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, ou il est le suivant dans la file d’attente et un thread qui détient le verrou appelle <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>However, if <ph id="ph1">`timeout`</ph> elapses before another thread invokes this object's <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.</source>
          <target state="translated">Toutefois, si <ph id="ph1">`timeout`</ph> s’écoule avant qu’un autre thread appelle l’objet <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> (méthode), le thread d’origine est déplacé vers la file d’attente opérationnelle pour récupérer le verrou.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>If a <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> representing –1 millisecond is specified for the <ph id="ph2">`timeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> représentant – 1 milliseconde est spécifié pour le <ph id="ph2">`timeout`</ph> paramètre, cette méthode bloque indéfiniment, sauf si le détenteur du verrou appelle <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 milliseconds, the thread that calls <ph id="ph2">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.</source>
          <target state="translated">Si <ph id="ph1">`timeout`</ph> est 0 milliseconde, le thread qui appelle <ph id="ph2">`Wait`</ph> libère le verrou et intègre immédiatement la file d’attente opérationnelle pour récupérer le verrou.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">L’appelant exécute <ph id="ph1">`Wait`</ph> une seule fois, quel que soit le nombre de fois <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> a été appelée pour l’objet spécifié.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Point de vue conceptuel, le <ph id="ph1">`Wait`</ph> méthode stocke le nombre de fois que l’appelant appelé <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> sur l’objet et appelle <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> autant de fois que nécessaire pour libérer complètement l’objet verrouillé.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">L’appelant se bloque en attendant l’acquérir à nouveau l’objet.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.</source>
          <target state="translated">Lorsque l’appelant acquiert de nouveau le verrou, le système appelle <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> autant de fois que nécessaire pour restaurer les <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> nombre pour l’appelant.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Appel de <ph id="ph1">`Wait`</ph> libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient le threads qui attendent pour la notification d’un changement d’état de l’objet.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, et <ph id="ph3">`Wait`</ph> méthodes doivent être appelées à partir d’un bloc de code synchronisé.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">La section Notes pour le <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> méthode expliquent ce qui se passe si <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> est appelé lorsque aucun thread en attente.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The thread that invokes <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is later interrupted from the waiting state.</source>
          <target state="translated">Le thread qui appelle <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> quitte ensuite l'état d'attente.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Cela se produit lorsqu’un autre thread appelle la méthode <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> de ce thread.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The value of the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter in milliseconds is negative and does not represent <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 millisecond), or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La valeur en millisecondes du paramètre <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est négative et ne représente pas <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 milliseconde) ou est supérieure à <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The object on which to wait.</source>
          <target state="translated">Objet sur lequel attendre.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The number of milliseconds to wait before the thread enters the ready queue.</source>
          <target state="translated">Nombre de millisecondes à attendre avant que le thread intègre la file d'attente opérationnelle.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour abandonner et acquérir à nouveau le domaine de synchronisation associé au contexte (dans le cas d'un contexte synchronisé) avant l'attente ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>If the specified time-out interval elapses, the thread enters the ready queue.</source>
          <target state="translated">Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</source>
          <target state="translated">Cette méthode spécifie également si le domaine de synchronisation associé au contexte (dans le cas d’un contexte synchronisé) est abandonné avant l’attente et acquis à nouveau par la suite.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was reacquired before the specified time elapsed; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the lock was reacquired after the specified time elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The method does not return until the lock is reacquired.</source>
          <target state="translated">La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This method does not return until it reacquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Cette méthode ne retourne pas jusqu'à ce qu’il acquière à nouveau un verrou exclusif sur la <ph id="ph1">`obj`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode pour libérer l’objet afin qu’un autre thread peut y accéder.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">L’appelant est bloqué en attendant l’acquérir à nouveau le verrou.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">Le délai d’attente garantit que le thread actuel ne se bloque pas indéfiniment si un autre thread libère le verrou sans appeler d’abord la <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</source>
          <target state="translated">Il déplace également le thread à la file d’attente opérationnelle, en ignorant les autres threads sont en avance dans la file d’attente, afin qu’il peut acquérir à nouveau le verrou plus tôt.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The thread can test the return value of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.</source>
          <target state="translated">Le thread peut tester la valeur de retour de la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode pour déterminer si elle a de nouveau acquis le verrou avant le délai d’attente. Le thread peut évaluer les conditions qui a causé l’attente, et si nécessaire, appeler le <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode à nouveau.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock and enters the waiting queue.</source>
          <target state="translated">Lorsqu’un thread appelle <ph id="ph1">`Wait`</ph>, il libère le verrou et passe à la file d’attente.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</source>
          <target state="translated">À ce stade, le thread suivant dans la file d’attente opérationnelle (le cas échéant) est autorisé à prendre le contrôle du verrou.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The thread that invoked <ph id="ph1">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</source>
          <target state="translated">Le thread qui a appelé <ph id="ph1">`Wait`</ph> reste dans la file d’attente jusqu'à ce qu’un thread qui détient le verrou appelle <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, ou il est le suivant dans la file d’attente et un thread qui détient le verrou appelle <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>However, if <ph id="ph1">`millisecondsTimeout`</ph> elapses before another thread invokes this object's <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.</source>
          <target state="translated">Toutefois, si <ph id="ph1">`millisecondsTimeout`</ph> s’écoule avant qu’un autre thread appelle l’objet <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> (méthode), le thread d’origine est déplacé vers la file d’attente opérationnelle pour récupérer le verrou.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> is specified for the <ph id="ph2">`millisecondsTimeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> est spécifié pour le <ph id="ph2">`millisecondsTimeout`</ph> paramètre, cette méthode bloque indéfiniment, sauf si le détenteur du verrou appelle <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> equals 0, the thread that calls <ph id="ph2">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> est égal à 0, le thread qui appelle <ph id="ph2">`Wait`</ph> libère le verrou et intègre immédiatement la file d’attente opérationnelle pour récupérer le verrou.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">L’appelant exécute <ph id="ph1">`Wait`</ph> une seule fois, quel que soit le nombre de fois <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> a été appelée pour l’objet spécifié.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Point de vue conceptuel, le <ph id="ph1">`Wait`</ph> méthode stocke le nombre de fois que l’appelant appelé <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> sur l’objet et appelle <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> autant de fois que nécessaire pour libérer complètement l’objet verrouillé.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">L’appelant se bloque en attendant l’acquérir à nouveau l’objet.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.</source>
          <target state="translated">Lorsque l’appelant acquiert de nouveau le verrou, le système appelle <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> autant de fois que nécessaire pour restaurer les <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> nombre pour l’appelant.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Appel de <ph id="ph1">`Wait`</ph> libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient le threads qui attendent pour la notification d’un changement d’état de l’objet.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, et <ph id="ph3">`Wait`</ph> méthodes doivent être appelées à partir d’un bloc de code synchronisé.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">La section Notes pour le <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> méthode expliquent ce qui se passe si <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> est appelé lorsque aucun thread en attente.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Remarques sur la sortie de contexte</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The<ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">Le<ph id="ph1">`exitContext`</ph> paramètre n’a aucun effet à moins que le <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode appelée à partir d’un contexte managé non défini par défaut.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Even if you are currently executing a method on a class that is not derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, comme <ph id="ph2">&lt;xref:System.String&gt;</ph>, vous pouvez être dans un contexte non défini par défaut si un <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> se trouve sur votre pile dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant <ph id="ph1">`true`</ph> pour <ph id="ph2">`exitContext`</ph> oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>It returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method completes.</source>
          <target state="translated">Il retourne au contexte par défaut d’origine après l’appel à la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode se termine.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This can be useful when the context-bound class has the <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribute applied.</source>
          <target state="translated">Cela peut être utile lorsque la classe liée au contexte comporte la <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribut appliqué.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Si le code dans la pile des appels d’un membre appelle la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> (méthode) et spécifie <ph id="ph2">`true`</ph> pour <ph id="ph3">`exitContext`</ph>, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is not invoked from within a synchronized block of code.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Wait" /&gt;</ph> n’est pas appelé à partir d’un bloc de code synchronisé.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The thread that invokes <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is later interrupted from the waiting state.</source>
          <target state="translated">Le thread qui appelle <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> quitte ensuite l'état d'attente.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Cela se produit lorsqu’un autre thread appelle la méthode <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> de ce thread.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The value of the <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> parameter is negative, and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">La valeur du paramètre <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> est négative et différente de <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The object on which to wait.</source>
          <target state="translated">Objet sur lequel attendre.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to wait before the thread enters the ready queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> qui représente le temps à attendre avant que le thread n'intègre la file d'attente opérationnelle.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> pour abandonner et acquérir à nouveau le domaine de synchronisation associé au contexte (dans le cas d'un contexte synchronisé) avant l'attente ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>If the specified time-out interval elapses, the thread enters the ready queue.</source>
          <target state="translated">Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</source>
          <target state="translated">Le domaine de synchronisation associé au contexte synchronisé peut être abandonné avant l’attente et acquis de nouveau par la suite.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was reacquired before the specified time elapsed; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the lock was reacquired after the specified time elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The method does not return until the lock is reacquired.</source>
          <target state="translated">La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This method does not return until it reacquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Cette méthode ne retourne pas jusqu'à ce qu’il acquière à nouveau un verrou exclusif sur la <ph id="ph1">`obj`</ph> paramètre.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode pour libérer l’objet afin qu’un autre thread peut y accéder.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">L’appelant est bloqué en attendant l’acquérir à nouveau le verrou.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">Le délai d’attente garantit que le thread actuel ne se bloque pas indéfiniment si un autre thread libère le verrou sans appeler d’abord la <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</source>
          <target state="translated">Il déplace également le thread à la file d’attente opérationnelle, en ignorant les autres threads sont en avance dans la file d’attente, afin qu’il peut acquérir à nouveau le verrou plus tôt.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The thread can test the return value of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.</source>
          <target state="translated">Le thread peut tester la valeur de retour de la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode pour déterminer si elle a de nouveau acquis le verrou avant le délai d’attente. Le thread peut évaluer les conditions qui a causé l’attente, et si nécessaire, appeler le <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode à nouveau.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock and enters the waiting queue.</source>
          <target state="translated">Lorsqu’un thread appelle <ph id="ph1">`Wait`</ph>, il libère le verrou et passe à la file d’attente.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</source>
          <target state="translated">À ce stade, le thread suivant dans la file d’attente opérationnelle (le cas échéant) est autorisé à prendre le contrôle du verrou.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The thread that invoked <ph id="ph1">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</source>
          <target state="translated">Le thread qui a appelé <ph id="ph1">`Wait`</ph> reste dans la file d’attente jusqu'à ce qu’un thread qui détient le verrou appelle <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, ou il est le suivant dans la file d’attente et un thread qui détient le verrou appelle <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>However, if <ph id="ph1">`timeout`</ph> milliseconds elapse before another thread invokes this object's <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.</source>
          <target state="translated">Toutefois, si <ph id="ph1">`timeout`</ph> millisecondes écoulent avant un autre thread appelle l’objet <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> (méthode), le thread d’origine est déplacé vers la file d’attente opérationnelle pour récupérer le verrou.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>If a <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> representing -1 millisecond is specified for the <ph id="ph2">`timeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> représentant-1 milliseconde est spécifié pour le <ph id="ph2">`timeout`</ph> paramètre, cette méthode bloque indéfiniment, sauf si le détenteur du verrou appelle <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ou <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 milliseconds, the thread that calls <ph id="ph2">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.</source>
          <target state="translated">Si <ph id="ph1">`timeout`</ph> est 0 milliseconde, le thread qui appelle <ph id="ph2">`Wait`</ph> libère le verrou et intègre immédiatement la file d’attente opérationnelle pour récupérer le verrou.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">L’appelant exécute <ph id="ph1">`Wait`</ph> une seule fois, quel que soit le nombre de fois <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> a été appelée pour l’objet spécifié.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Point de vue conceptuel, le <ph id="ph1">`Wait`</ph> méthode stocke le nombre de fois que l’appelant appelé <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> sur l’objet et appelle <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> autant de fois que nécessaire pour libérer complètement l’objet verrouillé.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">L’appelant se bloque en attendant l’acquérir à nouveau l’objet.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.</source>
          <target state="translated">Lorsque l’appelant acquiert de nouveau le verrou, le système appelle <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> autant de fois que nécessaire pour restaurer les <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> nombre pour l’appelant.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Appel de <ph id="ph1">`Wait`</ph> libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient le threads qui attendent pour la notification d’un changement d’état de l’objet.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, et <ph id="ph3">`Wait`</ph> méthodes doivent être appelées à partir d’un bloc de code synchronisé.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">La section Notes pour le <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> méthode expliquent ce qui se passe si <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> est appelé lorsque aucun thread en attente.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Remarques sur la sortie de contexte</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The<ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">Le<ph id="ph1">`exitContext`</ph> paramètre n’a aucun effet à moins que le <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode appelée à partir d’un contexte managé non défini par défaut.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Even if you are currently executing a method on a class that is not derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, comme <ph id="ph2">&lt;xref:System.String&gt;</ph>, vous pouvez être dans un contexte non défini par défaut si un <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> se trouve sur votre pile dans le domaine d’application actuel.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method.</source>
          <target state="translated">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant <ph id="ph1">`true`</ph> pour <ph id="ph2">`exitContext`</ph> oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>It returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method completes.</source>
          <target state="translated">Il retourne au contexte par défaut d’origine après l’appel à la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode se termine.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This can be useful when the context-bound class has the <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribute applied.</source>
          <target state="translated">Cela peut être utile lorsque la classe liée au contexte comporte la <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribut appliqué.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Si le code dans la pile des appels d’un membre appelle la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> (méthode) et spécifie <ph id="ph2">`true`</ph> pour <ph id="ph3">`exitContext`</ph>, le thread quitte le domaine de synchronisation, ce qui permet un thread qui est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Lorsque la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is not invoked from within a synchronized block of code.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Wait" /&gt;</ph> n’est pas appelé à partir d’un bloc de code synchronisé.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The thread that invokes Wait is later interrupted from the waiting state.</source>
          <target state="translated">Le thread qui appelle Wait quitte ensuite l’état d’attente.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Cela se produit lorsqu’un autre thread appelle la méthode <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> de ce thread.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is negative and does not represent <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 millisecond), or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> est négatif et ne représente pas <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1 milliseconde), ou est supérieur à <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>