<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e925d576d52267c0e301b6428f677609e99940d3" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53230739" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit un mécanisme qui synchronise l'accès aux objets.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les objets <xref:System.Threading.Monitor> permettent de synchroniser l'accès à une zone de code en prenant et en libérant un verrou sur un objet particulier à l'aide des méthodes <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> et <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>. Les verrous d’objets permettent de restreindre l’accès à un bloc de code, généralement appelé une section critique. Pendant un thread possède le verrou d’un objet, aucun autre thread ne peut acquérir ce verrou. Vous pouvez également utiliser le <xref:System.Threading.Monitor> classe pour vous assurer qu’aucun autre thread n’est autorisé à accéder à une section de l’application de code en cours d’exécution par le propriétaire du verrou, sauf si l’autre thread exécute le code à l’aide d’un autre objet verrouillé.  
  
 Dans cet article :  
  
 [La classe Monitor : Une vue d’ensemble](#Overview)   
 [L’objet de verrouillage](#Lock)   
 [La section critique](#CriticalSection)   
 [Wait, Pulse et PulseAll](#Pulse)   
 [Moniteurs et les handles d’attente](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>La classe Monitor : Une vue d’ensemble  
 <xref:System.Threading.Monitor> présente les caractéristiques suivantes :  
  
-   Il est associé à un objet à la demande.  
  
-   Il est indépendant, ce qui signifie qu’elle peut être appelée directement à partir de n’importe quel contexte.  
  
-   Une instance de la <xref:System.Threading.Monitor> classe ne peut pas être créée ; les méthodes de la <xref:System.Threading.Monitor> classe sont tous statiques. Chaque méthode est passée à l’objet synchronisé qui contrôle l’accès à la section critique.  
  
> [!NOTE]
>  Utilisez le <xref:System.Threading.Monitor> classe pour verrouiller les objets autres que des chaînes (autrement dit, les types référence autres que <xref:System.String>), pas des types valeur. Pour plus d’informations, consultez les surcharges de la <xref:System.Threading.Monitor.Enter%2A> (méthode) et [l’objet verrou](#Lock) section plus loin dans cet article.  
  
 Le tableau suivant décrit les actions qui peuvent être effectuées par les threads qui accèdent à des objets synchronisés :  
  
|Action|Description |  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|Acquiert un verrou pour un objet. Cette action marque également le début d’une section critique. Aucun autre thread ne peut entrer la section critique, sauf si elle s’exécute les instructions dans la section critique à l’aide d’un autre objet verrouillé.|  
|<xref:System.Threading.Monitor.Wait%2A>|Libère le verrou sur un objet afin de permettre d’autres threads pour verrouiller et accéder à l’objet. Le thread appelant attend qu’un autre thread accède à l’objet. Signaux d’impulsion sont utilisés pour informer les threads en attente sur les modifications apportées à un état d’objet.|  
|<xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A>|Envoie un signal à un ou plusieurs threads en attente. Le signal avertit un thread en attente que l’état de l’objet verrouillé a changé, et le propriétaire du verrou est prêt à libérer le verrou. Le thread en attente est placé dans la file d’attente opérationnelle de l’objet afin qu’il peut finir par recevoir le verrou pour l’objet. Une fois que le thread dispose le verrou, il peut vérifier le nouvel état de l’objet pour voir si l’état requis a été atteint.|  
|<xref:System.Threading.Monitor.Exit%2A>|Libère le verrou sur un objet. Cette action marque également la fin d’une section critique protégée par l’objet verrouillé.|  
  
 Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il existe deux ensembles de surcharges pour les <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.TryEnter%2A> méthodes. Un ensemble de surcharges a un `ref` (en c#) ou `ByRef` (en Visual Basic) <xref:System.Boolean> paramètre qui est défini atomiquement sur `true` si le verrou est acquis, même si une exception est levée lors de l’acquisition du verrou. Utilisez ces surcharges s’il est essentiel pour libérer le verrou dans tous les cas, même lorsque les ressources que protège le verrou ne peuvent pas être dans un état cohérent.  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>L’objet de verrouillage  
 La classe Monitor se compose de `static` (en c#) ou `Shared` (en Visual Basic) méthodes qui opèrent sur un objet qui contrôle l’accès à la section critique.  Les informations suivantes sont conservées pour chaque objet synchronisé :  
  
-   Une référence au thread qui détient actuellement le verrou.  
  
-   Une référence à une file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou.  
  
-   Une référence à une file d’attente, qui contient les threads qui attendent pour la notification d’un changement de l’état de l’objet verrouillé.  
  
 <xref:System.Threading.Monitor> verrouille des objets (c'est-à-dire des types référence), mais pas des types valeur. Il est possible de passer un type valeur à <xref:System.Threading.Monitor.Enter%2A> et à <xref:System.Threading.Monitor.Exit%2A>, mais il est converti (boxed) séparément pour chaque appel. Étant donné que chaque appel crée un objet distinct, <xref:System.Threading.Monitor.Enter%2A> n'est jamais bloqué, et le code qu'il est censé protéger n'est pas correctement synchronisé. Comme l'objet passé à <xref:System.Threading.Monitor.Exit%2A> est en plus différent de l'objet passé à <xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor> lève l'exception <xref:System.Threading.SynchronizationLockException> avec le message suivant : « La méthode de synchronisation de l'objet a été appelée à partir d'un bloc de code non synchronisé ».  
  
 L'exemple de code suivant illustre ce problème. Il lance dix tâches, chacune d'elles restant en veille pendant 250 millisecondes seulement. Ensuite, chaque tâche met à jour une variable de compteur, `nTasks`, qui sert à compter le nombre de tâches ayant été lancées et exécutées. `nTasks` est une variable globale qui peut être modifiée par plusieurs tâches simultanément. Pour empêcher cela, un gestionnaire (monitor) est utilisé. Toutefois, chaque tâche lève une exception <xref:System.Threading.SynchronizationLockException>, comme le montre le résultat de l'exemple.  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 Chaque tâche lève une exception <xref:System.Threading.SynchronizationLockException>, car la variable `nTasks` est convertie (boxed) avant l'appel à la méthode <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> dans chaque tâche. En d'autres termes, chaque appel de méthode est passé à une variable distincte, qui est indépendante des autres variables. `nTasks` est de nouveau convertie (boxed) dans l'appel à la méthode <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>. Cette opération crée encore dix variables boxed qui sont indépendantes les unes des autres, `nTasks`, et les dix variables boxed dans l'appel à la méthode <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>. L'exception est levée, car le code tente de libérer un verrou sur une nouvelle variable qui n'était pas précédemment verrouillée.  
  
 Vous pouvez convertir (box) une variable de type valeur avant d'appeler <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A>, comme dans l'exemple suivant, et passer le même objet boxed aux deux méthodes, mais cette opération n'offre aucun avantage. En effet, les modifications apportées à la variable non convertie (unboxed) ne sont pas répercutées dans la copie convertie (boxed), et il n'est pas possible de modifier la valeur de cette copie.  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 Lorsque vous sélectionnez un objet sur lequel effectuer la synchronisation, vous devez verrouiller l’uniquement sur les objets privés ou internes. Verrouillage d’objets externes peut entraîner des blocages, étant donné que le code non lié peut choisir les mêmes verrouiller objets à des fins différentes.  
  
 Notez que vous pouvez synchroniser sur un objet dans plusieurs domaines d’application si l’objet utilisé comme verrou dérive <xref:System.MarshalByRefObject>.  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>Section critique  
 Utilisez le <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A> méthodes pour marquer le début et la fin d’une section critique.  
  
> [!NOTE]
>  La fonctionnalité fournie par le <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A> méthodes est identique à celle fournie par le [verrou](~/docs/csharp/language-reference/keywords/lock-statement.md) instruction en langage c# et le [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) instruction en Visual Basic, à ceci près que le constructions de langage de type wrap le <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> surcharge de méthode et la <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> méthode dans un `try`...`finally` bloc pour garantir que la libération du moniteur.  
  
 Si la section critique est un ensemble d’instructions contiguës, puis le verrou acquis par la <xref:System.Threading.Monitor.Enter%2A> méthode ne garantit qu’un seul thread peut exécuter le code délimité avec l’objet verrouillé. Dans ce cas, nous vous recommandons de placer ce code dans un `try` bloquer et placer l’appel à la <xref:System.Threading.Monitor.Exit%2A> méthode dans un `finally` bloc. Cela garantit la libération du verrou même si une exception se produit. Le fragment de code suivant illustre ce concept :  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 Cette fonctionnalité est généralement utilisée pour synchroniser l’accès à un mappage statique ou méthode d’instance d’une classe.  
  
 Si une section critique s’étend sur l’ensemble d’une méthode, l’outil de verrouillage peut être obtenue en plaçant le <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> sur la méthode et en spécifiant le <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> valeur dans le constructeur de <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>. Lorsque vous utilisez cet attribut, le <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A> les appels de méthode ne sont pas nécessaires. Le fragment de code suivant illustre ce concept :  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 Notez que l’attribut oblige le thread actuel détient le verrou jusqu'à ce que la méthode est retournée ; Si le verrou peut être libéré plus tôt, utilisez la <xref:System.Threading.Monitor> classe c# [verrou](~/docs/csharp/language-reference/keywords/lock-statement.md) instruction ou Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) instruction à l’intérieur de la méthode au lieu de l’attribut.  
  
 S’il est possible pour le <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A> les instructions qui verrouillent et libèrent un objet donné à l’intersection des membres ou les limites de classe ou les deux, cette pratique n’est pas recommandée.  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Wait, Pulse et PulseAll  
 Une fois un thread possède le verrou et a entré dans la section critique qui protège le verrou, elle peut appeler le <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, et <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> méthodes.  
  
 Lorsque le thread qui détient les appels de verrou <xref:System.Threading.Monitor.Wait%2A>, le verrou est libéré et que le thread est ajouté à la file d’attente de l’objet synchronisé. Le premier thread dans la file d’attente opérationnelle, le cas échéant, acquiert le verrou et entre dans la section critique. Le thread est déplacé à partir de la file d’attente vers la file d’attente opérationnelle lorsque soit la <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> (pour être déplacée, le thread doit être au début de la file d’attente) ou le <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> méthode est appelée par le thread qui détient le verrou. Le <xref:System.Threading.Monitor.Wait%2A> méthode est retournée lorsque le thread appelant acquiert le verrou à nouveau.  
  
 Lorsque le thread qui détient les appels de verrou <xref:System.Threading.Monitor.Pulse%2A>, le thread à la tête de la file d’attente est déplacé vers la file d’attente opérationnelle. L’appel à la <xref:System.Threading.Monitor.PulseAll%2A> méthode déplace tous les threads à partir de la file d’attente vers la file d’attente opérationnelle.  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>Tâches et handles d’attente  
 Il est important de faire la distinction entre les objets <xref:System.Threading.Monitor> et <xref:System.Threading.WaitHandle>.  
  
-   Les objets <xref:System.Threading.Monitor> sont exclusivement managés et entièrement portables. Ils peuvent être plus appropriés pour remplir les exigences de ressources du système d'exploitation.  
  
-   Les objets <xref:System.Threading.WaitHandle> représentent des objets d'attente de système d'exploitation et sont utiles pour la synchronisation entre le code managé et le code non managé. Ils exposent certaines fonctionnalités avancées de système d'exploitation, comme la possibilité d'attendre plusieurs objets à la fois.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Threading.Monitor> classe pour synchroniser l’accès à une seule instance d’un générateur de nombres aléatoire représenté par la <xref:System.Random> classe. L’exemple crée dix tâches, chacun d’eux exécute de façon asynchrone sur un thread de pool de threads. Chaque tâche génère des nombres aléatoires 10 000, calcule leur moyenne et met à jour les deux variables de niveau de la procédure permettant de maintenir un total en cours d’exécution du nombre de nombres aléatoires et leur somme. Une fois que toutes les tâches ont été exécutées, ces deux valeurs sont ensuite utilisées pour calculer la moyenne globale.  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 Car ils sont accessibles à partir de n’importe quelle tâche en cours d’exécution sur un thread de pool de threads, accéder aux variables `total` et `n` doivent également être synchronisés. Le <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> méthode est utilisée à cet effet.  
  
 L'exemple de code suivant illustre l'utilisation combinée de la classe <xref:System.Threading.Monitor> (implémentée avec les instructions de compilateur `lock` et `SyncLock`), de la classe <xref:System.Threading.Interlocked> et de la classe <xref:System.Threading.AutoResetEvent>. Il définit deux classes `internal` (en C#) ou `Friend` (en Visual Basic), `SyncResource` et `UnSyncResource`, qui fournissent respectivement un accès synchronisé et non synchronisé à une ressource. Pour garantir que l’exemple illustre la différence entre l’accès synchronisé et non synchronisé (ce qui pourrait être le cas si chaque appel de méthode se termine rapidement), la méthode inclut un délai aléatoire : pour les threads dont la propriété <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> est paire, la méthode appelle <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> pour introduire un délai de 2000 millisecondes. La classe `SyncResource` n’étant pas publique, aucune partie du code client n’acquiert un verrou sur la ressource synchronisée. C’est la classe interne proprement dite qui acquiert le verrou. Cela empêche que du code malveillant acquière un verrou sur un objet public.  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 L’exemple définit une variable, `numOps`, qui définit le nombre de threads qui tenteront d’accéder à la ressource. Le thread d’application appelle la méthode <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> à cinq reprises pour l’accès synchronisé et non synchronisé. La méthode <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> possède un seul paramètre, un délégué qui n’accepte aucun paramètre et ne retourne aucune valeur. Pour l’accès synchronisé, elle appelle la méthode `SyncUpdateResource`. Pour l’accès non synchronisé, elle appelle la méthode `UnSyncUpdateResource`. Après chaque ensemble d’appels de méthode, le thread d’application appelle la méthode AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*)<xref:System.Threading.AutoResetEvent>[ pour provoquer un blocage jusqu’à ce que l’instance  soit signalée.  
  
 Chaque appel à la méthode `SyncUpdateResource` appelle la méthode `SyncResource.Access` interne, puis appelle la méthode <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> pour décrémenter le compteur `numOps`. La méthode <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> est utilisée pour décrémenter, car sinon vous ne pouvez pas être certain qu’un deuxième thread n’accédera pas à la valeur avant que la valeur décrémentée d’un premier thread ait été stockée dans la variable. Quand le dernier thread de travail synchronisé décrémente le compteur à zéro, ce qui indique que tous les threads synchronisés ont terminé d’accéder à la ressource, la méthode `SyncUpdateResource` appelle la méthode EventWaitHandle.Set<xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> pour signaler au thread principal qu’il doit poursuivre l’exécution.  
  
 Chaque appel à la méthode `UnSyncUpdateResource` appelle la méthode `UnSyncResource.Access` interne, puis appelle la méthode <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> pour décrémenter le compteur `numOps`. Là encore, la méthode <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> est utilisée pour décrémenter, afin de s’assurer qu’un deuxième thread n’accède pas à la valeur avant que la valeur décrémentée d’un premier thread n’ait été assignée à la variable. Quand le dernier thread de travail non synchronisé décrémente le compteur à zéro, ce qui indique que plus aucun thread non synchronisé n’a besoin d’accéder à la ressource, la méthode `UnSyncUpdateResource` appelle la méthode EventWaitHandle.Set<xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> pour signaler au thread principal qu’il doit poursuivre l’exécution.  
  
 Comme le montre la sortie de l’exemple, l’accès synchronisé garantit que le thread appelant quitte la ressource protégée avant qu’un autre thread puisse y accéder ; chaque thread attend son prédécesseur. En revanche, sans verrou la méthode `UnSyncResource.Access` est appelée dans l’ordre dans lequel les threads l’atteignent.  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">Fonctionnalités et objets de threading</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acquiert un verrou exclusif sur l'objet spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel acquérir le verrou du moniteur.</param>
        <summary>Acquiert un verrou exclusif sur l'objet spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez `Enter` pour acquérir le <xref:System.Threading.Monitor> sur l’objet passé comme paramètre. Si un autre thread a exécuté une `Enter` sur l’objet, mais le n'a pas encore exécuté correspondant <xref:System.Threading.Monitor.Exit%2A>, bloque le thread actuel jusqu'à ce que l’autre thread libère l’objet. Il est autorisé pour le même thread appeler `Enter` plusieurs fois sans se bloquer ; Toutefois, un nombre égal de `Exit` appels doivent être appelées avant que les autres threads en attente sur l’objet débloque.  
  
 <xref:System.Threading.Monitor> verrouille des objets (c'est-à-dire des types référence), mais pas des types valeur. Lorsque vous passez une variable de type valeur à `Enter`, il est converti (boxed) en tant qu’objet. Si vous transmettez la même variable à `Enter` là encore, il est converti (boxed) en tant qu’objet distinct et le thread ne bloque pas. Dans ce cas, le code qui `Monitor` est censé protéger n’est pas protégé. En outre, lorsque vous passez la variable à `Exit`, toujours à un autre objet distinct est créé. Étant donné que l’objet passé à `Exit` est différent de l’objet passé à `Enter`, `Monitor` lève <xref:System.Threading.SynchronizationLockException>. Pour plus d’informations, consultez la rubrique conceptuelle [moniteurs](xref:System.Threading.Monitor).  
  
 <xref:System.Threading.Thread.Interrupt%2A> peut interrompre des threads qui attendent pour entrer un `Monitor` sur un objet. Un <xref:System.Threading.ThreadInterruptedException> sera levée.  
  
 Utiliser C# `try`...`finally` `Try`Bloc`Finally` en Visual Basic) pour vous assurer que vous le moniteur de mise en production, ou utilisez le c# `lock` instruction (`SyncLock` instruction en Visual Basic), qui encapsule le <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A> méthodes dans un `try`...`finally` Bloc  
  
   
  
## Examples  
 L'exemple suivant décrit comment utiliser la méthode `Enter`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel attendre.</param>
        <param name="lockTaken">Résultat de la tentative d'acquisition du verrou, passé par la référence. L'entrée doit avoir la valeur <see langword="false" />. La sortie a la valeur <see langword="true" /> si un verrou est acquis ; sinon, elle a la valeur <see langword="false" />. La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.  
  
Remarque   Si aucune exception ne se produit, la sortie de cette méthode est toujours <see langword="true" />.</param>
        <summary>Acquiert un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez `Enter` pour acquérir le <xref:System.Threading.Monitor> sur l’objet passé comme le `obj` paramètre. Si un autre thread a exécuté une `Enter` sur l’objet, mais le n'a pas encore exécuté correspondant <xref:System.Threading.Monitor.Exit%2A>, bloque le thread actuel jusqu'à ce que l’autre thread libère l’objet. Il est autorisé pour le même thread appeler `Enter` plusieurs fois sans se bloquer ; Toutefois, un nombre égal de `Exit` appels doivent être appelées avant que les autres threads en attente sur l’objet débloque.  
  
 Si le verrou n’a pas été appliqué, car une exception a été levée, la variable spécifiée pour le `lockTaken` paramètre est `false` après la fin de cette méthode. Cela permet au programme déterminer, dans tous les cas, s’il est nécessaire libérer le verrou. Si cette méthode retourne sans lever d’exception, la variable spécifiée pour le `lockTaken` paramètre est toujours `true`, et il n’est pas nécessaire pour le tester.  
  
 <xref:System.Threading.Monitor> verrouille des objets (c'est-à-dire des types référence), mais pas des types valeur. Lorsque vous passez une variable de type valeur à `Enter`, il est converti (boxed) en tant qu’objet. Si vous transmettez la même variable à `Enter` là encore, il est converti (boxed) en tant qu’objet distinct et le thread ne bloque pas. Dans ce cas, le code qui `Monitor` est censé protéger n’est pas protégé. En outre, lorsque vous passez la variable à `Exit`, un autre objet distinct est créé. Étant donné que l’objet passé à `Exit` est différent de l’objet passé à `Enter`, `Monitor` lève <xref:System.Threading.SynchronizationLockException>. Pour plus d’informations, consultez la rubrique conceptuelle [moniteurs](xref:System.Threading.Monitor).  
  
 <xref:System.Threading.Thread.Interrupt%2A> peut interrompre des threads qui attendent pour entrer un `Monitor` sur un objet. Un <xref:System.Threading.ThreadInterruptedException> sera levée.  
  
   
  
## Examples  
 Le code suivant montre le modèle de base pour l’utilisation de la <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> surcharge de méthode. Cette surcharge définit toujours la valeur de la variable est passée à la `ref` paramètre (`ByRef` en Visual Basic) `lockTaken`, même si la méthode lève une exception, afin que la valeur de la variable de façon fiable pour déterminer si le verrou doit être publié.  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’entrée de <paramref name="lockTaken" /> est <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel libérer le verrou.</param>
        <summary>Libère un verrou exclusif sur l’objet spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le thread appelant doit posséder le verrou sur le `obj` paramètre. Si le thread appelant possède le verrou sur l’objet spécifié et a effectué un nombre égal de `Exit` et <xref:System.Threading.Monitor.Enter%2A> appelle pour l’objet, puis le verrou est libéré. Si le thread appelant n’a pas appelé `Exit` autant de fois en tant que `Enter`, le verrou n’est pas libéré.  
  
 Si le verrou est libéré et d’autres threads se trouvent dans la file d’attente prêt pour l’objet, un des threads acquiert le verrou. Si d’autres threads se trouvent dans la file d’attente attend pour acquérir le verrou, ils ne sont pas déplacés automatiquement vers la file d’attente opérationnelle lorsque le propriétaire du verrou appelle `Exit`. Pour déplacer un ou plusieurs threads en attente dans la file d’attente opérationnelle, appelez <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> avant d’appeler `Exit`.  
  
   
  
## Examples  
 L'exemple suivant décrit comment utiliser la méthode `Exit`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Le thread en cours ne possède pas le verrou pour l'objet spécifié.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à tester.</param>
        <summary>Détermine si le thread actuel détient le verrou sur l'objet spécifié.</summary>
        <returns><see langword="true" /> si le thread actuel détient le verrou sur <paramref name="obj" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fonctionne uniquement pour les verrous acquis en utilisant les méthodes de la <xref:System.Threading.Monitor> classe, ou en utilisant c# `lock` instruction ou Visual Basic `SyncLock` instruction, qui sont implémentées avec <xref:System.Threading.Monitor>.  
  
 Utilisez cette méthode avec les outils de diagnostic, comme le <xref:System.Diagnostics.Debug.Assert%2A> (méthode) et le <xref:System.Diagnostics.Contracts.Contract> (classe), pour déboguer les problèmes de verrouillage qui impliquent la <xref:System.Threading.Monitor> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet attendu par un thread.</param>
        <summary>Avertit un thread situé dans la file d'attente en suspens d'un changement d'état de l'objet verrouillé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Seul le propriétaire actuel du verrou peut signaler un objet en attente à l’aide `Pulse`.  
  
 Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode pour signaler au thread suivant dans la ligne du verrou. Lors de la réception de l’impulsion, le thread en attente est déplacé vers la file d’attente opérationnelle. Lorsque le thread qui a appelé `Pulse` libère le verrou, le thread suivant dans la file d’attente opérationnelle (qui n’est pas nécessairement le thread qui a été impulsions) acquiert le verrou.  
  
> [!IMPORTANT]
>  Le <xref:System.Threading.Monitor> classe ne conserve pas l’état indiquant que le <xref:System.Threading.Monitor.Pulse%2A> méthode a été appelée. Par conséquent, si vous appelez <xref:System.Threading.Monitor.Pulse%2A> lorsque aucun thread n’attend, le thread suivant qui appelle <xref:System.Threading.Monitor.Wait%2A> blocs comme si <xref:System.Threading.Monitor.Pulse%2A> n’avait jamais été appelée. Si deux threads utilisent <xref:System.Threading.Monitor.Pulse%2A> et <xref:System.Threading.Monitor.Wait%2A> pour interagir, cela peut provoquer un interblocage. Comparez ceci avec le comportement de la <xref:System.Threading.AutoResetEvent> classe : Si vous signalez un <xref:System.Threading.AutoResetEvent> en appelant son <xref:System.Threading.EventWaitHandle.Set%2A> (méthode) et il n’y aucun thread n’attend, le <xref:System.Threading.AutoResetEvent> reste dans un état signalé jusqu'à ce qu’un thread appelle <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, ou <xref:System.Threading.WaitHandle.WaitAll%2A>. Le <xref:System.Threading.AutoResetEvent> libère ce thread et retourne à l’état non signalé.  
  
 Notez qu’un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient les threads qui attendent pour la notification d’un changement d’état de l’objet.  
  
 Le `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, et <xref:System.Threading.Monitor.Wait%2A> méthodes doivent être appelées à partir d’un bloc de code synchronisé.  
  
 Pour signaler plusieurs threads, utilisez le <xref:System.Threading.Monitor.PulseAll%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet qui envoie l'impulsion.</param>
        <summary>Avertit tous les threads en attente d'un changement d'état de l'objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode pour signaler tous les threads attendant d’acquérir le verrou sur l’objet. Une fois que le signal est envoyé, les threads en attente sont déplacés vers la file d’attente opérationnelle. Lorsque le thread qui a appelé `PulseAll` libère le verrou, le thread suivant dans la file d’attente opérationnelle acquiert le verrou.  
  
 Notez qu’un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient les threads qui attendent pour la notification d’un changement d’état de l’objet.  
  
 Le <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, et <xref:System.Threading.Monitor.Wait%2A> méthodes doivent être appelées à partir d’un bloc de code synchronisé.  
  
 Les notes relatives à la <xref:System.Threading.Monitor.Pulse%2A> méthode expliquent ce qui se passe si <xref:System.Threading.Monitor.Pulse%2A> est appelé lorsque aucun thread n’attend.  
  
 Pour signaler un thread unique, utilisez le `Pulse` (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Essaie d'acquérir un verrou exclusif sur l'objet spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel acquérir le verrou.</param>
        <summary>Essaie d'acquérir un verrou exclusif sur l'objet spécifié.</summary>
        <returns><see langword="true" /> si le thread actuel acquiert le verrou ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si réussie, cette méthode acquiert un verrou exclusif sur la `obj` paramètre. Cette méthode retourne immédiatement, si le verrou est disponible ou non.  
  
 Cette méthode est similaire à <xref:System.Threading.Monitor.Enter%2A>, mais il ne se bloque jamais le thread actuel. Si le thread ne peut pas entrer sans se bloquer, la méthode retourne `false,`.  
  
> [!NOTE]
>  <xref:System.Threading.Monitor> verrouille des objets (c'est-à-dire des types référence), mais pas des types valeur. Pour plus d'informations, consultez la propriété <xref:System.Threading.Monitor>.  
  
 Pour vous assurer que le thread n’entre pas de la section critique, vous devez examiner la valeur de retour et exécuter du code dans la section critique uniquement si sa valeur de retour est `true`. Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode. Notez que vous devez appeler <xref:System.Threading.Monitor.Exit%2A> dans un `finally` bloc pour vous assurer que le thread appelant libère son verrou sur la section critique si une exception se produit.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode `TryEnter`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel acquérir le verrou.</param>
        <param name="lockTaken">Résultat de la tentative d'acquisition du verrou, passé par la référence. L'entrée doit avoir la valeur <see langword="false" />. La sortie a la valeur <see langword="true" /> si un verrou est acquis ; sinon, elle a la valeur <see langword="false" />. La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</param>
        <summary>Tente d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si réussie, cette méthode acquiert un verrou exclusif sur la `obj` paramètre. Cette méthode retourne immédiatement, si le verrou est disponible ou non.  
  
 Si le verrou n’a pas été appliqué, car une exception a été levée, la variable spécifiée pour le `lockTaken` paramètre est `false` après la fin de cette méthode. Cela permet au programme déterminer, dans tous les cas, s’il est nécessaire libérer le verrou.  
  
 Cette méthode est similaire à <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, mais il ne se bloque jamais le thread actuel. Si le thread ne peut pas entrer sans se bloquer, le `lockTaken` argument a la valeur `false` lorsque la méthode est retournée.  
  
> [!NOTE]
>  <xref:System.Threading.Monitor> verrouille des objets (c'est-à-dire des types référence), mais pas des types valeur. Pour plus d'informations, voir l'article <xref:System.Threading.Monitor>.  
  
 Pour vous assurer que le thread n’entre pas de la section critique, vous devez examiner la valeur de `lockTaken` et exécuter du code dans la section critique uniquement si sa valeur est `true`. Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode. Notez que vous devez appeler <xref:System.Threading.Monitor.Exit%2A> dans un `finally` bloc pour vous assurer que le thread appelant libère son verrou sur la section critique si une exception se produit.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 Le code suivant montre le modèle de base pour l’utilisation de la <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> surcharge de méthode. Cette surcharge définit toujours la valeur de la variable est passée à la `ref` paramètre (`ByRef` en Visual Basic) `lockTaken`, même si la méthode lève une exception, afin que la valeur de la variable de façon fiable pour déterminer si le verrou doit être publié.  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’entrée de <paramref name="lockTaken" /> est <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel acquérir le verrou.</param>
        <param name="millisecondsTimeout">Délai d'attente du verrou en millisecondes.</param>
        <summary>Tentatives d'acquisition d'un verrou exclusif sur l'objet spécifié au cours du nombre spécifié de millisecondes.</summary>
        <returns><see langword="true" /> si le thread actuel acquiert le verrou ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `millisecondsTimeout` paramètre est égal à <xref:System.Threading.Timeout.Infinite>, cette méthode équivaut à <xref:System.Threading.Monitor.Enter%2A>. Si `millisecondsTimeout` est égal à 0, cette méthode équivaut à <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  <xref:System.Threading.Monitor> verrouille des objets (c'est-à-dire des types référence), mais pas des types valeur. Pour plus d'informations, consultez la propriété <xref:System.Threading.Monitor>.  
  
 Pour vous assurer que le thread n’entre pas de la section critique, vous devez examiner la valeur de retour et exécuter du code dans la section critique uniquement si sa valeur de retour est `true`. Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode. Notez que vous devez appeler <xref:System.Threading.Monitor.Exit%2A> dans un `finally` bloc pour vous assurer que le thread appelant libère son verrou sur la section critique si une exception se produit.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est négatif et n’est pas égal à <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel acquérir le verrou.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> représentant le délai d'attente du verrou. Une valeur de -1 milliseconde spécifie une attente infinie.</param>
        <summary>Tentatives d'acquisition d'un verrou exclusif sur l'objet spécifié au cours de la période spécifiée.</summary>
        <returns><see langword="true" /> si le thread actuel acquiert le verrou ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur de la `timeout` paramètre convertie en millisecondes est égale à -1, cette méthode équivaut à <xref:System.Threading.Monitor.Enter%2A>. Si la valeur de `timeout` est égal à 0, cette méthode équivaut à <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  <xref:System.Threading.Monitor> verrouille des objets (c'est-à-dire des types référence), mais pas des types valeur. Pour plus d'informations, consultez la classe <xref:System.Threading.Monitor>.  
  
 Pour vous assurer que le thread n’entre pas de la section critique, vous devez examiner la valeur de retour et exécuter du code dans la section critique uniquement si sa valeur de retour est `true`. Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode. Notez que vous devez appeler <xref:System.Threading.Monitor.Exit%2A> dans un `finally` bloc pour vous assurer que le thread appelant libère son verrou sur la section critique si une exception se produit.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="timeout" /> en millisecondes est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milliseconde), ou est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel acquérir le verrou.</param>
        <param name="millisecondsTimeout">Délai d'attente du verrou en millisecondes.</param>
        <param name="lockTaken">Résultat de la tentative d'acquisition du verrou, passé par la référence. L'entrée doit avoir la valeur <see langword="false" />. La sortie a la valeur <see langword="true" /> si un verrou est acquis ; sinon, elle a la valeur <see langword="false" />. La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</param>
        <summary>Tente, pendant le nombre spécifié de millisecondes, d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `millisecondsTimeout` paramètre est égal à <xref:System.Threading.Timeout.Infinite>, cette méthode équivaut à <xref:System.Threading.Monitor.Enter%28System.Object%29>. Si `millisecondsTimeout` est égal à 0, cette méthode équivaut à <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Si le verrou n’a pas été appliqué, car une exception a été levée, la variable spécifiée pour le `lockTaken` paramètre est `false` après la fin de cette méthode. Cela permet au programme déterminer, dans tous les cas, s’il est nécessaire libérer le verrou.  
  
> [!NOTE]
>  <xref:System.Threading.Monitor> verrouille des objets (c'est-à-dire des types référence), mais pas des types valeur. Pour plus d'informations, consultez la classe <xref:System.Threading.Monitor>.  
  
 Pour vous assurer que le thread n’entre pas de la section critique, vous devez examiner la valeur de `lockTaken` et exécuter du code dans la section critique uniquement si sa valeur est `true`. Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode. Notez que vous devez appeler <xref:System.Threading.Monitor.Exit%2A> dans un `finally` bloc pour vous assurer que le thread appelant libère son verrou sur la section critique si une exception se produit.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 Le code suivant montre le modèle de base pour l’utilisation de la <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> surcharge de méthode. Cette surcharge définit toujours la valeur de la variable est passée à la `ref` paramètre (`ByRef` en Visual Basic) `lockTaken`, même si la méthode lève une exception, afin que la valeur de la variable de façon fiable pour déterminer si le verrou doit être publié.  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’entrée de <paramref name="lockTaken" /> est <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est négatif et n’est pas égal à <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel acquérir le verrou.</param>
        <param name="timeout">Délai d'attente du verrou. Une valeur de -1 milliseconde spécifie une attente infinie.</param>
        <param name="lockTaken">Résultat de la tentative d'acquisition du verrou, passé par la référence. L'entrée doit avoir la valeur <see langword="false" />. La sortie a la valeur <see langword="true" /> si un verrou est acquis ; sinon, elle a la valeur <see langword="false" />. La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</param>
        <summary>Tente, pendant le délai spécifié, d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur de la `timeout` paramètre convertie en millisecondes est égale à -1, cette méthode équivaut à <xref:System.Threading.Monitor.Enter%28System.Object%29>. Si la valeur de `timeout` est égal à 0, cette méthode équivaut à <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Si le verrou n’a pas été appliqué, car une exception a été levée, la variable spécifiée pour le `lockTaken` paramètre est `false` après la fin de cette méthode. Cela permet au programme déterminer, dans tous les cas, s’il est nécessaire libérer le verrou.  
  
> [!NOTE]
>  <xref:System.Threading.Monitor> verrouille des objets (c'est-à-dire des types référence), mais pas des types valeur. Pour plus d'informations, consultez la classe <xref:System.Threading.Monitor>.  
  
 Pour vous assurer que le thread n’entre pas de la section critique, vous devez examiner la valeur de `lockTaken` et exécuter du code dans la section critique uniquement si sa valeur est `true`. Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode. Notez que vous devez appeler <xref:System.Threading.Monitor.Exit%2A> dans un `finally` bloc pour vous assurer que le thread appelant libère son verrou sur la section critique si une exception se produit.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’entrée de <paramref name="lockTaken" /> est <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="timeout" /> en millisecondes est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milliseconde), ou est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel attendre.</param>
        <summary>Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</summary>
        <returns><see langword="true" /> si l'appel est retourné parce que l'appelant a de nouveau acquis le verrou pour l'objet spécifié. Cette méthode ne retourne rien si le verrou n'est pas acquis à nouveau.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode afin de libérer l’objet afin qu’un autre thread peut y accéder. L’appelant est bloqué en attendant d’acquérir le verrou. Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.  
  
 Lorsqu’un thread appelle `Wait`, il libère le verrou sur l’objet et passe la file d’attente de l’objet. Le thread suivant dans la file d’attente opérationnelle de l’objet (le cas échéant) acquiert le verrou et a l’usage exclusif de l’objet. Tous les threads qui appellent `Wait` restent dans la file d’attente jusqu'à ce qu’ils reçoivent un signal de <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A>, envoyé par le propriétaire du verrou. Si `Pulse` est envoyé, seul le thread à la tête de la file d’attente est affecté. Si `PulseAll` est envoyé, tous les threads qui attendent l’objet sont affectées. Lorsque le signal est reçu, un ou plusieurs threads laisser la file d’attente et la file d’attente opérationnelle. Un thread dans la file d’attente opérationnelle est autorisé à réacquérir le verrou.  
  
 Cette méthode est retournée lorsque le thread appelant acquiert le verrou sur l’objet à nouveau. Notez que cette méthode se bloque indéfiniment si le détenteur du verrou n’appelle pas `Pulse` ou `PulseAll`.  
  
 L’appelant exécute `Wait` une seule fois, quel que soit le nombre de fois <xref:System.Threading.Monitor.Enter%2A> a été appelée pour l’objet spécifié. Conceptuellement, la `Wait` méthode stocke le nombre de fois que l’appelant appelé `Enter` sur l’objet et appelle `Exit` autant de fois que nécessaire pour libérer complètement l’objet verrouillé. L’appelant se bloque en attendant d’acquérir de nouveau l’objet. Lorsque l’appelant acquiert le verrou à nouveau, le système appelle `Enter` autant de fois que nécessaire pour restaurer l’enregistré `Enter` nombre pour l’appelant. Appel `Wait` libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.  
  
 Notez qu’un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient les threads qui attendent pour la notification d’un changement d’état de l’objet.  
  
 Le <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, et `Wait` méthodes doivent être appelées à partir d’un bloc de code synchronisé.  
  
 Les notes relatives à la <xref:System.Threading.Monitor.Pulse%2A> méthode expliquent ce qui se passe si <xref:System.Threading.Monitor.Pulse%2A> est appelé lorsque aucun thread n’attend.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Le thread qui appelle <see langword="Wait" /> quitte ensuite l'état d'attente. Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel attendre.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre avant que le thread intègre la file d'attente opérationnelle.</param>
        <summary>Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou. Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</summary>
        <returns><see langword="true" /> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <see langword="false" /> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié. La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne retourne pas jusqu'à ce qu’il acquière à nouveau un verrou exclusif sur la `obj` paramètre.  
  
 Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode afin de libérer l’objet afin qu’un autre thread peut y accéder. L’appelant est bloqué en attendant d’acquérir le verrou. Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.  
  
 Le délai d’expiration garantit que le thread actuel ne se bloque pas indéfiniment si un autre thread libère le verrou sans appeler d’abord la <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode). Il déplace également le thread à la file d’attente opérationnelle, en contournant les autres threads en avance dans la file d’attente, afin que d’acquérir à nouveau le verrou plus tôt. Le thread peut tester la valeur de retour de la <xref:System.Threading.Monitor.Wait%2A> méthode pour déterminer si elle a de nouveau acquis le verrou avant le délai d’expiration. Le thread peut évaluer les conditions qui a causé l’attente, et si nécessaire, appeler le <xref:System.Threading.Monitor.Wait%2A> méthode à nouveau.  
  
 Lorsqu’un thread appelle `Wait`, il libère le verrou sur l’objet et passe la file d’attente de l’objet. Le thread suivant dans la file d’attente opérationnelle de l’objet (le cas échéant) acquiert le verrou et a l’usage exclusif de l’objet. Le thread qui a appelé `Wait` appelle d’un thread qui détient le verrou reste dans la file d’attente jusqu'à ce que <xref:System.Threading.Monitor.PulseAll%2A>, ou il est le suivant dans la file d’attente et un thread qui détient le verrou appelle <xref:System.Threading.Monitor.Pulse%2A>. Toutefois, si `millisecondsTimeout` s’écoule avant qu’un autre thread appelle de cet objet <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode), le thread d’origine est déplacé vers la file d’attente opérationnelle pour récupérer le verrou.  
  
> [!NOTE]
>  Si <xref:System.Threading.Timeout.Infinite> est spécifié pour le `millisecondsTimeout` paramètre, cette méthode se bloque indéfiniment, sauf si le détenteur du verrou appelle <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A>. Si `millisecondsTimeout` est égal à 0, le thread qui appelle `Wait` libère le verrou et intègre immédiatement la file d’attente opérationnelle pour récupérer le verrou.  
  
 L’appelant exécute `Wait` une seule fois, quel que soit le nombre de fois <xref:System.Threading.Monitor.Enter%2A> a été appelée pour l’objet spécifié. Conceptuellement, la `Wait` méthode stocke le nombre de fois que l’appelant appelé <xref:System.Threading.Monitor.Enter%2A> sur l’objet et appelle <xref:System.Threading.Monitor.Exit%2A> autant de fois que nécessaire pour libérer complètement l’objet verrouillé. L’appelant se bloque en attendant d’acquérir de nouveau l’objet. Lorsque l’appelant acquiert le verrou à nouveau, le système appelle <xref:System.Threading.Monitor.Enter%2A> autant de fois que nécessaire pour restaurer l’enregistré <xref:System.Threading.Monitor.Enter%2A> nombre pour l’appelant. Appel `Wait` libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.  
  
> [!NOTE]
>  Un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient le threads qui attendent pour la notification d’un changement d’état de l’objet.  
  
 Le <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, et `Wait` méthodes doivent être appelées à partir d’un bloc de code synchronisé.  
  
 Les notes relatives à la <xref:System.Threading.Monitor.Pulse%2A> méthode expliquent ce qui se passe si <xref:System.Threading.Monitor.Pulse%2A> est appelé lorsque aucun thread n’attend.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Le thread qui appelle <see langword="Wait" /> quitte ensuite l'état d'attente. Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur du paramètre <paramref name="millisecondsTimeout" /> est négative et différente de <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel attendre.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> qui représente le temps à attendre avant que le thread n'intègre la file d'attente opérationnelle.</param>
        <summary>Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou. Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</summary>
        <returns><see langword="true" /> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <see langword="false" /> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié. La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne retourne pas jusqu'à ce qu’il acquière à nouveau un verrou exclusif sur la `obj` paramètre.  
  
 Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode afin de libérer l’objet afin qu’un autre thread peut y accéder. L’appelant est bloqué en attendant d’acquérir le verrou. Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.  
  
 Le délai d’expiration garantit que le thread actuel ne se bloque pas indéfiniment si un autre thread libère le verrou sans appeler d’abord la <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode). Il déplace également le thread à la file d’attente opérationnelle, en contournant les autres threads en avance dans la file d’attente, afin que d’acquérir à nouveau le verrou plus tôt. Le thread peut tester la valeur de retour de la <xref:System.Threading.Monitor.Wait%2A> méthode pour déterminer si elle a de nouveau acquis le verrou avant le délai d’expiration. Le thread peut évaluer les conditions qui a causé l’attente, et si nécessaire, appeler le <xref:System.Threading.Monitor.Wait%2A> méthode à nouveau.  
  
 Lorsqu’un thread appelle `Wait`, il libère le verrou sur l’objet et passe la file d’attente de l’objet. Le thread suivant dans la file d’attente opérationnelle de l’objet (le cas échéant) acquiert le verrou et a l’usage exclusif de l’objet. Le thread qui a appelé `Wait` appelle d’un thread qui détient le verrou reste dans la file d’attente jusqu'à ce que <xref:System.Threading.Monitor.PulseAll%2A>, ou il est le suivant dans la file d’attente et un thread qui détient le verrou appelle <xref:System.Threading.Monitor.Pulse%2A>. Toutefois, si `timeout` s’écoule avant qu’un autre thread appelle de cet objet <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode), le thread d’origine est déplacé vers la file d’attente opérationnelle pour récupérer le verrou.  
  
> [!NOTE]
>  Si un <xref:System.TimeSpan> représentant-1 milliseconde est spécifié pour le `timeout` paramètre, cette méthode se bloque indéfiniment, sauf si le détenteur du verrou appelle <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A>. Si `timeout` est 0 milliseconde, le thread qui appelle `Wait` libère le verrou et intègre immédiatement la file d’attente opérationnelle pour récupérer le verrou.  
  
 L’appelant exécute `Wait` une seule fois, quel que soit le nombre de fois <xref:System.Threading.Monitor.Enter%2A> a été appelée pour l’objet spécifié. Conceptuellement, la `Wait` méthode stocke le nombre de fois que l’appelant appelé <xref:System.Threading.Monitor.Enter%2A> sur l’objet et appelle <xref:System.Threading.Monitor.Exit%2A> autant de fois que nécessaire pour libérer complètement l’objet verrouillé. L’appelant se bloque en attendant d’acquérir de nouveau l’objet. Lorsque l’appelant acquiert le verrou à nouveau, le système appelle <xref:System.Threading.Monitor.Enter%2A> autant de fois que nécessaire pour restaurer l’enregistré <xref:System.Threading.Monitor.Enter%2A> nombre pour l’appelant. Appel `Wait` libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.  
  
> [!NOTE]
>  Un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient le threads qui attendent pour la notification d’un changement d’état de l’objet.  
  
 Le <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, et `Wait` méthodes doivent être appelées à partir d’un bloc de code synchronisé.  
  
 Les notes relatives à la <xref:System.Threading.Monitor.Pulse%2A> méthode expliquent ce qui se passe si <xref:System.Threading.Monitor.Pulse%2A> est appelé lorsque aucun thread n’attend.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Le thread qui appelle <see langword="Wait" /> quitte ensuite l'état d'attente. Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur en millisecondes du paramètre <paramref name="timeout" /> est négative et ne représente pas <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milliseconde) ou est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel attendre.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre avant que le thread intègre la file d'attente opérationnelle.</param>
        <param name="exitContext"><see langword="true" /> pour abandonner et acquérir à nouveau le domaine de synchronisation associé au contexte (dans le cas d'un contexte synchronisé) avant l'attente ; sinon, <see langword="false" />.</param>
        <summary>Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou. Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle. Cette méthode spécifie également si le domaine de synchronisation associé au contexte (dans le cas d’un contexte synchronisé) est abandonné avant l’attente et acquis à nouveau par la suite.</summary>
        <returns><see langword="true" /> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <see langword="false" /> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié. La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne retourne pas jusqu'à ce qu’il acquière à nouveau un verrou exclusif sur la `obj` paramètre.  
  
 Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode afin de libérer l’objet afin qu’un autre thread peut y accéder. L’appelant est bloqué en attendant d’acquérir le verrou. Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.  
  
 Le délai d’expiration garantit que le thread actuel ne se bloque pas indéfiniment si un autre thread libère le verrou sans appeler d’abord la <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode). Il déplace également le thread à la file d’attente opérationnelle, en contournant les autres threads en avance dans la file d’attente, afin que d’acquérir à nouveau le verrou plus tôt. Le thread peut tester la valeur de retour de la <xref:System.Threading.Monitor.Wait%2A> méthode pour déterminer si elle a de nouveau acquis le verrou avant le délai d’expiration. Le thread peut évaluer les conditions qui a causé l’attente, et si nécessaire, appeler le <xref:System.Threading.Monitor.Wait%2A> méthode à nouveau.  
  
 Lorsqu’un thread appelle `Wait`, il libère le verrou et intègre la file d’attente en attente. À ce stade, le thread suivant dans la file d’attente opérationnelle (le cas échéant) est autorisé à prendre le contrôle du verrou. Le thread qui a appelé `Wait` appelle d’un thread qui détient le verrou reste dans la file d’attente jusqu'à ce que <xref:System.Threading.Monitor.PulseAll%2A>, ou il est le suivant dans la file d’attente et un thread qui détient le verrou appelle <xref:System.Threading.Monitor.Pulse%2A>. Toutefois, si `millisecondsTimeout` s’écoule avant qu’un autre thread appelle de cet objet <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode), le thread d’origine est déplacé vers la file d’attente opérationnelle pour récupérer le verrou.  
  
> [!NOTE]
>  Si <xref:System.Threading.Timeout.Infinite> est spécifié pour le `millisecondsTimeout` paramètre, cette méthode se bloque indéfiniment, sauf si le détenteur du verrou appelle <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A>. Si `millisecondsTimeout` est égal à 0, le thread qui appelle `Wait` libère le verrou et intègre immédiatement la file d’attente opérationnelle pour récupérer le verrou.  
  
 L’appelant exécute `Wait` une seule fois, quel que soit le nombre de fois <xref:System.Threading.Monitor.Enter%2A> a été appelée pour l’objet spécifié. Conceptuellement, la `Wait` méthode stocke le nombre de fois que l’appelant appelé <xref:System.Threading.Monitor.Enter%2A> sur l’objet et appelle <xref:System.Threading.Monitor.Exit%2A> autant de fois que nécessaire pour libérer complètement l’objet verrouillé. L’appelant se bloque en attendant d’acquérir de nouveau l’objet. Lorsque l’appelant acquiert le verrou à nouveau, le système appelle <xref:System.Threading.Monitor.Enter%2A> autant de fois que nécessaire pour restaurer l’enregistré <xref:System.Threading.Monitor.Enter%2A> nombre pour l’appelant. Appel `Wait` libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.  
  
> [!NOTE]
>  Un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient le threads qui attendent pour la notification d’un changement d’état de l’objet.  
  
 Le <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, et `Wait` méthodes doivent être appelées à partir d’un bloc de code synchronisé.  
  
 Les notes relatives à la <xref:System.Threading.Monitor.Pulse%2A> méthode expliquent ce qui se passe si <xref:System.Threading.Monitor.Pulse%2A> est appelé lorsque aucun thread n’attend.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le`exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.Monitor.Wait%2A> méthode est appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.Monitor.Wait%2A> (méthode). Il retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.Monitor.Wait%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte comporte la <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribut appliqué. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.Monitor.Wait%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque le <xref:System.Threading.Monitor.Wait%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> n’est pas appelé à partir d’un bloc de code synchronisé.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Le thread qui appelle <see langword="Wait" /> quitte ensuite l'état d'attente. Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur du paramètre <paramref name="millisecondsTimeout" /> est négative et différente de <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel attendre.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> qui représente le temps à attendre avant que le thread n'intègre la file d'attente opérationnelle.</param>
        <param name="exitContext"><see langword="true" /> pour abandonner et acquérir à nouveau le domaine de synchronisation associé au contexte (dans le cas d'un contexte synchronisé) avant l'attente ; sinon, <see langword="false" />.</param>
        <summary>Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou. Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle. Le domaine de synchronisation associé au contexte synchronisé peut être abandonné avant l’attente et acquis de nouveau par la suite.</summary>
        <returns><see langword="true" /> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <see langword="false" /> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié. La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne retourne pas jusqu'à ce qu’il acquière à nouveau un verrou exclusif sur la `obj` paramètre.  
  
 Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode afin de libérer l’objet afin qu’un autre thread peut y accéder. L’appelant est bloqué en attendant d’acquérir le verrou. Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.  
  
 Le délai d’expiration garantit que le thread actuel ne se bloque pas indéfiniment si un autre thread libère le verrou sans appeler d’abord la <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode). Il déplace également le thread à la file d’attente opérationnelle, en contournant les autres threads en avance dans la file d’attente, afin que d’acquérir à nouveau le verrou plus tôt. Le thread peut tester la valeur de retour de la <xref:System.Threading.Monitor.Wait%2A> méthode pour déterminer si elle a de nouveau acquis le verrou avant le délai d’expiration. Le thread peut évaluer les conditions qui a causé l’attente, et si nécessaire, appeler le <xref:System.Threading.Monitor.Wait%2A> méthode à nouveau.  
  
 Lorsqu’un thread appelle `Wait`, il libère le verrou et intègre la file d’attente en attente. À ce stade, le thread suivant dans la file d’attente opérationnelle (le cas échéant) est autorisé à prendre le contrôle du verrou. Le thread qui a appelé `Wait` appelle d’un thread qui détient le verrou reste dans la file d’attente jusqu'à ce que <xref:System.Threading.Monitor.PulseAll%2A>, ou il est le suivant dans la file d’attente et un thread qui détient le verrou appelle <xref:System.Threading.Monitor.Pulse%2A>. Toutefois, si `timeout` millisecondes écoulent avant un autre thread appelle de cet objet <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode), le thread d’origine est déplacé vers la file d’attente opérationnelle pour récupérer le verrou.  
  
> [!NOTE]
>  Si un <xref:System.TimeSpan> représentant-1 milliseconde est spécifié pour le `timeout` paramètre, cette méthode se bloque indéfiniment, sauf si le détenteur du verrou appelle <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A>. Si `timeout` est 0 milliseconde, le thread qui appelle `Wait` libère le verrou et intègre immédiatement la file d’attente opérationnelle pour récupérer le verrou.  
  
 L’appelant exécute `Wait` une seule fois, quel que soit le nombre de fois <xref:System.Threading.Monitor.Enter%2A> a été appelée pour l’objet spécifié. Conceptuellement, la `Wait` méthode stocke le nombre de fois que l’appelant appelé <xref:System.Threading.Monitor.Enter%2A> sur l’objet et appelle <xref:System.Threading.Monitor.Exit%2A> autant de fois que nécessaire pour libérer complètement l’objet verrouillé. L’appelant se bloque en attendant d’acquérir de nouveau l’objet. Lorsque l’appelant acquiert le verrou à nouveau, le système appelle <xref:System.Threading.Monitor.Enter%2A> autant de fois que nécessaire pour restaurer l’enregistré <xref:System.Threading.Monitor.Enter%2A> nombre pour l’appelant. Appel `Wait` libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.  
  
> [!NOTE]
>  Un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient le threads qui attendent pour la notification d’un changement d’état de l’objet.  
  
 Le <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, et `Wait` méthodes doivent être appelées à partir d’un bloc de code synchronisé.  
  
 Les notes relatives à la <xref:System.Threading.Monitor.Pulse%2A> méthode expliquent ce qui se passe si <xref:System.Threading.Monitor.Pulse%2A> est appelé lorsque aucun thread n’attend.  
  
## <a name="notes-on-exiting-the-context"></a>Remarques sur la sortie de contexte  
 Le`exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.Monitor.Wait%2A> méthode est appelée à partir d’un contexte managé non défini par défaut. Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>. Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.  
  
 Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.Monitor.Wait%2A> (méthode). Il retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.Monitor.Wait%2A> méthode se termine.  
  
 Cela peut être utile lorsque la classe liée au contexte comporte la <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribut appliqué. Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe. Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.Monitor.Wait%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer. Lorsque le <xref:System.Threading.Monitor.Wait%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> n’est pas appelé à partir d’un bloc de code synchronisé.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Le thread qui appelle Wait quitte ensuite l’état d’attente. Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="timeout" /> est négatif et ne représente pas <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milliseconde), ou est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Threading managé</related>
      </Docs>
    </Member>
  </Members>
</Type>