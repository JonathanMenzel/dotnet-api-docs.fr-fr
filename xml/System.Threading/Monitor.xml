<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="df70f7cc62e1ef013835d69cf0220d9e8b42bc5a" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48729798" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="f038c-101">Fournit un mécanisme qui synchronise l'accès aux objets.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f038c-101">Provides a mechanism that synchronizes access to objects.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-102">Le <xref:System.Threading.Monitor> classe permet de synchroniser l’accès à une région de code en prenant et en libérant un verrou sur un objet particulier en appelant le <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, et <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="f038c-102">The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="f038c-103">Les verrous d’objets permettent de restreindre l’accès à un bloc de code, généralement appelé une section critique.</span><span class="sxs-lookup"><span data-stu-id="f038c-103">Object locks provide the ability to restrict access to a block of code, commonly called a critical section.</span></span> <span data-ttu-id="f038c-104">Pendant un thread possède le verrou d’un objet, aucun autre thread ne peut acquérir ce verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-104">While a thread owns the lock for an object, no other thread can acquire that lock.</span></span> <span data-ttu-id="f038c-105">Vous pouvez également utiliser le <xref:System.Threading.Monitor> classe pour vous assurer qu’aucun autre thread n’est autorisé à accéder à une section de l’application de code en cours d’exécution par le propriétaire du verrou, sauf si l’autre thread exécute le code à l’aide d’un autre objet verrouillé.</span><span class="sxs-lookup"><span data-stu-id="f038c-105">You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</span></span>  
  
 <span data-ttu-id="f038c-106">Dans cet article :</span><span class="sxs-lookup"><span data-stu-id="f038c-106">In this article:</span></span>  
  
 <span data-ttu-id="f038c-107">[La classe Monitor : une vue d’ensemble](#Overview) </span><span class="sxs-lookup"><span data-stu-id="f038c-107">[The Monitor class: An overview](#Overview) </span></span>  
 <span data-ttu-id="f038c-108">[L’objet de verrouillage](#Lock) </span><span class="sxs-lookup"><span data-stu-id="f038c-108">[The lock object](#Lock) </span></span>  
 <span data-ttu-id="f038c-109">[La section critique](#CriticalSection) </span><span class="sxs-lookup"><span data-stu-id="f038c-109">[The critical section](#CriticalSection) </span></span>  
 <span data-ttu-id="f038c-110">[Wait, Pulse et PulseAll](#Pulse) </span><span class="sxs-lookup"><span data-stu-id="f038c-110">[Pulse, PulseAll, and Wait](#Pulse) </span></span>  
 [<span data-ttu-id="f038c-111">Moniteurs et les handles d’attente</span><span class="sxs-lookup"><span data-stu-id="f038c-111">Monitors and wait handles</span></span>](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a><span data-ttu-id="f038c-112">La classe Monitor : une vue d’ensemble</span><span class="sxs-lookup"><span data-stu-id="f038c-112">The Monitor class: An overview</span></span>  
 <span data-ttu-id="f038c-113"><xref:System.Threading.Monitor> présente les caractéristiques suivantes :</span><span class="sxs-lookup"><span data-stu-id="f038c-113"><xref:System.Threading.Monitor> has the following features:</span></span>  
  
-   <span data-ttu-id="f038c-114">Il est associé à un objet à la demande.</span><span class="sxs-lookup"><span data-stu-id="f038c-114">It is associated with an object on demand.</span></span>  
  
-   <span data-ttu-id="f038c-115">Il est indépendant, ce qui signifie qu’elle peut être appelée directement à partir de n’importe quel contexte.</span><span class="sxs-lookup"><span data-stu-id="f038c-115">It is unbound, which means it can be called directly from any context.</span></span>  
  
-   <span data-ttu-id="f038c-116">Une instance de la <xref:System.Threading.Monitor> classe ne peut pas être créée ; les méthodes de la <xref:System.Threading.Monitor> classe sont tous statiques.</span><span class="sxs-lookup"><span data-stu-id="f038c-116">An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static.</span></span> <span data-ttu-id="f038c-117">Chaque méthode est passée à l’objet synchronisé qui contrôle l’accès à la section critique.</span><span class="sxs-lookup"><span data-stu-id="f038c-117">Each method is passed the synchronized object that controls access to the critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-118">Utilisez le <xref:System.Threading.Monitor> classe pour verrouiller les objets autres que des chaînes (autrement dit, les types référence autres que <xref:System.String>), pas des types valeur.</span><span class="sxs-lookup"><span data-stu-id="f038c-118">Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types.</span></span> <span data-ttu-id="f038c-119">Pour plus d’informations, consultez les surcharges de la <xref:System.Threading.Monitor.Enter%2A> (méthode) et [l’objet verrou](#Lock) section plus loin dans cet article.</span><span class="sxs-lookup"><span data-stu-id="f038c-119">For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.</span></span>  
  
 <span data-ttu-id="f038c-120">Le tableau suivant décrit les actions qui peuvent être effectuées par les threads qui accèdent à des objets synchronisés :</span><span class="sxs-lookup"><span data-stu-id="f038c-120">The following table describes the actions that can be taken by threads that access synchronized objects:</span></span>  
  
|<span data-ttu-id="f038c-121">Action</span><span class="sxs-lookup"><span data-stu-id="f038c-121">Action</span></span>|<span data-ttu-id="f038c-122">Description </span><span class="sxs-lookup"><span data-stu-id="f038c-122">Description</span></span>|  
|------------|-----------------|  
|<span data-ttu-id="f038c-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span><span class="sxs-lookup"><span data-stu-id="f038c-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span></span>|<span data-ttu-id="f038c-124">Acquiert un verrou pour un objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-124">Acquires a lock for an object.</span></span> <span data-ttu-id="f038c-125">Cette action marque également le début d’une section critique.</span><span class="sxs-lookup"><span data-stu-id="f038c-125">This action also marks the beginning of a critical section.</span></span> <span data-ttu-id="f038c-126">Aucun autre thread ne peut entrer la section critique, sauf si elle s’exécute les instructions dans la section critique à l’aide d’un autre objet verrouillé.</span><span class="sxs-lookup"><span data-stu-id="f038c-126">No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.</span></span>|  
|<xref:System.Threading.Monitor.Wait%2A>|<span data-ttu-id="f038c-127">Libère le verrou sur un objet afin de permettre d’autres threads pour verrouiller et accéder à l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-127">Releases the lock on an object in order to permit other threads to lock and access the object.</span></span> <span data-ttu-id="f038c-128">Le thread appelant attend qu’un autre thread accède à l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-128">The calling thread waits while another thread accesses the object.</span></span> <span data-ttu-id="f038c-129">Signaux d’impulsion sont utilisés pour informer les threads en attente sur les modifications apportées à un état d’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-129">Pulse signals are used to notify waiting threads about changes to an object's state.</span></span>|  
|<span data-ttu-id="f038c-130"><xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A></span><span class="sxs-lookup"><span data-stu-id="f038c-130"><xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A></span></span>|<span data-ttu-id="f038c-131">Envoie un signal à un ou plusieurs threads en attente.</span><span class="sxs-lookup"><span data-stu-id="f038c-131">Sends a signal to one or more waiting threads.</span></span> <span data-ttu-id="f038c-132">Le signal avertit un thread en attente que l’état de l’objet verrouillé a changé, et le propriétaire du verrou est prêt à libérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-132">The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.</span></span> <span data-ttu-id="f038c-133">Le thread en attente est placé dans la file d’attente opérationnelle de l’objet afin qu’il peut finir par recevoir le verrou pour l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-133">The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.</span></span> <span data-ttu-id="f038c-134">Une fois que le thread dispose le verrou, il peut vérifier le nouvel état de l’objet pour voir si l’état requis a été atteint.</span><span class="sxs-lookup"><span data-stu-id="f038c-134">Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.</span></span>|  
|<xref:System.Threading.Monitor.Exit%2A>|<span data-ttu-id="f038c-135">Libère le verrou sur un objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-135">Releases the lock on an object.</span></span> <span data-ttu-id="f038c-136">Cette action marque également la fin d’une section critique protégée par l’objet verrouillé.</span><span class="sxs-lookup"><span data-stu-id="f038c-136">This action also marks the end of a critical section protected by the locked object.</span></span>|  
  
 <span data-ttu-id="f038c-137">Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il existe deux ensembles de surcharges pour les <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.TryEnter%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="f038c-137">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods.</span></span> <span data-ttu-id="f038c-138">Un ensemble de surcharges a un `ref` (en c#) ou `ByRef` (en Visual Basic) <xref:System.Boolean> paramètre qui est défini atomiquement sur `true` si le verrou est acquis, même si une exception est levée lors de l’acquisition du verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-138">One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock.</span></span> <span data-ttu-id="f038c-139">Utilisez ces surcharges s’il est essentiel pour libérer le verrou dans tous les cas, même lorsque les ressources que protège le verrou ne peuvent pas être dans un état cohérent.</span><span class="sxs-lookup"><span data-stu-id="f038c-139">Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.</span></span>  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a><span data-ttu-id="f038c-140">L’objet de verrouillage</span><span class="sxs-lookup"><span data-stu-id="f038c-140">The lock object</span></span>  
 <span data-ttu-id="f038c-141">La classe Monitor se compose de `static` (en c#) ou `Shared` (en Visual Basic) méthodes qui opèrent sur un objet qui contrôle l’accès à la section critique.</span><span class="sxs-lookup"><span data-stu-id="f038c-141">The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section.</span></span>  <span data-ttu-id="f038c-142">Les informations suivantes sont conservées pour chaque objet synchronisé :</span><span class="sxs-lookup"><span data-stu-id="f038c-142">The following information is maintained for each synchronized object:</span></span>  
  
-   <span data-ttu-id="f038c-143">Une référence au thread qui détient actuellement le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-143">A reference to the thread that currently holds the lock.</span></span>  
  
-   <span data-ttu-id="f038c-144">Une référence à une file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-144">A reference to a ready queue, which contains the threads that are ready to obtain the lock.</span></span>  
  
-   <span data-ttu-id="f038c-145">Une référence à une file d’attente, qui contient les threads qui attendent pour la notification d’un changement de l’état de l’objet verrouillé.</span><span class="sxs-lookup"><span data-stu-id="f038c-145">A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</span></span>  
  
 <span data-ttu-id="f038c-146"><xref:System.Threading.Monitor> verrouille des objets (c'est-à-dire des types référence), mais pas des types valeur.</span><span class="sxs-lookup"><span data-stu-id="f038c-146"><xref:System.Threading.Monitor> locks objects (that is, reference types), not value types.</span></span> <span data-ttu-id="f038c-147">Il est possible de passer un type valeur à <xref:System.Threading.Monitor.Enter%2A> et à <xref:System.Threading.Monitor.Exit%2A>, mais il est converti (boxed) séparément pour chaque appel.</span><span class="sxs-lookup"><span data-stu-id="f038c-147">While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call.</span></span> <span data-ttu-id="f038c-148">Étant donné que chaque appel crée un objet distinct, <xref:System.Threading.Monitor.Enter%2A> n'est jamais bloqué, et le code qu'il est censé protéger n'est pas correctement synchronisé.</span><span class="sxs-lookup"><span data-stu-id="f038c-148">Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized.</span></span> <span data-ttu-id="f038c-149">Comme l'objet passé à <xref:System.Threading.Monitor.Exit%2A> est en plus différent de l'objet passé à <xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor> lève l'exception <xref:System.Threading.SynchronizationLockException> avec le message suivant : « La méthode de synchronisation de l'objet a été appelée à partir d'un bloc de code non synchronisé ».</span><span class="sxs-lookup"><span data-stu-id="f038c-149">In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message "Object synchronization method was called from an unsynchronized block of code."</span></span>  
  
 <span data-ttu-id="f038c-150">L'exemple de code suivant illustre ce problème.</span><span class="sxs-lookup"><span data-stu-id="f038c-150">The following example illustrates this problem.</span></span> <span data-ttu-id="f038c-151">Il lance dix tâches, chacune d'elles restant en veille pendant 250 millisecondes seulement.</span><span class="sxs-lookup"><span data-stu-id="f038c-151">It launches ten tasks, each of which just sleeps for 250 milliseconds.</span></span> <span data-ttu-id="f038c-152">Ensuite, chaque tâche met à jour une variable de compteur, `nTasks`, qui sert à compter le nombre de tâches ayant été lancées et exécutées.</span><span class="sxs-lookup"><span data-stu-id="f038c-152">Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed.</span></span> <span data-ttu-id="f038c-153">`nTasks` est une variable globale qui peut être modifiée par plusieurs tâches simultanément. Pour empêcher cela, un gestionnaire (monitor) est utilisé.</span><span class="sxs-lookup"><span data-stu-id="f038c-153">Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.</span></span> <span data-ttu-id="f038c-154">Toutefois, chaque tâche lève une exception <xref:System.Threading.SynchronizationLockException>, comme le montre le résultat de l'exemple.</span><span class="sxs-lookup"><span data-stu-id="f038c-154">However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 <span data-ttu-id="f038c-155">Chaque tâche lève une exception <xref:System.Threading.SynchronizationLockException>, car la variable `nTasks` est convertie (boxed) avant l'appel à la méthode <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> dans chaque tâche.</span><span class="sxs-lookup"><span data-stu-id="f038c-155">Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method in each task.</span></span> <span data-ttu-id="f038c-156">En d'autres termes, chaque appel de méthode est passé à une variable distincte, qui est indépendante des autres variables.</span><span class="sxs-lookup"><span data-stu-id="f038c-156">In other words, each method call is passed a separate variable that is independent of the others.</span></span> <span data-ttu-id="f038c-157">`nTasks` est de nouveau convertie (boxed) dans l'appel à la méthode <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f038c-157">`nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f038c-158">Cette opération crée encore dix variables boxed qui sont indépendantes les unes des autres, `nTasks`, et les dix variables boxed dans l'appel à la méthode <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f038c-158">Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f038c-159">L'exception est levée, car le code tente de libérer un verrou sur une nouvelle variable qui n'était pas précédemment verrouillée.</span><span class="sxs-lookup"><span data-stu-id="f038c-159">The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.</span></span>  
  
 <span data-ttu-id="f038c-160">Vous pouvez convertir (box) une variable de type valeur avant d'appeler <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A>, comme dans l'exemple suivant, et passer le même objet boxed aux deux méthodes, mais cette opération n'offre aucun avantage.</span><span class="sxs-lookup"><span data-stu-id="f038c-160">Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.</span></span> <span data-ttu-id="f038c-161">En effet, les modifications apportées à la variable non convertie (unboxed) ne sont pas répercutées dans la copie convertie (boxed), et il n'est pas possible de modifier la valeur de cette copie.</span><span class="sxs-lookup"><span data-stu-id="f038c-161">Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 <span data-ttu-id="f038c-162">Lorsque vous sélectionnez un objet sur lequel effectuer la synchronisation, vous devez verrouiller l’uniquement sur les objets privés ou internes.</span><span class="sxs-lookup"><span data-stu-id="f038c-162">When selecting an object on which to synchronize, you should lock only on private or internal objects.</span></span> <span data-ttu-id="f038c-163">Verrouillage d’objets externes peut entraîner des blocages, étant donné que le code non lié peut choisir les mêmes verrouiller objets à des fins différentes.</span><span class="sxs-lookup"><span data-stu-id="f038c-163">Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</span></span>  
  
 <span data-ttu-id="f038c-164">Notez que vous pouvez synchroniser sur un objet dans plusieurs domaines d’application si l’objet utilisé comme verrou dérive <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="f038c-164">Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a><span data-ttu-id="f038c-165">La section critique</span><span class="sxs-lookup"><span data-stu-id="f038c-165">The critical section</span></span>  
 <span data-ttu-id="f038c-166">Utilisez le <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A> méthodes pour marquer le début et la fin d’une section critique.</span><span class="sxs-lookup"><span data-stu-id="f038c-166">Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-167">La fonctionnalité fournie par le <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A> méthodes est identique à celle fournie par le [verrou](~/docs/csharp/language-reference/keywords/lock-statement.md) instruction en langage c# et le [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) instruction en Visual Basic, à ceci près que le constructions de langage de type wrap le <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> surcharge de méthode et la <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> méthode dans un `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="f038c-167">The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method in a `try`…`finally`</span></span> <span data-ttu-id="f038c-168">bloc pour garantir que la libération du moniteur.</span><span class="sxs-lookup"><span data-stu-id="f038c-168">block to ensure that the monitor is released.</span></span>  
  
 <span data-ttu-id="f038c-169">Si la section critique est un ensemble d’instructions contiguës, puis le verrou acquis par la <xref:System.Threading.Monitor.Enter%2A> méthode ne garantit qu’un seul thread peut exécuter le code délimité avec l’objet verrouillé.</span><span class="sxs-lookup"><span data-stu-id="f038c-169">If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object.</span></span> <span data-ttu-id="f038c-170">Dans ce cas, nous vous recommandons de placer ce code dans un `try` bloquer et placer l’appel à la <xref:System.Threading.Monitor.Exit%2A> méthode dans un `finally` bloc.</span><span class="sxs-lookup"><span data-stu-id="f038c-170">In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block.</span></span> <span data-ttu-id="f038c-171">Cela garantit la libération du verrou même si une exception se produit.</span><span class="sxs-lookup"><span data-stu-id="f038c-171">This ensures that the lock is released even if an exception occurs.</span></span> <span data-ttu-id="f038c-172">Le fragment de code suivant illustre ce modèle.</span><span class="sxs-lookup"><span data-stu-id="f038c-172">The following code fragment illustrates this pattern.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 <span data-ttu-id="f038c-173">Cette fonctionnalité est généralement utilisée pour synchroniser l’accès à un mappage statique ou méthode d’instance d’une classe.</span><span class="sxs-lookup"><span data-stu-id="f038c-173">This facility is typically used to synchronize access to a static or instance method of a class.</span></span>  
  
 <span data-ttu-id="f038c-174">Si une section critique s’étend sur l’ensemble d’une méthode, l’outil de verrouillage peut être obtenue en plaçant le <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> sur la méthode et en spécifiant le <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> valeur dans le constructeur de <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f038c-174">If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f038c-175">Lorsque vous utilisez cet attribut, le <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A> les appels de méthode ne sont pas nécessaires.</span><span class="sxs-lookup"><span data-stu-id="f038c-175">When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed.</span></span> <span data-ttu-id="f038c-176">Le fragment de code suivant illustre ce modèle :</span><span class="sxs-lookup"><span data-stu-id="f038c-176">The following code fragment illustrates this pattern:</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 <span data-ttu-id="f038c-177">Notez que l’attribut oblige le thread actuel détient le verrou jusqu'à ce que la méthode est retournée ; Si le verrou peut être libéré plus tôt, utilisez la <xref:System.Threading.Monitor> classe c# [verrou](~/docs/csharp/language-reference/keywords/lock-statement.md) instruction ou Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) instruction à l’intérieur de la méthode au lieu de l’attribut.</span><span class="sxs-lookup"><span data-stu-id="f038c-177">Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <xref:System.Threading.Monitor> class, the C# [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement, or the Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement inside of the method instead of the attribute.</span></span>  
  
 <span data-ttu-id="f038c-178">S’il est possible pour le <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A> les instructions qui verrouillent et libèrent un objet donné à l’intersection des membres ou les limites de classe ou les deux, cette pratique n’est pas recommandée.</span><span class="sxs-lookup"><span data-stu-id="f038c-178">While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</span></span>  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a><span data-ttu-id="f038c-179">Wait, Pulse et PulseAll</span><span class="sxs-lookup"><span data-stu-id="f038c-179">Pulse, PulseAll, and Wait</span></span>  
 <span data-ttu-id="f038c-180">Une fois un thread possède le verrou et a entré dans la section critique qui protège le verrou, elle peut appeler le <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, et <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="f038c-180">Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="f038c-181">Lorsque le thread qui détient les appels de verrou <xref:System.Threading.Monitor.Wait%2A>, le verrou est libéré et que le thread est ajouté à la file d’attente de l’objet synchronisé.</span><span class="sxs-lookup"><span data-stu-id="f038c-181">When the thread that holds the lock calls <xref:System.Threading.Monitor.Wait%2A>, the lock is released and the thread is added to the waiting queue of the synchronized object.</span></span> <span data-ttu-id="f038c-182">Le premier thread dans la file d’attente opérationnelle, le cas échéant, acquiert le verrou et entre dans la section critique.</span><span class="sxs-lookup"><span data-stu-id="f038c-182">The first thread in the ready queue, if any, acquires the lock and enters the critical section.</span></span> <span data-ttu-id="f038c-183">Le thread est déplacé à partir de la file d’attente vers la file d’attente opérationnelle lorsque soit la <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> (pour être déplacée, le thread doit être au début de la file d’attente) ou le <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> méthode est appelée par le thread qui détient le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-183">The thread is moved from the waiting queue to the ready queue when either the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> (to be moved, the thread must be at the head of the waiting queue) or the <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> method is called by the thread that holds the lock.</span></span> <span data-ttu-id="f038c-184">Le <xref:System.Threading.Monitor.Wait%2A> méthode est retournée lorsque le thread appelant acquiert le verrou à nouveau.</span><span class="sxs-lookup"><span data-stu-id="f038c-184">The <xref:System.Threading.Monitor.Wait%2A> method returns when the calling thread reacquires the lock.</span></span>  
  
 <span data-ttu-id="f038c-185">Lorsque le thread qui détient les appels de verrou <xref:System.Threading.Monitor.Pulse%2A>, le thread à la tête de la file d’attente est déplacé vers la file d’attente opérationnelle.</span><span class="sxs-lookup"><span data-stu-id="f038c-185">When the thread that holds the lock calls <xref:System.Threading.Monitor.Pulse%2A>, the thread at the head of the waiting queue is moved to the ready queue.</span></span> <span data-ttu-id="f038c-186">L’appel à la <xref:System.Threading.Monitor.PulseAll%2A> méthode déplace tous les threads à partir de la file d’attente vers la file d’attente opérationnelle.</span><span class="sxs-lookup"><span data-stu-id="f038c-186">The call to the <xref:System.Threading.Monitor.PulseAll%2A> method moves all the threads from the waiting queue to the ready queue.</span></span>  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a><span data-ttu-id="f038c-187">Moniteurs et les handles d’attente</span><span class="sxs-lookup"><span data-stu-id="f038c-187">Monitors and wait handles</span></span>  
 <span data-ttu-id="f038c-188">Il est important de noter la distinction entre l’utilisation de la <xref:System.Threading.Monitor> classe et <xref:System.Threading.WaitHandle> objets.</span><span class="sxs-lookup"><span data-stu-id="f038c-188">It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects.</span></span>  
  
-   <span data-ttu-id="f038c-189">Le <xref:System.Threading.Monitor> classe est purement managés, entièrement portables et peuvent être plus efficace en termes de besoins en ressources de système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="f038c-189">The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</span></span>  
  
-   <span data-ttu-id="f038c-190">Les objets <xref:System.Threading.WaitHandle> représentent des objets d'attente de système d'exploitation et sont utiles pour la synchronisation entre le code managé et le code non managé. Ils exposent certaines fonctionnalités avancées de système d'exploitation, comme la possibilité d'attendre plusieurs objets à la fois.</span><span class="sxs-lookup"><span data-stu-id="f038c-190"><xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f038c-191">L’exemple suivant utilise le <xref:System.Threading.Monitor> classe pour synchroniser l’accès à une seule instance d’un générateur de nombres aléatoire représenté par la <xref:System.Random> classe.</span><span class="sxs-lookup"><span data-stu-id="f038c-191">The following example uses the <xref:System.Threading.Monitor> class to synchronize access to a single instance of a random number generator represented by the <xref:System.Random> class.</span></span> <span data-ttu-id="f038c-192">L’exemple crée dix tâches, chacun d’eux exécute de façon asynchrone sur un thread de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="f038c-192">The example creates ten tasks, each of which executes asynchronously on a thread pool thread.</span></span> <span data-ttu-id="f038c-193">Chaque tâche génère des nombres aléatoires 10 000, calcule leur moyenne et met à jour les deux variables de niveau de la procédure permettant de maintenir un total en cours d’exécution du nombre de nombres aléatoires et leur somme.</span><span class="sxs-lookup"><span data-stu-id="f038c-193">Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum.</span></span> <span data-ttu-id="f038c-194">Une fois que toutes les tâches ont été exécutées, ces deux valeurs sont ensuite utilisées pour calculer la moyenne globale.</span><span class="sxs-lookup"><span data-stu-id="f038c-194">After all tasks have executed, these two values are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="f038c-195">Car ils sont accessibles à partir de n’importe quelle tâche en cours d’exécution sur un thread de pool de threads, accéder aux variables `total` et `n` doivent également être synchronisés.</span><span class="sxs-lookup"><span data-stu-id="f038c-195">Because they can be accessed from any task running on a thread pool thread, access to the variables `total` and `n` must also be synchronized.</span></span> <span data-ttu-id="f038c-196">Le <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> méthode est utilisée à cet effet.</span><span class="sxs-lookup"><span data-stu-id="f038c-196">The <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> method is used for this purpose.</span></span>  
  
 <span data-ttu-id="f038c-197">L’exemple suivant illustre l’utilisation combinée de la <xref:System.Threading.Monitor> classe (implémentée avec le `lock` ou `SyncLock` construction de langage), le <xref:System.Threading.Interlocked> (classe) et le <xref:System.Threading.AutoResetEvent> classe.</span><span class="sxs-lookup"><span data-stu-id="f038c-197">The following example demonstrates the combined use of the <xref:System.Threading.Monitor> class (implemented with the `lock` or `SyncLock` language construct), the <xref:System.Threading.Interlocked> class, and the <xref:System.Threading.AutoResetEvent> class.</span></span> <span data-ttu-id="f038c-198">Il définit deux `internal` (en c#) ou `Friend` (en Visual Basic), les classes `SyncResource` et `UnSyncResource`, qui fournissent respectivement un accès synchronisé et non synchronisé à une ressource.</span><span class="sxs-lookup"><span data-stu-id="f038c-198">It defines two `internal` (in C#) or `Friend` (in Visual Basic) classes, `SyncResource` and `UnSyncResource`, that respectively provide synchronized and unsynchronized access to a resource.</span></span> <span data-ttu-id="f038c-199">Pour vous assurer que l’exemple illustre la différence entre l’accès synchronisé et non synchronisé (ce qui serait le cas si chaque appel de méthode se termine rapidement), la méthode inclut un délai aléatoire : pour les threads dont <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> propriété est pair, le appels de méthode <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> pour introduire un délai de 2 000 millisecondes.</span><span class="sxs-lookup"><span data-stu-id="f038c-199">To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property is even, the method calls <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> to introduce a delay of 2,000 milliseconds.</span></span> <span data-ttu-id="f038c-200">Notez que, étant donné que la `SyncResource` classe n’est pas publique, le code client acquiert un verrou sur la ressource synchronisée ; la classe interne proprement dite qui acquiert le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-200">Note that, because the `SyncResource` class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock.</span></span> <span data-ttu-id="f038c-201">Cela empêche que du code malveillant acquière un verrou sur un objet public.</span><span class="sxs-lookup"><span data-stu-id="f038c-201">This prevents malicious code from taking a lock on a public object.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 <span data-ttu-id="f038c-202">L’exemple définit une variable, `numOps`, qui définit le nombre de threads qui tentera d’accéder à la ressource.</span><span class="sxs-lookup"><span data-stu-id="f038c-202">The example defines a variable, `numOps`, that defines the number of threads that will attempt to access the resource.</span></span> <span data-ttu-id="f038c-203">Le thread d’application appelle le <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> méthode pour synchronisé et non synchronisé accéder à cinq fois chacune.</span><span class="sxs-lookup"><span data-stu-id="f038c-203">The application thread calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method for synchronized and unsynchronized access five times each.</span></span> <span data-ttu-id="f038c-204">Le <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> méthode possède un seul paramètre, un délégué qui n’accepte aucun paramètre et ne retourne aucune valeur.</span><span class="sxs-lookup"><span data-stu-id="f038c-204">The <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method has a single parameter, a delegate that accepts no parameters and returns no value.</span></span> <span data-ttu-id="f038c-205">Pour l’accès synchronisé, elle appelle le `SyncUpdateResource` méthode ; pour l’accès non synchronisé, elle appelle le `UnSyncUpdateResource` (méthode).</span><span class="sxs-lookup"><span data-stu-id="f038c-205">For synchronized access, it invokes the `SyncUpdateResource` method; for unsynchronized access, it invokes the `UnSyncUpdateResource` method.</span></span> <span data-ttu-id="f038c-206">Après chaque ensemble d’appels de méthode, le thread d’application appelle le [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) méthode afin qu’elle se bloque jusqu'à ce que le <xref:System.Threading.AutoResetEvent> instance est signalée.</span><span class="sxs-lookup"><span data-stu-id="f038c-206">After each set of method calls, the application thread calls the [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) method so that it blocks until the <xref:System.Threading.AutoResetEvent> instance is signaled.</span></span>  
  
 <span data-ttu-id="f038c-207">Chaque appel à la `SyncUpdateResource` méthode appelle en interne `SyncResource.Access` (méthode), puis appelle la <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> méthode pour décrémenter le `numOps` compteur.</span><span class="sxs-lookup"><span data-stu-id="f038c-207">Each call to the `SyncUpdateResource` method calls the internal `SyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="f038c-208">Le <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> méthode est utilisée pour décrémenter le compteur, car sinon vous ne pouvez pas être certain qu’un deuxième thread accéder à la valeur avant du d’un thread de premier décrémenté valeur ayant été stockée dans la variable.</span><span class="sxs-lookup"><span data-stu-id="f038c-208">The <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable.</span></span> <span data-ttu-id="f038c-209">Lors de la dernière synchronisation décrémente de thread de travail le compteur à zéro, indiquant que tous les threads synchronisés ont terminé d’accéder à la ressource, le `SyncUpdateResource` les appels de méthode le <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> (méthode), qui signale au thread principal de continuer exécution.</span><span class="sxs-lookup"><span data-stu-id="f038c-209">When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the `SyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="f038c-210">Chaque appel à la `UnSyncUpdateResource` méthode appelle en interne `UnSyncResource.Access` (méthode), puis appelle la <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> méthode pour décrémenter le `numOps` compteur.</span><span class="sxs-lookup"><span data-stu-id="f038c-210">Each call to the `UnSyncUpdateResource` method calls the internal `UnSyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="f038c-211">Une fois encore, le <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> méthode est utilisée pour décrémenter le compteur pour vous assurer qu’un deuxième thread n’accède pas à la valeur avant valeur décrémentée d’un premier thread ait été attribuée à la variable.</span><span class="sxs-lookup"><span data-stu-id="f038c-211">Once again, the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable.</span></span> <span data-ttu-id="f038c-212">Lors de la dernière non synchronisé décrémente de thread de travail le compteur à zéro, indiquant qu’aucun autre non synchronisé threads doivent accéder à la ressource, le `UnSyncUpdateResource` les appels de méthode le <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> (méthode), qui signale le thread principal pour continuer l’exécution .</span><span class="sxs-lookup"><span data-stu-id="f038c-212">When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the `UnSyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="f038c-213">Comme le montre la sortie de l’exemple, l’accès synchronisé garantit que le thread appelant quitte la ressource protégée avant qu’un autre thread puisse y accéder ; chaque thread attend son prédécesseur.</span><span class="sxs-lookup"><span data-stu-id="f038c-213">As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor.</span></span> <span data-ttu-id="f038c-214">En revanche, sans verrou, le `UnSyncResource.Access` méthode est appelée dans l’ordre dans lequel les threads l’atteignent.</span><span class="sxs-lookup"><span data-stu-id="f038c-214">On the other hand, without the lock, the `UnSyncResource.Access` method is called in the order in which threads reach it.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="f038c-215">Ce type est thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f038c-215">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="f038c-216">Threading managé</span>
      <span class="sxs-lookup">
        <span data-stu-id="f038c-216">Managed Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">
      <span data-ttu-id="f038c-217">Fonctionnalités et objets de threading</span>
      <span class="sxs-lookup">
        <span data-stu-id="f038c-217">Threading Objects and Features</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f038c-218">Acquiert un verrou exclusif sur l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-218">Acquires an exclusive lock on a specified object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-219">Objet sur lequel acquérir le verrou du moniteur.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-219">The object on which to acquire the monitor lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-220">Acquiert un verrou exclusif sur l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-220">Acquires an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-221">Utilisez `Enter` pour acquérir le <xref:System.Threading.Monitor> sur l’objet passé comme paramètre.</span><span class="sxs-lookup"><span data-stu-id="f038c-221">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter.</span></span> <span data-ttu-id="f038c-222">Si un autre thread a exécuté une `Enter` sur l’objet, mais le n'a pas encore exécuté correspondant <xref:System.Threading.Monitor.Exit%2A>, bloque le thread actuel jusqu'à ce que l’autre thread libère l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-222">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="f038c-223">Il est autorisé pour le même thread appeler `Enter` plusieurs fois sans se bloquer ; Toutefois, un nombre égal de `Exit` appels doivent être appelées avant que les autres threads en attente sur l’objet débloque.</span><span class="sxs-lookup"><span data-stu-id="f038c-223">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="f038c-224">Utilisez <xref:System.Threading.Monitor> pour verrouiller les objets (autrement dit, les types référence), pas des types valeur.</span><span class="sxs-lookup"><span data-stu-id="f038c-224">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="f038c-225">Lorsque vous passez une variable de type valeur à `Enter`, il est converti (boxed) en tant qu’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-225">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="f038c-226">Si vous transmettez la même variable à `Enter` là encore, il est converti (boxed) en tant qu’objet distinct et le thread ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="f038c-226">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="f038c-227">Dans ce cas, le code qui `Monitor` est censé protéger n’est pas protégé.</span><span class="sxs-lookup"><span data-stu-id="f038c-227">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="f038c-228">En outre, lorsque vous passez la variable à `Exit`, toujours à un autre objet distinct est créé.</span><span class="sxs-lookup"><span data-stu-id="f038c-228">Furthermore, when you pass the variable to `Exit`, still another separate object is created.</span></span> <span data-ttu-id="f038c-229">Étant donné que l’objet passé à `Exit` est différent de l’objet passé à `Enter`, `Monitor` lève <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="f038c-229">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="f038c-230">Pour plus d’informations, consultez la rubrique conceptuelle [moniteurs](xref:System.Threading.Monitor).</span><span class="sxs-lookup"><span data-stu-id="f038c-230">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="f038c-231"><xref:System.Threading.Thread.Interrupt%2A> peut interrompre des threads qui attendent pour entrer un `Monitor` sur un objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-231"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="f038c-232">Un <xref:System.Threading.ThreadInterruptedException> sera levée.</span><span class="sxs-lookup"><span data-stu-id="f038c-232">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
 <span data-ttu-id="f038c-233">Utiliser C# `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="f038c-233">Use a C# `try`…`finally`</span></span> <span data-ttu-id="f038c-234">bloc (`Try`...`Finally`</span><span class="sxs-lookup"><span data-stu-id="f038c-234">block (`Try`…`Finally`</span></span> <span data-ttu-id="f038c-235">en Visual Basic) pour vous assurer que vous le moniteur de mise en production, ou utilisez le c# `lock` instruction (`SyncLock` instruction en Visual Basic), qui encapsule le <xref:System.Threading.Monitor.Enter%2A> et <xref:System.Threading.Monitor.Exit%2A> méthodes dans un `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="f038c-235">in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`…`finally`</span></span> <span data-ttu-id="f038c-236">bloc.</span><span class="sxs-lookup"><span data-stu-id="f038c-236">block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f038c-237">L'exemple suivant décrit comment utiliser la méthode `Enter`.</span><span class="sxs-lookup"><span data-stu-id="f038c-237">The following example demonstrates how to use the `Enter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-238">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-238">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-239">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-239">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-240">Objet sur lequel attendre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-240">The object on which to wait.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="f038c-241">Résultat de la tentative d'acquisition du verrou, passé par la référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-241">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="f038c-242">L'entrée doit avoir la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-242">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f038c-243">La sortie a la valeur <see langword="true" /> si un verrou est acquis ; sinon, elle a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-243">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f038c-244">La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-244">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
          <span data-ttu-id="f038c-245">Remarque   Si aucune exception ne se produit, la sortie de cette méthode est toujours <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-245">Note   If no exception occurs, the output of this method is always <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-246">Acquiert un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-246">Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-247">Utilisez `Enter` pour acquérir le <xref:System.Threading.Monitor> sur l’objet passé comme le `obj` paramètre.</span><span class="sxs-lookup"><span data-stu-id="f038c-247">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter.</span></span> <span data-ttu-id="f038c-248">Si un autre thread a exécuté une `Enter` sur l’objet, mais le n'a pas encore exécuté correspondant <xref:System.Threading.Monitor.Exit%2A>, bloque le thread actuel jusqu'à ce que l’autre thread libère l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-248">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="f038c-249">Il est autorisé pour le même thread appeler `Enter` plusieurs fois sans se bloquer ; Toutefois, un nombre égal de `Exit` appels doivent être appelées avant que les autres threads en attente sur l’objet débloque.</span><span class="sxs-lookup"><span data-stu-id="f038c-249">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="f038c-250">Si le verrou n’a pas été appliqué, car une exception a été levée, la variable spécifiée pour le `lockTaken` paramètre est `false` après la fin de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-250">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="f038c-251">Cela permet au programme déterminer, dans tous les cas, s’il est nécessaire libérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-251">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span> <span data-ttu-id="f038c-252">Si cette méthode retourne sans lever d’exception, la variable spécifiée pour le `lockTaken` paramètre est toujours `true`, et il n’est pas nécessaire pour le tester.</span><span class="sxs-lookup"><span data-stu-id="f038c-252">If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it.</span></span>  
  
 <span data-ttu-id="f038c-253">Utilisez <xref:System.Threading.Monitor> pour verrouiller les objets (autrement dit, les types référence), pas des types valeur.</span><span class="sxs-lookup"><span data-stu-id="f038c-253">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="f038c-254">Lorsque vous passez une variable de type valeur à `Enter`, il est converti (boxed) en tant qu’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-254">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="f038c-255">Si vous transmettez la même variable à `Enter` là encore, il est converti (boxed) en tant qu’objet distinct et le thread ne bloque pas.</span><span class="sxs-lookup"><span data-stu-id="f038c-255">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="f038c-256">Dans ce cas, le code qui `Monitor` est censé protéger n’est pas protégé.</span><span class="sxs-lookup"><span data-stu-id="f038c-256">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="f038c-257">En outre, lorsque vous passez la variable à `Exit`, un autre objet distinct est créé.</span><span class="sxs-lookup"><span data-stu-id="f038c-257">Furthermore, when you pass the variable to `Exit`, another separate object is created.</span></span> <span data-ttu-id="f038c-258">Étant donné que l’objet passé à `Exit` est différent de l’objet passé à `Enter`, `Monitor` lève <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="f038c-258">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="f038c-259">Pour plus d’informations, consultez la rubrique conceptuelle [moniteurs](xref:System.Threading.Monitor).</span><span class="sxs-lookup"><span data-stu-id="f038c-259">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="f038c-260"><xref:System.Threading.Thread.Interrupt%2A> peut interrompre des threads qui attendent pour entrer un `Monitor` sur un objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-260"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="f038c-261">Un <xref:System.Threading.ThreadInterruptedException> sera levée.</span><span class="sxs-lookup"><span data-stu-id="f038c-261">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f038c-262">Le code suivant montre le modèle de base pour l’utilisation de la <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-262">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="f038c-263">Cette surcharge définit toujours la valeur de la variable est passée à la `ref` paramètre (`ByRef` en Visual Basic) `lockTaken`, même si la méthode lève une exception, afin que la valeur de la variable de façon fiable pour déterminer si le verrou doit être publié.</span><span class="sxs-lookup"><span data-stu-id="f038c-263">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f038c-264">L’entrée de <paramref name="lockTaken" /> est <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-264">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-265">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-265">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-266">Objet sur lequel libérer le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-266">The object on which to release the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-267">Libère un verrou exclusif sur l’objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-267">Releases an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-268">Le thread appelant doit posséder le verrou sur le `obj` paramètre.</span><span class="sxs-lookup"><span data-stu-id="f038c-268">The calling thread must own the lock on the `obj` parameter.</span></span> <span data-ttu-id="f038c-269">Si le thread appelant possède le verrou sur l’objet spécifié et a effectué un nombre égal de `Exit` et <xref:System.Threading.Monitor.Enter%2A> appelle pour l’objet, puis le verrou est libéré.</span><span class="sxs-lookup"><span data-stu-id="f038c-269">If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released.</span></span> <span data-ttu-id="f038c-270">Si le thread appelant n’a pas appelé `Exit` autant de fois en tant que `Enter`, le verrou n’est pas libéré.</span><span class="sxs-lookup"><span data-stu-id="f038c-270">If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released.</span></span>  
  
 <span data-ttu-id="f038c-271">Si le verrou est libéré et d’autres threads se trouvent dans la file d’attente prêt pour l’objet, un des threads acquiert le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-271">If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.</span></span> <span data-ttu-id="f038c-272">Si d’autres threads se trouvent dans la file d’attente attend pour acquérir le verrou, ils ne sont pas déplacés automatiquement vers la file d’attente opérationnelle lorsque le propriétaire du verrou appelle `Exit`.</span><span class="sxs-lookup"><span data-stu-id="f038c-272">If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`.</span></span> <span data-ttu-id="f038c-273">Pour déplacer un ou plusieurs threads en attente dans la file d’attente opérationnelle, appelez <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> avant d’appeler `Exit`.</span><span class="sxs-lookup"><span data-stu-id="f038c-273">To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f038c-274">L'exemple suivant décrit comment utiliser la méthode `Exit`.</span><span class="sxs-lookup"><span data-stu-id="f038c-274">The following example demonstrates how to use the `Exit` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-275">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-275">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="f038c-276">Le thread en cours ne possède pas le verrou pour l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-276">The current thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-277">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-277">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-278">Objet à tester.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-278">The object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-279">Détermine si le thread actuel détient le verrou sur l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-279">Determines whether the current thread holds the lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f038c-280">
            <see langword="true" /> si le thread actuel détient le verrou sur <paramref name="obj" /> ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-280">
              <see langword="true" /> if the current thread holds the lock on <paramref name="obj" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-281">Cette méthode fonctionne uniquement pour les verrous acquis en utilisant les méthodes de la <xref:System.Threading.Monitor> classe, ou en utilisant c# `lock` instruction ou Visual Basic `SyncLock` instruction, qui sont implémentées avec <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="f038c-281">This method works only for locks that are acquired by using the methods of the <xref:System.Threading.Monitor> class, or by using the C# `lock` statement or the Visual Basic `SyncLock` statement, which are implemented with <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="f038c-282">Utilisez cette méthode avec les outils de diagnostic, comme le <xref:System.Diagnostics.Debug.Assert%2A> (méthode) et le <xref:System.Diagnostics.Contracts.Contract> (classe), pour déboguer les problèmes de verrouillage qui impliquent la <xref:System.Threading.Monitor> classe.</span><span class="sxs-lookup"><span data-stu-id="f038c-282">Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-283">
            <paramref name="obj" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-283">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-284">Objet attendu par un thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-284">The object a thread is waiting for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-285">Avertit un thread situé dans la file d'attente en suspens d'un changement d'état de l'objet verrouillé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-285">Notifies a thread in the waiting queue of a change in the locked object's state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-286">Seul le propriétaire actuel du verrou peut signaler un objet en attente à l’aide `Pulse`.</span><span class="sxs-lookup"><span data-stu-id="f038c-286">Only the current owner of the lock can signal a waiting object using `Pulse`.</span></span>  
  
 <span data-ttu-id="f038c-287">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode pour signaler au thread suivant dans la ligne du verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-287">The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.</span></span> <span data-ttu-id="f038c-288">Lors de la réception de l’impulsion, le thread en attente est déplacé vers la file d’attente opérationnelle.</span><span class="sxs-lookup"><span data-stu-id="f038c-288">Upon receiving the pulse, the waiting thread is moved to the ready queue.</span></span> <span data-ttu-id="f038c-289">Lorsque le thread qui a appelé `Pulse` libère le verrou, le thread suivant dans la file d’attente opérationnelle (qui n’est pas nécessairement le thread qui a été impulsions) acquiert le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-289">When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f038c-290">Le <xref:System.Threading.Monitor> classe ne conserve pas l’état indiquant que le <xref:System.Threading.Monitor.Pulse%2A> méthode a été appelée.</span><span class="sxs-lookup"><span data-stu-id="f038c-290">The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called.</span></span> <span data-ttu-id="f038c-291">Par conséquent, si vous appelez <xref:System.Threading.Monitor.Pulse%2A> lorsque aucun thread n’attend, le thread suivant qui appelle <xref:System.Threading.Monitor.Wait%2A> blocs comme si <xref:System.Threading.Monitor.Pulse%2A> n’avait jamais été appelée.</span><span class="sxs-lookup"><span data-stu-id="f038c-291">Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called.</span></span> <span data-ttu-id="f038c-292">Si deux threads utilisent <xref:System.Threading.Monitor.Pulse%2A> et <xref:System.Threading.Monitor.Wait%2A> pour interagir, cela peut provoquer un interblocage.</span><span class="sxs-lookup"><span data-stu-id="f038c-292">If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock.</span></span> <span data-ttu-id="f038c-293">Comparez ceci avec le comportement de la <xref:System.Threading.AutoResetEvent> classe : Si vous signalez un <xref:System.Threading.AutoResetEvent> en appelant son <xref:System.Threading.EventWaitHandle.Set%2A> (méthode) et il n’y aucun thread n’attend, le <xref:System.Threading.AutoResetEvent> reste dans un état signalé jusqu'à ce qu’un thread appelle <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, ou <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-293">Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="f038c-294">Le <xref:System.Threading.AutoResetEvent> libère ce thread et retourne à l’état non signalé.</span><span class="sxs-lookup"><span data-stu-id="f038c-294">The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.</span></span>  
  
 <span data-ttu-id="f038c-295">Notez qu’un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient les threads qui attendent pour la notification d’un changement d’état de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-295">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="f038c-296">Le `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, et <xref:System.Threading.Monitor.Wait%2A> méthodes doivent être appelées à partir d’un bloc de code synchronisé.</span><span class="sxs-lookup"><span data-stu-id="f038c-296">The `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="f038c-297">Pour signaler plusieurs threads, utilisez le <xref:System.Threading.Monitor.PulseAll%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="f038c-297">To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-298">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-298">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="f038c-299">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-299">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-300">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-300">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-301">Objet qui envoie l'impulsion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-301">The object that sends the pulse.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-302">Avertit tous les threads en attente d'un changement d'état de l'objet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-302">Notifies all waiting threads of a change in the object's state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-303">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode pour signaler tous les threads attendant d’acquérir le verrou sur l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-303">The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.</span></span> <span data-ttu-id="f038c-304">Une fois que le signal est envoyé, les threads en attente sont déplacés vers la file d’attente opérationnelle.</span><span class="sxs-lookup"><span data-stu-id="f038c-304">After the signal is sent, the waiting threads are moved to the ready queue.</span></span> <span data-ttu-id="f038c-305">Lorsque le thread qui a appelé `PulseAll` libère le verrou, le thread suivant dans la file d’attente opérationnelle acquiert le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-305">When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock.</span></span>  
  
 <span data-ttu-id="f038c-306">Notez qu’un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient les threads qui attendent pour la notification d’un changement d’état de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-306">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="f038c-307">Le <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, et <xref:System.Threading.Monitor.Wait%2A> méthodes doivent être appelées à partir d’un bloc de code synchronisé.</span><span class="sxs-lookup"><span data-stu-id="f038c-307">The <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="f038c-308">Les notes relatives à la <xref:System.Threading.Monitor.Pulse%2A> méthode expliquent ce qui se passe si <xref:System.Threading.Monitor.Pulse%2A> est appelé lorsque aucun thread n’attend.</span><span class="sxs-lookup"><span data-stu-id="f038c-308">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 <span data-ttu-id="f038c-309">Pour signaler un thread unique, utilisez le `Pulse` (méthode).</span><span class="sxs-lookup"><span data-stu-id="f038c-309">To signal a single thread, use the `Pulse` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-310">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-310">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="f038c-311">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-311">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-312">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-312">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f038c-313">Essaie d'acquérir un verrou exclusif sur l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-313">Attempts to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-314">Objet sur lequel acquérir le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-314">The object on which to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-315">Essaie d'acquérir un verrou exclusif sur l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-315">Attempts to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f038c-316">
            <see langword="true" /> si le thread actuel acquiert le verrou ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-316">
              <see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-317">Si réussie, cette méthode acquiert un verrou exclusif sur la `obj` paramètre.</span><span class="sxs-lookup"><span data-stu-id="f038c-317">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="f038c-318">Cette méthode retourne immédiatement, si le verrou est disponible ou non.</span><span class="sxs-lookup"><span data-stu-id="f038c-318">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="f038c-319">Cette méthode est similaire à <xref:System.Threading.Monitor.Enter%2A>, mais il ne se bloque jamais le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="f038c-319">This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread.</span></span> <span data-ttu-id="f038c-320">Si le thread ne peut pas entrer sans se bloquer, la méthode retourne `false,`.</span><span class="sxs-lookup"><span data-stu-id="f038c-320">If the thread cannot enter without blocking, the method returns `false,`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-321">Utilisez <xref:System.Threading.Monitor> pour verrouiller les objets (autrement dit, les types référence), pas des types valeur.</span><span class="sxs-lookup"><span data-stu-id="f038c-321">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="f038c-322">Pour plus d’informations, consultez le <xref:System.Threading.Monitor> article.</span><span class="sxs-lookup"><span data-stu-id="f038c-322">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="f038c-323">Pour vous assurer que le thread n’entre pas de la section critique, vous devez examiner la valeur de retour et exécuter du code dans la section critique uniquement si sa valeur de retour est `true`.</span><span class="sxs-lookup"><span data-stu-id="f038c-323">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="f038c-324">Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-324">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="f038c-325">Notez que vous devez appeler <xref:System.Threading.Monitor.Exit%2A> dans un `finally` bloc pour vous assurer que le thread appelant libère son verrou sur la section critique si une exception se produit.</span><span class="sxs-lookup"><span data-stu-id="f038c-325">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="f038c-326">L'exemple de code suivant illustre l'utilisation de la méthode `TryEnter`.</span><span class="sxs-lookup"><span data-stu-id="f038c-326">The following code example demonstrates how to use the `TryEnter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-327">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-327">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-328">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-328">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-329">Objet sur lequel acquérir le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-329">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="f038c-330">Résultat de la tentative d'acquisition du verrou, passé par la référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-330">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="f038c-331">L'entrée doit avoir la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-331">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f038c-332">La sortie a la valeur <see langword="true" /> si un verrou est acquis ; sinon, elle a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-332">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f038c-333">La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-333">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-334">Tente d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-334">Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-335">Si réussie, cette méthode acquiert un verrou exclusif sur la `obj` paramètre.</span><span class="sxs-lookup"><span data-stu-id="f038c-335">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="f038c-336">Cette méthode retourne immédiatement, si le verrou est disponible ou non.</span><span class="sxs-lookup"><span data-stu-id="f038c-336">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="f038c-337">Si le verrou n’a pas été appliqué, car une exception a été levée, la variable spécifiée pour le `lockTaken` paramètre est `false` après la fin de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-337">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="f038c-338">Cela permet au programme déterminer, dans tous les cas, s’il est nécessaire libérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-338">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
 <span data-ttu-id="f038c-339">Cette méthode est similaire à <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, mais il ne se bloque jamais le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="f038c-339">This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread.</span></span> <span data-ttu-id="f038c-340">Si le thread ne peut pas entrer sans se bloquer, le `lockTaken` argument a la valeur `false` lorsque la méthode est retournée.</span><span class="sxs-lookup"><span data-stu-id="f038c-340">If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-341">Utilisez <xref:System.Threading.Monitor> pour verrouiller les objets (autrement dit, les types référence), pas des types valeur.</span><span class="sxs-lookup"><span data-stu-id="f038c-341">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="f038c-342">Pour plus d'informations, voir l'article <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="f038c-342">For more information, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="f038c-343">Pour vous assurer que le thread n’entre pas de la section critique, vous devez examiner la valeur de `lockTaken` et exécuter du code dans la section critique uniquement si sa valeur est `true`.</span><span class="sxs-lookup"><span data-stu-id="f038c-343">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="f038c-344">Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-344">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="f038c-345">Notez que vous devez appeler <xref:System.Threading.Monitor.Exit%2A> dans un `finally` bloc pour vous assurer que le thread appelant libère son verrou sur la section critique si une exception se produit.</span><span class="sxs-lookup"><span data-stu-id="f038c-345">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="f038c-346">Le code suivant montre le modèle de base pour l’utilisation de la <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-346">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="f038c-347">Cette surcharge définit toujours la valeur de la variable est passée à la `ref` paramètre (`ByRef` en Visual Basic) `lockTaken`, même si la méthode lève une exception, afin que la valeur de la variable de façon fiable pour déterminer si le verrou doit être publié.</span><span class="sxs-lookup"><span data-stu-id="f038c-347">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f038c-348">L’entrée de <paramref name="lockTaken" /> est <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-348">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-349">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-349">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-350">Objet sur lequel acquérir le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-350">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f038c-351">Délai d'attente du verrou en millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-351">The number of milliseconds to wait for the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-352">Tentatives d'acquisition d'un verrou exclusif sur l'objet spécifié au cours du nombre spécifié de millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-352">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f038c-353">
            <see langword="true" /> si le thread actuel acquiert le verrou ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-353">
              <see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-354">Si le `millisecondsTimeout` paramètre est égal à <xref:System.Threading.Timeout.Infinite>, cette méthode équivaut à <xref:System.Threading.Monitor.Enter%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-354">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="f038c-355">Si `millisecondsTimeout` est égal à 0, cette méthode équivaut à <xref:System.Threading.Monitor.TryEnter%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-355">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-356">Utilisez <xref:System.Threading.Monitor> pour verrouiller les objets (autrement dit, les types référence), pas des types valeur.</span><span class="sxs-lookup"><span data-stu-id="f038c-356">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="f038c-357">Pour plus d’informations, consultez le <xref:System.Threading.Monitor> article.</span><span class="sxs-lookup"><span data-stu-id="f038c-357">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="f038c-358">Pour vous assurer que le thread n’entre pas de la section critique, vous devez examiner la valeur de retour et exécuter du code dans la section critique uniquement si sa valeur de retour est `true`.</span><span class="sxs-lookup"><span data-stu-id="f038c-358">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="f038c-359">Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-359">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="f038c-360">Notez que vous devez appeler <xref:System.Threading.Monitor.Exit%2A> dans un `finally` bloc pour vous assurer que le thread appelant libère son verrou sur la section critique si une exception se produit.</span><span class="sxs-lookup"><span data-stu-id="f038c-360">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-361">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-361">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f038c-362">
            <paramref name="millisecondsTimeout" /> est négatif et n’est pas égal à <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-362">
              <paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-363">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-363">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-364">Objet sur lequel acquérir le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-364">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f038c-365">
            <see cref="T:System.TimeSpan" /> représentant le délai d'attente du verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-365">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait for the lock.</span>
          </span>
          <span data-ttu-id="f038c-366">Une valeur de –1 milliseconde spécifie une attente infinie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-366">A value of –1 millisecond specifies an infinite wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-367">Tentatives d'acquisition d'un verrou exclusif sur l'objet spécifié au cours de la période spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-367">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f038c-368">
            <see langword="true" /> si le thread actuel acquiert le verrou ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-368">
              <see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-369">Si la valeur de la `timeout` paramètre convertie en millisecondes est égale à – 1, cette méthode équivaut à <xref:System.Threading.Monitor.Enter%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-369">If the value of the `timeout` parameter converted to milliseconds equals –1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="f038c-370">Si la valeur de `timeout` est égal à 0, cette méthode équivaut à <xref:System.Threading.Monitor.TryEnter%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-370">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-371">Utilisez <xref:System.Threading.Monitor> pour verrouiller les objets (autrement dit, les types référence), pas des types valeur.</span><span class="sxs-lookup"><span data-stu-id="f038c-371">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="f038c-372">Pour plus d’informations, consultez le <xref:System.Threading.Monitor> rubrique de la classe.</span><span class="sxs-lookup"><span data-stu-id="f038c-372">For details, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="f038c-373">Pour vous assurer que le thread n’entre pas de la section critique, vous devez examiner la valeur de retour et exécuter du code dans la section critique uniquement si sa valeur de retour est `true`.</span><span class="sxs-lookup"><span data-stu-id="f038c-373">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="f038c-374">Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-374">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="f038c-375">Notez que vous devez appeler <xref:System.Threading.Monitor.Exit%2A> dans un `finally` bloc pour vous assurer que le thread appelant libère son verrou sur la section critique si une exception se produit.</span><span class="sxs-lookup"><span data-stu-id="f038c-375">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-376">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-376">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f038c-377">La valeur de <paramref name="timeout" /> en millisecondes est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /> (–1 milliseconde), ou est supérieure à <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-377">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-378">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-378">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-379">Objet sur lequel acquérir le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-379">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f038c-380">Délai d'attente du verrou en millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-380">The number of milliseconds to wait for the lock.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="f038c-381">Résultat de la tentative d'acquisition du verrou, passé par la référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-381">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="f038c-382">L'entrée doit avoir la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-382">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f038c-383">La sortie a la valeur <see langword="true" /> si un verrou est acquis ; sinon, elle a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-383">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f038c-384">La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-384">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-385">Tente, pendant le nombre spécifié de millisecondes, d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-385">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-386">Si le `millisecondsTimeout` paramètre est égal à <xref:System.Threading.Timeout.Infinite>, cette méthode équivaut à <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="f038c-386">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="f038c-387">Si `millisecondsTimeout` est égal à 0, cette méthode équivaut à <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="f038c-387">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="f038c-388">Si le verrou n’a pas été appliqué, car une exception a été levée, la variable spécifiée pour le `lockTaken` paramètre est `false` après la fin de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-388">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="f038c-389">Cela permet au programme déterminer, dans tous les cas, s’il est nécessaire libérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-389">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-390">Utilisez <xref:System.Threading.Monitor> pour verrouiller les objets (autrement dit, les types référence), pas des types valeur.</span><span class="sxs-lookup"><span data-stu-id="f038c-390">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="f038c-391">Pour plus d’informations, consultez le <xref:System.Threading.Monitor> rubrique de la classe.</span><span class="sxs-lookup"><span data-stu-id="f038c-391">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="f038c-392">Pour vous assurer que le thread n’entre pas de la section critique, vous devez examiner la valeur de `lockTaken` et exécuter du code dans la section critique uniquement si sa valeur est `true`.</span><span class="sxs-lookup"><span data-stu-id="f038c-392">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="f038c-393">Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-393">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="f038c-394">Notez que vous devez appeler <xref:System.Threading.Monitor.Exit%2A> dans un `finally` bloc pour vous assurer que le thread appelant libère son verrou sur la section critique si une exception se produit.</span><span class="sxs-lookup"><span data-stu-id="f038c-394">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="f038c-395">Le code suivant montre le modèle de base pour l’utilisation de la <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-395">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="f038c-396">Cette surcharge définit toujours la valeur de la variable est passée à la `ref` paramètre (`ByRef` en Visual Basic) `lockTaken`, même si la méthode lève une exception, afin que la valeur de la variable de façon fiable pour déterminer si le verrou doit être publié.</span><span class="sxs-lookup"><span data-stu-id="f038c-396">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f038c-397">L’entrée de <paramref name="lockTaken" /> est <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-397">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-398">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-398">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f038c-399">
            <paramref name="millisecondsTimeout" /> est négatif et n’est pas égal à <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-399">
              <paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-400">Objet sur lequel acquérir le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-400">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f038c-401">Délai d'attente du verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-401">The amount of time to wait for the lock.</span>
          </span>
          <span data-ttu-id="f038c-402">Une valeur de –1 milliseconde spécifie une attente infinie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-402">A value of –1 millisecond specifies an infinite wait.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="f038c-403">Résultat de la tentative d'acquisition du verrou, passé par la référence.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-403">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="f038c-404">L'entrée doit avoir la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-404">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f038c-405">La sortie a la valeur <see langword="true" /> si un verrou est acquis ; sinon, elle a la valeur <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-405">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="f038c-406">La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-406">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-407">Tente, pendant le délai spécifié, d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-407">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-408">Si la valeur de la `timeout` paramètre convertie en millisecondes est égale à – 1, cette méthode équivaut à <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="f038c-408">If the value of the `timeout` parameter converted to milliseconds equals –1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="f038c-409">Si la valeur de `timeout` est égal à 0, cette méthode équivaut à <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="f038c-409">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="f038c-410">Si le verrou n’a pas été appliqué, car une exception a été levée, la variable spécifiée pour le `lockTaken` paramètre est `false` après la fin de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-410">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="f038c-411">Cela permet au programme déterminer, dans tous les cas, s’il est nécessaire libérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-411">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-412">Utilisez <xref:System.Threading.Monitor> pour verrouiller les objets (autrement dit, les types référence), pas des types valeur.</span><span class="sxs-lookup"><span data-stu-id="f038c-412">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="f038c-413">Pour plus d’informations, consultez le <xref:System.Threading.Monitor> rubrique de la classe.</span><span class="sxs-lookup"><span data-stu-id="f038c-413">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="f038c-414">Pour vous assurer que le thread n’entre pas de la section critique, vous devez examiner la valeur de `lockTaken` et exécuter du code dans la section critique uniquement si sa valeur est `true`.</span><span class="sxs-lookup"><span data-stu-id="f038c-414">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="f038c-415">Le fragment de code suivant montre le modèle utilisé pour appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="f038c-415">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="f038c-416">Notez que vous devez appeler <xref:System.Threading.Monitor.Exit%2A> dans un `finally` bloc pour vous assurer que le thread appelant libère son verrou sur la section critique si une exception se produit.</span><span class="sxs-lookup"><span data-stu-id="f038c-416">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f038c-417">L’entrée de <paramref name="lockTaken" /> est <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-417">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-418">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-418">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f038c-419">La valeur de <paramref name="timeout" /> en millisecondes est négative et n’est pas égale à <see cref="F:System.Threading.Timeout.Infinite" /> (–1 milliseconde), ou est supérieure à <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-419">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-420">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-420">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f038c-421">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-421">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-422">Objet sur lequel attendre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-422">The object on which to wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-423">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-423">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f038c-424">
            <see langword="true" /> si l'appel est retourné parce que l'appelant a de nouveau acquis le verrou pour l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-424">
              <see langword="true" /> if the call returned because the caller reacquired the lock for the specified object.</span>
          </span>
          <span data-ttu-id="f038c-425">Cette méthode ne retourne rien si le verrou n'est pas acquis à nouveau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-425">This method does not return if the lock is not reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-426">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode afin de libérer l’objet afin qu’un autre thread peut y accéder.</span><span class="sxs-lookup"><span data-stu-id="f038c-426">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="f038c-427">L’appelant est bloqué en attendant d’acquérir le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-427">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="f038c-428">Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.</span><span class="sxs-lookup"><span data-stu-id="f038c-428">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="f038c-429">Lorsqu’un thread appelle `Wait`, il libère le verrou sur l’objet et passe la file d’attente de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-429">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="f038c-430">Le thread suivant dans la file d’attente opérationnelle de l’objet (le cas échéant) acquiert le verrou et a l’usage exclusif de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-430">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="f038c-431">Tous les threads qui appellent `Wait` restent dans la file d’attente jusqu'à ce qu’ils reçoivent un signal de <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A>, envoyé par le propriétaire du verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-431">All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock.</span></span> <span data-ttu-id="f038c-432">Si `Pulse` est envoyé, seul le thread à la tête de la file d’attente est affecté.</span><span class="sxs-lookup"><span data-stu-id="f038c-432">If `Pulse` is sent, only the thread at the head of the waiting queue is affected.</span></span> <span data-ttu-id="f038c-433">Si `PulseAll` est envoyé, tous les threads qui attendent l’objet sont affectées.</span><span class="sxs-lookup"><span data-stu-id="f038c-433">If `PulseAll` is sent, all threads that are waiting for the object are affected.</span></span> <span data-ttu-id="f038c-434">Lorsque le signal est reçu, un ou plusieurs threads laisser la file d’attente et la file d’attente opérationnelle.</span><span class="sxs-lookup"><span data-stu-id="f038c-434">When the signal is received, one or more threads leave the waiting queue and enter the ready queue.</span></span> <span data-ttu-id="f038c-435">Un thread dans la file d’attente opérationnelle est autorisé à réacquérir le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-435">A thread in the ready queue is permitted to reacquire the lock.</span></span>  
  
 <span data-ttu-id="f038c-436">Cette méthode est retournée lorsque le thread appelant acquiert le verrou sur l’objet à nouveau.</span><span class="sxs-lookup"><span data-stu-id="f038c-436">This method returns when the calling thread reacquires the lock on the object.</span></span> <span data-ttu-id="f038c-437">Notez que cette méthode se bloque indéfiniment si le détenteur du verrou n’appelle pas `Pulse` ou `PulseAll`.</span><span class="sxs-lookup"><span data-stu-id="f038c-437">Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`.</span></span>  
  
 <span data-ttu-id="f038c-438">L’appelant exécute `Wait` une seule fois, quel que soit le nombre de fois <xref:System.Threading.Monitor.Enter%2A> a été appelée pour l’objet spécifié.</span><span class="sxs-lookup"><span data-stu-id="f038c-438">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="f038c-439">Conceptuellement, la `Wait` méthode stocke le nombre de fois que l’appelant appelé `Enter` sur l’objet et appelle `Exit` autant de fois que nécessaire pour libérer complètement l’objet verrouillé.</span><span class="sxs-lookup"><span data-stu-id="f038c-439">Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="f038c-440">L’appelant se bloque en attendant d’acquérir de nouveau l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-440">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="f038c-441">Lorsque l’appelant acquiert le verrou à nouveau, le système appelle `Enter` autant de fois que nécessaire pour restaurer l’enregistré `Enter` nombre pour l’appelant.</span><span class="sxs-lookup"><span data-stu-id="f038c-441">When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller.</span></span> <span data-ttu-id="f038c-442">Appel `Wait` libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.</span><span class="sxs-lookup"><span data-stu-id="f038c-442">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
 <span data-ttu-id="f038c-443">Notez qu’un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient les threads qui attendent pour la notification d’un changement d’état de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-443">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="f038c-444">Le <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, et `Wait` méthodes doivent être appelées à partir d’un bloc de code synchronisé.</span><span class="sxs-lookup"><span data-stu-id="f038c-444">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="f038c-445">Les notes relatives à la <xref:System.Threading.Monitor.Pulse%2A> méthode expliquent ce qui se passe si <xref:System.Threading.Monitor.Pulse%2A> est appelé lorsque aucun thread n’attend.</span><span class="sxs-lookup"><span data-stu-id="f038c-445">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-446">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-446">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="f038c-447">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-447">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="f038c-448">Le thread qui appelle <see langword="Wait" /> quitte ensuite l'état d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-448">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="f038c-449">Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-449">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-450">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-450">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-451">Objet sur lequel attendre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-451">The object on which to wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f038c-452">Nombre de millisecondes à attendre avant que le thread intègre la file d'attente opérationnelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-452">The number of milliseconds to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-453">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-453">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="f038c-454">Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-454">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f038c-455">
            <see langword="true" /> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <see langword="false" /> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-455">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="f038c-456">La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-456">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-457">Cette méthode ne retourne pas jusqu'à ce qu’il acquière à nouveau un verrou exclusif sur la `obj` paramètre.</span><span class="sxs-lookup"><span data-stu-id="f038c-457">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="f038c-458">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode afin de libérer l’objet afin qu’un autre thread peut y accéder.</span><span class="sxs-lookup"><span data-stu-id="f038c-458">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="f038c-459">L’appelant est bloqué en attendant d’acquérir le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-459">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="f038c-460">Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.</span><span class="sxs-lookup"><span data-stu-id="f038c-460">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="f038c-461">Le délai d’expiration garantit que le thread actuel ne se bloque pas indéfiniment si un autre thread libère le verrou sans appeler d’abord la <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="f038c-461">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="f038c-462">Il déplace également le thread à la file d’attente opérationnelle, en contournant les autres threads en avance dans la file d’attente, afin que d’acquérir à nouveau le verrou plus tôt.</span><span class="sxs-lookup"><span data-stu-id="f038c-462">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="f038c-463">Le thread peut tester la valeur de retour de la <xref:System.Threading.Monitor.Wait%2A> méthode pour déterminer si elle a de nouveau acquis le verrou avant le délai d’expiration. Le thread peut évaluer les conditions qui a causé l’attente, et si nécessaire, appeler le <xref:System.Threading.Monitor.Wait%2A> méthode à nouveau.</span><span class="sxs-lookup"><span data-stu-id="f038c-463">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="f038c-464">Lorsqu’un thread appelle `Wait`, il libère le verrou sur l’objet et passe la file d’attente de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-464">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="f038c-465">Le thread suivant dans la file d’attente opérationnelle de l’objet (le cas échéant) acquiert le verrou et a l’usage exclusif de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-465">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="f038c-466">Le thread qui a appelé `Wait` appelle d’un thread qui détient le verrou reste dans la file d’attente jusqu'à ce que <xref:System.Threading.Monitor.PulseAll%2A>, ou il est le suivant dans la file d’attente et un thread qui détient le verrou appelle <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-466">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="f038c-467">Toutefois, si `millisecondsTimeout` s’écoule avant qu’un autre thread appelle de cet objet <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode), le thread d’origine est déplacé vers la file d’attente opérationnelle pour récupérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-467">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-468">Si <xref:System.Threading.Timeout.Infinite> est spécifié pour le `millisecondsTimeout` paramètre, cette méthode se bloque indéfiniment, sauf si le détenteur du verrou appelle <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-468">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="f038c-469">Si `millisecondsTimeout` est égal à 0, le thread qui appelle `Wait` libère le verrou et intègre immédiatement la file d’attente opérationnelle pour récupérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-469">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="f038c-470">L’appelant exécute `Wait` une seule fois, quel que soit le nombre de fois <xref:System.Threading.Monitor.Enter%2A> a été appelée pour l’objet spécifié.</span><span class="sxs-lookup"><span data-stu-id="f038c-470">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="f038c-471">Conceptuellement, la `Wait` méthode stocke le nombre de fois que l’appelant appelé <xref:System.Threading.Monitor.Enter%2A> sur l’objet et appelle <xref:System.Threading.Monitor.Exit%2A> autant de fois que nécessaire pour libérer complètement l’objet verrouillé.</span><span class="sxs-lookup"><span data-stu-id="f038c-471">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="f038c-472">L’appelant se bloque en attendant d’acquérir de nouveau l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-472">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="f038c-473">Lorsque l’appelant acquiert le verrou à nouveau, le système appelle <xref:System.Threading.Monitor.Enter%2A> autant de fois que nécessaire pour restaurer l’enregistré <xref:System.Threading.Monitor.Enter%2A> nombre pour l’appelant.</span><span class="sxs-lookup"><span data-stu-id="f038c-473">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="f038c-474">Appel `Wait` libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.</span><span class="sxs-lookup"><span data-stu-id="f038c-474">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-475">Un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient le threads qui attendent pour la notification d’un changement d’état de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-475">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="f038c-476">Le <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, et `Wait` méthodes doivent être appelées à partir d’un bloc de code synchronisé.</span><span class="sxs-lookup"><span data-stu-id="f038c-476">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="f038c-477">Les notes relatives à la <xref:System.Threading.Monitor.Pulse%2A> méthode expliquent ce qui se passe si <xref:System.Threading.Monitor.Pulse%2A> est appelé lorsque aucun thread n’attend.</span><span class="sxs-lookup"><span data-stu-id="f038c-477">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-478">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-478">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="f038c-479">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-479">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="f038c-480">Le thread qui appelle <see langword="Wait" /> quitte ensuite l'état d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-480">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="f038c-481">Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-481">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f038c-482">La valeur du paramètre <paramref name="millisecondsTimeout" /> est négative et différente de <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-482">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-483">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-483">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-484">Objet sur lequel attendre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-484">The object on which to wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f038c-485">
            <see cref="T:System.TimeSpan" /> qui représente le temps à attendre avant que le thread n'intègre la file d'attente opérationnelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-485">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-486">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-486">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="f038c-487">Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-487">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f038c-488">
            <see langword="true" /> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <see langword="false" /> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-488">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="f038c-489">La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-489">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-490">Cette méthode ne retourne pas jusqu'à ce qu’il acquière à nouveau un verrou exclusif sur la `obj` paramètre.</span><span class="sxs-lookup"><span data-stu-id="f038c-490">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="f038c-491">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode afin de libérer l’objet afin qu’un autre thread peut y accéder.</span><span class="sxs-lookup"><span data-stu-id="f038c-491">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="f038c-492">L’appelant est bloqué en attendant d’acquérir le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-492">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="f038c-493">Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.</span><span class="sxs-lookup"><span data-stu-id="f038c-493">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="f038c-494">Le délai d’expiration garantit que le thread actuel ne se bloque pas indéfiniment si un autre thread libère le verrou sans appeler d’abord la <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="f038c-494">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="f038c-495">Il déplace également le thread à la file d’attente opérationnelle, en contournant les autres threads en avance dans la file d’attente, afin que d’acquérir à nouveau le verrou plus tôt.</span><span class="sxs-lookup"><span data-stu-id="f038c-495">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="f038c-496">Le thread peut tester la valeur de retour de la <xref:System.Threading.Monitor.Wait%2A> méthode pour déterminer si elle a de nouveau acquis le verrou avant le délai d’expiration. Le thread peut évaluer les conditions qui a causé l’attente, et si nécessaire, appeler le <xref:System.Threading.Monitor.Wait%2A> méthode à nouveau.</span><span class="sxs-lookup"><span data-stu-id="f038c-496">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="f038c-497">Lorsqu’un thread appelle `Wait`, il libère le verrou sur l’objet et passe la file d’attente de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-497">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="f038c-498">Le thread suivant dans la file d’attente opérationnelle de l’objet (le cas échéant) acquiert le verrou et a l’usage exclusif de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-498">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="f038c-499">Le thread qui a appelé `Wait` appelle d’un thread qui détient le verrou reste dans la file d’attente jusqu'à ce que <xref:System.Threading.Monitor.PulseAll%2A>, ou il est le suivant dans la file d’attente et un thread qui détient le verrou appelle <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-499">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="f038c-500">Toutefois, si `timeout` s’écoule avant qu’un autre thread appelle de cet objet <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode), le thread d’origine est déplacé vers la file d’attente opérationnelle pour récupérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-500">However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-501">Si un <xref:System.TimeSpan> représentant – 1 milliseconde est spécifié pour le `timeout` paramètre, cette méthode se bloque indéfiniment, sauf si le détenteur du verrou appelle <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-501">If a <xref:System.TimeSpan> representing –1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="f038c-502">Si `timeout` est 0 milliseconde, le thread qui appelle `Wait` libère le verrou et intègre immédiatement la file d’attente opérationnelle pour récupérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-502">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="f038c-503">L’appelant exécute `Wait` une seule fois, quel que soit le nombre de fois <xref:System.Threading.Monitor.Enter%2A> a été appelée pour l’objet spécifié.</span><span class="sxs-lookup"><span data-stu-id="f038c-503">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="f038c-504">Conceptuellement, la `Wait` méthode stocke le nombre de fois que l’appelant appelé <xref:System.Threading.Monitor.Enter%2A> sur l’objet et appelle <xref:System.Threading.Monitor.Exit%2A> autant de fois que nécessaire pour libérer complètement l’objet verrouillé.</span><span class="sxs-lookup"><span data-stu-id="f038c-504">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="f038c-505">L’appelant se bloque en attendant d’acquérir de nouveau l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-505">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="f038c-506">Lorsque l’appelant acquiert le verrou à nouveau, le système appelle <xref:System.Threading.Monitor.Enter%2A> autant de fois que nécessaire pour restaurer l’enregistré <xref:System.Threading.Monitor.Enter%2A> nombre pour l’appelant.</span><span class="sxs-lookup"><span data-stu-id="f038c-506">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="f038c-507">Appel `Wait` libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.</span><span class="sxs-lookup"><span data-stu-id="f038c-507">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-508">Un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient le threads qui attendent pour la notification d’un changement d’état de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-508">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="f038c-509">Le <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, et `Wait` méthodes doivent être appelées à partir d’un bloc de code synchronisé.</span><span class="sxs-lookup"><span data-stu-id="f038c-509">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="f038c-510">Les notes relatives à la <xref:System.Threading.Monitor.Pulse%2A> méthode expliquent ce qui se passe si <xref:System.Threading.Monitor.Pulse%2A> est appelé lorsque aucun thread n’attend.</span><span class="sxs-lookup"><span data-stu-id="f038c-510">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-511">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-511">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="f038c-512">Le thread appelant ne possède pas le verrou pour l'objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-512">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="f038c-513">Le thread qui appelle <see langword="Wait" /> quitte ensuite l'état d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-513">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="f038c-514">Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-514">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f038c-515">La valeur en millisecondes du paramètre <paramref name="timeout" /> est négative et ne représente pas <see cref="F:System.Threading.Timeout.Infinite" /> (–1 milliseconde) ou est supérieure à <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-515">The value of the <paramref name="timeout" /> parameter in milliseconds is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-516">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-516">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-517">Objet sur lequel attendre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-517">The object on which to wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f038c-518">Nombre de millisecondes à attendre avant que le thread intègre la file d'attente opérationnelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-518">The number of milliseconds to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f038c-519">
            <see langword="true" /> pour abandonner et acquérir à nouveau le domaine de synchronisation associé au contexte (dans le cas d'un contexte synchronisé) avant l'attente ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-519">
              <see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-520">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-520">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="f038c-521">Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-521">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
          <span data-ttu-id="f038c-522">Cette méthode spécifie également si le domaine de synchronisation associé au contexte (dans le cas d’un contexte synchronisé) est abandonné avant l’attente et acquis à nouveau par la suite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-522">This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f038c-523">
            <see langword="true" /> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <see langword="false" /> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-523">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="f038c-524">La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-524">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-525">Cette méthode ne retourne pas jusqu'à ce qu’il acquière à nouveau un verrou exclusif sur la `obj` paramètre.</span><span class="sxs-lookup"><span data-stu-id="f038c-525">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="f038c-526">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode afin de libérer l’objet afin qu’un autre thread peut y accéder.</span><span class="sxs-lookup"><span data-stu-id="f038c-526">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="f038c-527">L’appelant est bloqué en attendant d’acquérir le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-527">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="f038c-528">Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.</span><span class="sxs-lookup"><span data-stu-id="f038c-528">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="f038c-529">Le délai d’expiration garantit que le thread actuel ne se bloque pas indéfiniment si un autre thread libère le verrou sans appeler d’abord la <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="f038c-529">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="f038c-530">Il déplace également le thread à la file d’attente opérationnelle, en contournant les autres threads en avance dans la file d’attente, afin que d’acquérir à nouveau le verrou plus tôt.</span><span class="sxs-lookup"><span data-stu-id="f038c-530">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="f038c-531">Le thread peut tester la valeur de retour de la <xref:System.Threading.Monitor.Wait%2A> méthode pour déterminer si elle a de nouveau acquis le verrou avant le délai d’expiration. Le thread peut évaluer les conditions qui a causé l’attente, et si nécessaire, appeler le <xref:System.Threading.Monitor.Wait%2A> méthode à nouveau.</span><span class="sxs-lookup"><span data-stu-id="f038c-531">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="f038c-532">Lorsqu’un thread appelle `Wait`, il libère le verrou et intègre la file d’attente en attente.</span><span class="sxs-lookup"><span data-stu-id="f038c-532">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="f038c-533">À ce stade, le thread suivant dans la file d’attente opérationnelle (le cas échéant) est autorisé à prendre le contrôle du verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-533">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="f038c-534">Le thread qui a appelé `Wait` appelle d’un thread qui détient le verrou reste dans la file d’attente jusqu'à ce que <xref:System.Threading.Monitor.PulseAll%2A>, ou il est le suivant dans la file d’attente et un thread qui détient le verrou appelle <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-534">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="f038c-535">Toutefois, si `millisecondsTimeout` s’écoule avant qu’un autre thread appelle de cet objet <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode), le thread d’origine est déplacé vers la file d’attente opérationnelle pour récupérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-535">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-536">Si <xref:System.Threading.Timeout.Infinite> est spécifié pour le `millisecondsTimeout` paramètre, cette méthode se bloque indéfiniment, sauf si le détenteur du verrou appelle <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-536">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="f038c-537">Si `millisecondsTimeout` est égal à 0, le thread qui appelle `Wait` libère le verrou et intègre immédiatement la file d’attente opérationnelle pour récupérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-537">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="f038c-538">L’appelant exécute `Wait` une seule fois, quel que soit le nombre de fois <xref:System.Threading.Monitor.Enter%2A> a été appelée pour l’objet spécifié.</span><span class="sxs-lookup"><span data-stu-id="f038c-538">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="f038c-539">Conceptuellement, la `Wait` méthode stocke le nombre de fois que l’appelant appelé <xref:System.Threading.Monitor.Enter%2A> sur l’objet et appelle <xref:System.Threading.Monitor.Exit%2A> autant de fois que nécessaire pour libérer complètement l’objet verrouillé.</span><span class="sxs-lookup"><span data-stu-id="f038c-539">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="f038c-540">L’appelant se bloque en attendant d’acquérir de nouveau l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-540">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="f038c-541">Lorsque l’appelant acquiert le verrou à nouveau, le système appelle <xref:System.Threading.Monitor.Enter%2A> autant de fois que nécessaire pour restaurer l’enregistré <xref:System.Threading.Monitor.Enter%2A> nombre pour l’appelant.</span><span class="sxs-lookup"><span data-stu-id="f038c-541">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="f038c-542">Appel `Wait` libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.</span><span class="sxs-lookup"><span data-stu-id="f038c-542">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-543">Un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient le threads qui attendent pour la notification d’un changement d’état de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-543">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="f038c-544">Le <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, et `Wait` méthodes doivent être appelées à partir d’un bloc de code synchronisé.</span><span class="sxs-lookup"><span data-stu-id="f038c-544">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="f038c-545">Les notes relatives à la <xref:System.Threading.Monitor.Pulse%2A> méthode expliquent ce qui se passe si <xref:System.Threading.Monitor.Pulse%2A> est appelé lorsque aucun thread n’attend.</span><span class="sxs-lookup"><span data-stu-id="f038c-545">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f038c-546">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="f038c-546">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f038c-547">Le`exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.Monitor.Wait%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="f038c-547">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f038c-548">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f038c-548">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f038c-549">Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="f038c-549">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f038c-550">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.Monitor.Wait%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="f038c-550">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="f038c-551">Il retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.Monitor.Wait%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="f038c-551">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="f038c-552">Cela peut être utile lorsque la classe liée au contexte comporte la <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribut appliqué.</span><span class="sxs-lookup"><span data-stu-id="f038c-552">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="f038c-553">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="f038c-553">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f038c-554">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.Monitor.Wait%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="f038c-554">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f038c-555">Lorsque le <xref:System.Threading.Monitor.Wait%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="f038c-555">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-556">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-556">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="f038c-557">
            <see langword="Wait" /> n’est pas appelé à partir d’un bloc de code synchronisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-557">
              <see langword="Wait" /> is not invoked from within a synchronized block of code.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="f038c-558">Le thread qui appelle <see langword="Wait" /> quitte ensuite l'état d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-558">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="f038c-559">Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-559">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f038c-560">La valeur du paramètre <paramref name="millisecondsTimeout" /> est négative et différente de <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-560">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-561">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-561">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f038c-562">Objet sur lequel attendre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-562">The object on which to wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f038c-563">
            <see cref="T:System.TimeSpan" /> qui représente le temps à attendre avant que le thread n'intègre la file d'attente opérationnelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-563">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f038c-564">
            <see langword="true" /> pour abandonner et acquérir à nouveau le domaine de synchronisation associé au contexte (dans le cas d'un contexte synchronisé) avant l'attente ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-564">
              <see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f038c-565">Libère le verrou d’un objet et bloque le thread actuel jusqu’à ce qu’il acquière à nouveau le verrou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-565">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="f038c-566">Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-566">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
          <span data-ttu-id="f038c-567">Le domaine de synchronisation associé au contexte synchronisé peut être abandonné avant l’attente et acquis de nouveau par la suite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-567">Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f038c-568">
            <see langword="true" /> si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; <see langword="false" /> si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-568">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="f038c-569">La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-569">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f038c-570">Cette méthode ne retourne pas jusqu'à ce qu’il acquière à nouveau un verrou exclusif sur la `obj` paramètre.</span><span class="sxs-lookup"><span data-stu-id="f038c-570">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="f038c-571">Le thread qui possède actuellement le verrou sur l’objet spécifié appelle cette méthode afin de libérer l’objet afin qu’un autre thread peut y accéder.</span><span class="sxs-lookup"><span data-stu-id="f038c-571">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="f038c-572">L’appelant est bloqué en attendant d’acquérir le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-572">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="f038c-573">Cette méthode est appelée lorsque l’appelant doit attendre un changement d’état qui se produit suite à des opérations d’un autre thread.</span><span class="sxs-lookup"><span data-stu-id="f038c-573">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="f038c-574">Le délai d’expiration garantit que le thread actuel ne se bloque pas indéfiniment si un autre thread libère le verrou sans appeler d’abord la <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="f038c-574">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="f038c-575">Il déplace également le thread à la file d’attente opérationnelle, en contournant les autres threads en avance dans la file d’attente, afin que d’acquérir à nouveau le verrou plus tôt.</span><span class="sxs-lookup"><span data-stu-id="f038c-575">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="f038c-576">Le thread peut tester la valeur de retour de la <xref:System.Threading.Monitor.Wait%2A> méthode pour déterminer si elle a de nouveau acquis le verrou avant le délai d’expiration. Le thread peut évaluer les conditions qui a causé l’attente, et si nécessaire, appeler le <xref:System.Threading.Monitor.Wait%2A> méthode à nouveau.</span><span class="sxs-lookup"><span data-stu-id="f038c-576">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="f038c-577">Lorsqu’un thread appelle `Wait`, il libère le verrou et intègre la file d’attente en attente.</span><span class="sxs-lookup"><span data-stu-id="f038c-577">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="f038c-578">À ce stade, le thread suivant dans la file d’attente opérationnelle (le cas échéant) est autorisé à prendre le contrôle du verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-578">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="f038c-579">Le thread qui a appelé `Wait` appelle d’un thread qui détient le verrou reste dans la file d’attente jusqu'à ce que <xref:System.Threading.Monitor.PulseAll%2A>, ou il est le suivant dans la file d’attente et un thread qui détient le verrou appelle <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-579">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="f038c-580">Toutefois, si `timeout` millisecondes écoulent avant un autre thread appelle de cet objet <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A> (méthode), le thread d’origine est déplacé vers la file d’attente opérationnelle pour récupérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-580">However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-581">Si un <xref:System.TimeSpan> représentant-1 milliseconde est spécifié pour le `timeout` paramètre, cette méthode se bloque indéfiniment, sauf si le détenteur du verrou appelle <xref:System.Threading.Monitor.Pulse%2A> ou <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="f038c-581">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="f038c-582">Si `timeout` est 0 milliseconde, le thread qui appelle `Wait` libère le verrou et intègre immédiatement la file d’attente opérationnelle pour récupérer le verrou.</span><span class="sxs-lookup"><span data-stu-id="f038c-582">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="f038c-583">L’appelant exécute `Wait` une seule fois, quel que soit le nombre de fois <xref:System.Threading.Monitor.Enter%2A> a été appelée pour l’objet spécifié.</span><span class="sxs-lookup"><span data-stu-id="f038c-583">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="f038c-584">Conceptuellement, la `Wait` méthode stocke le nombre de fois que l’appelant appelé <xref:System.Threading.Monitor.Enter%2A> sur l’objet et appelle <xref:System.Threading.Monitor.Exit%2A> autant de fois que nécessaire pour libérer complètement l’objet verrouillé.</span><span class="sxs-lookup"><span data-stu-id="f038c-584">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="f038c-585">L’appelant se bloque en attendant d’acquérir de nouveau l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-585">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="f038c-586">Lorsque l’appelant acquiert le verrou à nouveau, le système appelle <xref:System.Threading.Monitor.Enter%2A> autant de fois que nécessaire pour restaurer l’enregistré <xref:System.Threading.Monitor.Enter%2A> nombre pour l’appelant.</span><span class="sxs-lookup"><span data-stu-id="f038c-586">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="f038c-587">Appel `Wait` libère le verrou pour l’objet spécifié uniquement ; si l’appelant est le propriétaire de verrous sur d’autres objets, ces verrous sont libérés pas.</span><span class="sxs-lookup"><span data-stu-id="f038c-587">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f038c-588">Un objet synchronisé comprend plusieurs références, y compris une référence au thread qui détient actuellement le verrou, une référence à la file d’attente opérationnelle, qui contient les threads prêts à obtenir le verrou, et une référence à la file d’attente, qui contient le threads qui attendent pour la notification d’un changement d’état de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f038c-588">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="f038c-589">Le <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, et `Wait` méthodes doivent être appelées à partir d’un bloc de code synchronisé.</span><span class="sxs-lookup"><span data-stu-id="f038c-589">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="f038c-590">Les notes relatives à la <xref:System.Threading.Monitor.Pulse%2A> méthode expliquent ce qui se passe si <xref:System.Threading.Monitor.Pulse%2A> est appelé lorsque aucun thread n’attend.</span><span class="sxs-lookup"><span data-stu-id="f038c-590">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f038c-591">Remarques sur la sortie de contexte</span><span class="sxs-lookup"><span data-stu-id="f038c-591">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f038c-592">Le`exitContext` paramètre n’a aucun effet à moins que le <xref:System.Threading.Monitor.Wait%2A> méthode est appelée à partir d’un contexte managé non défini par défaut.</span><span class="sxs-lookup"><span data-stu-id="f038c-592">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f038c-593">Cela peut se produire si votre thread se trouve à l’intérieur d’un appel à une instance d’une classe dérivée de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f038c-593">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f038c-594">Même si vous exécutez actuellement une méthode sur une classe qui n’est pas dérivée <xref:System.ContextBoundObject>, comme <xref:System.String>, vous pouvez être dans un contexte non défini par défaut si un <xref:System.ContextBoundObject> se trouve sur votre pile dans le domaine d’application actuel.</span><span class="sxs-lookup"><span data-stu-id="f038c-594">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f038c-595">Lorsque votre code s’exécute dans un contexte non défini par défaut, en spécifiant `true` pour `exitContext` oblige le thread quitter le contexte managé non défini par défaut (autrement dit, pour effectuer la transition vers le contexte par défaut) avant d’exécuter le <xref:System.Threading.Monitor.Wait%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="f038c-595">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="f038c-596">Il retourne au contexte d’origine non défini par défaut après l’appel à la <xref:System.Threading.Monitor.Wait%2A> méthode se termine.</span><span class="sxs-lookup"><span data-stu-id="f038c-596">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="f038c-597">Cela peut être utile lorsque la classe liée au contexte comporte la <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribut appliqué.</span><span class="sxs-lookup"><span data-stu-id="f038c-597">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="f038c-598">Dans ce cas, tous les appels aux membres de la classe sont automatiquement synchronisés, et le domaine de synchronisation est le corps de code pour la classe.</span><span class="sxs-lookup"><span data-stu-id="f038c-598">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f038c-599">Si le code dans la pile des appels d’un membre appelle le <xref:System.Threading.Monitor.Wait%2A> (méthode) et spécifie `true` pour `exitContext`, le thread quitte le domaine de synchronisation, permettant à un thread est bloqué sur un appel à n’importe quel membre de l’objet pour continuer.</span><span class="sxs-lookup"><span data-stu-id="f038c-599">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f038c-600">Lorsque le <xref:System.Threading.Monitor.Wait%2A> méthode est retournée, le thread qui a effectué l’appel doit attendre pour rentrer dans le domaine de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="f038c-600">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f038c-601">Le paramètre <paramref name="obj" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-601">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="f038c-602">
            <see langword="Wait" /> n’est pas appelé à partir d’un bloc de code synchronisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-602">
              <see langword="Wait" /> is not invoked from within a synchronized block of code.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="f038c-603">Le thread qui appelle Wait quitte ensuite l’état d’attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-603">The thread that invokes Wait is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="f038c-604">Cela se produit lorsqu’un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-604">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f038c-605">Le paramètre <paramref name="timeout" /> est négatif et ne représente pas <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milliseconde), ou est supérieur à <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-605">The <paramref name="timeout" /> parameter is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="f038c-606">Threading managé</span>
          <span class="sxs-lookup">
            <span data-stu-id="f038c-606">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
  </Members>
</Type>