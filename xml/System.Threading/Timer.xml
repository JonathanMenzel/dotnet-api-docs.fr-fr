<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Timer.xml" source-language="en-US" target-language="fr-FR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac567fe19429800288028bf5585c9bd4f03134790db.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67fe19429800288028bf5585c9bd4f03134790db</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Provides a mechanism for executing a method on a thread pool thread at specified intervals.</source>
          <target state="translated">Fournit un mécanisme permettant d'exécuter une méthode sur un thread de pool de threads à intervalles spécifiés.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>This class cannot be inherited.</source>
          <target state="translated">Cette classe ne peut pas être héritée.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Use a <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate to specify the method you want the <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> to execute.</source>
          <target state="translated">Utilisez un <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> délégué pour spécifier la méthode que vous souhaitez le <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> à exécuter.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The signature of the <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate is:</source>
          <target state="translated">La signature de la <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> délégué est :</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The timer delegate is specified when the timer is constructed, and cannot be changed.</source>
          <target state="translated">Le délégué de la minuterie est spécifié lors de la minuterie est construite et ne peut pas être modifiée.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The method does not execute on the thread that created the timer; it executes on a <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread supplied by the system.</source>
          <target state="translated">La méthode ne s’exécute pas sur le thread qui a créé la minuterie ; Il s’exécute sur un <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread fourni par le système.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>.NET includes four classes named <ph id="ph1">`Timer`</ph>, each of which offers different functionality:</source>
          <target state="translated">.NET comprend quatre classes nommées <ph id="ph1">`Timer`</ph>, chaque de qui offre des fonctionnalités différentes :</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, which fires an event and executes the code in one or more event sinks at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, qui déclenche un événement et exécute le code dans un ou plusieurs événements récepteurs à intervalles réguliers.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</source>
          <target state="translated">La classe est destinée à en tant que la basée sur un serveur ou les composants de service dans un environnement multithread ; Il ne dispose d’aucune interface utilisateur et n’est pas visible lors de l’exécution.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph>, which executes a single callback method on a thread pool thread at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph>, qui exécute une méthode de rappel unique sur un thread de pool de threads à intervalles réguliers.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The callback method is defined when the timer is instantiated and cannot be changed.</source>
          <target state="translated">La méthode de rappel est définie lorsque la minuterie est instanciée et ne peut pas être modifiée.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Like the <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> class, this class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</source>
          <target state="translated">Comme le <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> (classe), cette classe est destinée à être utilisée comme un composant basé sur le serveur ou le service dans un environnement multithread ; elle ne dispose d’aucune interface utilisateur et n’est pas visible lors de l’exécution.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> (.NET Framework only), a Windows Forms component that fires an event and executes the code in one or more event sinks at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> (.NET framework uniquement), un composant Windows Forms qui déclenche un événement et exécute le code dans un ou plusieurs récepteurs d’événements à intervalles réguliers.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The component has no user interface and is designed for use in a single-threaded environment; it executes on the UI thread.</source>
          <target state="translated">Le composant a pas d’interface utilisateur et est conçu pour une utilisation dans un environnement monothread. Il s’exécute sur le thread d’interface utilisateur.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Web.UI.Timer?displayProperty=nameWithType&gt;</ph> (.NET Framework only), an ASP.NET component that performs asynchronous or synchronous web page postbacks at a regular interval.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Timer?displayProperty=nameWithType&gt;</ph> (.NET framework uniquement), un composant ASP.NET qui effectue des publications de pages web asynchrones ou synchrones à intervalles réguliers.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When you create a timer, you can specify an amount of time to wait before the first execution of the method (due time), and an amount of time to wait between subsequent executions (period).</source>
          <target state="translated">Lorsque vous créez un minuteur, vous pouvez spécifier un intervalle de temps à attendre avant la première exécution de la méthode (délai d’attente) et un intervalle de temps d’attente entre les exécutions suivantes (période).</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe a la même résolution que l’horloge système.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>This means that if the period is less than the resolution of the system clock, the <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate will execute at intervals defined by the resolution of the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems.</source>
          <target state="translated">Cela signifie que si la période est inférieure à la résolution de l’horloge système, le <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> délégué s’exécute à intervalles définis par la résolution de l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows 7 et Windows 8.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>You can change the due time and period, or disable the timer, by using the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Vous pouvez modifier le montant dû heure et un point ou désactiver la minuterie, à l’aide de la <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>As long as you are using a <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph>, you must keep a reference to it.</source>
          <target state="translated">Tant que vous utilisez un <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph>, vous devez conserver une référence à celui-ci.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>As with any managed object, a <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> is subject to garbage collection when there are no references to it.</source>
          <target state="translated">Comme avec n’importe quel objet géré, un <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> est soumis au garbage collection lorsqu’il n’existe aucune référence à celle-ci.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The fact that a <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> is still active does not prevent it from being collected.</source>
          <target state="translated">Le fait qu’un <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> est toujours actif ne pas empêche d’être récupéré.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When a timer is no longer needed, use the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> method to free the resources held by the timer.</source>
          <target state="translated">Lorsqu’un minuteur n’est plus nécessaire, utilisez la <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> méthode pour libérer les ressources détenues par la minuterie.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Note that callbacks can occur after the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> method overload has been called, because the timer queues callbacks for execution by thread pool threads.</source>
          <target state="translated">Notez que les rappels peuvent se produire après la <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> surcharge de méthode a été appelée, car le minuteur de files d’attente des rappels pour l’exécution par les threads du pool.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload to wait until all callbacks have completed.</source>
          <target state="translated">Vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> la surcharge de méthode pour attendre que tous les rappels.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The callback method executed by the timer should be reentrant, because it is called on <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">La méthode de rappel exécutée par la minuterie doit être réentrante, parce qu’elle est appelée sur <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The callback can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the callback, or if all thread pool threads are in use and the callback is queued multiple times.</source>
          <target state="translated">Le rappel peut être exécuté simultanément sur deux threads du pool si l’intervalle de minuterie est inférieur au temps requis pour exécuter le rappel, ou si tous les threads du pool sont en cours d’utilisation et le rappel est en file d’attente plusieurs fois.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph> is a simple, lightweight timer that uses callback methods and is served by thread pool threads.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph> est une minuterie simple et léger qui utilise des méthodes de rappel et est pris en charge par les threads du pool.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>It is not recommended for use with Windows Forms, because its callbacks do not occur on the user interface thread.</source>
          <target state="translated">Il n’est pas recommandé pour une utilisation avec Windows Forms, car ses rappels ne se produisent pas sur le thread d’interface utilisateur.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> is a better choice for use with Windows Forms.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> est un meilleur choix pour une utilisation avec Windows Forms.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>For server-based timer functionality, you might consider using <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, which raises events and has additional features.</source>
          <target state="translated">Pour les fonctionnalités de minuterie serveur, vous pouvez envisager d’utiliser <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, qui déclenche des événements et comporte des fonctionnalités supplémentaires.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The following example defines a <ph id="ph1">`StatusChecker`</ph> class  that includes a <ph id="ph2">`CheckStatus`</ph> method whose signature is the same as the <ph id="ph3">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">L’exemple suivant définit un <ph id="ph1">`StatusChecker`</ph> classe inclut un <ph id="ph2">`CheckStatus`</ph> méthode dont la signature est le même comme le <ph id="ph3">&lt;xref:System.Threading.TimerCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The  <ph id="ph1">`state`</ph> argument of the <ph id="ph2">`CheckStatus`</ph> method is an <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object that is used to synchronize the application thread and the thread pool thread that executes the callback delegate.</source>
          <target state="translated">Le <ph id="ph1">`state`</ph> argument de la <ph id="ph2">`CheckStatus`</ph> méthode est un <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> objet qui est utilisé pour synchroniser le thread d’application et le thread qui exécute le délégué de rappel.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The <ph id="ph1">`StatusChecker`</ph> class also includes two state variables:</source>
          <target state="translated">La <ph id="ph1">`StatusChecker`</ph> classe inclut également deux variables de l’état :</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Indicates the number of times the callback method has been invoked.</source>
          <target state="translated">Indique le nombre de fois où que la méthode de rappel a été appelée.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Determines the maximum number of times the callback method should be invoked.</source>
          <target state="translated">Détermine le nombre maximal de fois où que la méthode de rappel doit être appelée.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The application thread creates the timer, which waits one second and then executes  the <ph id="ph1">`CheckStatus`</ph> callback method every 250 milliseconds.</source>
          <target state="translated">Le thread d’application crée l’horloge, qui attend une seconde, puis exécute la <ph id="ph1">`CheckStatus`</ph> méthode de rappel chaque 250 millisecondes.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The application thread then blocks until the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object is signaled.</source>
          <target state="translated">Puis, le thread d’application se bloque jusqu'à ce que le <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> objet est signalé.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When the <ph id="ph1">`CheckStatus`</ph> callback method executes <ph id="ph2">`maxCount`</ph> times, it calls the <ph id="ph3">`AutoResetEvent.Set`</ph> method to set the state of the <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object to signaled.</source>
          <target state="translated">Lorsque le <ph id="ph1">`CheckStatus`</ph> méthode de rappel s’exécute <ph id="ph2">`maxCount`</ph> fois, il appelle la <ph id="ph3">`AutoResetEvent.Set`</ph> pour définir l’état de la <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> objet signalé.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The first time this happens, the application thread calls the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29&gt;</ph> method so that the callback method now executes every half second.</source>
          <target state="translated">La première fois dans ce cas, le thread d’application appelle la <ph id="ph1">&lt;xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29&gt;</ph> méthode afin que la méthode de rappel s’exécute maintenant chaque seconde moitié.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>It once again blocks until the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object is signaled.</source>
          <target state="translated">Il bloque de nouveau jusqu'à ce que le <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> objet est signalé.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When this happens, the timer is destroyed by calling its <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> method, and the application terminates.</source>
          <target state="translated">Dans ce cas, la minuterie est détruite en appelant son <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> (méthode) et l’application se termine.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>This type is thread safe.</source>
          <target state="translated">Ce type est thread-safe.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> delegate representing a method to be executed.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> représentant une méthode à exécuter.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> class with an infinite period and an infinite due time, using the newly created <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> object as the state object.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> avec une période infinie et un délai d'attente infini, à l'aide de l'objet <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> créé récemment comme objet d'état.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>Call this constructor when you want to use the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> object itself as the state object.</source>
          <target state="translated">Appeler ce constructeur lorsque vous souhaitez utiliser le <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> objet lui-même en tant que l’objet d’état.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>After creating the timer, use the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method to set the interval and due time.</source>
          <target state="translated">Après avoir créé la minuterie, utilisez le <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> pour définir l’intervalle et le délai d’attente.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>This constructor specifies an infinite due time before the first callback and an infinite interval between callbacks, in order to prevent the first callback from occurring before the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> object is assigned to the state object.</source>
          <target state="translated">Ce constructeur spécifie une attente infini avant le premier rappel et un intervalle infini entre les rappels, pour empêcher le premier rappel avant le <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> objet est assigné à l’objet d’état.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">La méthode spécifiée pour <ph id="ph1">`callback`</ph> doit être réentrante, parce qu’elle est appelée sur <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">La méthode peut être exécutée simultanément sur deux threads du pool si l’intervalle de minuterie est inférieur au temps nécessaire à l’exécution de la méthode, ou si tous les threads du pool sont en cours d’utilisation et la méthode est en file d’attente plusieurs fois.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The following code example creates a new timer, using the timer itself as the state object.</source>
          <target state="translated">L’exemple de code suivant crée une minuterie, en utilisant la minuterie comme objet d’état.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method is used to start the timer.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> méthode est utilisée pour démarrer la minuterie.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>When the timer callback occurs, the state object is used to turn the timer off.</source>
          <target state="translated">Lorsque le rappel timer se produit, l’objet d’état est utilisé pour désactiver la minuterie.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> delegate representing a method to be executed.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> représentant une méthode à exécuter.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objet contenant les informations que la méthode de rappel doit utiliser ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The amount of time to delay before <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> is invoked, in milliseconds.</source>
          <target state="translated">Délai d’attente, en millisecondes, avant que <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> soit appelé.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from starting.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> pour empêcher le démarrage de la minuterie.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Spécifiez zéro (0) pour démarrer la minuterie immédiatement.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The time interval between invocations of <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, in milliseconds.</source>
          <target state="translated">Intervalle de temps, en millisecondes, entre les appels de <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> pour désactiver la signalisation périodique.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using a 32-bit signed integer to specify the time interval.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> utilisant un entier signé 32 bits pour spécifier l'intervalle de temps.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">Le délégué spécifié par le <ph id="ph1">`callback`</ph> paramètre est appelé une seule fois après <ph id="ph2">`dueTime`</ph> expiration et par la suite chaque fois que le <ph id="ph3">`period`</ph> expiration de l’intervalle de temps.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est zéro (0), <ph id="ph2">`callback`</ph> est appelé immédiatement.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> n’est pas appelé ; la minuterie est désactivée, mais peut être réactivée en appelant le <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe a la même résolution que l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows 7 et Windows 8, le <ph id="ph2">`callback`</ph> délégué s’exécute à intervalles définis par la résolution de l’horloge système si <ph id="ph3">`period`</ph>est inférieure à la résolution de l’horloge système.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> est zéro (0) ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">`dueTime`</ph> n’est pas <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> est appelé une seule fois ; le comportement périodique de la minuterie est désactivé, mais peut être réactivé à l’aide de la <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">La méthode spécifiée pour <ph id="ph1">`callback`</ph> doit être réentrante, parce qu’elle est appelée sur <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">La méthode peut être exécutée simultanément sur deux threads du pool si l’intervalle de minuterie est inférieur au temps nécessaire à l’exécution de la méthode, ou si tous les threads du pool sont en cours d’utilisation et la méthode est en file d’attente plusieurs fois.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to create a <ph id="ph1">`TimerCallback`</ph> delegate and initialize a new instance of the <ph id="ph2">`Timer`</ph> class.</source>
          <target state="translated">L’exemple de code suivant montre comment créer un <ph id="ph1">`TimerCallback`</ph> déléguer et initialiser une nouvelle instance de la <ph id="ph2">`Timer`</ph> classe.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph> est négatif et différent de <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> delegate representing a method to be executed.</source>
          <target state="translated">Délégué <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> représentant une méthode à exécuter.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objet contenant les informations que la méthode de rappel doit utiliser ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The amount of time to delay before <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> is invoked, in milliseconds.</source>
          <target state="translated">Délai d’attente, en millisecondes, avant que <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> soit appelé.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from starting.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> pour empêcher le démarrage de la minuterie.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Spécifiez zéro (0) pour démarrer la minuterie immédiatement.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The time interval between invocations of <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, in milliseconds.</source>
          <target state="translated">Intervalle de temps, en millisecondes, entre les appels de <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> pour désactiver la signalisation périodique.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using 64-bit signed integers to measure time intervals.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> utilisant des entiers 64 bits signés pour mesurer les intervalles de temps.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">Le délégué spécifié par le <ph id="ph1">`callback`</ph> paramètre est appelé une seule fois après <ph id="ph2">`dueTime`</ph> expiration et par la suite chaque fois que le <ph id="ph3">`period`</ph> expiration de l’intervalle de temps.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est zéro (0), <ph id="ph2">`callback`</ph> est appelé immédiatement.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> n’est pas appelé ; la minuterie est désactivée, mais peut être réactivée en appelant le <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe a la même résolution que l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows 7 et Windows 8, le <ph id="ph2">`callback`</ph> délégué s’exécute à intervalles définis par la résolution de l’horloge système si <ph id="ph3">`period`</ph>est inférieure à la résolution de l’horloge système.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> est zéro (0) ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">`dueTime`</ph> n’est pas <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> est appelé une seule fois ; le comportement périodique de la minuterie est désactivé, mais peut être réactivé à l’aide de la <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">La méthode spécifiée pour <ph id="ph1">`callback`</ph> doit être réentrante, parce qu’elle est appelée sur <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">La méthode peut être exécutée simultanément sur deux threads du pool si l’intervalle de minuterie est inférieur au temps nécessaire à l’exécution de la méthode, ou si tous les threads du pool sont en cours d’utilisation et la méthode est en file d’attente plusieurs fois.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph> est négatif et différent de <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is greater than 4294967294.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph>  est supérieur à 4 294 967 294.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>A delegate representing a method to be executed.</source>
          <target state="translated">Délégué représentant une méthode à exécuter.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objet contenant les informations que la méthode de rappel doit utiliser ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The amount of time to delay before the <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> parameter invokes its methods.</source>
          <target state="translated">Délai d’attente avant que le paramètre <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> appelle ses méthodes.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to prevent the timer from starting.</source>
          <target state="translated">Spécifiez -1 milliseconde pour empêcher le démarrage de la minuterie.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Spécifiez zéro (0) pour démarrer la minuterie immédiatement.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The time interval between invocations of the methods referenced by <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Intervalle de temps entre les appels des méthodes référencées par <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to disable periodic signaling.</source>
          <target state="translated">Spécifiez -1 milliseconde pour désactiver la signalisation périodique.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> values to measure time intervals.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> utilisant des valeurs <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> pour mesurer les intervalles de temps.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">Le délégué spécifié par le <ph id="ph1">`callback`</ph> paramètre est appelé une seule fois après <ph id="ph2">`dueTime`</ph> expiration et par la suite chaque fois que le <ph id="ph3">`period`</ph> expiration de l’intervalle de temps.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est zéro (0), <ph id="ph2">`callback`</ph> est appelé immédiatement.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is negative one (-1) milliseconds, <ph id="ph2">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est négatif (-1) millisecondes, <ph id="ph2">`callback`</ph> n’est pas appelé ; la minuterie est désactivée, mais peut être réactivée en appelant le <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe a la même résolution que l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows 7 et Windows 8, le <ph id="ph2">`callback`</ph> délégué s’exécute à intervalles définis par la résolution de l’horloge système si <ph id="ph3">`period`</ph>est inférieure à la résolution de l’horloge système.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or negative one (-1) milliseconds and <ph id="ph2">`dueTime`</ph> is positive, <ph id="ph3">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> est zéro (0) ou négatif (-1) milliseconde et <ph id="ph2">`dueTime`</ph> est un nombre positif, <ph id="ph3">`callback`</ph> est appelé une seule fois ; le comportement périodique de la minuterie est désactivé, mais peut être réactivé à l’aide de la <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">La méthode spécifiée pour <ph id="ph1">`callback`</ph> doit être réentrante, parce qu’elle est appelée sur <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">La méthode peut être exécutée simultanément sur deux threads du pool si l’intervalle de minuterie est inférieur au temps nécessaire à l’exécution de la méthode, ou si tous les threads du pool sont en cours d’utilisation et la méthode est en file d’attente plusieurs fois.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The following code example shows how to create a <ph id="ph1">`TimerCallback`</ph> delegate and initialize a new instance of the <ph id="ph2">`Timer`</ph> class.</source>
          <target state="translated">L’exemple de code suivant montre comment créer un <ph id="ph1">`TimerCallback`</ph> déléguer et initialiser une nouvelle instance de la <ph id="ph2">`Timer`</ph> classe.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The number of milliseconds in the value of <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> is negative and not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>, or is greater than <ph id="ph4">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Le nombre de millisecondes indiqué dans la valeur de <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou de <ph id="ph2">&lt;paramref name="period" /&gt;</ph> est négatif et différent de <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> ou est supérieur à <ph id="ph4">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>A delegate representing a method to be executed.</source>
          <target state="translated">Délégué représentant une méthode à exécuter.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objet contenant les informations que la méthode de rappel doit utiliser ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The amount of time to delay before <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> is invoked, in milliseconds.</source>
          <target state="translated">Délai d’attente, en millisecondes, avant que <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> soit appelé.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from starting.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> pour empêcher le démarrage de la minuterie.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Spécifiez zéro (0) pour démarrer la minuterie immédiatement.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The time interval between invocations of <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, in milliseconds.</source>
          <target state="translated">Intervalle de temps, en millisecondes, entre les appels de <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> pour désactiver la signalisation périodique.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using 32-bit unsigned integers to measure time intervals.</source>
          <target state="translated">Initialise une nouvelle instance de la classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> utilisant des entiers 32 bits non signés pour mesurer les intervalles de temps.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">Le délégué spécifié par le <ph id="ph1">`callback`</ph> paramètre est appelé une seule fois après <ph id="ph2">`dueTime`</ph> expiration et par la suite chaque fois que le <ph id="ph3">`period`</ph> expiration de l’intervalle de temps.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est zéro (0), <ph id="ph2">`callback`</ph> est appelé immédiatement.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> n’est pas appelé ; la minuterie est désactivée, mais peut être réactivée en appelant le <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Étant donné que la <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe a la même résolution que l’horloge système, qui est d’environ 15 millisecondes sur les systèmes Windows 7 et Windows 8, le <ph id="ph2">`callback`</ph> délégué s’exécute à intervalles définis par la résolution de l’horloge système si <ph id="ph3">`period`</ph>est inférieure à la résolution de l’horloge système.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> est zéro (0) ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> et <ph id="ph3">`dueTime`</ph> n’est pas <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> est appelé une seule fois ; le comportement périodique de la minuterie est désactivé, mais peut être réactivé à l’aide de la <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">La méthode spécifiée pour <ph id="ph1">`callback`</ph> doit être réentrante, parce qu’elle est appelée sur <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">La méthode peut être exécutée simultanément sur deux threads du pool si l’intervalle de minuterie est inférieur au temps nécessaire à l’exécution de la méthode, ou si tous les threads du pool sont en cours d’utilisation et la méthode est en file d’attente plusieurs fois.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph> est négatif et différent de <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Changes the start time and the interval between method invocations for a timer.</source>
          <target state="translated">Modifie l'heure de début et l'intervalle entre les appels de méthode d'une minuterie.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The amount of time to delay before the invoking the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Délai d'attente, en millisecondes, avant l'appel de la méthode de rappel spécifiée au moment de la construction de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from restarting.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> pour empêcher le redémarrage de la minuterie.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Spécifiez zéro (0) pour redémarrer la minuterie immédiatement.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Intervalle de temps, en millisecondes, entre les appels de la méthode de rappel spécifiée au moment de la construction de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> pour désactiver la signalisation périodique.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Changes the start time and the interval between method invocations for a timer, using 32-bit signed integers to measure time intervals.</source>
          <target state="translated">Modifie l'heure de début et l'intervalle entre les appels de méthode d'une minuterie ; les intervalles de temps sont mesurés à l'aide d'entiers 32 bits signés.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le minuteur a été correctement mis à jour ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">La méthode de rappel est appelée une seule fois après <ph id="ph1">`dueTime`</ph> expiration, puis chaque fois que l’intervalle de temps spécifié par <ph id="ph2">`period`</ph> s’écoule.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est zéro (0), la méthode de rappel est appelée immédiatement.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph4">`dueTime`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, la méthode de rappel n’est jamais appelée ; la minuterie est désactivée, mais peut être réactivé en appelant <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> et en spécifiant une valeur positive pour <ph id="ph4">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph6">`period`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> est zéro (0) ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, et <ph id="ph3">`dueTime`</ph> n’est pas <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, la méthode de rappel est appelée une seule fois ; le comportement périodique de la minuterie est désactivé, mais peut être réactivé en appelant <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> et en spécifiant une valeur positive pour <ph id="ph6">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> méthode peut être appelée à partir de la <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The following code example demonstrates how to start a <ph id="ph1">`Timer`</ph> and, after a set number of invocations, change its period.</source>
          <target state="translated">L’exemple de code suivant montre comment démarrer un <ph id="ph1">`Timer`</ph> et, après un nombre défini d’appels, modifier sa période.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph> est négatif et différent de <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The amount of time to delay before the invoking the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Délai d'attente, en millisecondes, avant l'appel de la méthode de rappel spécifiée au moment de la construction de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from restarting.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> pour empêcher le redémarrage de la minuterie.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Spécifiez zéro (0) pour redémarrer la minuterie immédiatement.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Intervalle de temps, en millisecondes, entre les appels de la méthode de rappel spécifiée au moment de la construction de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> pour désactiver la signalisation périodique.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Changes the start time and the interval between method invocations for a timer, using 64-bit signed integers to measure time intervals.</source>
          <target state="translated">Modifie l'heure de début et l'intervalle entre les appels de méthode d'une minuterie ; les intervalles de temps sont mesurés à l'aide d'entiers 64 bits signés.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le minuteur a été correctement mis à jour ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">La méthode de rappel est appelée une seule fois après <ph id="ph1">`dueTime`</ph> expiration, puis chaque fois que l’intervalle de temps spécifié par <ph id="ph2">`period`</ph> s’écoule.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est zéro (0), la méthode de rappel est appelée immédiatement.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph4">`dueTime`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, la méthode de rappel n’est jamais appelée ; la minuterie est désactivée, mais peut être réactivé en appelant <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> et en spécifiant une valeur positive pour <ph id="ph4">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph6">`period`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> est zéro (0) ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, et <ph id="ph3">`dueTime`</ph> n’est pas <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, la méthode de rappel est appelée une seule fois ; le comportement périodique de la minuterie est désactivé, mais peut être réactivé en appelant <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> et en spécifiant une valeur positive pour <ph id="ph6">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> méthode peut être appelée à partir de la <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is less than -1.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph>  est inférieur à -1.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is greater than 4294967294.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph>  est supérieur à 4 294 967 294.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to delay before invoking the callback method specified when the <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> représentant le délai d'attente avant l'appel de la méthode de rappel spécifiée au moment de la construction de <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to prevent the timer from restarting.</source>
          <target state="translated">Spécifiez -1 milliseconde pour empêcher le démarrage de la minuterie.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Spécifiez zéro (0) pour redémarrer la minuterie immédiatement.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed.</source>
          <target state="translated">Intervalle de temps entre les appels de la méthode de rappel spécifiée au moment de la construction de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to disable periodic signaling.</source>
          <target state="translated">Spécifiez -1 milliseconde pour désactiver la signalisation périodique.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Changes the start time and the interval between method invocations for a timer, using <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> values to measure time intervals.</source>
          <target state="translated">Modifie l'heure de début et l'intervalle entre les appels de méthode d'une minuterie ; les intervalles de temps sont mesurés à l'aide de valeurs <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le minuteur a été correctement mis à jour ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">La méthode de rappel est appelée une seule fois après <ph id="ph1">`dueTime`</ph> expiration, puis chaque fois que l’intervalle de temps spécifié par <ph id="ph2">`period`</ph> s’écoule.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est zéro (0), la méthode de rappel est appelée immédiatement.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is negative one (-1) milliseconds, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph2">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph3">`dueTime`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est millisecondes négatif (-1), la méthode de rappel n’est jamais appelée ; la minuterie est désactivée, mais peut être réactivé en appelant <ph id="ph2">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> et en spécifiant une valeur positive pour <ph id="ph3">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or negative one (-1) milliseconds, and <ph id="ph2">`dueTime`</ph> is positive, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a value greater than zero for <ph id="ph4">`period`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> est zéro (0) ou négatif (-1) millisecondes, et <ph id="ph2">`dueTime`</ph> est un nombre positif, la méthode de rappel est appelée une seule fois ; le comportement périodique de la minuterie est désactivé, mais peut être réactivé en appelant <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> et en spécifiant une valeur supérieure à zéro pour <ph id="ph4">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> méthode peut être appelée à partir de la <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The following code example demonstrates how to start a <ph id="ph1">`Timer`</ph> and, after a set number of invocations, change its period.</source>
          <target state="translated">L’exemple de code suivant montre comment démarrer un <ph id="ph1">`Timer`</ph> et, après un nombre défini d’appels, modifier sa période.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter, in milliseconds, is less than -1.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph>, exprimé en millisecondes, est inférieur à -1.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter, in milliseconds, is greater than 4294967294.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph>, exprimé en millisecondes, est supérieur à 4294967294.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The amount of time to delay before the invoking the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Délai d'attente, en millisecondes, avant l'appel de la méthode de rappel spécifiée au moment de la construction de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from restarting.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> pour empêcher le redémarrage de la minuterie.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Spécifiez zéro (0) pour redémarrer la minuterie immédiatement.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Intervalle de temps, en millisecondes, entre les appels de la méthode de rappel spécifiée au moment de la construction de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Spécifiez <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> pour désactiver la signalisation périodique.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Changes the start time and the interval between method invocations for a timer, using 32-bit unsigned integers to measure time intervals.</source>
          <target state="translated">Modifie l'heure de début et l'intervalle entre les appels de méthode d'une minuterie ; les intervalles de temps sont mesurés à l'aide d'entiers 32 bits non signés.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si le minuteur a été correctement mis à jour ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">La méthode de rappel est appelée une seule fois après <ph id="ph1">`dueTime`</ph> expiration, puis chaque fois que l’intervalle de temps spécifié par <ph id="ph2">`period`</ph> s’écoule.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est zéro (0), la méthode de rappel est appelée immédiatement.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph4">`dueTime`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> est <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, la méthode de rappel n’est jamais appelée ; la minuterie est désactivée, mais peut être réactivé en appelant <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> et en spécifiant une valeur positive pour <ph id="ph4">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph6">`period`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> est zéro (0) ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, et <ph id="ph3">`dueTime`</ph> n’est pas <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, la méthode de rappel est appelée une seule fois ; le comportement périodique de la minuterie est désactivé, mais peut être réactivé en appelant <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> et en spécifiant une valeur positive pour <ph id="ph6">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">Le <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> méthode peut être appelée à partir de la <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> déléguer.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> a déjà été supprimé.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Releases all resources used by the current instance of <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</source>
          <target state="translated">Libère toutes les ressources utilisées par l'instance actuelle de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose">
          <source>Releases all resources used by the current instance of <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</source>
          <target state="translated">Libère toutes les ressources utilisées par l'instance actuelle de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>Calling <ph id="ph1">`Dispose`</ph> allows the resources used by the <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> to be reallocated for other purposes.</source>
          <target state="translated">Appel de <ph id="ph1">`Dispose`</ph> autorise les ressources utilisées par le <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> à être réaffectés à d’autres fins.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>For more information about <ph id="ph1">`Dispose`</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`Dispose`</ph>, consultez <bpt id="p1">[</bpt>de nettoyage des ressources non managées<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>Callbacks can occur after the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> method overload has been called, because the timer queues callbacks for execution by thread pool threads.</source>
          <target state="translated">Rappels peuvent se produire après la <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> surcharge de méthode a été appelée, car le minuteur de files d’attente des rappels pour l’exécution par les threads du pool.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload to wait until all callbacks have completed.</source>
          <target state="translated">Vous pouvez utiliser la <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> la surcharge de méthode pour attendre que tous les rappels.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>The following code example shows how to free the resources held by a <ph id="ph1">`Timer`</ph>.</source>
          <target state="translated">L’exemple de code suivant montre comment libérer les ressources détenues par un <ph id="ph1">`Timer`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> to be signaled when the <ph id="ph2">&lt;see langword="Timer" /&gt;</ph> has been disposed of.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> à signaler lorsque <ph id="ph2">&lt;see langword="Timer" /&gt;</ph> a été supprimé.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>Releases all resources used by the current instance of <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> and signals when the timer has been disposed of.</source>
          <target state="translated">Libère toutes les ressources utilisées par l'instance actuelle de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> et signale le moment où la minuterie a été supprimée.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the function succeeds; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la fonction aboutit ; sinon, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>Calling <ph id="ph1">`Dispose`</ph> allows the resources used by the <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> to be reallocated for other purposes.</source>
          <target state="translated">Appel de <ph id="ph1">`Dispose`</ph> autorise les ressources utilisées par le <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> à être réaffectés à d’autres fins.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>For more information about <ph id="ph1">`Dispose`</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Pour plus d’informations sur <ph id="ph1">`Dispose`</ph>, consultez <bpt id="p1">[</bpt>de nettoyage des ressources non managées<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>When this method completes, it signals the <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> specified by the <ph id="ph2">`notifyObject`</ph> parameter.Use this overload of the <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> method if you want to be able to block until you are certain that the timer has been disposed.</source>
          <target state="translated">Quand cette méthode se termine, il signale le <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> spécifié par le <ph id="ph2">`notifyObject`</ph> paramètre. Utilisez cette surcharge de la <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> méthode si vous souhaitez être en mesure de bloquer jusqu'à ce que vous êtes certain que la minuterie a été supprimée.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>The timer is not disposed until all currently queued callbacks have completed.</source>
          <target state="translated">La minuterie n’est pas supprimée jusqu'à ce que tous les rappels actuellement en file d’attente s’est terminé.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>If the callback uses the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method to set the <ph id="ph2">`dueTime`</ph> parameter to zero, a race condition can occur when the <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload is called: If the timer queues a new callback before the <ph id="ph4">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload detects that there are no callbacks queued, <ph id="ph5">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> continues to block; otherwise, the timer is disposed while the new callback is being queued, and an <ph id="ph6">&lt;xref:System.ObjectDisposedException&gt;</ph> is thrown when the new callback calls the <ph id="ph7">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si le rappel utilise le <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> pour définir le <ph id="ph2">`dueTime`</ph> paramètre zéro, une condition de concurrence peut se produire lorsque le <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> surcharge de méthode est appelée : si la minuterie des files d’attente un nouveau rappel avant que le <ph id="ph4">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> surcharge de méthode détecte qu’il aucun rappel n’est en attente, <ph id="ph5">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> continue à bloquer ; sinon, la minuterie est supprimée pendant le rappel nouvelle est en file d’attente et qu’un <ph id="ph6">&lt;xref:System.ObjectDisposedException&gt;</ph> est levée lorsque le nouveau rappel appelle le <ph id="ph7">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> (méthode).</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>The <ph id="ph1">&lt;paramref name="notifyObject" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Le paramètre <ph id="ph1">&lt;paramref name="notifyObject" /&gt;</ph> a la valeur <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>