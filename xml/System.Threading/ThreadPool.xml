<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9f9c9e42dff8e89feb11010c57e7d17bc9b44648" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48675425" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="a1375-101">Fournit un pool de threads qui peuvent servir à exécuter des tâches, publier des éléments de travail, traiter des E/S asynchrones, attendre au nom d’autres threads et traiter des minuteries.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a1375-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-102">De nombreuses applications créent des threads qui consacrent beaucoup de temps en état de veille, en attente pour un événement se produise.</span><span class="sxs-lookup"><span data-stu-id="a1375-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="a1375-103">Autres threads peuvent entrer en état de veille uniquement pour être réactivés interroger pour une modification ou de mettre à jour les informations d’état.</span><span class="sxs-lookup"><span data-stu-id="a1375-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="a1375-104">Le pool de threads vous permet d’utiliser des threads plus efficacement en fournissant votre application avec un pool de threads de travail qui sont gérés par le système.</span><span class="sxs-lookup"><span data-stu-id="a1375-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="a1375-105">Exemples d’opérations qui utilisent des threads de pool sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="a1375-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="a1375-106">Lorsque vous créez un <xref:System.Threading.Tasks.Task> ou <xref:System.Threading.Tasks.Task%601> objet pour effectuer une tâche de façon asynchrone, par défaut, la tâche est planifiée pour s’exécuter sur un thread de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="a1375-107">Les minuteries asynchrones utilisent le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="a1375-108">Thread du pool de threads exécutent des rappels de la <xref:System.Threading.Timer?displayProperty=nameWithType> classe et déclencher des événements à partir de la <xref:System.Timers.Timer?displayProperty=nameWithType> classe.</span><span class="sxs-lookup"><span data-stu-id="a1375-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="a1375-109">Lorsque vous utilisez des handles d’attente inscrite, un thread système analyse l’état des handles d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="a1375-110">Lorsqu’une opération d’attente se termine, un thread de travail du pool de threads exécute la fonction de rappel correspondante.</span><span class="sxs-lookup"><span data-stu-id="a1375-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="a1375-111">Lorsque vous appelez le <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> méthode en file d’attente d’une méthode pour une exécution sur un thread de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="a1375-112">Pour ce faire, en passant la méthode un <xref:System.Threading.WaitCallback> déléguer.</span><span class="sxs-lookup"><span data-stu-id="a1375-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="a1375-113">Le délégué a la signature</span><span class="sxs-lookup"><span data-stu-id="a1375-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="a1375-114">où `state` est un objet qui contient les données à utiliser par le délégué.</span><span class="sxs-lookup"><span data-stu-id="a1375-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="a1375-115">Les données réelles qui peuvent être passées au délégué en appelant le <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a1375-116">Les threads dans le pool de threads managés sont des threads d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="a1375-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="a1375-117">Autrement dit, leur <xref:System.Threading.Thread.IsBackground%2A> propriétés sont `true`.</span><span class="sxs-lookup"><span data-stu-id="a1375-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="a1375-118">Cela signifie qu’un <xref:System.Threading.ThreadPool> thread ne garde pas une application en cours d’exécution une fois que tous les threads de premier plan ont quitté.</span><span class="sxs-lookup"><span data-stu-id="a1375-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a1375-119">Lorsque le pool de threads réutilise un thread, il n’efface pas les données dans le stockage local des threads ou dans les champs marqués avec le <xref:System.ThreadStaticAttribute> attribut.</span><span class="sxs-lookup"><span data-stu-id="a1375-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="a1375-120">Par conséquent, quand une méthode examine le stockage local des threads ou les champs sont marqués avec le <xref:System.ThreadStaticAttribute> attribut, les valeurs qu’il trouve peuvent subsister à partir d’une utilisation antérieure du thread du pool.</span><span class="sxs-lookup"><span data-stu-id="a1375-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="a1375-121">Vous pouvez également mettre en file d’attente des éléments de travail qui ne sont pas liées à une opération d’attente pour le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="a1375-122">Pour demander qu’un élément de travail soit géré par un thread dans le pool de threads, appelez le <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="a1375-123">Cette méthode prend comme paramètre une référence à la méthode ou un délégué qui sera appelée par le thread sélectionné dans le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="a1375-124">Il n’existe aucun moyen d’annuler un élément de travail une fois qu’il a été mis en attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="a1375-125">Minuteries de la file d’attente du minuteur et les opérations d’attente inscrites utilisent également le pool de thread.</span><span class="sxs-lookup"><span data-stu-id="a1375-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="a1375-126">Leurs fonctions de rappel sont en file d’attente pour le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="a1375-127">Il existe un pool de threads par processus.</span><span class="sxs-lookup"><span data-stu-id="a1375-127">There is one thread pool per process.</span></span> <span data-ttu-id="a1375-128">Dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] et versions ultérieures, la taille par défaut du pool de threads d'un processus dépend de plusieurs facteurs, dont la taille de l'espace d'adressage virtuel.</span><span class="sxs-lookup"><span data-stu-id="a1375-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="a1375-129">Un processus peut appeler la méthode <xref:System.Threading.ThreadPool.GetMaxThreads%2A> pour déterminer le nombre de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="a1375-130">Le nombre de threads du pool de threads peut être modifié à l’aide de la <xref:System.Threading.ThreadPool.SetMaxThreads%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="a1375-131">Chaque thread utilise la taille de pile par défaut et s’exécute à la priorité par défaut.</span><span class="sxs-lookup"><span data-stu-id="a1375-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a1375-132">Code non managé qui héberge le .NET Framework peut modifier la taille du pool de threads à l’aide de la `CorSetMaxThreads` fonction, définie dans le fichier mscoree.h.</span><span class="sxs-lookup"><span data-stu-id="a1375-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="a1375-133">Le pool de threads fournit de nouveaux threads de travail ou des threads de terminaison d’e/s à la demande jusqu'à ce qu’il atteigne la valeur minimale pour chaque catégorie.</span><span class="sxs-lookup"><span data-stu-id="a1375-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="a1375-134">Lorsqu’une valeur minimale est atteinte, le pool de threads peut créer des threads supplémentaires dans cette catégorie ou attendre que certaines tâches soient terminées.</span><span class="sxs-lookup"><span data-stu-id="a1375-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="a1375-135">Dans [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] et versions ultérieures, le pool de threads crée et détruit des threads de travail pour optimiser le débit, qui est défini comme le nombre de tâches exécutées par unité de temps.</span><span class="sxs-lookup"><span data-stu-id="a1375-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="a1375-136">Un nombre trop bas de threads peut ne pas permettre une utilisation optimale des ressources disponibles, tandis qu'un nombre trop élevé de threads peut augmenter les conflits de ressources.</span><span class="sxs-lookup"><span data-stu-id="a1375-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a1375-137">Quand la demande est faible, le nombre réel de threads du pool peut être inférieur aux valeurs minimales.</span><span class="sxs-lookup"><span data-stu-id="a1375-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="a1375-138">Vous pouvez utiliser la méthode <xref:System.Threading.ThreadPool.GetMinThreads%2A> pour obtenir ces valeurs minimales.</span><span class="sxs-lookup"><span data-stu-id="a1375-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a1375-139">Vous pouvez utiliser la <xref:System.Threading.ThreadPool.SetMinThreads%2A> méthode pour augmenter le nombre minimal de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="a1375-140">Toutefois, une augmentation non nécessaire de ces valeurs peut entraîner des problèmes de performances.</span><span class="sxs-lookup"><span data-stu-id="a1375-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="a1375-141">Si vous démarrez trop de tâches en même temps, celles-ci seront lentes.</span><span class="sxs-lookup"><span data-stu-id="a1375-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="a1375-142">Dans la plupart des cas, le pool de threads sera plus performant avec son propre algorithme d'allocation de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1375-143">Dans l’exemple suivant, le thread principal de l’application files d’attente une méthode nommée `ThreadProc` à exécuter sur un thread, en veille pendant une seconde et puis se ferme.</span><span class="sxs-lookup"><span data-stu-id="a1375-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="a1375-144">Le `ThreadProc` méthode affiche simplement un message.</span><span class="sxs-lookup"><span data-stu-id="a1375-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="a1375-145">Si vous commentez l’appel à la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> (méthode), le thread principal s’arrête avant que la méthode s’exécute sur le thread de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="a1375-146">Le pool de threads utilise des threads d’arrière-plan qui arrêtent l’application en cours d’exécution si tous les threads de premier plan sont terminés.</span><span class="sxs-lookup"><span data-stu-id="a1375-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="a1375-147">(Il s’agit d’un exemple simple d’une condition de concurrence.)</span><span class="sxs-lookup"><span data-stu-id="a1375-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="a1375-148">Ce type est thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a1375-148">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
      <span data-ttu-id="a1375-149">Threads et threading</span>
      <span class="sxs-lookup">
        <span data-stu-id="a1375-149">Threads and Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
      <span data-ttu-id="a1375-150">Le regroupement de threads managés</span>
      <span class="sxs-lookup">
        <span data-stu-id="a1375-150">The Managed Thread Pooling</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a1375-151">Lie un handle de système d'exploitation à <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-151">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="a1375-152">
            <see cref="T:System.IntPtr" /> qui contient le handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-152">An <see cref="T:System.IntPtr" /> that holds the handle.</span>
          </span>
          <span data-ttu-id="a1375-153">Il faut que le handle ait été ouvert pour des E/S avec chevauchement du côté non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-153">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-154">Lie un handle de système d'exploitation à <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-154">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-155">
            <see langword="true" /> si le handle est lié ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-155">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="a1375-156">L'appelant n'a pas l'autorisation requise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-156">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="a1375-157">pour avoir la possibilité d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-157">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="a1375-158">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-158">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="a1375-159">
            <see cref="T:System.Runtime.InteropServices.SafeHandle" /> qui contient le handle du système d'exploitation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-159">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span>
          </span>
          <span data-ttu-id="a1375-160">Il faut que le handle ait été ouvert pour des E/S avec chevauchement du côté non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-160">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-161">Lie un handle de système d'exploitation à <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-161">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-162">
            <see langword="true" /> si le handle est lié ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-162">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-163">Le `osHandle` paramètre doit être un <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, qui dérive de la classe abstraite <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="a1375-163">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a1375-164">
            <paramref name="osHandle" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-164">
              <paramref name="osHandle" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="a1375-165">pour avoir la possibilité d’appeler du code non managé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-165">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="a1375-166">Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-166">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="a1375-167">Nombre de threads de travail disponibles.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-167">The number of available worker threads.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="a1375-168">Nombre de threads d'E/S asynchrones disponibles.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-168">The number of available asynchronous I/O threads.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-169">Récupère la différence entre le nombre maximal de threads du pool retourné par la méthode <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> et le nombre actuel de threads actifs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-169">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-170">Lorsque <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> est retournée, la variable spécifiée par `workerThreads` contient le nombre de threads de travail supplémentaires qui peuvent être démarrés et la variable spécifiée par `completionPortThreads` contient le nombre de threads d’e/s asynchrones qui peuvent être démarré.</span><span class="sxs-lookup"><span data-stu-id="a1375-170">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="a1375-171">S’il n’existe aucun thread disponible, les demandes de pool de thread supplémentaire restent en file d’attente jusqu'à ce que les threads du pool deviennent disponibles.</span><span class="sxs-lookup"><span data-stu-id="a1375-171">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1375-172">L’exemple suivant affiche le nombre de threads de travail et de threads d’e/s disponibles au démarrage d’une application simple.</span><span class="sxs-lookup"><span data-stu-id="a1375-172">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="a1375-173">Nombre maximal de threads de travail dans le pool de threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-173">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="a1375-174">Nombre maximal de threads d'E/S asynchrones dans le pool de threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-174">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-175">Récupère le nombre de demandes au pool de threads pouvant être simultanément actives.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-175">Retrieves the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="a1375-176">Toutes les demandes excédant ce nombre restent dans la file d'attente jusqu'à ce que des threads du pool soient disponibles.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-176">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-177">Lorsque <xref:System.Threading.ThreadPool.GetMaxThreads%2A> est retournée, la variable spécifiée par `workerThreads` contient le nombre maximal de threads de travail autorisés dans le pool de threads et la variable spécifiée par `completionPortThreads` contient le nombre maximal de threads d’e/s asynchrones autorisés dans le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-177">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="a1375-178">Vous pouvez utiliser la <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> méthode pour déterminer le nombre réel de threads dans le pool de threads à un moment donné.</span><span class="sxs-lookup"><span data-stu-id="a1375-178">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="a1375-179">Vous pouvez utiliser la <xref:System.Threading.ThreadPool.SetMaxThreads%2A> pour définir le nombre maximal de threads de travail et les threads d’e/s asynchrones dans le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-179">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="a1375-180">Vous pouvez en file d’attente comme grand nombre de demandes de pool de threads comme la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="a1375-180">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="a1375-181">S’il existe plus de requêtes que les threads du pool, les demandes supplémentaires sont en file d’attente jusqu'à ce que les threads du pool deviennent disponibles.</span><span class="sxs-lookup"><span data-stu-id="a1375-181">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1375-182">L’exemple de code suivant montre comment récupérer le nombre maximal et disponible de threads dans le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-182">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="a1375-183">Un élément de travail est en attente qui utilise `FileStream` pour l’écriture asynchrone dans deux fichiers.</span><span class="sxs-lookup"><span data-stu-id="a1375-183">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="a1375-184">Les méthodes de rappel sont programmées pour se chevaucher.</span><span class="sxs-lookup"><span data-stu-id="a1375-184">The callback methods are timed to overlap.</span></span> <span data-ttu-id="a1375-185">Un thread de travail gère l’élément de travail et, selon la vitesse et le nombre de processeurs sur l’ordinateur, un ou deux threads de port de terminaison gèrent les opérations d’écriture.</span><span class="sxs-lookup"><span data-stu-id="a1375-185">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="a1375-186">Lorsque cette méthode est retournée, contient le nombre minimal de threads de travail que le pool de threads crée à la demande.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-186">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="a1375-187">Lorsque cette méthode est retournée, contient le nombre minimal de threads d'E/S asynchrones que le pool de threads crée à la demande.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-187">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-188">Récupère le nombre minimal de threads que le pool de threads crée à la demande, au fur et à mesure que de nouvelles requêtes sont effectuées, avant de basculer sur un algorithme pour la gestion de la création et de la suppression des threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-188">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-189">Le pool de threads fournit de nouveaux threads de travail ou des threads de terminaison d’e/s à la demande jusqu'à ce qu’il atteigne la valeur minimale pour chaque catégorie.</span><span class="sxs-lookup"><span data-stu-id="a1375-189">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="a1375-190">Le nombre minimal de threads a la valeur par défaut, le nombre de processeurs sur un système.</span><span class="sxs-lookup"><span data-stu-id="a1375-190">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="a1375-191">Lorsque la valeur minimale est atteinte, le pool de threads peut créer des threads supplémentaires dans cette catégorie ou attendre que certaines tâches soient terminées.</span><span class="sxs-lookup"><span data-stu-id="a1375-191">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="a1375-192">Compter les [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], le pool de threads crée et détruit des threads pour optimiser le débit, ce qui est défini comme le nombre de tâches exécutées par unité de temps.</span><span class="sxs-lookup"><span data-stu-id="a1375-192">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="a1375-193">Un nombre trop bas de threads peut ne pas permettre une utilisation optimale des ressources disponibles, tandis qu'un nombre trop élevé de threads peut augmenter les conflits de ressources.</span><span class="sxs-lookup"><span data-stu-id="a1375-193">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a1375-194">Quand la demande est faible, le nombre réel de threads du pool peut être inférieur aux valeurs minimales.</span><span class="sxs-lookup"><span data-stu-id="a1375-194">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1375-195">L’exemple suivant définit le nombre minimal de threads de travail à quatre et conserve la valeur d’origine pour le nombre minimal de threads d’achèvement d’e/s asynchrones.</span><span class="sxs-lookup"><span data-stu-id="a1375-195">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a1375-196">Place une méthode en file d'attente pour exécution.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-196">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="a1375-197">La méthode s'exécute lorsqu'un thread du pool devient disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-197">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="a1375-198">
            <see cref="T:System.Threading.WaitCallback" /> qui représente la méthode à exécuter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-198">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-199">Place une méthode en file d'attente pour exécution.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-199">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="a1375-200">La méthode s'exécute lorsqu'un thread du pool devient disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-200">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-201">
            <see langword="true" /> si la méthode est placée en file d'attente avec succès ; <see cref="T:System.NotSupportedException" /> est levé si l'élément de travail n'a pas pu être placé en file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-201">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-202">Vous pouvez placer les données requises par la méthode en file d’attente dans les champs d’instance de la classe dans laquelle la méthode est définie, ou vous pouvez utiliser le <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> surcharge qui accepte un objet contenant les données nécessaires.</span><span class="sxs-lookup"><span data-stu-id="a1375-202">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a1375-203">Les utilisateurs de Visual Basic peuvent omettre le <xref:System.Threading.WaitCallback> constructeur et utiliser simplement le `AddressOf` opérateur lors du passage de la méthode de rappel à <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="a1375-203">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="a1375-204">Visual Basic appelle automatiquement le constructeur délégué approprié.</span><span class="sxs-lookup"><span data-stu-id="a1375-204">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="a1375-205">Informations sur la version</span><span class="sxs-lookup"><span data-stu-id="a1375-205">Version Information</span></span>  
 <span data-ttu-id="a1375-206">Dans le .NET Framework version 2.0, le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valeur de propriété est propagée aux threads de travail en file d’attente à l’aide de la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-206">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="a1375-207">Dans les versions antérieures, les informations du principal ne sont pas propagées.</span><span class="sxs-lookup"><span data-stu-id="a1375-207">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1375-208">L’exemple suivant utilise le <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> surcharge de méthode en file d’attente une tâche, qui est représentée par la `ThreadProc` méthode, à exécuter lorsqu’un thread devient disponible.</span><span class="sxs-lookup"><span data-stu-id="a1375-208">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="a1375-209">Aucune information de tâche n’est fournie avec cette surcharge.</span><span class="sxs-lookup"><span data-stu-id="a1375-209">No task information is supplied with this overload.</span></span> <span data-ttu-id="a1375-210">Par conséquent, les informations qui est disponibles pour le `ThreadProc` méthode est limitée à l’objet auquel appartient la méthode.</span><span class="sxs-lookup"><span data-stu-id="a1375-210">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a1375-211">
            <paramref name="callBack" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-211">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a1375-212">Le Common Language Runtime (CLR) est hébergé et l'hôte ne prend pas en charge cette action.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-212">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="a1375-213">Pool de threads managés</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-213">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="a1375-214">
            <see cref="T:System.Threading.WaitCallback" /> représentant la méthode à exécuter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-214">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="a1375-215">Objet contenant les données que la méthode doit utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-215">An object containing data to be used by the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-216">Place une méthode en file d'attente pour exécution et spécifie un objet contenant les données que la méthode doit utiliser.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-216">Queues a method for execution, and specifies an object containing data to be used by the method.</span>
          </span>
          <span data-ttu-id="a1375-217">La méthode s'exécute lorsqu'un thread du pool devient disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-217">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-218">
            <see langword="true" /> si la méthode est placée en file d'attente avec succès ; <see cref="T:System.NotSupportedException" /> est levé si l'élément de travail n'a pas pu être placé en file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-218">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-219">Si la méthode de rappel requiert des données complexes, vous pouvez définir une classe pour contenir les données.</span><span class="sxs-lookup"><span data-stu-id="a1375-219">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a1375-220">Les utilisateurs de Visual Basic peuvent omettre le <xref:System.Threading.WaitCallback> constructeur et utiliser simplement le `AddressOf` opérateur lors du passage de la méthode de rappel à <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="a1375-220">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="a1375-221">Visual Basic appelle automatiquement le constructeur délégué approprié.</span><span class="sxs-lookup"><span data-stu-id="a1375-221">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="a1375-222">Informations sur la version</span><span class="sxs-lookup"><span data-stu-id="a1375-222">Version Information</span></span>  
 <span data-ttu-id="a1375-223">Dans le .NET Framework version 2.0, le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valeur de propriété est propagée aux threads de travail en file d’attente à l’aide de la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-223">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="a1375-224">Dans les versions antérieures, les informations du principal ne sont pas propagées.</span><span class="sxs-lookup"><span data-stu-id="a1375-224">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1375-225">L’exemple suivant utilise le pool de threads .NET pour calculer le `Fibonacci` résultat pour cinq des nombres compris entre 20 et 40.</span><span class="sxs-lookup"><span data-stu-id="a1375-225">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="a1375-226">Chaque résultat `Fibonacci` est représenté par la classe `Fibonacci`, qui fournit une méthode nommée `ThreadPoolCallback` qui effectue le calcul.</span><span class="sxs-lookup"><span data-stu-id="a1375-226">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="a1375-227">Un objet représentant chaque valeur `Fibonacci` est créé, et la méthode `ThreadPoolCallback` est passée à <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, qui assigne un thread disponible du pool pour exécuter la méthode.</span><span class="sxs-lookup"><span data-stu-id="a1375-227">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="a1375-228">Étant donné que chaque `Fibonacci` objet se voit attribuer une valeur semi-aléatoire à calculer, et étant donné que chaque thread est en concurrence pour le temps processeur, vous ne pouvez pas savoir à l’avance la durée pour toutes les cinq résultats doit être calculée.</span><span class="sxs-lookup"><span data-stu-id="a1375-228">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="a1375-229">C’est pourquoi chaque objet `Fibonacci` reçoit une instance de la classe <xref:System.Threading.ManualResetEvent> pendant la construction.</span><span class="sxs-lookup"><span data-stu-id="a1375-229">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="a1375-230">Chaque objet signale à l’objet d’événement fourni quand son calcul est terminé, ce qui permet au thread principal de bloquer l’exécution avec <xref:System.Threading.WaitHandle.WaitAll%2A> jusqu'à ce que toutes les cinq `Fibonacci` objets aient calculé un résultat.</span><span class="sxs-lookup"><span data-stu-id="a1375-230">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="a1375-231">La méthode `Main` affiche ensuite chaque résultat `Fibonacci`.</span><span class="sxs-lookup"><span data-stu-id="a1375-231">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a1375-232">Le Common Language Runtime (CLR) est hébergé et l'hôte ne prend pas en charge cette action.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-232">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a1375-233">
            <paramref name="callBack" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-233">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="a1375-234">Pool de threads managés</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-234">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a1375-235">Inscrit un délégué en attente de <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-235">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="a1375-236">
            <see cref="T:System.Threading.WaitHandle" /> à inscrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-236">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="a1375-237">Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-237">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="a1375-238">Délégué <see cref="T:System.Threading.WaitOrTimerCallback" /> à appeler quand le paramètre <c>waitObject</c> est signalé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-238">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="a1375-239">Objet passé au délégué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-239">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="a1375-240">Délai en millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-240">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="a1375-241">Si le paramètre <c>millisecondsTimeOutInterval</c> a la valeur zéro (0), la fonction teste l’état de l’objet et procède à un retour immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-241">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="a1375-242">Si <c>millisecondsTimeOutInterval</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-242">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="a1375-243">
            <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-243">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-244">Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, en utilisant, pour indiquer le délai en millisecondes, un entier 32 bits signé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-244">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-245">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> qui encapsule le handle natif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-245">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-246">Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-246">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="a1375-247">Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="a1375-247">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="a1375-248">Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.</span><span class="sxs-lookup"><span data-stu-id="a1375-248">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="a1375-249">Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode files d’attente le délégué spécifié pour le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-249">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="a1375-250">Un thread de travail exécute le délégué lorsqu’une des actions suivantes se produit :</span><span class="sxs-lookup"><span data-stu-id="a1375-250">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="a1375-251">L’objet spécifié est dans l’état signalé.</span><span class="sxs-lookup"><span data-stu-id="a1375-251">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="a1375-252">L’intervalle de délai d’attente est dépassé.</span><span class="sxs-lookup"><span data-stu-id="a1375-252">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="a1375-253">Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode vérifie l’état actuel de l’objet spécifié <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="a1375-253">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="a1375-254">Si l’état de l’objet n’est pas signalé, la méthode inscrit une opération d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-254">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="a1375-255">L’opération d’attente est effectuée par un thread du pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-255">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="a1375-256">Le délégué est exécuté par un thread de travail lors de l’état de l’objet est signalé ou que l’intervalle de délai d’expiration est écoulé.</span><span class="sxs-lookup"><span data-stu-id="a1375-256">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="a1375-257">Si le `timeOutInterval` paramètre n’est pas 0 (zéro) et le `executeOnlyOnce` paramètre est `false`, le minuteur est réinitialisé chaque fois que l’événement est signalé ou que l’intervalle de délai d’expiration est écoulé.</span><span class="sxs-lookup"><span data-stu-id="a1375-257">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a1375-258">À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct.</span><span class="sxs-lookup"><span data-stu-id="a1375-258">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="a1375-259">Au lieu d’un <xref:System.Threading.Mutex>, utilisez un <xref:System.Threading.Semaphore> avec un nombre maximal de 1.</span><span class="sxs-lookup"><span data-stu-id="a1375-259">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="a1375-260">Pour annuler l’opération d’attente, appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-260">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="a1375-261">Le thread d’attente utilise Win32 `WaitForMultipleObjects` (fonction) pour surveiller les opérations d’attente inscrite.</span><span class="sxs-lookup"><span data-stu-id="a1375-261">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="a1375-262">Par conséquent, si vous devez utiliser le même handle de système d’exploitation natif dans plusieurs appels à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, vous devez dupliquer le handle à l’aide de Win32 `DuplicateHandle` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a1375-262">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="a1375-263">Notez que vous ne devez pas pulse un objet d’événement passé à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, car le thread d’attente peut ne pas détecte que l’événement est signalé avant la réinitialisation.</span><span class="sxs-lookup"><span data-stu-id="a1375-263">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="a1375-264">Avant de retourner, la fonction modifie l’état de certains types d’objets de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="a1375-264">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="a1375-265">Modification se produit uniquement pour l’objet dont l’état signalé a provoqué la condition d’attente à satisfaire.</span><span class="sxs-lookup"><span data-stu-id="a1375-265">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="a1375-266">Par exemple, le nombre d’un sémaphore est diminué d’un.</span><span class="sxs-lookup"><span data-stu-id="a1375-266">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="a1375-267">Informations sur la version</span><span class="sxs-lookup"><span data-stu-id="a1375-267">Version Information</span></span>  
 <span data-ttu-id="a1375-268">En commençant par le .NET Framework version 2.0, le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valeur de propriété est propagée aux threads de travail en file d’attente à l’aide de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-268">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="a1375-269">Dans les versions antérieures, les informations du principal ne sont pas propagées.</span><span class="sxs-lookup"><span data-stu-id="a1375-269">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a1375-270">Le paramètre <paramref name="millisecondsTimeOutInterval" /> est inférieur à -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-270">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="a1375-271">Pool de threads managés</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-271">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="a1375-272">
            <see cref="T:System.Threading.WaitHandle" /> à inscrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-272">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="a1375-273">Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-273">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="a1375-274">Délégué <see cref="T:System.Threading.WaitOrTimerCallback" /> à appeler quand le paramètre <c>waitObject</c> est signalé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-274">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="a1375-275">Objet passé au délégué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-275">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="a1375-276">Délai en millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-276">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="a1375-277">Si le paramètre <c>millisecondsTimeOutInterval</c> a la valeur zéro (0), la fonction teste l’état de l’objet et procède à un retour immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-277">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="a1375-278">Si <c>millisecondsTimeOutInterval</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-278">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="a1375-279">
            <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-279">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-280">Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, en utilisant, pour indiquer le délai en millisecondes, un entier 64 bits signé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-280">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-281">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> qui encapsule le handle natif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-281">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-282">Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-282">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="a1375-283">Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="a1375-283">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="a1375-284">Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.</span><span class="sxs-lookup"><span data-stu-id="a1375-284">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="a1375-285">Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode files d’attente le délégué spécifié pour le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-285">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="a1375-286">Un thread de travail exécute le délégué lorsqu’une des actions suivantes se produit :</span><span class="sxs-lookup"><span data-stu-id="a1375-286">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="a1375-287">L’objet spécifié est dans l’état signalé.</span><span class="sxs-lookup"><span data-stu-id="a1375-287">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="a1375-288">L’intervalle de délai d’attente est dépassé.</span><span class="sxs-lookup"><span data-stu-id="a1375-288">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="a1375-289">Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode vérifie l’état actuel de l’objet spécifié <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="a1375-289">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="a1375-290">Si l’état de l’objet n’est pas signalé, la méthode inscrit une opération d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-290">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="a1375-291">L’opération d’attente est effectuée par un thread du pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-291">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="a1375-292">Le délégué est exécuté par un thread de travail lors de l’état de l’objet est signalé ou que l’intervalle de délai d’expiration est écoulé.</span><span class="sxs-lookup"><span data-stu-id="a1375-292">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="a1375-293">Si le `timeOutInterval` paramètre n’est pas 0 (zéro) et le `executeOnlyOnce` paramètre est `false`, le minuteur est réinitialisé chaque fois que l’événement est signalé ou que l’intervalle de délai d’expiration est écoulé.</span><span class="sxs-lookup"><span data-stu-id="a1375-293">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a1375-294">À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct.</span><span class="sxs-lookup"><span data-stu-id="a1375-294">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="a1375-295">Au lieu d’un <xref:System.Threading.Mutex>, utilisez un <xref:System.Threading.Semaphore> avec un nombre maximal de 1.</span><span class="sxs-lookup"><span data-stu-id="a1375-295">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="a1375-296">Pour annuler l’opération d’attente, appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-296">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="a1375-297">Le thread d’attente utilise Win32 `WaitForMultipleObjects` (fonction) pour surveiller les opérations d’attente inscrite.</span><span class="sxs-lookup"><span data-stu-id="a1375-297">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="a1375-298">Par conséquent, si vous devez utiliser le même handle de système d’exploitation natif dans plusieurs appels à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, vous devez dupliquer le handle à l’aide de Win32 `DuplicateHandle` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a1375-298">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="a1375-299">Notez que vous ne devez pas pulse un objet d’événement passé à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, car le thread d’attente peut ne pas détecte que l’événement est signalé avant la réinitialisation.</span><span class="sxs-lookup"><span data-stu-id="a1375-299">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="a1375-300">Avant de retourner, la fonction modifie l’état de certains types d’objets de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="a1375-300">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="a1375-301">Modification se produit uniquement pour l’objet dont l’état signalé a provoqué la condition d’attente à satisfaire.</span><span class="sxs-lookup"><span data-stu-id="a1375-301">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="a1375-302">Par exemple, le nombre d’un sémaphore est diminué d’un.</span><span class="sxs-lookup"><span data-stu-id="a1375-302">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="a1375-303">Informations sur la version</span><span class="sxs-lookup"><span data-stu-id="a1375-303">Version Information</span></span>  
 <span data-ttu-id="a1375-304">En commençant par le .NET Framework version 2.0, le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valeur de propriété est propagée aux threads de travail en file d’attente à l’aide de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-304">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="a1375-305">Dans les versions antérieures, les informations du principal ne sont pas propagées.</span><span class="sxs-lookup"><span data-stu-id="a1375-305">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a1375-306">Le paramètre <paramref name="millisecondsTimeOutInterval" /> est inférieur à -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-306">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="a1375-307">Pool de threads managés</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-307">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="a1375-308">
            <see cref="T:System.Threading.WaitHandle" /> à inscrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-308">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="a1375-309">Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-309">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="a1375-310">Délégué <see cref="T:System.Threading.WaitOrTimerCallback" /> à appeler quand le paramètre <c>waitObject</c> est signalé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-310">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="a1375-311">Objet passé au délégué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-311">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="a1375-312">Délai représenté par <see cref="T:System.TimeSpan" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-312">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="a1375-313">Si le paramètre <c>timeout</c> a la valeur 0 (zéro), la fonction teste l’état de l’objet et procède à un retour immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-313">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="a1375-314">Si <c>timeout</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-314">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="a1375-315">
            <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-315">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-316">Inscrit un délégué en attente de <see cref="T:System.Threading.WaitHandle" />, en spécifiant une valeur <see cref="T:System.TimeSpan" /> pour indiquer le délai.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-316">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-317">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> qui encapsule le handle natif.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-317">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-318">Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-318">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="a1375-319">Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="a1375-319">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="a1375-320">Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.</span><span class="sxs-lookup"><span data-stu-id="a1375-320">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="a1375-321">Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode files d’attente le délégué spécifié pour le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-321">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="a1375-322">Un thread de travail exécute le délégué lorsqu’une des actions suivantes se produit :</span><span class="sxs-lookup"><span data-stu-id="a1375-322">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="a1375-323">L’objet spécifié est dans l’état signalé.</span><span class="sxs-lookup"><span data-stu-id="a1375-323">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="a1375-324">L’intervalle de délai d’attente est dépassé.</span><span class="sxs-lookup"><span data-stu-id="a1375-324">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="a1375-325">Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode vérifie l’état actuel de l’objet spécifié <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="a1375-325">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="a1375-326">Si l’état de l’objet n’est pas signalé, la méthode inscrit une opération d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-326">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="a1375-327">L’opération d’attente est effectuée par un thread du pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-327">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="a1375-328">Le délégué est exécuté par un thread de travail lors de l’état de l’objet est signalé ou que l’intervalle de délai d’expiration est écoulé.</span><span class="sxs-lookup"><span data-stu-id="a1375-328">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="a1375-329">Si le `timeOutInterval` paramètre n’est pas 0 (zéro) et le `executeOnlyOnce` paramètre est `false`, le minuteur est réinitialisé chaque fois que l’événement est signalé ou que l’intervalle de délai d’expiration est écoulé.</span><span class="sxs-lookup"><span data-stu-id="a1375-329">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a1375-330">À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct.</span><span class="sxs-lookup"><span data-stu-id="a1375-330">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="a1375-331">Au lieu d’un <xref:System.Threading.Mutex>, utilisez un <xref:System.Threading.Semaphore> avec un nombre maximal de 1.</span><span class="sxs-lookup"><span data-stu-id="a1375-331">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="a1375-332">Pour annuler l’opération d’attente, appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-332">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="a1375-333">Le thread d’attente utilise Win32 `WaitForMultipleObjects` (fonction) pour surveiller les opérations d’attente inscrite.</span><span class="sxs-lookup"><span data-stu-id="a1375-333">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="a1375-334">Par conséquent, si vous devez utiliser le même handle de système d’exploitation natif dans plusieurs appels à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, vous devez dupliquer le handle à l’aide de Win32 `DuplicateHandle` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a1375-334">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="a1375-335">Notez que vous ne devez pas pulse un objet d’événement passé à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, car le thread d’attente peut ne pas détecte que l’événement est signalé avant la réinitialisation.</span><span class="sxs-lookup"><span data-stu-id="a1375-335">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="a1375-336">Avant de retourner, la fonction modifie l’état de certains types d’objets de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="a1375-336">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="a1375-337">Modification se produit uniquement pour l’objet dont l’état signalé a provoqué la condition d’attente à satisfaire.</span><span class="sxs-lookup"><span data-stu-id="a1375-337">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="a1375-338">Par exemple, le nombre d’un sémaphore est diminué d’un.</span><span class="sxs-lookup"><span data-stu-id="a1375-338">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="a1375-339">Informations sur la version</span><span class="sxs-lookup"><span data-stu-id="a1375-339">Version Information</span></span>  
 <span data-ttu-id="a1375-340">En commençant par le .NET Framework version 2.0, le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valeur de propriété est propagée aux threads de travail en file d’attente à l’aide de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-340">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="a1375-341">Dans les versions antérieures, les informations du principal ne sont pas propagées.</span><span class="sxs-lookup"><span data-stu-id="a1375-341">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a1375-342">Le paramètre <paramref name="timeout" /> est inférieur à -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-342">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a1375-343">Le paramètre <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-343">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="a1375-344">Pool de threads managés</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-344">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="a1375-345">
            <see cref="T:System.Threading.WaitHandle" /> à inscrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-345">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="a1375-346">Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-346">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="a1375-347">Délégué <see cref="T:System.Threading.WaitOrTimerCallback" /> à appeler quand le paramètre <c>waitObject</c> est signalé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-347">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="a1375-348">Objet passé au délégué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-348">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="a1375-349">Délai en millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-349">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="a1375-350">Si le paramètre <c>millisecondsTimeOutInterval</c> a la valeur zéro (0), la fonction teste l’état de l’objet et procède à un retour immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-350">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="a1375-351">Si <c>millisecondsTimeOutInterval</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-351">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="a1375-352">
            <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-352">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-353">Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, en utilisant, pour indiquer le délai en millisecondes, un entier 32 bits non signé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-353">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-354">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> pouvant être utilisé pour annuler l'opération d'attente inscrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-354">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-355">Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-355">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="a1375-356">Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="a1375-356">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="a1375-357">Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.</span><span class="sxs-lookup"><span data-stu-id="a1375-357">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="a1375-358">Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode files d’attente le délégué spécifié pour le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-358">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="a1375-359">Un thread de travail exécute le délégué lorsqu’une des actions suivantes se produit :</span><span class="sxs-lookup"><span data-stu-id="a1375-359">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="a1375-360">L’objet spécifié est dans l’état signalé.</span><span class="sxs-lookup"><span data-stu-id="a1375-360">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="a1375-361">L’intervalle de délai d’attente est dépassé.</span><span class="sxs-lookup"><span data-stu-id="a1375-361">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="a1375-362">Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode vérifie l’état actuel de l’objet spécifié <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="a1375-362">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="a1375-363">Si l’état de l’objet n’est pas signalé, la méthode inscrit une opération d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-363">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="a1375-364">L’opération d’attente est effectuée par un thread du pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-364">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="a1375-365">Le délégué est exécuté par un thread de travail lors de l’état de l’objet est signalé ou que l’intervalle de délai d’expiration est écoulé.</span><span class="sxs-lookup"><span data-stu-id="a1375-365">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="a1375-366">Si le `timeOutInterval` paramètre n’est pas 0 (zéro) et le `executeOnlyOnce` paramètre est `false`, le minuteur est réinitialisé chaque fois que l’événement est signalé ou que l’intervalle de délai d’expiration est écoulé.</span><span class="sxs-lookup"><span data-stu-id="a1375-366">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a1375-367">À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct.</span><span class="sxs-lookup"><span data-stu-id="a1375-367">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="a1375-368">Au lieu d’un <xref:System.Threading.Mutex>, utilisez un <xref:System.Threading.Semaphore> avec un nombre maximal de 1.</span><span class="sxs-lookup"><span data-stu-id="a1375-368">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="a1375-369">Pour annuler l’opération d’attente, appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-369">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="a1375-370">Le thread d’attente utilise Win32 `WaitForMultipleObjects` (fonction) pour surveiller les opérations d’attente inscrite.</span><span class="sxs-lookup"><span data-stu-id="a1375-370">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="a1375-371">Par conséquent, si vous devez utiliser le même handle de système d’exploitation natif dans plusieurs appels à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, vous devez dupliquer le handle à l’aide de Win32 `DuplicateHandle` (fonction).</span><span class="sxs-lookup"><span data-stu-id="a1375-371">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="a1375-372">Notez que vous ne devez pas pulse un objet d’événement passé à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, car le thread d’attente peut ne pas détecte que l’événement est signalé avant la réinitialisation.</span><span class="sxs-lookup"><span data-stu-id="a1375-372">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="a1375-373">Avant de retourner, la fonction modifie l’état de certains types d’objets de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="a1375-373">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="a1375-374">Modification se produit uniquement pour l’objet dont l’état signalé a provoqué la condition d’attente à satisfaire.</span><span class="sxs-lookup"><span data-stu-id="a1375-374">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="a1375-375">Par exemple, le nombre d’un sémaphore est diminué d’un.</span><span class="sxs-lookup"><span data-stu-id="a1375-375">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="a1375-376">Informations sur la version</span><span class="sxs-lookup"><span data-stu-id="a1375-376">Version Information</span></span>  
 <span data-ttu-id="a1375-377">En commençant par le .NET Framework version 2.0, le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valeur de propriété est propagée aux threads de travail en file d’attente à l’aide de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-377">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="a1375-378">Dans les versions antérieures, les informations du principal ne sont pas propagées.</span><span class="sxs-lookup"><span data-stu-id="a1375-378">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1375-379">L’exemple suivant montre comment utiliser le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode à exécuter une méthode de rappel spécifiée lorsqu’un handle d’attente spécifié est signalé.</span><span class="sxs-lookup"><span data-stu-id="a1375-379">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="a1375-380">Dans cet exemple, la méthode de rappel est `WaitProc`, et le handle d’attente est un <xref:System.Threading.AutoResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="a1375-380">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="a1375-381">L’exemple définit un `TaskInfo` classe pour contenir les informations qui sont passées au rappel lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="a1375-381">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="a1375-382">L’exemple crée un `TaskInfo` de l’objet et lui assigne des données de chaîne.</span><span class="sxs-lookup"><span data-stu-id="a1375-382">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="a1375-383">Le <xref:System.Threading.RegisteredWaitHandle> qui est retourné par la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode est attribuée à la `Handle` champ la `TaskInfo` afin que la méthode de rappel a accès à l’objet le <xref:System.Threading.RegisteredWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="a1375-383">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="a1375-384">Outre la spécification `TaskInfo` que l’objet à passer à la méthode de rappel, l’appel à la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode spécifie le <xref:System.Threading.AutoResetEvent> qui attend la tâche, un <xref:System.Threading.WaitOrTimerCallback> délégué qui représente le `WaitProc` méthode de rappel, un intervalle du délai d’attente d’une seconde et plusieurs rappels.</span><span class="sxs-lookup"><span data-stu-id="a1375-384">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="a1375-385">Lorsque le thread principal signale le <xref:System.Threading.AutoResetEvent> en appelant son <xref:System.Threading.EventWaitHandle.Set%2A> (méthode), le <xref:System.Threading.WaitOrTimerCallback> délégué est appelé.</span><span class="sxs-lookup"><span data-stu-id="a1375-385">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="a1375-386">Le `WaitProc` méthode tests <xref:System.Threading.RegisteredWaitHandle> pour déterminer si un délai d’attente s’est produite.</span><span class="sxs-lookup"><span data-stu-id="a1375-386">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="a1375-387">Si le rappel a été appelé parce que le handle d’attente a été signalé, le `WaitProc` annule l’inscription de la méthode le <xref:System.Threading.RegisteredWaitHandle>, l’arrêt des rappels supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="a1375-387">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="a1375-388">Dans le cas d’un délai d’attente, la tâche continue à attendre.</span><span class="sxs-lookup"><span data-stu-id="a1375-388">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="a1375-389">Le `WaitProc` méthode se termine en affichant un message à la console.</span><span class="sxs-lookup"><span data-stu-id="a1375-389">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a1375-390">Le paramètre <paramref name="millisecondsTimeOutInterval" /> est inférieur à -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-390">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="a1375-391">Pool de threads managés</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-391">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="a1375-392">Nombre maximal de threads de travail dans le pool de threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-392">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="a1375-393">Nombre maximal de threads d'E/S asynchrones dans le pool de threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-393">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-394">Définit le nombre de demandes au pool de threads pouvant être simultanément actives.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-394">Sets the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="a1375-395">Toutes les demandes excédant ce nombre restent dans la file d'attente jusqu'à ce que des threads du pool soient disponibles.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-395">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-396">
            <see langword="true" /> si la modification aboutit ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-396">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-397">Impossible de définir le nombre maximal de threads de travail ou des threads de terminaison d’e/s à un nombre plus petit que le nombre de processeurs sur l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="a1375-397">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="a1375-398">Pour déterminer le nombre de processeurs est présent, récupérez la valeur de la <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="a1375-398">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="a1375-399">En outre, vous ne pouvez pas définir le nombre maximal de threads de travail ou des threads de terminaison d’e/s pour un nombre plus petit que le nombre minimal correspondant de threads de travail ou des threads de terminaison d’e/s.</span><span class="sxs-lookup"><span data-stu-id="a1375-399">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="a1375-400">Pour déterminer la taille de pool de threads minimum, appelez le <xref:System.Threading.ThreadPool.GetMinThreads%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="a1375-400">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="a1375-401">Si le common language runtime est hébergé, par exemple par Internet Information Services (IIS) ou SQL Server, l’hôte peut limiter ou empêcher la modification de la taille de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-401">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="a1375-402">Soyez prudent lorsque vous modifiez le nombre maximal de threads dans le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-402">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="a1375-403">Pendant que votre code pourrait bénéficier, les modifications peuvent avoir un impact négatif sur les bibliothèques de code que vous utilisez.</span><span class="sxs-lookup"><span data-stu-id="a1375-403">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="a1375-404">Définition de la taille de pool de threads trop volumineux peut entraîner des problèmes de performances.</span><span class="sxs-lookup"><span data-stu-id="a1375-404">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="a1375-405">Si trop de threads s’exécutent en même temps, le basculement de tâche devient une surcharge d’un facteur important.</span><span class="sxs-lookup"><span data-stu-id="a1375-405">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="a1375-406">pour la possibilité de contrôler les threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-406">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="a1375-407">Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-407">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="a1375-408">Nombre minimal de threads de travail que le pool de threads crée à la demande.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-408">The minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="a1375-409">Nombre minimal de threads d'E/S asynchrones que le pool de threads crée à la demande.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-409">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-410">Définit le nombre minimal de threads que le pool de threads crée à la demande, au fur et à mesure que de nouvelles requêtes sont effectuées, avant de basculer sur un algorithme pour la gestion de la création et de la suppression des threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-410">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-411">
            <see langword="true" /> si la modification aboutit ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-411">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-412">Le pool de threads fournit de nouveaux threads de travail ou des threads de terminaison d’e/s à la demande jusqu'à ce qu’il atteigne la valeur minimale pour chaque catégorie.</span><span class="sxs-lookup"><span data-stu-id="a1375-412">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="a1375-413">Lorsque la valeur minimale est atteinte, le pool de threads peut créer des threads supplémentaires dans cette catégorie ou attendre que certaines tâches soient terminées.</span><span class="sxs-lookup"><span data-stu-id="a1375-413">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="a1375-414">Compter les [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], le pool de threads crée et détruit des threads pour optimiser le débit, ce qui est défini comme le nombre de tâches exécutées par unité de temps.</span><span class="sxs-lookup"><span data-stu-id="a1375-414">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="a1375-415">Un nombre trop bas de threads peut ne pas permettre une utilisation optimale des ressources disponibles, tandis qu'un nombre trop élevé de threads peut augmenter les conflits de ressources.</span><span class="sxs-lookup"><span data-stu-id="a1375-415">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="a1375-416">Quand la demande est faible, le nombre réel de threads du pool peut être inférieur aux valeurs minimales.</span><span class="sxs-lookup"><span data-stu-id="a1375-416">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="a1375-417">Si vous spécifiez un nombre négatif ou un nombre supérieur au nombre maximal de threads de pool de thread actif (obtenu à l’aide <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> retourne `false` et ne change pas une des valeurs minimales.</span><span class="sxs-lookup"><span data-stu-id="a1375-417">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a1375-418">Le nombre minimal de threads a la valeur par défaut, le nombre de processeurs sur un système.</span><span class="sxs-lookup"><span data-stu-id="a1375-418">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="a1375-419">Vous pouvez utiliser la <xref:System.Threading.ThreadPool.SetMinThreads%2A> méthode pour augmenter l’ofthreads nombre minimal.</span><span class="sxs-lookup"><span data-stu-id="a1375-419">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="a1375-420">Toutefois, une augmentation non nécessaire de ces valeurs peut entraîner des problèmes de performances.</span><span class="sxs-lookup"><span data-stu-id="a1375-420">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="a1375-421">Si vous démarrez trop de tâches en même temps, celles-ci seront lentes.</span><span class="sxs-lookup"><span data-stu-id="a1375-421">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="a1375-422">Dans la plupart des cas, le pool de threads offrira de meilleures performances avec son propre algorithme d’allocation de threads.</span><span class="sxs-lookup"><span data-stu-id="a1375-422">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="a1375-423">À moins que le nombre de processeurs peut également dégrader les performances, en réduisant au minimum.</span><span class="sxs-lookup"><span data-stu-id="a1375-423">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1375-424">L’exemple suivant définit le nombre minimal de threads de travail à quatre et conserve la valeur d’origine pour le nombre minimal de threads d’achèvement d’e/s asynchrones.</span><span class="sxs-lookup"><span data-stu-id="a1375-424">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="a1375-425">pour la possibilité de contrôler les threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-425">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="a1375-426">Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-426">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">
          <span data-ttu-id="a1375-427">Structure <see cref="T:System.Threading.NativeOverlapped" /> à placer en file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-427">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-428">Met en file d'attente l'exécution d'une opération d'E/S avec chevauchement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-428">Queues an overlapped I/O operation for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-429">
            <see langword="true" /> si l'opération a été mise en file d'attente dans un port de terminaison d'E/S ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-429">
              <see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-430">Pour plus d’informations sur l’utilisation de Win32 natives avec chevauchement d’e/s, consultez le <xref:System.Threading.Overlapped> (classe), le <xref:System.Threading.NativeOverlapped> structure et le `OVERLAPPED` structure dans Win32 Platform SDK.</span><span class="sxs-lookup"><span data-stu-id="a1375-430">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a1375-431">À l’aide de la <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> méthode peut accidentellement ouvrir une faille de sécurité.</span><span class="sxs-lookup"><span data-stu-id="a1375-431">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="a1375-432">Sécurité d’accès du code base ses vérifications d’autorisations sur les autorisations de tous les appelants sur la pile.</span><span class="sxs-lookup"><span data-stu-id="a1375-432">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="a1375-433">Lorsque le travail est en file d’attente sur un thread de pool de thread à l’aide <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, la pile du thread du pool n’a pas le contexte des appelants réels.</span><span class="sxs-lookup"><span data-stu-id="a1375-433">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="a1375-434">Code malveillant peut être en mesure d’exploiter ceci pour éviter les vérifications d’autorisations.</span><span class="sxs-lookup"><span data-stu-id="a1375-434">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="a1375-435">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-435">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="a1375-436">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-436">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="a1375-437">
            <see cref="T:System.Threading.WaitCallback" /> représentant le délégué à appeler lorsqu'un thread du pool de threads sélectionne l'élément de travail.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-437">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="a1375-438">Objet passé au délégué lors de son traitement dans le pool de threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-438">The object that is passed to the delegate when serviced from the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-439">Met le délégué spécifié en file d'attente dans le pool de threads, mais ne propage pas la pile d'appels vers le thread de travail.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-439">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-440">
            <see langword="true" /> si la méthode est exécutée avec succès ; <see cref="T:System.OutOfMemoryException" /> est levée si l'élément de travail n'a pas pu être placé en file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-440">
              <see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-441">Contrairement à la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (méthode), <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> ne propage pas la pile appelante vers le thread de travail.</span><span class="sxs-lookup"><span data-stu-id="a1375-441">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="a1375-442">Ainsi, le code de perdre la pile appelante et ainsi d’élever ses privilèges de sécurité.</span><span class="sxs-lookup"><span data-stu-id="a1375-442">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a1375-443">À l’aide de <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> peut accidentellement ouvrir une faille de sécurité.</span><span class="sxs-lookup"><span data-stu-id="a1375-443">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="a1375-444">Sécurité d’accès du code base ses vérifications d’autorisations sur les autorisations de tous les appelants sur la pile.</span><span class="sxs-lookup"><span data-stu-id="a1375-444">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="a1375-445">Lorsque le travail est en file d’attente sur un thread de pool de thread à l’aide <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, la pile du thread du pool n’aura pas le contexte des appelants réels.</span><span class="sxs-lookup"><span data-stu-id="a1375-445">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="a1375-446">Code malveillant peut être en mesure d’exploiter ceci pour éviter les vérifications d’autorisations.</span><span class="sxs-lookup"><span data-stu-id="a1375-446">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="a1375-447">L'appelant n'a pas l'autorisation requise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-447">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a1375-448">Une condition de mémoire insuffisante a été rencontrée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-448">An out-of-memory condition was encountered.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="a1375-449">L'élément de travail n'a pas pu être placé en file d'attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-449">The work item could not be queued.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a1375-450">
            <paramref name="callBack" /> est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-450">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="a1375-451">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-451">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="a1375-452">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-452">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="a1375-453">Pool de threads managés</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-453">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a1375-454">Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, mais ne propage pas la pile appelante vers le thread de travail.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-454">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="a1375-455">
            <see cref="T:System.Threading.WaitHandle" /> à inscrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-455">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="a1375-456">Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-456">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="a1375-457">Délégué à appeler quand le paramètre <c>waitObject</c> est signalé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-457">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="a1375-458">Objet passé au délégué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-458">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="a1375-459">Délai en millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-459">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="a1375-460">Si le paramètre <c>millisecondsTimeOutInterval</c> a la valeur zéro (0), la fonction teste l’état de l’objet et procède à un retour immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-460">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="a1375-461">Si <c>millisecondsTimeOutInterval</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-461">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="a1375-462">
            <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-462">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-463">Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, en utilisant, pour indiquer le délai en millisecondes, un entier signé 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-463">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="a1375-464">Cette méthode ne propage pas la pile appelante vers le thread de travail.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-464">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-465">Objet <see cref="T:System.Threading.RegisteredWaitHandle" /> pouvant être utilisé pour annuler l'opération d'attente inscrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-465">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-466">Contrairement à la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode), <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> ne propage pas la pile appelante vers le thread de travail.</span><span class="sxs-lookup"><span data-stu-id="a1375-466">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="a1375-467">Ainsi, le code de perdre la pile appelante et ainsi d’élever ses privilèges de sécurité.</span><span class="sxs-lookup"><span data-stu-id="a1375-467">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a1375-468">À l’aide de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> peut accidentellement ouvrir une faille de sécurité.</span><span class="sxs-lookup"><span data-stu-id="a1375-468">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="a1375-469">Sécurité d’accès du code base ses vérifications d’autorisations sur les autorisations de tous les appelants sur la pile.</span><span class="sxs-lookup"><span data-stu-id="a1375-469">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="a1375-470">Lorsque le travail est en file d’attente sur un thread de pool de thread à l’aide <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pile du thread du pool n’aura pas le contexte des appelants réels.</span><span class="sxs-lookup"><span data-stu-id="a1375-470">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="a1375-471">Code malveillant peut être en mesure d’exploiter ceci pour éviter les vérifications d’autorisations.</span><span class="sxs-lookup"><span data-stu-id="a1375-471">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="a1375-472">À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct.</span><span class="sxs-lookup"><span data-stu-id="a1375-472">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="a1375-473">Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-473">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="a1375-474">Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="a1375-474">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="a1375-475">Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.</span><span class="sxs-lookup"><span data-stu-id="a1375-475">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a1375-476">Le paramètre <paramref name="millisecondsTimeOutInterval" /> est inférieur à -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-476">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="a1375-477">L'appelant n'a pas l'autorisation requise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-477">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="a1375-478">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-478">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="a1375-479">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-479">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="a1375-480">Pool de threads managés</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-480">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="a1375-481">
            <see cref="T:System.Threading.WaitHandle" /> à inscrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-481">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="a1375-482">Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-482">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="a1375-483">Délégué à appeler quand le paramètre <c>waitObject</c> est signalé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-483">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="a1375-484">Objet passé au délégué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-484">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="a1375-485">Délai en millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-485">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="a1375-486">Si le paramètre <c>millisecondsTimeOutInterval</c> a la valeur zéro (0), la fonction teste l’état de l’objet et procède à un retour immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-486">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="a1375-487">Si <c>millisecondsTimeOutInterval</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-487">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="a1375-488">
            <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-488">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-489">Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, en utilisant, pour indiquer le délai en millisecondes, un entier 64 bits signé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-489">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="a1375-490">Cette méthode ne propage pas la pile appelante vers le thread de travail.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-490">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-491">Objet <see cref="T:System.Threading.RegisteredWaitHandle" /> pouvant être utilisé pour annuler l'opération d'attente inscrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-491">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-492">Contrairement à la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode), <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> ne propage pas la pile appelante vers le thread de travail.</span><span class="sxs-lookup"><span data-stu-id="a1375-492">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="a1375-493">Ainsi, le code de perdre la pile appelante et ainsi d’élever ses privilèges de sécurité.</span><span class="sxs-lookup"><span data-stu-id="a1375-493">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a1375-494">À l’aide de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> peut accidentellement ouvrir une faille de sécurité.</span><span class="sxs-lookup"><span data-stu-id="a1375-494">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="a1375-495">Sécurité d’accès du code base ses vérifications d’autorisations sur les autorisations de tous les appelants sur la pile.</span><span class="sxs-lookup"><span data-stu-id="a1375-495">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="a1375-496">Lorsque le travail est en file d’attente sur un thread de pool de thread à l’aide <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pile du thread du pool n’aura pas le contexte des appelants réels.</span><span class="sxs-lookup"><span data-stu-id="a1375-496">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="a1375-497">Code malveillant peut être en mesure d’exploiter ceci pour éviter les vérifications d’autorisations.</span><span class="sxs-lookup"><span data-stu-id="a1375-497">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="a1375-498">À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct.</span><span class="sxs-lookup"><span data-stu-id="a1375-498">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="a1375-499">Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-499">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="a1375-500">Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="a1375-500">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="a1375-501">Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.</span><span class="sxs-lookup"><span data-stu-id="a1375-501">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a1375-502">Le paramètre <paramref name="millisecondsTimeOutInterval" /> est inférieur à -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-502">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="a1375-503">L'appelant n'a pas l'autorisation requise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-503">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="a1375-504">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-504">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="a1375-505">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-505">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="a1375-506">Pool de threads managés</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-506">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="a1375-507">
            <see cref="T:System.Threading.WaitHandle" /> à inscrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-507">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="a1375-508">Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-508">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="a1375-509">Délégué à appeler quand le paramètre <c>waitObject</c> est signalé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-509">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="a1375-510">Objet passé au délégué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-510">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="a1375-511">Délai représenté par <see cref="T:System.TimeSpan" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-511">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="a1375-512">Si le paramètre <c>timeout</c> a la valeur 0 (zéro), la fonction teste l’état de l’objet et procède à un retour immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-512">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="a1375-513">Si <c>timeout</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-513">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="a1375-514">
            <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-514">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-515">Inscrit un délégué en attente de <see cref="T:System.Threading.WaitHandle" />, en spécifiant une valeur <see cref="T:System.TimeSpan" /> pour indiquer le délai. Cette méthode ne propage pas la pile appelante vers le thread de travail.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-515">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-516">Objet <see cref="T:System.Threading.RegisteredWaitHandle" /> pouvant être utilisé pour annuler l'opération d'attente inscrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-516">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-517">Contrairement à la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode), <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> ne propage pas la pile appelante vers le thread de travail.</span><span class="sxs-lookup"><span data-stu-id="a1375-517">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="a1375-518">Ainsi, le code de perdre la pile appelante et ainsi d’élever ses privilèges de sécurité.</span><span class="sxs-lookup"><span data-stu-id="a1375-518">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a1375-519">À l’aide de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> peut accidentellement ouvrir une faille de sécurité.</span><span class="sxs-lookup"><span data-stu-id="a1375-519">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="a1375-520">Sécurité d’accès du code base ses vérifications d’autorisations sur les autorisations de tous les appelants sur la pile.</span><span class="sxs-lookup"><span data-stu-id="a1375-520">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="a1375-521">Lorsque le travail est en file d’attente sur un thread de pool de thread à l’aide <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pile du thread du pool n’aura pas le contexte des appelants réels.</span><span class="sxs-lookup"><span data-stu-id="a1375-521">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="a1375-522">Code malveillant peut être en mesure d’exploiter ceci pour éviter les vérifications d’autorisations.</span><span class="sxs-lookup"><span data-stu-id="a1375-522">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="a1375-523">À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct.</span><span class="sxs-lookup"><span data-stu-id="a1375-523">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="a1375-524">Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-524">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="a1375-525">Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="a1375-525">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="a1375-526">Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.</span><span class="sxs-lookup"><span data-stu-id="a1375-526">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a1375-527">Le paramètre <paramref name="timeout" /> est inférieur à -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-527">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a1375-528">Le paramètre <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-528">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="a1375-529">L'appelant n'a pas l'autorisation requise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-529">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="a1375-530">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-530">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="a1375-531">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-531">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="a1375-532">Pool de threads managés</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-532">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="a1375-533">
            <see cref="T:System.Threading.WaitHandle" /> à inscrire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-533">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="a1375-534">Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-534">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="a1375-535">Délégué à appeler quand le paramètre <c>waitObject</c> est signalé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-535">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="a1375-536">Objet passé au délégué.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-536">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="a1375-537">Délai en millisecondes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-537">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="a1375-538">Si le paramètre <c>millisecondsTimeOutInterval</c> a la valeur zéro (0), la fonction teste l’état de l’objet et procède à un retour immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-538">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="a1375-539">Si <c>millisecondsTimeOutInterval</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-539">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="a1375-540">
            <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-540">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1375-541">Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, en utilisant, pour indiquer le délai en millisecondes, un entier 32 bits non signé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-541">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="a1375-542">Cette méthode ne propage pas la pile appelante vers le thread de travail.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-542">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1375-543">Objet <see cref="T:System.Threading.RegisteredWaitHandle" /> pouvant être utilisé pour annuler l'opération d'attente inscrite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-543">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1375-544">Contrairement à la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode), <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> ne propage pas la pile appelante vers le thread de travail.</span><span class="sxs-lookup"><span data-stu-id="a1375-544">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="a1375-545">Ainsi, le code de perdre la pile appelante et ainsi d’élever ses privilèges de sécurité.</span><span class="sxs-lookup"><span data-stu-id="a1375-545">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="a1375-546">À l’aide de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> peut accidentellement ouvrir une faille de sécurité.</span><span class="sxs-lookup"><span data-stu-id="a1375-546">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="a1375-547">Sécurité d’accès du code base ses vérifications d’autorisations sur les autorisations de tous les appelants sur la pile.</span><span class="sxs-lookup"><span data-stu-id="a1375-547">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="a1375-548">Lorsque le travail est en file d’attente sur un thread de pool de thread à l’aide <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pile du thread du pool n’aura pas le contexte des appelants réels.</span><span class="sxs-lookup"><span data-stu-id="a1375-548">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="a1375-549">Code malveillant peut être en mesure d’exploiter ceci pour éviter les vérifications d’autorisations.</span><span class="sxs-lookup"><span data-stu-id="a1375-549">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="a1375-550">À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct.</span><span class="sxs-lookup"><span data-stu-id="a1375-550">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="a1375-551">Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente.</span><span class="sxs-lookup"><span data-stu-id="a1375-551">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="a1375-552">Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="a1375-552">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="a1375-553">Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.</span><span class="sxs-lookup"><span data-stu-id="a1375-553">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="a1375-554">L'appelant n'a pas l'autorisation requise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-554">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="a1375-555">requiert une confiance totale pour l’appelant immédiat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-555">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="a1375-556">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-556">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="a1375-557">Pool de threads managés</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1375-557">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
  </Members>
</Type>