<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9f9c9e42dff8e89feb11010c57e7d17bc9b44648" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48675425" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit un pool de threads qui peuvent servir à exécuter des tâches, publier des éléments de travail, traiter des E/S asynchrones, attendre au nom d’autres threads et traiter des minuteries.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De nombreuses applications créent des threads qui consacrent beaucoup de temps en état de veille, en attente pour un événement se produise. Autres threads peuvent entrer en état de veille uniquement pour être réactivés interroger pour une modification ou de mettre à jour les informations d’état. Le pool de threads vous permet d’utiliser des threads plus efficacement en fournissant votre application avec un pool de threads de travail qui sont gérés par le système. Exemples d’opérations qui utilisent des threads de pool sont les suivants :  
  
-   Lorsque vous créez un <xref:System.Threading.Tasks.Task> ou <xref:System.Threading.Tasks.Task%601> objet pour effectuer une tâche de façon asynchrone, par défaut, la tâche est planifiée pour s’exécuter sur un thread de pool de threads.  
  
-   Les minuteries asynchrones utilisent le pool de threads. Thread du pool de threads exécutent des rappels de la <xref:System.Threading.Timer?displayProperty=nameWithType> classe et déclencher des événements à partir de la <xref:System.Timers.Timer?displayProperty=nameWithType> classe.  
  
-   Lorsque vous utilisez des handles d’attente inscrite, un thread système analyse l’état des handles d’attente. Lorsqu’une opération d’attente se termine, un thread de travail du pool de threads exécute la fonction de rappel correspondante.  
  
-   Lorsque vous appelez le <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> méthode en file d’attente d’une méthode pour une exécution sur un thread de pool de threads. Pour ce faire, en passant la méthode un <xref:System.Threading.WaitCallback> déléguer.   Le délégué a la signature  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     où `state` est un objet qui contient les données à utiliser par le délégué. Les données réelles qui peuvent être passées au délégué en appelant le <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> (méthode).  
  
> [!NOTE]
>  Les threads dans le pool de threads managés sont des threads d’arrière-plan. Autrement dit, leur <xref:System.Threading.Thread.IsBackground%2A> propriétés sont `true`. Cela signifie qu’un <xref:System.Threading.ThreadPool> thread ne garde pas une application en cours d’exécution une fois que tous les threads de premier plan ont quitté.  
  
> [!IMPORTANT]
>  Lorsque le pool de threads réutilise un thread, il n’efface pas les données dans le stockage local des threads ou dans les champs marqués avec le <xref:System.ThreadStaticAttribute> attribut. Par conséquent, quand une méthode examine le stockage local des threads ou les champs sont marqués avec le <xref:System.ThreadStaticAttribute> attribut, les valeurs qu’il trouve peuvent subsister à partir d’une utilisation antérieure du thread du pool.  
  
 Vous pouvez également mettre en file d’attente des éléments de travail qui ne sont pas liées à une opération d’attente pour le pool de threads. Pour demander qu’un élément de travail soit géré par un thread dans le pool de threads, appelez le <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (méthode). Cette méthode prend comme paramètre une référence à la méthode ou un délégué qui sera appelée par le thread sélectionné dans le pool de threads. Il n’existe aucun moyen d’annuler un élément de travail une fois qu’il a été mis en attente.  
  
 Minuteries de la file d’attente du minuteur et les opérations d’attente inscrites utilisent également le pool de thread. Leurs fonctions de rappel sont en file d’attente pour le pool de threads.  
  
 Il existe un pool de threads par processus. Dans [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] et versions ultérieures, la taille par défaut du pool de threads d'un processus dépend de plusieurs facteurs, dont la taille de l'espace d'adressage virtuel. Un processus peut appeler la méthode <xref:System.Threading.ThreadPool.GetMaxThreads%2A> pour déterminer le nombre de threads. Le nombre de threads du pool de threads peut être modifié à l’aide de la <xref:System.Threading.ThreadPool.SetMaxThreads%2A> (méthode). Chaque thread utilise la taille de pile par défaut et s’exécute à la priorité par défaut.  
  
> [!NOTE]
>  Code non managé qui héberge le .NET Framework peut modifier la taille du pool de threads à l’aide de la `CorSetMaxThreads` fonction, définie dans le fichier mscoree.h.  
  
 Le pool de threads fournit de nouveaux threads de travail ou des threads de terminaison d’e/s à la demande jusqu'à ce qu’il atteigne la valeur minimale pour chaque catégorie. Lorsqu’une valeur minimale est atteinte, le pool de threads peut créer des threads supplémentaires dans cette catégorie ou attendre que certaines tâches soient terminées. Dans [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] et versions ultérieures, le pool de threads crée et détruit des threads de travail pour optimiser le débit, qui est défini comme le nombre de tâches exécutées par unité de temps. Un nombre trop bas de threads peut ne pas permettre une utilisation optimale des ressources disponibles, tandis qu'un nombre trop élevé de threads peut augmenter les conflits de ressources.  
  
> [!NOTE]
>  Quand la demande est faible, le nombre réel de threads du pool peut être inférieur aux valeurs minimales.  
  
 Vous pouvez utiliser la méthode <xref:System.Threading.ThreadPool.GetMinThreads%2A> pour obtenir ces valeurs minimales.  
  
> [!CAUTION]
>  Vous pouvez utiliser la <xref:System.Threading.ThreadPool.SetMinThreads%2A> méthode pour augmenter le nombre minimal de threads. Toutefois, une augmentation non nécessaire de ces valeurs peut entraîner des problèmes de performances. Si vous démarrez trop de tâches en même temps, celles-ci seront lentes. Dans la plupart des cas, le pool de threads sera plus performant avec son propre algorithme d'allocation de threads.  
  
   
  
## Examples  
 Dans l’exemple suivant, le thread principal de l’application files d’attente une méthode nommée `ThreadProc` à exécuter sur un thread, en veille pendant une seconde et puis se ferme. Le `ThreadProc` méthode affiche simplement un message.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 Si vous commentez l’appel à la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> (méthode), le thread principal s’arrête avant que la méthode s’exécute sur le thread de pool de threads.  Le pool de threads utilise des threads d’arrière-plan qui arrêtent l’application en cours d’exécution si tous les threads de premier plan sont terminés.  (Il s’agit d’un exemple simple d’une condition de concurrence.)  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Threads et threading</related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Le regroupement de threads managés</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lie un handle de système d'exploitation à <see cref="T:System.Threading.ThreadPool" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <see cref="T:System.IntPtr" /> qui contient le handle. Il faut que le handle ait été ouvert pour des E/S avec chevauchement du côté non managé.</param>
        <summary>Lie un handle de système d'exploitation à <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns>
          <see langword="true" /> si le handle est lié ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <see cref="T:System.Runtime.InteropServices.SafeHandle" /> qui contient le handle du système d'exploitation. Il faut que le handle ait été ouvert pour des E/S avec chevauchement du côté non managé.</param>
        <summary>Lie un handle de système d'exploitation à <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns>
          <see langword="true" /> si le handle est lié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `osHandle` paramètre doit être un <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, qui dérive de la classe abstraite <xref:System.Runtime.InteropServices.SafeHandle> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="osHandle" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Nombre de threads de travail disponibles.</param>
        <param name="completionPortThreads">Nombre de threads d'E/S asynchrones disponibles.</param>
        <summary>Récupère la différence entre le nombre maximal de threads du pool retourné par la méthode <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> et le nombre actuel de threads actifs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> est retournée, la variable spécifiée par `workerThreads` contient le nombre de threads de travail supplémentaires qui peuvent être démarrés et la variable spécifiée par `completionPortThreads` contient le nombre de threads d’e/s asynchrones qui peuvent être démarré.  
  
 S’il n’existe aucun thread disponible, les demandes de pool de thread supplémentaire restent en file d’attente jusqu'à ce que les threads du pool deviennent disponibles.  
  
   
  
## Examples  
 L’exemple suivant affiche le nombre de threads de travail et de threads d’e/s disponibles au démarrage d’une application simple.  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Nombre maximal de threads de travail dans le pool de threads.</param>
        <param name="completionPortThreads">Nombre maximal de threads d'E/S asynchrones dans le pool de threads.</param>
        <summary>Récupère le nombre de demandes au pool de threads pouvant être simultanément actives. Toutes les demandes excédant ce nombre restent dans la file d'attente jusqu'à ce que des threads du pool soient disponibles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Threading.ThreadPool.GetMaxThreads%2A> est retournée, la variable spécifiée par `workerThreads` contient le nombre maximal de threads de travail autorisés dans le pool de threads et la variable spécifiée par `completionPortThreads` contient le nombre maximal de threads d’e/s asynchrones autorisés dans le pool de threads.  
  
 Vous pouvez utiliser la <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> méthode pour déterminer le nombre réel de threads dans le pool de threads à un moment donné.  
  
 Vous pouvez utiliser la <xref:System.Threading.ThreadPool.SetMaxThreads%2A> pour définir le nombre maximal de threads de travail et les threads d’e/s asynchrones dans le pool de threads.  
  
 Vous pouvez en file d’attente comme grand nombre de demandes de pool de threads comme la mémoire système. S’il existe plus de requêtes que les threads du pool, les demandes supplémentaires sont en file d’attente jusqu'à ce que les threads du pool deviennent disponibles.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment récupérer le nombre maximal et disponible de threads dans le pool de threads. Un élément de travail est en attente qui utilise `FileStream` pour l’écriture asynchrone dans deux fichiers. Les méthodes de rappel sont programmées pour se chevaucher. Un thread de travail gère l’élément de travail et, selon la vitesse et le nombre de processeurs sur l’ordinateur, un ou deux threads de port de terminaison gèrent les opérations d’écriture.  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Lorsque cette méthode est retournée, contient le nombre minimal de threads de travail que le pool de threads crée à la demande.</param>
        <param name="completionPortThreads">Lorsque cette méthode est retournée, contient le nombre minimal de threads d'E/S asynchrones que le pool de threads crée à la demande.</param>
        <summary>Récupère le nombre minimal de threads que le pool de threads crée à la demande, au fur et à mesure que de nouvelles requêtes sont effectuées, avant de basculer sur un algorithme pour la gestion de la création et de la suppression des threads.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le pool de threads fournit de nouveaux threads de travail ou des threads de terminaison d’e/s à la demande jusqu'à ce qu’il atteigne la valeur minimale pour chaque catégorie. Le nombre minimal de threads a la valeur par défaut, le nombre de processeurs sur un système. Lorsque la valeur minimale est atteinte, le pool de threads peut créer des threads supplémentaires dans cette catégorie ou attendre que certaines tâches soient terminées. Compter les [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], le pool de threads crée et détruit des threads pour optimiser le débit, ce qui est défini comme le nombre de tâches exécutées par unité de temps. Un nombre trop bas de threads peut ne pas permettre une utilisation optimale des ressources disponibles, tandis qu'un nombre trop élevé de threads peut augmenter les conflits de ressources.  
  
> [!NOTE]
>  Quand la demande est faible, le nombre réel de threads du pool peut être inférieur aux valeurs minimales.  
  
   
  
## Examples  
 L’exemple suivant définit le nombre minimal de threads de travail à quatre et conserve la valeur d’origine pour le nombre minimal de threads d’achèvement d’e/s asynchrones.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Place une méthode en file d'attente pour exécution. La méthode s'exécute lorsqu'un thread du pool devient disponible.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <see cref="T:System.Threading.WaitCallback" /> qui représente la méthode à exécuter.</param>
        <summary>Place une méthode en file d'attente pour exécution. La méthode s'exécute lorsqu'un thread du pool devient disponible.</summary>
        <returns>
          <see langword="true" /> si la méthode est placée en file d'attente avec succès ; <see cref="T:System.NotSupportedException" /> est levé si l'élément de travail n'a pas pu être placé en file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez placer les données requises par la méthode en file d’attente dans les champs d’instance de la classe dans laquelle la méthode est définie, ou vous pouvez utiliser le <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> surcharge qui accepte un objet contenant les données nécessaires.  
  
> [!NOTE]
>  Les utilisateurs de Visual Basic peuvent omettre le <xref:System.Threading.WaitCallback> constructeur et utiliser simplement le `AddressOf` opérateur lors du passage de la méthode de rappel à <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic appelle automatiquement le constructeur délégué approprié.  
  
## <a name="version-information"></a>Informations sur la version  
 Dans le .NET Framework version 2.0, le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valeur de propriété est propagée aux threads de travail en file d’attente à l’aide de la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (méthode). Dans les versions antérieures, les informations du principal ne sont pas propagées.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> surcharge de méthode en file d’attente une tâche, qui est représentée par la `ThreadProc` méthode, à exécuter lorsqu’un thread devient disponible. Aucune information de tâche n’est fournie avec cette surcharge. Par conséquent, les informations qui est disponibles pour le `ThreadProc` méthode est limitée à l’objet auquel appartient la méthode.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Le Common Language Runtime (CLR) est hébergé et l'hôte ne prend pas en charge cette action.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pool de threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <see cref="T:System.Threading.WaitCallback" /> représentant la méthode à exécuter.</param>
        <param name="state">Objet contenant les données que la méthode doit utiliser.</param>
        <summary>Place une méthode en file d'attente pour exécution et spécifie un objet contenant les données que la méthode doit utiliser. La méthode s'exécute lorsqu'un thread du pool devient disponible.</summary>
        <returns>
          <see langword="true" /> si la méthode est placée en file d'attente avec succès ; <see cref="T:System.NotSupportedException" /> est levé si l'élément de travail n'a pas pu être placé en file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la méthode de rappel requiert des données complexes, vous pouvez définir une classe pour contenir les données.  
  
> [!NOTE]
>  Les utilisateurs de Visual Basic peuvent omettre le <xref:System.Threading.WaitCallback> constructeur et utiliser simplement le `AddressOf` opérateur lors du passage de la méthode de rappel à <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic appelle automatiquement le constructeur délégué approprié.  
  
## <a name="version-information"></a>Informations sur la version  
 Dans le .NET Framework version 2.0, le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valeur de propriété est propagée aux threads de travail en file d’attente à l’aide de la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (méthode). Dans les versions antérieures, les informations du principal ne sont pas propagées.  
  
   
  
## Examples  
 L’exemple suivant utilise le pool de threads .NET pour calculer le `Fibonacci` résultat pour cinq des nombres compris entre 20 et 40. Chaque résultat `Fibonacci` est représenté par la classe `Fibonacci`, qui fournit une méthode nommée `ThreadPoolCallback` qui effectue le calcul. Un objet représentant chaque valeur `Fibonacci` est créé, et la méthode `ThreadPoolCallback` est passée à <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, qui assigne un thread disponible du pool pour exécuter la méthode.  
  
 Étant donné que chaque `Fibonacci` objet se voit attribuer une valeur semi-aléatoire à calculer, et étant donné que chaque thread est en concurrence pour le temps processeur, vous ne pouvez pas savoir à l’avance la durée pour toutes les cinq résultats doit être calculée. C’est pourquoi chaque objet `Fibonacci` reçoit une instance de la classe <xref:System.Threading.ManualResetEvent> pendant la construction. Chaque objet signale à l’objet d’événement fourni quand son calcul est terminé, ce qui permet au thread principal de bloquer l’exécution avec <xref:System.Threading.WaitHandle.WaitAll%2A> jusqu'à ce que toutes les cinq `Fibonacci` objets aient calculé un résultat. La méthode `Main` affiche ensuite chaque résultat `Fibonacci`.
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le Common Language Runtime (CLR) est hébergé et l'hôte ne prend pas en charge cette action.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> est <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pool de threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit un délégué en attente de <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> à inscrire. Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Délégué <see cref="T:System.Threading.WaitOrTimerCallback" /> à appeler quand le paramètre <c>waitObject</c> est signalé.</param>
        <param name="state">Objet passé au délégué.</param>
        <param name="millisecondsTimeOutInterval">Délai en millisecondes. Si le paramètre <c>millisecondsTimeOutInterval</c> a la valeur zéro (0), la fonction teste l’état de l’objet et procède à un retour immédiat. Si <c>millisecondsTimeOutInterval</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</param>
        <summary>Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, en utilisant, pour indiquer le délai en millisecondes, un entier 32 bits signé.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> qui encapsule le handle natif.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente. Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`. Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.  
  
 Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode files d’attente le délégué spécifié pour le pool de threads. Un thread de travail exécute le délégué lorsqu’une des actions suivantes se produit :  
  
-   L’objet spécifié est dans l’état signalé.  
  
-   L’intervalle de délai d’attente est dépassé.  
  
 Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode vérifie l’état actuel de l’objet spécifié <xref:System.Threading.WaitHandle>. Si l’état de l’objet n’est pas signalé, la méthode inscrit une opération d’attente. L’opération d’attente est effectuée par un thread du pool de threads. Le délégué est exécuté par un thread de travail lors de l’état de l’objet est signalé ou que l’intervalle de délai d’expiration est écoulé. Si le `timeOutInterval` paramètre n’est pas 0 (zéro) et le `executeOnlyOnce` paramètre est `false`, le minuteur est réinitialisé chaque fois que l’événement est signalé ou que l’intervalle de délai d’expiration est écoulé.  
  
> [!IMPORTANT]
>  À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct. Au lieu d’un <xref:System.Threading.Mutex>, utilisez un <xref:System.Threading.Semaphore> avec un nombre maximal de 1.  
  
 Pour annuler l’opération d’attente, appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode).  
  
 Le thread d’attente utilise Win32 `WaitForMultipleObjects` (fonction) pour surveiller les opérations d’attente inscrite. Par conséquent, si vous devez utiliser le même handle de système d’exploitation natif dans plusieurs appels à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, vous devez dupliquer le handle à l’aide de Win32 `DuplicateHandle` (fonction). Notez que vous ne devez pas pulse un objet d’événement passé à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, car le thread d’attente peut ne pas détecte que l’événement est signalé avant la réinitialisation.  
  
 Avant de retourner, la fonction modifie l’état de certains types d’objets de synchronisation. Modification se produit uniquement pour l’objet dont l’état signalé a provoqué la condition d’attente à satisfaire. Par exemple, le nombre d’un sémaphore est diminué d’un.  
  
## <a name="version-information"></a>Informations sur la version  
 En commençant par le .NET Framework version 2.0, le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valeur de propriété est propagée aux threads de travail en file d’attente à l’aide de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode). Dans les versions antérieures, les informations du principal ne sont pas propagées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="millisecondsTimeOutInterval" /> est inférieur à -1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pool de threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> à inscrire. Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Délégué <see cref="T:System.Threading.WaitOrTimerCallback" /> à appeler quand le paramètre <c>waitObject</c> est signalé.</param>
        <param name="state">Objet passé au délégué.</param>
        <param name="millisecondsTimeOutInterval">Délai en millisecondes. Si le paramètre <c>millisecondsTimeOutInterval</c> a la valeur zéro (0), la fonction teste l’état de l’objet et procède à un retour immédiat. Si <c>millisecondsTimeOutInterval</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</param>
        <summary>Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, en utilisant, pour indiquer le délai en millisecondes, un entier 64 bits signé.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> qui encapsule le handle natif.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente. Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`. Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.  
  
 Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode files d’attente le délégué spécifié pour le pool de threads. Un thread de travail exécute le délégué lorsqu’une des actions suivantes se produit :  
  
-   L’objet spécifié est dans l’état signalé.  
  
-   L’intervalle de délai d’attente est dépassé.  
  
 Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode vérifie l’état actuel de l’objet spécifié <xref:System.Threading.WaitHandle>. Si l’état de l’objet n’est pas signalé, la méthode inscrit une opération d’attente. L’opération d’attente est effectuée par un thread du pool de threads. Le délégué est exécuté par un thread de travail lors de l’état de l’objet est signalé ou que l’intervalle de délai d’expiration est écoulé. Si le `timeOutInterval` paramètre n’est pas 0 (zéro) et le `executeOnlyOnce` paramètre est `false`, le minuteur est réinitialisé chaque fois que l’événement est signalé ou que l’intervalle de délai d’expiration est écoulé.  
  
> [!IMPORTANT]
>  À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct. Au lieu d’un <xref:System.Threading.Mutex>, utilisez un <xref:System.Threading.Semaphore> avec un nombre maximal de 1.  
  
 Pour annuler l’opération d’attente, appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode).  
  
 Le thread d’attente utilise Win32 `WaitForMultipleObjects` (fonction) pour surveiller les opérations d’attente inscrite. Par conséquent, si vous devez utiliser le même handle de système d’exploitation natif dans plusieurs appels à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, vous devez dupliquer le handle à l’aide de Win32 `DuplicateHandle` (fonction). Notez que vous ne devez pas pulse un objet d’événement passé à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, car le thread d’attente peut ne pas détecte que l’événement est signalé avant la réinitialisation.  
  
 Avant de retourner, la fonction modifie l’état de certains types d’objets de synchronisation. Modification se produit uniquement pour l’objet dont l’état signalé a provoqué la condition d’attente à satisfaire. Par exemple, le nombre d’un sémaphore est diminué d’un.  
  
## <a name="version-information"></a>Informations sur la version  
 En commençant par le .NET Framework version 2.0, le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valeur de propriété est propagée aux threads de travail en file d’attente à l’aide de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode). Dans les versions antérieures, les informations du principal ne sont pas propagées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="millisecondsTimeOutInterval" /> est inférieur à -1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pool de threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> à inscrire. Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Délégué <see cref="T:System.Threading.WaitOrTimerCallback" /> à appeler quand le paramètre <c>waitObject</c> est signalé.</param>
        <param name="state">Objet passé au délégué.</param>
        <param name="timeout">Délai représenté par <see cref="T:System.TimeSpan" />. Si le paramètre <c>timeout</c> a la valeur 0 (zéro), la fonction teste l’état de l’objet et procède à un retour immédiat. Si <c>timeout</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</param>
        <summary>Inscrit un délégué en attente de <see cref="T:System.Threading.WaitHandle" />, en spécifiant une valeur <see cref="T:System.TimeSpan" /> pour indiquer le délai.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> qui encapsule le handle natif.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente. Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`. Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.  
  
 Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode files d’attente le délégué spécifié pour le pool de threads. Un thread de travail exécute le délégué lorsqu’une des actions suivantes se produit :  
  
-   L’objet spécifié est dans l’état signalé.  
  
-   L’intervalle de délai d’attente est dépassé.  
  
 Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode vérifie l’état actuel de l’objet spécifié <xref:System.Threading.WaitHandle>. Si l’état de l’objet n’est pas signalé, la méthode inscrit une opération d’attente. L’opération d’attente est effectuée par un thread du pool de threads. Le délégué est exécuté par un thread de travail lors de l’état de l’objet est signalé ou que l’intervalle de délai d’expiration est écoulé. Si le `timeOutInterval` paramètre n’est pas 0 (zéro) et le `executeOnlyOnce` paramètre est `false`, le minuteur est réinitialisé chaque fois que l’événement est signalé ou que l’intervalle de délai d’expiration est écoulé.  
  
> [!IMPORTANT]
>  À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct. Au lieu d’un <xref:System.Threading.Mutex>, utilisez un <xref:System.Threading.Semaphore> avec un nombre maximal de 1.  
  
 Pour annuler l’opération d’attente, appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode).  
  
 Le thread d’attente utilise Win32 `WaitForMultipleObjects` (fonction) pour surveiller les opérations d’attente inscrite. Par conséquent, si vous devez utiliser le même handle de système d’exploitation natif dans plusieurs appels à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, vous devez dupliquer le handle à l’aide de Win32 `DuplicateHandle` (fonction). Notez que vous ne devez pas pulse un objet d’événement passé à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, car le thread d’attente peut ne pas détecte que l’événement est signalé avant la réinitialisation.  
  
 Avant de retourner, la fonction modifie l’état de certains types d’objets de synchronisation. Modification se produit uniquement pour l’objet dont l’état signalé a provoqué la condition d’attente à satisfaire. Par exemple, le nombre d’un sémaphore est diminué d’un.  
  
## <a name="version-information"></a>Informations sur la version  
 En commençant par le .NET Framework version 2.0, le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valeur de propriété est propagée aux threads de travail en file d’attente à l’aide de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode). Dans les versions antérieures, les informations du principal ne sont pas propagées.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="timeout" /> est inférieur à -1.</exception>
        <exception cref="T:System.NotSupportedException">Le paramètre <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pool de threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> à inscrire. Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Délégué <see cref="T:System.Threading.WaitOrTimerCallback" /> à appeler quand le paramètre <c>waitObject</c> est signalé.</param>
        <param name="state">Objet passé au délégué.</param>
        <param name="millisecondsTimeOutInterval">Délai en millisecondes. Si le paramètre <c>millisecondsTimeOutInterval</c> a la valeur zéro (0), la fonction teste l’état de l’objet et procède à un retour immédiat. Si <c>millisecondsTimeOutInterval</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</param>
        <summary>Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, en utilisant, pour indiquer le délai en millisecondes, un entier 32 bits non signé.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> pouvant être utilisé pour annuler l'opération d'attente inscrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente. Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`. Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.  
  
 Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode files d’attente le délégué spécifié pour le pool de threads. Un thread de travail exécute le délégué lorsqu’une des actions suivantes se produit :  
  
-   L’objet spécifié est dans l’état signalé.  
  
-   L’intervalle de délai d’attente est dépassé.  
  
 Le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode vérifie l’état actuel de l’objet spécifié <xref:System.Threading.WaitHandle>. Si l’état de l’objet n’est pas signalé, la méthode inscrit une opération d’attente. L’opération d’attente est effectuée par un thread du pool de threads. Le délégué est exécuté par un thread de travail lors de l’état de l’objet est signalé ou que l’intervalle de délai d’expiration est écoulé. Si le `timeOutInterval` paramètre n’est pas 0 (zéro) et le `executeOnlyOnce` paramètre est `false`, le minuteur est réinitialisé chaque fois que l’événement est signalé ou que l’intervalle de délai d’expiration est écoulé.  
  
> [!IMPORTANT]
>  À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct. Au lieu d’un <xref:System.Threading.Mutex>, utilisez un <xref:System.Threading.Semaphore> avec un nombre maximal de 1.  
  
 Pour annuler l’opération d’attente, appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode).  
  
 Le thread d’attente utilise Win32 `WaitForMultipleObjects` (fonction) pour surveiller les opérations d’attente inscrite. Par conséquent, si vous devez utiliser le même handle de système d’exploitation natif dans plusieurs appels à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, vous devez dupliquer le handle à l’aide de Win32 `DuplicateHandle` (fonction). Notez que vous ne devez pas pulse un objet d’événement passé à <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, car le thread d’attente peut ne pas détecte que l’événement est signalé avant la réinitialisation.  
  
 Avant de retourner, la fonction modifie l’état de certains types d’objets de synchronisation. Modification se produit uniquement pour l’objet dont l’état signalé a provoqué la condition d’attente à satisfaire. Par exemple, le nombre d’un sémaphore est diminué d’un.  
  
## <a name="version-information"></a>Informations sur la version  
 En commençant par le .NET Framework version 2.0, le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valeur de propriété est propagée aux threads de travail en file d’attente à l’aide de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode). Dans les versions antérieures, les informations du principal ne sont pas propagées.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode à exécuter une méthode de rappel spécifiée lorsqu’un handle d’attente spécifié est signalé. Dans cet exemple, la méthode de rappel est `WaitProc`, et le handle d’attente est un <xref:System.Threading.AutoResetEvent>.  
  
 L’exemple définit un `TaskInfo` classe pour contenir les informations qui sont passées au rappel lors de l’exécution. L’exemple crée un `TaskInfo` de l’objet et lui assigne des données de chaîne. Le <xref:System.Threading.RegisteredWaitHandle> qui est retourné par la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode est attribuée à la `Handle` champ la `TaskInfo` afin que la méthode de rappel a accès à l’objet le <xref:System.Threading.RegisteredWaitHandle>.  
  
 Outre la spécification `TaskInfo` que l’objet à passer à la méthode de rappel, l’appel à la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> méthode spécifie le <xref:System.Threading.AutoResetEvent> qui attend la tâche, un <xref:System.Threading.WaitOrTimerCallback> délégué qui représente le `WaitProc` méthode de rappel, un intervalle du délai d’attente d’une seconde et plusieurs rappels.  
  
 Lorsque le thread principal signale le <xref:System.Threading.AutoResetEvent> en appelant son <xref:System.Threading.EventWaitHandle.Set%2A> (méthode), le <xref:System.Threading.WaitOrTimerCallback> délégué est appelé. Le `WaitProc` méthode tests <xref:System.Threading.RegisteredWaitHandle> pour déterminer si un délai d’attente s’est produite. Si le rappel a été appelé parce que le handle d’attente a été signalé, le `WaitProc` annule l’inscription de la méthode le <xref:System.Threading.RegisteredWaitHandle>, l’arrêt des rappels supplémentaires. Dans le cas d’un délai d’attente, la tâche continue à attendre. Le `WaitProc` méthode se termine en affichant un message à la console.  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="millisecondsTimeOutInterval" /> est inférieur à -1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pool de threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Nombre maximal de threads de travail dans le pool de threads.</param>
        <param name="completionPortThreads">Nombre maximal de threads d'E/S asynchrones dans le pool de threads.</param>
        <summary>Définit le nombre de demandes au pool de threads pouvant être simultanément actives. Toutes les demandes excédant ce nombre restent dans la file d'attente jusqu'à ce que des threads du pool soient disponibles.</summary>
        <returns>
          <see langword="true" /> si la modification aboutit ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impossible de définir le nombre maximal de threads de travail ou des threads de terminaison d’e/s à un nombre plus petit que le nombre de processeurs sur l’ordinateur. Pour déterminer le nombre de processeurs est présent, récupérez la valeur de la <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> propriété. En outre, vous ne pouvez pas définir le nombre maximal de threads de travail ou des threads de terminaison d’e/s pour un nombre plus petit que le nombre minimal correspondant de threads de travail ou des threads de terminaison d’e/s. Pour déterminer la taille de pool de threads minimum, appelez le <xref:System.Threading.ThreadPool.GetMinThreads%2A> (méthode).  
  
 Si le common language runtime est hébergé, par exemple par Internet Information Services (IIS) ou SQL Server, l’hôte peut limiter ou empêcher la modification de la taille de pool de threads.  
  
 Soyez prudent lorsque vous modifiez le nombre maximal de threads dans le pool de threads. Pendant que votre code pourrait bénéficier, les modifications peuvent avoir un impact négatif sur les bibliothèques de code que vous utilisez.  
  
 Définition de la taille de pool de threads trop volumineux peut entraîner des problèmes de performances. Si trop de threads s’exécutent en même temps, le basculement de tâche devient une surcharge d’un facteur important.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la possibilité de contrôler les threads. Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Nombre minimal de threads de travail que le pool de threads crée à la demande.</param>
        <param name="completionPortThreads">Nombre minimal de threads d'E/S asynchrones que le pool de threads crée à la demande.</param>
        <summary>Définit le nombre minimal de threads que le pool de threads crée à la demande, au fur et à mesure que de nouvelles requêtes sont effectuées, avant de basculer sur un algorithme pour la gestion de la création et de la suppression des threads.</summary>
        <returns>
          <see langword="true" /> si la modification aboutit ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le pool de threads fournit de nouveaux threads de travail ou des threads de terminaison d’e/s à la demande jusqu'à ce qu’il atteigne la valeur minimale pour chaque catégorie. Lorsque la valeur minimale est atteinte, le pool de threads peut créer des threads supplémentaires dans cette catégorie ou attendre que certaines tâches soient terminées. Compter les [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], le pool de threads crée et détruit des threads pour optimiser le débit, ce qui est défini comme le nombre de tâches exécutées par unité de temps. Un nombre trop bas de threads peut ne pas permettre une utilisation optimale des ressources disponibles, tandis qu'un nombre trop élevé de threads peut augmenter les conflits de ressources.  
  
 Quand la demande est faible, le nombre réel de threads du pool peut être inférieur aux valeurs minimales.  
  
 Si vous spécifiez un nombre négatif ou un nombre supérieur au nombre maximal de threads de pool de thread actif (obtenu à l’aide <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> retourne `false` et ne change pas une des valeurs minimales.  
  
> [!CAUTION]
>  Le nombre minimal de threads a la valeur par défaut, le nombre de processeurs sur un système. Vous pouvez utiliser la <xref:System.Threading.ThreadPool.SetMinThreads%2A> méthode pour augmenter l’ofthreads nombre minimal. Toutefois, une augmentation non nécessaire de ces valeurs peut entraîner des problèmes de performances. Si vous démarrez trop de tâches en même temps, celles-ci seront lentes. Dans la plupart des cas, le pool de threads offrira de meilleures performances avec son propre algorithme d’allocation de threads. À moins que le nombre de processeurs peut également dégrader les performances, en réduisant au minimum.  
  
   
  
## Examples  
 L’exemple suivant définit le nombre minimal de threads de travail à quatre et conserve la valeur d’origine pour le nombre minimal de threads d’achèvement d’e/s asynchrones.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la possibilité de contrôler les threads. Valeur d’autorisation : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">Structure <see cref="T:System.Threading.NativeOverlapped" /> à placer en file d'attente.</param>
        <summary>Met en file d'attente l'exécution d'une opération d'E/S avec chevauchement.</summary>
        <returns>
          <see langword="true" /> si l'opération a été mise en file d'attente dans un port de terminaison d'E/S ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur l’utilisation de Win32 natives avec chevauchement d’e/s, consultez le <xref:System.Threading.Overlapped> (classe), le <xref:System.Threading.NativeOverlapped> structure et le `OVERLAPPED` structure dans Win32 Platform SDK.  
  
> [!CAUTION]
>  À l’aide de la <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> méthode peut accidentellement ouvrir une faille de sécurité. Sécurité d’accès du code base ses vérifications d’autorisations sur les autorisations de tous les appelants sur la pile. Lorsque le travail est en file d’attente sur un thread de pool de thread à l’aide <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, la pile du thread du pool n’a pas le contexte des appelants réels. Code malveillant peut être en mesure d’exploiter ceci pour éviter les vérifications d’autorisations.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <see cref="T:System.Threading.WaitCallback" /> représentant le délégué à appeler lorsqu'un thread du pool de threads sélectionne l'élément de travail.</param>
        <param name="state">Objet passé au délégué lors de son traitement dans le pool de threads.</param>
        <summary>Met le délégué spécifié en file d'attente dans le pool de threads, mais ne propage pas la pile d'appels vers le thread de travail.</summary>
        <returns>
          <see langword="true" /> si la méthode est exécutée avec succès ; <see cref="T:System.OutOfMemoryException" /> est levée si l'élément de travail n'a pas pu être placé en file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (méthode), <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> ne propage pas la pile appelante vers le thread de travail. Ainsi, le code de perdre la pile appelante et ainsi d’élever ses privilèges de sécurité.  
  
> [!CAUTION]
>  À l’aide de <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> peut accidentellement ouvrir une faille de sécurité. Sécurité d’accès du code base ses vérifications d’autorisations sur les autorisations de tous les appelants sur la pile. Lorsque le travail est en file d’attente sur un thread de pool de thread à l’aide <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, la pile du thread du pool n’aura pas le contexte des appelants réels. Code malveillant peut être en mesure d’exploiter ceci pour éviter les vérifications d’autorisations.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <exception cref="T:System.ApplicationException">Une condition de mémoire insuffisante a été rencontrée.</exception>
        <exception cref="T:System.OutOfMemoryException">L'élément de travail n'a pas pu être placé en file d'attente.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pool de threads managés</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, mais ne propage pas la pile appelante vers le thread de travail.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> à inscrire. Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Délégué à appeler quand le paramètre <c>waitObject</c> est signalé.</param>
        <param name="state">Objet passé au délégué.</param>
        <param name="millisecondsTimeOutInterval">Délai en millisecondes. Si le paramètre <c>millisecondsTimeOutInterval</c> a la valeur zéro (0), la fonction teste l’état de l’objet et procède à un retour immédiat. Si <c>millisecondsTimeOutInterval</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</param>
        <summary>Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, en utilisant, pour indiquer le délai en millisecondes, un entier signé 32 bits. Cette méthode ne propage pas la pile appelante vers le thread de travail.</summary>
        <returns>Objet <see cref="T:System.Threading.RegisteredWaitHandle" /> pouvant être utilisé pour annuler l'opération d'attente inscrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode), <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> ne propage pas la pile appelante vers le thread de travail. Ainsi, le code de perdre la pile appelante et ainsi d’élever ses privilèges de sécurité.  
  
> [!CAUTION]
>  À l’aide de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> peut accidentellement ouvrir une faille de sécurité. Sécurité d’accès du code base ses vérifications d’autorisations sur les autorisations de tous les appelants sur la pile. Lorsque le travail est en file d’attente sur un thread de pool de thread à l’aide <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pile du thread du pool n’aura pas le contexte des appelants réels. Code malveillant peut être en mesure d’exploiter ceci pour éviter les vérifications d’autorisations.  
  
 À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct.  
  
 Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente. Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`. Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="millisecondsTimeOutInterval" /> est inférieur à -1.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pool de threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> à inscrire. Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Délégué à appeler quand le paramètre <c>waitObject</c> est signalé.</param>
        <param name="state">Objet passé au délégué.</param>
        <param name="millisecondsTimeOutInterval">Délai en millisecondes. Si le paramètre <c>millisecondsTimeOutInterval</c> a la valeur zéro (0), la fonction teste l’état de l’objet et procède à un retour immédiat. Si <c>millisecondsTimeOutInterval</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</param>
        <summary>Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, en utilisant, pour indiquer le délai en millisecondes, un entier 64 bits signé. Cette méthode ne propage pas la pile appelante vers le thread de travail.</summary>
        <returns>Objet <see cref="T:System.Threading.RegisteredWaitHandle" /> pouvant être utilisé pour annuler l'opération d'attente inscrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode), <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> ne propage pas la pile appelante vers le thread de travail. Ainsi, le code de perdre la pile appelante et ainsi d’élever ses privilèges de sécurité.  
  
> [!CAUTION]
>  À l’aide de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> peut accidentellement ouvrir une faille de sécurité. Sécurité d’accès du code base ses vérifications d’autorisations sur les autorisations de tous les appelants sur la pile. Lorsque le travail est en file d’attente sur un thread de pool de thread à l’aide <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pile du thread du pool n’aura pas le contexte des appelants réels. Code malveillant peut être en mesure d’exploiter ceci pour éviter les vérifications d’autorisations.  
  
 À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct.  
  
 Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente. Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`. Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="millisecondsTimeOutInterval" /> est inférieur à -1.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pool de threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> à inscrire. Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Délégué à appeler quand le paramètre <c>waitObject</c> est signalé.</param>
        <param name="state">Objet passé au délégué.</param>
        <param name="timeout">Délai représenté par <see cref="T:System.TimeSpan" />. Si le paramètre <c>timeout</c> a la valeur 0 (zéro), la fonction teste l’état de l’objet et procède à un retour immédiat. Si <c>timeout</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</param>
        <summary>Inscrit un délégué en attente de <see cref="T:System.Threading.WaitHandle" />, en spécifiant une valeur <see cref="T:System.TimeSpan" /> pour indiquer le délai. Cette méthode ne propage pas la pile appelante vers le thread de travail.</summary>
        <returns>Objet <see cref="T:System.Threading.RegisteredWaitHandle" /> pouvant être utilisé pour annuler l'opération d'attente inscrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode), <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> ne propage pas la pile appelante vers le thread de travail. Ainsi, le code de perdre la pile appelante et ainsi d’élever ses privilèges de sécurité.  
  
> [!CAUTION]
>  À l’aide de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> peut accidentellement ouvrir une faille de sécurité. Sécurité d’accès du code base ses vérifications d’autorisations sur les autorisations de tous les appelants sur la pile. Lorsque le travail est en file d’attente sur un thread de pool de thread à l’aide <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pile du thread du pool n’aura pas le contexte des appelants réels. Code malveillant peut être en mesure d’exploiter ceci pour éviter les vérifications d’autorisations.  
  
 À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct.  
  
 Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente. Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`. Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le paramètre <paramref name="timeout" /> est inférieur à -1.</exception>
        <exception cref="T:System.NotSupportedException">Le paramètre <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pool de threads managés</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> à inscrire. Utilisez un <see cref="T:System.Threading.WaitHandle" /> autre que <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Délégué à appeler quand le paramètre <c>waitObject</c> est signalé.</param>
        <param name="state">Objet passé au délégué.</param>
        <param name="millisecondsTimeOutInterval">Délai en millisecondes. Si le paramètre <c>millisecondsTimeOutInterval</c> a la valeur zéro (0), la fonction teste l’état de l’objet et procède à un retour immédiat. Si <c>millisecondsTimeOutInterval</c> a la valeur -1, le délai d’expiration de la fonction ne prend jamais fin.</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> pour indiquer que le thread ne tient plus compte du paramètre <c>waitObject</c> une fois le délégué appelé ; <see langword="false" /> pour indiquer que la minuterie est réinitialisée à chaque achèvement d’opération d’attente, jusqu’à annulation de l’inscription de l’attente.</param>
        <summary>Inscrit un délégué pour attendre un <see cref="T:System.Threading.WaitHandle" />, en utilisant, pour indiquer le délai en millisecondes, un entier 32 bits non signé. Cette méthode ne propage pas la pile appelante vers le thread de travail.</summary>
        <returns>Objet <see cref="T:System.Threading.RegisteredWaitHandle" /> pouvant être utilisé pour annuler l'opération d'attente inscrite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (méthode), <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> ne propage pas la pile appelante vers le thread de travail. Ainsi, le code de perdre la pile appelante et ainsi d’élever ses privilèges de sécurité.  
  
> [!CAUTION]
>  À l’aide de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> peut accidentellement ouvrir une faille de sécurité. Sécurité d’accès du code base ses vérifications d’autorisations sur les autorisations de tous les appelants sur la pile. Lorsque le travail est en file d’attente sur un thread de pool de thread à l’aide <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pile du thread du pool n’aura pas le contexte des appelants réels. Code malveillant peut être en mesure d’exploiter ceci pour éviter les vérifications d’autorisations.  
  
 À l’aide un <xref:System.Threading.Mutex> pour `waitObject` ne fournit pas l’exclusion mutuelle des rappels, car l’API Win32 sous-jacente utilise la valeur par défaut `WT_EXECUTEDEFAULT` indicateur, de sorte que chaque rappel est distribué sur un thread distinct.  
  
 Lorsque vous avez terminé à l’aide de la <xref:System.Threading.RegisteredWaitHandle> qui est retourné par cette méthode, appelez sa <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode pour libérer les références au handle d’attente. Nous vous recommandons de toujours appeler le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (méthode), même si vous spécifiez `true` pour `executeOnlyOnce`. Le garbage collection fonctionne plus efficacement si vous appelez le <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> méthode au lieu de selon le finaliseur du handle d’attente inscrite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Pool de threads managés</related>
      </Docs>
    </Member>
  </Members>
</Type>