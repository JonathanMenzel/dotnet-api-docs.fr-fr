<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="04ca1c444cfd772670659b4609b267628b38c728" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531143" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un événement de synchronisation de threads.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Threading.EventWaitHandle> classe permet aux threads de communiquer entre eux par la signalisation. En général, un ou plusieurs threads se bloquent sur un <xref:System.Threading.EventWaitHandle> jusqu'à ce qu’un thread débloqué appelle la <xref:System.Threading.EventWaitHandle.Set%2A> méthode et libère un ou plusieurs des threads bloqués. Un thread peut signaler un <xref:System.Threading.EventWaitHandle> et bloquer ensuite sur celui-ci, en appelant le `static` (`Shared` en Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> (méthode).  
  
> [!NOTE]
>  La <xref:System.Threading.EventWaitHandle> classe fournit l’accès aux événements de synchronisation système nommé.  
  
 Le comportement d’un <xref:System.Threading.EventWaitHandle> qui a été signalé dépend de son mode de réinitialisation. Un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> indicateur réinitialise automatiquement quand il est signalé, après avoir libéré un seul thread en attente. Un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> indicateur reste signalé jusqu'à ce que son <xref:System.Threading.EventWaitHandle.Reset%2A> méthode est appelée.  
  
 Événements de réinitialisation automatique fournissent un accès exclusif à une ressource. Si un événement à réinitialisation automatique est signalé alors qu’aucun thread n’attend, il reste signalé jusqu'à ce qu’un thread tente de l’attendre. L’événement libère le thread et est immédiatement réinitialisé, ce qui bloque les threads suivants.  
  
 Les événements sont comme des portes de réinitialisation manuelle. Lorsque l’événement n’est pas signalé, les threads qui l’attendent se bloquent. Lorsque l’événement est signalé, tous les threads en attente sont libérés et l’événement reste signalé (c'est-à-dire que les attentes suivantes ne se bloquent pas) jusqu'à ce que son <xref:System.Threading.EventWaitHandle.Reset%2A> méthode est appelée. Événements de réinitialisation manuelle sont utiles lorsqu’un thread doit terminer une activité avant de procéder des autres threads.  
  
 <xref:System.Threading.EventWaitHandle> objets peuvent être utilisés avec la `static`(`Shared` en Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> et <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> méthodes.  
  
 Pour plus d’informations sur les mécanismes de synchronisation de threads, consultez [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.  
  
 L’exemple démarre cinq threads et leur permet de bloquer sur un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> indicateur, puis libère un thread chaque fois que l’utilisateur appuie sur la touche ENTRÉE. L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant une <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> indicateur.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> pour définir l'état initial comme étant signalé ; <see langword="false" /> pour le définir comme étant non signalé.</param>
        <param name="mode">L’une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, en spécifiant si le handle d'attente est signalé initialement et s'il se réinitialise automatiquement ou manuellement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’état initial de l’événement est "non signalé", les threads qui attendent que l’événement se bloquent. Si l’état initial est signalé et le <xref:System.Threading.EventResetMode.ManualReset> indicateur est spécifié pour `mode`, les threads qui attendent que l’événement se bloquent pas. Si l’état initial est signalé, et `mode` est <xref:System.Threading.EventResetMode.AutoReset>, le premier thread qui attend l’événement est libéré immédiatement, après laquelle l’événement va réinitialiser et bloquent les threads suivants.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.  
  
 L’exemple démarre cinq threads et leur permet de bloquer sur un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> indicateur, puis libère un thread chaque fois que l’utilisateur appuie sur la touche ENTRÉE. L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant une <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> indicateur.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> pour définir l’état initial sur signalé si l’événement nommé est créé suite à cet appel ; <see langword="false" /> pour le définir sur non signalé.</param>
        <param name="mode">L’une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</param>
        <param name="name">Le nom d’un événement de synchronisation à l’échelle du système.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, en spécifiant si le handle d'attente est signalé initialement s'il a été créé à la suite de cet appel, s'il se réinitialise automatiquement ou manuellement, ainsi que le nom d'un événement de synchronisation du système.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `name` est `null` ou une chaîne vide, une variable locale <xref:System.Threading.EventWaitHandle> est créé.  
  
 Si un événement système avec le nom spécifié pour le `name` paramètre existe déjà, le `initialState` paramètre est ignoré.  
  
> [!IMPORTANT]
>  Lorsque vous utilisez ce constructeur pour des événements système nommé, spécifiez `false` pour `initialState`. Ce constructeur ne fournit aucun moyen de déterminer si un événement système nommé a été créé, vous ne pouvez pas faire d’hypothèses concernant l’état de l’événement nommé. Pour déterminer si un événement nommé a été créé, utilisez la <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructeur ou <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructeur.  
  
 Si l’état initial de l’événement est "non signalé", les threads qui attendent que l’événement se bloquent. Si l’état initial est signalé et le <xref:System.Threading.EventResetMode.ManualReset> indicateur est spécifié pour `mode`, les threads qui attendent que l’événement se bloquent pas. Si l’état initial est signalé, et `mode` est <xref:System.Threading.EventResetMode.AutoReset>, le premier thread qui attend l’événement est libéré immédiatement, après laquelle l’événement va réinitialiser et bloquent les threads suivants.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’événement nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L’événement nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> fait plus de 260 caractères.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> pour définir l’état initial sur signalé si l’événement nommé est créé suite à cet appel ; <see langword="false" /> pour le définir sur non signalé.</param>
        <param name="mode">L’une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</param>
        <param name="name">Le nom d’un événement de synchronisation à l’échelle du système.</param>
        <param name="createdNew">Cette méthode retourne <see langword="true" /> si un événement local a été créé (en d’autres termes, si <c>name</c> est <see langword="null" /> ou une chaîne vide) ou si l’événement système nommé spécifié a été créé ; <see langword="false" /> si l’événement système nommé spécifié existait déjà. Ce paramètre est passé sans être initialisé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, spécifiant si le handle d’attente est signalé initialement s’il est créé suite à cet appel, s’il se réinitialise automatiquement ou manuellement, le nom d’un événement de synchronisation du système et une variable booléenne dont la valeur après l’appel indique si l’événement système nommé a été créé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un événement système avec le nom spécifié pour le `name` paramètre existe déjà, le `initialState` paramètre est ignoré. Après l’appel de ce constructeur, utilisez la valeur de la variable spécifiée pour le `ref` paramètre (`ByRef` paramètre en Visual Basic)`createdNew` pour déterminer si l’événement système nommé existait déjà ou a été créé.  
  
 Si l’état initial de l’événement est "non signalé", les threads qui attendent que l’événement se bloquent. Si l’état initial est signalé et le <xref:System.Threading.EventResetMode.ManualReset> indicateur est spécifié pour `mode`, les threads qui attendent que l’événement se bloquent pas. Si l’état initial est signalé, et `mode` est <xref:System.Threading.EventResetMode.AutoReset>, le premier thread qui attend l’événement est libéré immédiatement, après laquelle l’événement va réinitialiser et bloquent les threads suivants.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’événement nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L’événement nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> fait plus de 260 caractères.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> pour définir l’état initial sur signalé si l’événement nommé est créé suite à cet appel ; <see langword="false" /> pour le définir sur non signalé.</param>
        <param name="mode">L’une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</param>
        <param name="name">Le nom d’un événement de synchronisation à l’échelle du système.</param>
        <param name="createdNew">Cette méthode retourne <see langword="true" /> si un événement local a été créé (en d’autres termes, si <c>name</c> est <see langword="null" /> ou une chaîne vide) ou si l’événement système nommé spécifié a été créé ; <see langword="false" /> si l’événement système nommé spécifié existait déjà. Ce paramètre est passé sans être initialisé.</param>
        <param name="eventSecurity">Objet <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> qui représente la sécurité de contrôle d’accès à appliquer à l’événement système nommé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, spécifiant si le handle d’attente est signalé initialement s’il est créé suite à cet appel, s’il se réinitialise automatiquement ou manuellement, le nom d’un événement de synchronisation du système et une variable booléenne dont la valeur après l’appel indique si l’événement système nommé a été créé, et la sécurité de contrôle d’accès à appliquer à l’événement nommé s’il est créé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur pour appliquer la sécurité de contrôle d’accès à un événement système nommé lors de sa création, en empêchant l’autre code de prendre le contrôle de l’événement.  
  
 Ce constructeur initialise un <xref:System.Threading.EventWaitHandle> objet qui représente un événement système. Vous pouvez créer plusieurs <xref:System.Threading.EventWaitHandle> objets qui représentent le même événement système.  
  
 Si l’événement système n’existe pas, il est créé avec la sécurité de contrôle d’accès spécifié. Si l’événement existe, la sécurité de contrôle d’accès spécifié est ignorée.  
  
> [!NOTE]
>  L’appelant a un contrôle total sur nouvellement créé <xref:System.Threading.EventWaitHandle> objet même si `eventSecurity` refuse ou ne parvient pas à accorder des droits d’accès à l’utilisateur actuel. Toutefois, si l’utilisateur actuel tente d’obtenir un autre <xref:System.Threading.EventWaitHandle> pour représenter le même événement nommé, en utilisant un constructeur de l’objet ou le <xref:System.Threading.EventWaitHandle.OpenExisting%2A> (méthode), Windows de sécurité de contrôle d’accès est appliquée.  
  
 Si un événement système avec le nom spécifié pour le `name` paramètre existe déjà, le `initialState` paramètre est ignoré. Après l’appel de ce constructeur, utilisez la valeur de la variable spécifiée pour le `ref` paramètre (`ByRef` paramètre en Visual Basic) `createdNew` pour déterminer si l’événement système nommé existait déjà ou a été créé.  
  
 Si l’état initial de l’événement est "non signalé", les threads qui attendent que l’événement se bloquent. Si l’état initial est signalé et le <xref:System.Threading.EventResetMode.ManualReset> indicateur est spécifié pour `mode`, les threads qui attendent que l’événement se bloquent pas. Si l’état initial est signalé, et `mode` est <xref:System.Threading.EventResetMode.AutoReset>, le premier thread qui attend l’événement est libéré immédiatement, après laquelle l’événement va réinitialiser et bloquent les threads suivants.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec une sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> la surcharge de méthode pour tester l’existence d’un événement nommé.  
  
 Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse de l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. L’exception est interceptée et l’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.  
  
 Une fois que les autorisations sont modifiées, l’événement est ouvert avec les droits requis pour l’attendre et le signaler. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’événement nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L’événement nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> fait plus de 260 caractères.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> qui représente la sécurité de contrôle d'accès pour l'événement système nommé représenté par l'objet <see cref="T:System.Threading.EventWaitHandle" /> actuel.</summary>
        <returns>Objet <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> qui représente la sécurité de contrôle d'accès pour l'événement système nommé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> méthode utilise la combinaison d’indicateurs (combinées à l’aide de l’opération OR au niveau du bit) suivante pour rechercher des autorisations : <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, et <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 L’utilisateur doit avoir <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> droits pour appeler cette méthode et l’événement doivent avoir été ouvert avec le <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> indicateur.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec une sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> la surcharge de méthode pour tester l’existence d’un événement nommé.  
  
 Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse de l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. L’exception est interceptée et l’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.  
  
 Une fois que les autorisations ont été lus, à l’aide de la <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> (méthode), et modifié, l’événement est ouvert avec les droits requis pour attendre et le signaler. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'objet <see cref="T:System.Threading.EventWaitHandle" /> actuel représente un événement système nommé et l'utilisateur n'a pas de droits <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  
  
 - ou -  
  
 L'objet <see cref="T:System.Threading.EventWaitHandle" /> actuel représente un événement système nommé ; il n'a pas été ouvert avec <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Non pris en charge par Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode <see cref="M:System.Threading.WaitHandle.Close" /> a été précédemment appelée sur ce <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un événement de synchronisation nommé spécifié s'il existe déjà.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l’événement de synchronisation système à ouvrir.</param>
        <summary>Ouvre l'événement de synchronisation nommé spécifié s'il existe déjà.</summary>
        <returns>Objet qui représente l’événement système nommé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Threading.EventWaitHandle.OpenExisting%2A> méthode essaie d’ouvrir l’événement système nommé spécifié. Si l’événement système n’existe pas, cette méthode lève une exception au lieu de créer l’événement système. Pour créer l’événement système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructeurs qui a un `name` paramètre.  
  
 Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.EventWaitHandle> de l’objet, même si les objets retournés représentent le même événement système nommé.  
  
 Cette surcharge de méthode équivaut à appeler le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode et en spécifiant <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> et <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> des droits, combinés à l’aide de l’opération OR au niveau du bit.  
  
 En spécifiant le <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> indicateur permet à un thread d’attendre l’événement système nommé et en spécifiant le <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> indicateur permet à un thread d’appeler le <xref:System.Threading.EventWaitHandle.Set%2A> et <xref:System.Threading.EventWaitHandle.Reset%2A> méthodes.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec une sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> la surcharge de méthode pour tester l’existence d’un événement nommé.  
  
 Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse de l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. L’exception est interceptée et l’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.  
  
 Une fois que les autorisations sont modifiées, l’événement est ouvert avec les droits requis pour l’attendre et le signaler. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> est une chaîne vide.  
  
 - ou -  
  
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'événement de système nommé n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'événement nommé existe, mais l'utilisateur ne possède pas l'accès de sécurité requis pour l'utiliser.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l’événement de synchronisation système à ouvrir.</param>
        <param name="rights">Combinaison d'opérations de bits des valeurs d'énumération qui représentent l'accès de sécurité voulu.</param>
        <summary>Ouvre l'événement de synchronisation nommé spécifié, s'il existe déjà, avec l'accès de sécurité souhaité.</summary>
        <returns>Objet qui représente l'événement système nommé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `rights` paramètre doit inclure le <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> indicateur pour permettre aux threads d’attendre l’événement et le <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> indicateur pour permettre aux threads d’appeler le <xref:System.Threading.EventWaitHandle.Set%2A> et <xref:System.Threading.EventWaitHandle.Reset%2A> méthodes.  
  
 Le <xref:System.Threading.EventWaitHandle.OpenExisting%2A> méthode essaie d’ouvrir un événement système nommé existant. Si l’événement système n’existe pas, cette méthode lève une exception au lieu de créer l’événement système. Pour créer l’événement système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructeurs qui a un `name` paramètre.  
  
 Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.EventWaitHandle> de l’objet, même si les objets retournés représentent le même événement système nommé.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec une sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> la surcharge de méthode pour tester l’existence d’un événement nommé.  
  
 Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse de l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. L’exception est interceptée et l’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.  
  
 Une fois que les autorisations sont modifiées, l’événement est ouvert avec les droits requis pour l’attendre et le signaler. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> est une chaîne vide.  
  
 - ou -  
  
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'événement de système nommé n'existe pas.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’événement nommé existe mais l’utilisateur ne dispose de l’accès de sécurité nécessaire.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Définit l’état de l’événement à “non signalé”, ce qui entraîne le blocage des threads.</summary>
        <returns>
          <see langword="true" /> si l'opération aboutit ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">La méthode <see cref="M:System.Threading.WaitHandle.Close" /> a été précédemment appelée sur ce <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Définit l’état de l’événement à Signalé, ce qui permet à un ou plusieurs threads en attente de continuer.</summary>
        <returns>
          <see langword="true" /> si l'opération aboutit ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour un <xref:System.Threading.EventWaitHandle> avec <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (y compris <xref:System.Threading.AutoResetEvent>), la <xref:System.Threading.EventWaitHandle.Set%2A> méthode libère un thread unique. S’il n’y a pas de threads en attente, le handle d’attente reste signalé jusqu'à ce qu’un thread tente d’attendre sur celui-ci, ou jusqu'à ce que son <xref:System.Threading.EventWaitHandle.Reset%2A> méthode est appelée.  
  
> [!IMPORTANT]
>  Il n’existe aucune garantie que chaque appel à la <xref:System.Threading.EventWaitHandle.Set%2A> libère un thread d’une <xref:System.Threading.EventWaitHandle> dont le mode de réinitialisation est <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>. Si deux appels sont trop proches, afin que le deuxième appel se produit avant qu’un thread a été publié, un seul thread est libéré. Il s’agit comme si le deuxième appel n’est pas possible. En outre, si <xref:System.Threading.EventWaitHandle.Set%2A> est appelée lorsqu’il n’y a aucune threads en attente et le <xref:System.Threading.EventWaitHandle> est déjà signalé, l’appel n’a aucun effet.  
  
 Pour un <xref:System.Threading.EventWaitHandle> avec <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (y compris <xref:System.Threading.ManualResetEvent>), l’appel du <xref:System.Threading.EventWaitHandle.Set%2A> méthode laisse le handle d’attente dans un état signalé jusqu'à ce que son <xref:System.Threading.EventWaitHandle.Reset%2A> méthode est appelée.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.  
  
 L’exemple démarre cinq threads et leur permet de bloquer sur un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> indicateur, puis libère un thread chaque fois que l’utilisateur appuie sur la touche ENTRÉE. L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant une <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> indicateur.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La méthode <see cref="M:System.Threading.WaitHandle.Close" /> a été précédemment appelée sur ce <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">Objet <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> qui représente la sécurité de contrôle d’accès à appliquer à l’événement système nommé.</param>
        <summary>Définit la sécurité de contrôle d’accès pour un événement système nommé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’utilisateur doit avoir <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> droits pour appeler cette méthode et l’événement doivent avoir été ouvert avec le <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> indicateur.  
  
   
  
## Examples  
 L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec une sécurité de contrôle d’accès. L’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> la surcharge de méthode pour tester l’existence d’un événement nommé.  
  
 Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse de l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.  
  
 Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. L’exception est interceptée et l’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.  
  
 Une fois que les autorisations sont modifiées, à l’aide de la <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> méthode, l’événement est ouvert avec les droits requis pour l’attendre et le signaler. Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" /> est <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utilisateur ne détient pas d'autorisations <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  
  
 - ou -  
  
 L'événement n'a pas été ouvert avec <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">L'objet <see cref="T:System.Threading.EventWaitHandle" /> actuel ne représente pas un événement système nommé.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode <see cref="M:System.Threading.WaitHandle.Close" /> a été précédemment appelée sur ce <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre un événement de synchronisation nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l’événement de synchronisation système à ouvrir.</param>
        <param name="result">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.EventWaitHandle" /> qui représente l’événement de synchronisation nommé si l’appel a réussi, ou <see langword="null" /> si l’appel a échoué. Ce paramètre est traité comme étant non initialisé.</param>
        <summary>Ouvre l’événement de synchronisation nommé spécifié, s’il existe déjà, et retourne une valeur indiquant si l’opération a réussi.</summary>
        <returns>
          <see langword="true" /> si l’événement de synchronisation nommé a été ouvert ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’événement de synchronisation nommé n’existe pas, cette méthode ne crée pas il. Pour créer l’événement système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructeurs qui a un `name` paramètre.  
  
 Si vous n’êtes pas certain qu’il existe un événement de synchronisation nommé, utilisez cette surcharge de méthode à la place de la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> surcharge de méthode qui lève une exception si l’événement de synchronisation n’existe pas.  
  
 Cette surcharge de méthode équivaut à appeler le <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> surcharge de méthode et en spécifiant <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> et <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> des droits, combinés à l’aide de l’opération OR au niveau du bit. En spécifiant le <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> indicateur permet à un thread d’attendre l’événement système nommé et en spécifiant le <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> indicateur permet à un thread d’appeler le <xref:System.Threading.EventWaitHandle.Set%2A> et <xref:System.Threading.EventWaitHandle.Reset%2A> méthodes.  
  
 Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.EventWaitHandle> de l’objet, même si les objets retournés représentent le même événement système nommé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> est une chaîne vide.  
  
 - ou -  
  
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’événement nommé existe mais l’utilisateur ne dispose de l’accès de sécurité nécessaire.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l’événement de synchronisation système à ouvrir.</param>
        <param name="rights">Combinaison d'opérations de bits des valeurs d'énumération qui représentent l'accès de sécurité voulu.</param>
        <param name="result">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.EventWaitHandle" /> qui représente l'événement de synchronisation nommé si l'appel a réussi, ou <see langword="null" /> si l'appel a échoué. Ce paramètre est traité comme étant non initialisé.</param>
        <summary>Ouvre l'événement de synchronisation nommé spécifié, s'il existe déjà, avec l'accès de sécurité souhaité, puis retourne une valeur indiquant si l'opération a réussi.</summary>
        <returns>
          <see langword="true" /> si l’événement de synchronisation nommé a été ouvert ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’événement de synchronisation nommé n’existe pas, cette méthode ne crée pas il. Pour créer l’événement système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructeurs qui a un `name` paramètre.  
  
 Si vous n’êtes pas certain qu’il existe un événement de synchronisation nommé, utilisez cette surcharge de méthode à la place de la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode qui lève une exception si l’événement de synchronisation n’existe pas.  
  
 Le `rights` paramètre doit inclure le <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> indicateur pour permettre aux threads d’attendre l’événement et le <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> indicateur pour permettre aux threads d’appeler le <xref:System.Threading.EventWaitHandle.Set%2A> et <xref:System.Threading.EventWaitHandle.Reset%2A> méthodes.  
  
 Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.EventWaitHandle> de l’objet, même si les objets retournés représentent le même événement système nommé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> est une chaîne vide.  
  
 - ou -  
  
 <paramref name="name" /> fait plus de 260 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur Win32 s’est produite.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’événement nommé existe mais l’utilisateur ne dispose de l’accès de sécurité nécessaire.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
  </Members>
</Type>