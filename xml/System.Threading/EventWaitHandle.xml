<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3c9a486faca32942b613bb0f56059ee6c2c59528" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57955216" /></Metadata><TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="c9f7e-101">Représente un événement de synchronisation de threads.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-101">Represents a thread synchronization event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c9f7e-102">Le <xref:System.Threading.EventWaitHandle> classe permet aux threads de communiquer entre eux par la signalisation.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-102">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling.</span></span> <span data-ttu-id="c9f7e-103">En général, un ou plusieurs threads se bloquent sur un <xref:System.Threading.EventWaitHandle> jusqu'à ce qu’un thread débloqué appelle la <xref:System.Threading.EventWaitHandle.Set%2A> méthode et libère un ou plusieurs des threads bloqués.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-103">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads.</span></span> <span data-ttu-id="c9f7e-104">Un thread peut signaler un <xref:System.Threading.EventWaitHandle> , puis se bloquer sur celui-ci, en appelant le `static` (`Shared` en Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="c9f7e-104">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c9f7e-105">Le <xref:System.Threading.EventWaitHandle> classe fournit l’accès aux événements de synchronisation système nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-105">The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.</span></span>  
  
 <span data-ttu-id="c9f7e-106">Le comportement d’un <xref:System.Threading.EventWaitHandle> qui a été signalé dépend de son mode de réinitialisation.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-106">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode.</span></span> <span data-ttu-id="c9f7e-107">Un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> indicateur se réinitialise automatiquement quand il est signalé, après avoir libéré un seul thread en attente.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-107">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="c9f7e-108">Un <xref:System.Threading.EventWaitHandle> créé avec l’indicateur <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> reste signalé jusqu'à ce que la méthode <xref:System.Threading.EventWaitHandle.Reset%2A> soit appelée.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-108">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="c9f7e-109">Les événements de réinitialisation automatique fournissent un accès exclusif à une ressource.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-109">Automatic reset events provide exclusive access to a resource.</span></span> <span data-ttu-id="c9f7e-110">Si un événement à réinitialisation automatique est signalé alors qu’aucun thread n’attend, il reste signalé jusqu'à ce qu’un thread tente de l’attendre.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-110">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="c9f7e-111">L’événement libère le thread et est immédiatement réinitialisé, ce qui bloque les threads suivants.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-111">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
 <span data-ttu-id="c9f7e-112">Les événements sont comme des portes de réinitialisation manuelle.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-112">Manual reset events are like gates.</span></span> <span data-ttu-id="c9f7e-113">Lorsque l’événement n’est pas signalé, les threads qui l’attendent se bloquent.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-113">When the event is not signaled, threads that wait on it will block.</span></span> <span data-ttu-id="c9f7e-114">Lorsque l’événement est signalé, tous les threads en attente sont publiées, et l’événement reste signalé (autrement dit, que les attentes suivantes ne se bloquent pas) jusqu'à ce que son <xref:System.Threading.EventWaitHandle.Reset%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-114">When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="c9f7e-115">Événements de réinitialisation manuelle sont utiles lorsqu’un thread doit terminer une activité avant les autres threads puissent continuer.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-115">Manual reset events are useful when one thread must complete an activity before other threads can proceed.</span></span>  
  
 <span data-ttu-id="c9f7e-116"><xref:System.Threading.EventWaitHandle> objets peuvent être utilisés avec la `static`(`Shared` en Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> et <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> méthodes.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-116"><xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="c9f7e-117">Pour plus d’informations, consultez le [Thread interaction ou sa signalisation](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling) section de la [vue d’ensemble des primitives de synchronisation](~/docs/standard/threading/overview-of-synchronization-primitives.md) article.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-117">For more information, see the [Thread interaction, or signaling](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling) section of the [Overview of synchronization primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md) article.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c9f7e-118">Le code suivant exemple utilise le <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-118">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="c9f7e-119">L’exemple démarre cinq threads et leur permet de bloquer sur un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> indicateur, puis libère un thread chaque fois l’utilisateur appuie sur la touche ENTRÉE.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-119">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="c9f7e-120">L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-120">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="c9f7e-121">Ce type est thread-safe.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-121">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="c9f7e-122">Threading managé</span><span class="sxs-lookup"><span data-stu-id="c9f7e-122">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="c9f7e-123">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="c9f7e-123">Overview of synchronization primitives</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c9f7e-124">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-124">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="c9f7e-125"><see langword="true" /> pour définir l'état initial comme étant signalé ; <see langword="false" /> pour le définir comme étant non signalé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-125"><see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="c9f7e-126">L’une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-126">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <summary><span data-ttu-id="c9f7e-127">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, en spécifiant si le handle d'attente est signalé initialement et s'il se réinitialise automatiquement ou manuellement.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-127">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c9f7e-128">Si l’état initial de l’événement est "non signalé", les threads qui attendent l’événement se bloquent.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-128">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="c9f7e-129">Si l’état initial est signalé et le <xref:System.Threading.EventResetMode.ManualReset> indicateur est spécifié pour `mode`, les threads qui attendent l’événement ne bloquent pas.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-129">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="c9f7e-130">Si l’état initial est signalé, et `mode` est <xref:System.Threading.EventResetMode.AutoReset>, le premier thread qui attend que l’événement sortira immédiatement, après laquelle l’événement réinitialisera et bloquent les threads suivants.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-130">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c9f7e-131">Le code suivant exemple utilise le <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-131">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="c9f7e-132">L’exemple démarre cinq threads et leur permet de bloquer sur un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> indicateur, puis libère un thread chaque fois l’utilisateur appuie sur la touche ENTRÉE.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-132">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses ENTER key.</span></span> <span data-ttu-id="c9f7e-133">L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-133">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="c9f7e-134">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="c9f7e-134">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="c9f7e-135"><see langword="true" /> pour définir l’état initial sur signalé si l’événement nommé est créé suite à cet appel ; <see langword="false" /> pour le définir sur non signalé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-135"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="c9f7e-136">L’une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-136">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="c9f7e-137">Le nom d’un événement de synchronisation à l’échelle du système.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-137">The name of a system-wide synchronization event.</span></span></param>
        <summary><span data-ttu-id="c9f7e-138">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, en spécifiant si le handle d'attente est signalé initialement s'il a été créé à la suite de cet appel, s'il se réinitialise automatiquement ou manuellement, ainsi que le nom d'un événement de synchronisation du système.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-138">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c9f7e-139">Si `name` est `null` ou une chaîne vide, une variable locale <xref:System.Threading.EventWaitHandle> est créé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-139">If `name` is `null` or an empty string, a local <xref:System.Threading.EventWaitHandle> is created.</span></span>  
  
 <span data-ttu-id="c9f7e-140">Si un événement système avec le nom spécifié pour le `name` paramètre existe déjà, le `initialState` paramètre est ignoré.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-140">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c9f7e-141">Lorsque vous utilisez ce constructeur pour les événements de système nommé, spécifiez `false` pour `initialState`.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-141">When using this constructor for named system events, specify `false` for `initialState`.</span></span> <span data-ttu-id="c9f7e-142">Ce constructeur ne fournit aucun moyen de déterminer si un événement système nommé a été créé, donc vous ne pouvez pas faire d’hypothèses concernant l’état de l’événement nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-142">This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</span></span> <span data-ttu-id="c9f7e-143">Pour déterminer si un événement nommé a été créé, utilisez la <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructeur ou la <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructeur.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-143">To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.</span></span>  
  
 <span data-ttu-id="c9f7e-144">Si l’état initial de l’événement est "non signalé", les threads qui attendent l’événement se bloquent.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-144">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="c9f7e-145">Si l’état initial est signalé et le <xref:System.Threading.EventResetMode.ManualReset> indicateur est spécifié pour `mode`, les threads qui attendent l’événement ne bloquent pas.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-145">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="c9f7e-146">Si l’état initial est signalé, et `mode` est <xref:System.Threading.EventResetMode.AutoReset>, le premier thread qui attend que l’événement sortira immédiatement, après laquelle l’événement réinitialisera et bloquent les threads suivants.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-146">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c9f7e-147">Une erreur Win32 s’est produite.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-147">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c9f7e-148">L’événement nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-148">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="c9f7e-149">L’événement nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-149">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c9f7e-150"><paramref name="name" /> fait plus de 260 caractères.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-150"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c9f7e-151">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-151">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c9f7e-152">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-152">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="c9f7e-153">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="c9f7e-153">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="c9f7e-154"><see langword="true" /> pour définir l’état initial sur signalé si l’événement nommé est créé suite à cet appel ; <see langword="false" /> pour le définir sur non signalé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-154"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="c9f7e-155">L’une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-155">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="c9f7e-156">Le nom d’un événement de synchronisation à l’échelle du système.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-156">The name of a system-wide synchronization event.</span></span></param>
        <param name="createdNew"><span data-ttu-id="c9f7e-157">Cette méthode retourne <see langword="true" /> si un événement local a été créé (en d'autres termes, si <paramref name="name" /> est <see langword="null" /> ou une chaîne vide) ou si l'événement système nommé spécifié a été créé ; <see langword="false" /> si l'événement système nommé spécifié existait déjà.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-157">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span></span> <span data-ttu-id="c9f7e-158">Ce paramètre est passé sans être initialisé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-158">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="c9f7e-159">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, spécifiant si le handle d’attente est signalé initialement s’il est créé suite à cet appel, s’il se réinitialise automatiquement ou manuellement, le nom d’un événement de synchronisation du système et une variable booléenne dont la valeur après l’appel indique si l’événement système nommé a été créé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-159">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c9f7e-160">Si un événement système avec le nom spécifié pour le `name` paramètre existe déjà, le `initialState` paramètre est ignoré.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-160">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="c9f7e-161">Après l’appel de ce constructeur, utilisez la valeur de la variable spécifiée pour le `ref` paramètre (`ByRef` paramètre en Visual Basic)`createdNew` pour déterminer si l’événement système nommé existait déjà ou a été créé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-161">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="c9f7e-162">Si l’état initial de l’événement est "non signalé", les threads qui attendent l’événement se bloquent.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-162">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="c9f7e-163">Si l’état initial est signalé et le <xref:System.Threading.EventResetMode.ManualReset> indicateur est spécifié pour `mode`, les threads qui attendent l’événement ne bloquent pas.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-163">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="c9f7e-164">Si l’état initial est signalé, et `mode` est <xref:System.Threading.EventResetMode.AutoReset>, le premier thread qui attend que l’événement sortira immédiatement, après laquelle l’événement réinitialisera et bloquent les threads suivants.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-164">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c9f7e-165">Une erreur Win32 s’est produite.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-165">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c9f7e-166">L’événement nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-166">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="c9f7e-167">L’événement nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-167">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c9f7e-168"><paramref name="name" /> fait plus de 260 caractères.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-168"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c9f7e-169">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-169">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c9f7e-170">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-170">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="c9f7e-171">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="c9f7e-171">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="c9f7e-172"><see langword="true" /> pour définir l’état initial sur signalé si l’événement nommé est créé suite à cet appel ; <see langword="false" /> pour le définir sur non signalé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-172"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="c9f7e-173">L’une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui détermine si l’événement se réinitialise automatiquement ou manuellement.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-173">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="c9f7e-174">Le nom d’un événement de synchronisation à l’échelle du système.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-174">The name of a system-wide synchronization event.</span></span></param>
        <param name="createdNew"><span data-ttu-id="c9f7e-175">Cette méthode retourne <see langword="true" /> si un événement local a été créé (en d'autres termes, si <paramref name="name" /> est <see langword="null" /> ou une chaîne vide) ou si l'événement système nommé spécifié a été créé ; <see langword="false" /> si l'événement système nommé spécifié existait déjà.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-175">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span></span> <span data-ttu-id="c9f7e-176">Ce paramètre est passé sans être initialisé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-176">This parameter is passed uninitialized.</span></span></param>
        <param name="eventSecurity"><span data-ttu-id="c9f7e-177">Objet <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> qui représente la sécurité de contrôle d’accès à appliquer à l’événement système nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-177">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span></span></param>
        <summary><span data-ttu-id="c9f7e-178">Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, spécifiant si le handle d’attente est signalé initialement s’il est créé suite à cet appel, s’il se réinitialise automatiquement ou manuellement, le nom d’un événement de synchronisation du système et une variable booléenne dont la valeur après l’appel indique si l’événement système nommé a été créé, et la sécurité de contrôle d’accès à appliquer à l’événement nommé s’il est créé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-178">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c9f7e-179">Utilisez ce constructeur pour appliquer la sécurité de contrôle d’accès à un événement système nommé lors de sa création, en empêchant l’autre code de prendre le contrôle de l’événement.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-179">Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</span></span>  
  
 <span data-ttu-id="c9f7e-180">Ce constructeur initialise un <xref:System.Threading.EventWaitHandle> objet qui représente un événement système.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-180">This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event.</span></span> <span data-ttu-id="c9f7e-181">Vous pouvez créer plusieurs <xref:System.Threading.EventWaitHandle> objets qui représentent le même événement système.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-181">You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.</span></span>  
  
 <span data-ttu-id="c9f7e-182">Si l’événement système n’existe pas, il est créé avec la sécurité de contrôle d’accès spécifié.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-182">If the system event does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="c9f7e-183">Si l’événement existe, la sécurité de contrôle d’accès spécifié est ignorée.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-183">If the event exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c9f7e-184">L’appelant a un contrôle total sur nouvellement créé <xref:System.Threading.EventWaitHandle> objet voire si `eventSecurity` refuse ou ne parvient pas à accorder des droits d’accès à l’utilisateur actuel.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-184">The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="c9f7e-185">Toutefois, si l’utilisateur actuel tente d’obtenir un autre <xref:System.Threading.EventWaitHandle> pour représenter le même événement nommé, en utilisant un constructeur de l’objet ou le <xref:System.Threading.EventWaitHandle.OpenExisting%2A> (méthode), Windows sécurité de contrôle d’accès est appliquée.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-185">However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="c9f7e-186">Si un événement système avec le nom spécifié pour le `name` paramètre existe déjà, le `initialState` paramètre est ignoré.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-186">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="c9f7e-187">Après l’appel de ce constructeur, utilisez la valeur de la variable spécifiée pour le `ref` paramètre (`ByRef` paramètre en Visual Basic) `createdNew` pour déterminer si l’événement système nommé existait déjà ou a été créé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-187">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="c9f7e-188">Si l’état initial de l’événement est "non signalé", les threads qui attendent l’événement se bloquent.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-188">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="c9f7e-189">Si l’état initial est signalé et le <xref:System.Threading.EventResetMode.ManualReset> indicateur est spécifié pour `mode`, les threads qui attendent l’événement ne bloquent pas.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-189">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="c9f7e-190">Si l’état initial est signalé, et `mode` est <xref:System.Threading.EventResetMode.AutoReset>, le premier thread qui attend que l’événement sortira immédiatement, après laquelle l’événement réinitialisera et bloquent les threads suivants.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-190">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c9f7e-191">L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec la sécurité de contrôle d’accès.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-191">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="c9f7e-192">L’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un événement nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-192">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="c9f7e-193">Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-193">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="c9f7e-194">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-194">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="c9f7e-195">L’exception est interceptée et l’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-195">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="c9f7e-196">Une fois que les autorisations sont modifiées, l’événement est ouvert avec les droits requis pour attendre et le signaler.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-196">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="c9f7e-197">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-197">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c9f7e-198">Une erreur Win32 s’est produite.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-198">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c9f7e-199">L’événement nommé existe et a la sécurité de contrôle d’accès, mais l’utilisateur n’a pas <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-199">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="c9f7e-200">L’événement nommé ne peut pas être créé. Il existe peut-être un handle d’attente d’un type différent portant le même nom.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-200">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c9f7e-201"><paramref name="name" /> fait plus de 260 caractères.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-201"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c9f7e-202">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-202">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c9f7e-203">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-203">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="c9f7e-204">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="c9f7e-204">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c9f7e-205">Obtient un objet <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> qui représente la sécurité de contrôle d'accès pour l'événement système nommé représenté par l'objet <see cref="T:System.Threading.EventWaitHandle" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-205">Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</span></span></summary>
        <returns><span data-ttu-id="c9f7e-206">Objet <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> qui représente la sécurité de contrôle d'accès pour l'événement système nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-206">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c9f7e-207">Le <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> méthode utilise la combinaison d’indicateurs (combinées à l’aide de l’opération OR au niveau du bit) suivante pour rechercher des autorisations : <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, et <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-207">The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c9f7e-208">L’utilisateur doit avoir <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> droits pour appeler cette méthode et l’événement doivent avoir été ouvert avec le <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-208">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c9f7e-209">L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec la sécurité de contrôle d’accès.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-209">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="c9f7e-210">L’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un événement nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-210">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="c9f7e-211">Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-211">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="c9f7e-212">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-212">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="c9f7e-213">L’exception est interceptée et l’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-213">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="c9f7e-214">Une fois que les autorisations ont été lus, à l’aide de la <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> (méthode), et modifié, l’événement est ouvert avec les droits requis pour attendre et le signaler.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-214">After the permissions have been read, using the <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method, and changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="c9f7e-215">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-215">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c9f7e-216">L'objet <see cref="T:System.Threading.EventWaitHandle" /> actuel représente un événement système nommé et l'utilisateur n'a pas de droits <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-216">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span></span>  
  
<span data-ttu-id="c9f7e-217">ou</span><span class="sxs-lookup"><span data-stu-id="c9f7e-217">-or-</span></span> 
<span data-ttu-id="c9f7e-218">L'objet <see cref="T:System.Threading.EventWaitHandle" /> actuel représente un événement système nommé ; il n'a pas été ouvert avec <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-218">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c9f7e-219">Non pris en charge par Windows 98 ou Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-219">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c9f7e-220">La méthode <see cref="M:System.Threading.WaitHandle.Close" /> a été précédemment appelée sur ce <see cref="T:System.Threading.EventWaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-220">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="c9f7e-221">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="c9f7e-221">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c9f7e-222">Ouvre un événement de synchronisation nommé spécifié s'il existe déjà.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-222">Opens a specified named synchronization event, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c9f7e-223">Nom de l’événement de synchronisation système à ouvrir.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-223">The name of the system synchronization event to open.</span></span></param>
        <summary><span data-ttu-id="c9f7e-224">Ouvre l'événement de synchronisation nommé spécifié s'il existe déjà.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-224">Opens the specified named synchronization event, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="c9f7e-225">Objet qui représente l’événement système nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-225">An  object that represents the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c9f7e-226">Le <xref:System.Threading.EventWaitHandle.OpenExisting%2A> méthode tente d’ouvrir l’événement système nommé spécifié.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-226">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event.</span></span> <span data-ttu-id="c9f7e-227">Si l’événement système n’existe pas, cette méthode lève une exception au lieu de créer l’événement système.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-227">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="c9f7e-228">Pour créer l’événement système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructeurs qui a un `name` paramètre.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-228">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="c9f7e-229">Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.EventWaitHandle> de l’objet, même si les objets retournés représentent le même événement système nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-229">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 <span data-ttu-id="c9f7e-230">Cette surcharge de méthode revient à appeler le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode et en spécifiant <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> et <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> droits, combinés à l’aide de l’opération OR au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-230">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="c9f7e-231">En spécifiant le <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> indicateur permet à un thread à attendre l’événement système nommé et en spécifiant le <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> indicateur permet à un thread d’appeler le <xref:System.Threading.EventWaitHandle.Set%2A> et <xref:System.Threading.EventWaitHandle.Reset%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-231">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c9f7e-232">L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec la sécurité de contrôle d’accès.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-232">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="c9f7e-233">L’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un événement nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-233">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="c9f7e-234">Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-234">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="c9f7e-235">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-235">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="c9f7e-236">L’exception est interceptée et l’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-236">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="c9f7e-237">Une fois que les autorisations sont modifiées, l’événement est ouvert avec les droits requis pour attendre et le signaler.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-237">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="c9f7e-238">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-238">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c9f7e-239"><paramref name="name" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-239"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="c9f7e-240">ou</span><span class="sxs-lookup"><span data-stu-id="c9f7e-240">-or-</span></span> 
 <span data-ttu-id="c9f7e-241"><paramref name="name" /> fait plus de 260 caractères.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-241"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c9f7e-242"><paramref name="name" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-242"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="c9f7e-243">L'événement de système nommé n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-243">The named system event does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c9f7e-244">Une erreur Win32 s’est produite.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-244">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c9f7e-245">L'événement nommé existe, mais l'utilisateur ne possède pas l'accès de sécurité requis pour l'utiliser.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-245">The named event exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c9f7e-246">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-246">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c9f7e-247">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-247">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="c9f7e-248">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="c9f7e-248">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c9f7e-249">Nom de l’événement de synchronisation système à ouvrir.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-249">The name of the system synchronization event to open.</span></span></param>
        <param name="rights"><span data-ttu-id="c9f7e-250">Combinaison d'opérations de bits des valeurs d'énumération qui représentent l'accès de sécurité voulu.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-250">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="c9f7e-251">Ouvre l'événement de synchronisation nommé spécifié, s'il existe déjà, avec l'accès de sécurité souhaité.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-251">Opens the specified named synchronization event, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="c9f7e-252">Objet qui représente l'événement système nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-252">An object that represents the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c9f7e-253">Le `rights` paramètre doit inclure le <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> indicateur pour permettre aux threads d’attendre l’événement et le <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> indicateur pour permettre d’appeler le <xref:System.Threading.EventWaitHandle.Set%2A> et <xref:System.Threading.EventWaitHandle.Reset%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-253">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="c9f7e-254">Le <xref:System.Threading.EventWaitHandle.OpenExisting%2A> méthode tente d’ouvrir un événement système nommé existant.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-254">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event.</span></span> <span data-ttu-id="c9f7e-255">Si l’événement système n’existe pas, cette méthode lève une exception au lieu de créer l’événement système.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-255">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="c9f7e-256">Pour créer l’événement système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructeurs qui a un `name` paramètre.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-256">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="c9f7e-257">Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.EventWaitHandle> de l’objet, même si les objets retournés représentent le même événement système nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-257">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c9f7e-258">L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec la sécurité de contrôle d’accès.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-258">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="c9f7e-259">L’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un événement nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-259">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="c9f7e-260">Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-260">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="c9f7e-261">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-261">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="c9f7e-262">L’exception est interceptée et l’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-262">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="c9f7e-263">Une fois que les autorisations sont modifiées, l’événement est ouvert avec les droits requis pour attendre et le signaler.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-263">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="c9f7e-264">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-264">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c9f7e-265"><paramref name="name" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-265"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="c9f7e-266">ou</span><span class="sxs-lookup"><span data-stu-id="c9f7e-266">-or-</span></span> 
 <span data-ttu-id="c9f7e-267"><paramref name="name" /> fait plus de 260 caractères.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-267"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c9f7e-268"><paramref name="name" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-268"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="c9f7e-269">L'événement de système nommé n'existe pas.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-269">The named system event does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c9f7e-270">Une erreur Win32 s’est produite.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-270">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c9f7e-271">L’événement nommé existe mais l’utilisateur ne dispose de l’accès de sécurité nécessaire.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-271">The named event exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c9f7e-272">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-272">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c9f7e-273">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-273">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="c9f7e-274">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="c9f7e-274">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c9f7e-275">Définit l'état de l'événement comme étant non signalé, entraînant le blocage des threads.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-275">Sets the state of the event to nonsignaled, causing threads to block.</span></span></summary>
        <returns><span data-ttu-id="c9f7e-276"><see langword="true" /> si l'opération aboutit ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-276"><see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c9f7e-277">La méthode <see cref="M:System.Threading.WaitHandle.Close" /> a été précédemment appelée sur ce <see cref="T:System.Threading.EventWaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-277">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="c9f7e-278">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="c9f7e-278">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c9f7e-279">Définit l'état de l'événement comme étant signalé, ce qui permet à un ou plusieurs threads en attente de continuer.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-279">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</span></span></summary>
        <returns><span data-ttu-id="c9f7e-280"><see langword="true" /> si l'opération aboutit ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-280"><see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c9f7e-281">Pour un <xref:System.Threading.EventWaitHandle> avec <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (y compris <xref:System.Threading.AutoResetEvent>), la <xref:System.Threading.EventWaitHandle.Set%2A> méthode libère un thread unique.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-281">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread.</span></span> <span data-ttu-id="c9f7e-282">S’il n’y a pas de threads en attente, le handle d’attente reste signalé jusqu'à ce qu’un thread tente d’attendre sur celui-ci, ou jusqu'à ce que son <xref:System.Threading.EventWaitHandle.Reset%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-282">If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c9f7e-283">N’est pas garanti que chaque appel à la <xref:System.Threading.EventWaitHandle.Set%2A> libère un thread à partir d’un <xref:System.Threading.EventWaitHandle> dont le mode de réinitialisation est <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-283">There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c9f7e-284">Si deux appels sont trop proches, afin que le deuxième appel se produit avant la libération d’un thread, un seul thread est libéré.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-284">If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</span></span> <span data-ttu-id="c9f7e-285">Il s’agit comme si le deuxième appel n’a pas eu lieu.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-285">It is as if the second call did not happen.</span></span> <span data-ttu-id="c9f7e-286">En outre, si <xref:System.Threading.EventWaitHandle.Set%2A> est appelée lorsqu’il n’y a aucun thread n’attend que <xref:System.Threading.EventWaitHandle> est déjà signalé, l’appel n’a aucun effet.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-286">Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.</span></span>  
  
 <span data-ttu-id="c9f7e-287">Pour un <xref:System.Threading.EventWaitHandle> avec <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (y compris <xref:System.Threading.ManualResetEvent>), l’appel la <xref:System.Threading.EventWaitHandle.Set%2A> méthode laisse le handle d’attente dans un état signalé jusqu'à ce que son <xref:System.Threading.EventWaitHandle.Reset%2A> méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-287">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c9f7e-288">Le code suivant exemple utilise le <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> surcharge de méthode pour permettre au thread principal de signaler un thread bloqué et d’attendre jusqu'à ce que le thread termine une tâche.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-288">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="c9f7e-289">L’exemple démarre cinq threads et leur permet de bloquer sur un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> indicateur, puis libère un thread chaque fois l’utilisateur appuie sur la touche ENTRÉE.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-289">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="c9f7e-290">L’exemple, puis les files d’attente cinq autres threads et ne les libère tout en utilisant un <xref:System.Threading.EventWaitHandle> créé avec le <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-290">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c9f7e-291">La méthode <see cref="M:System.Threading.WaitHandle.Close" /> a été précédemment appelée sur ce <see cref="T:System.Threading.EventWaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-291">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="c9f7e-292">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="c9f7e-292">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="eventSecurity"><span data-ttu-id="c9f7e-293">Objet <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> qui représente la sécurité de contrôle d’accès à appliquer à l’événement système nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-293">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span></span></param>
        <summary><span data-ttu-id="c9f7e-294">Définit la sécurité de contrôle d'accès pour un événement système nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-294">Sets the access control security for a named system event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c9f7e-295">L’utilisateur doit avoir <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> droits pour appeler cette méthode et l’événement doivent avoir été ouvert avec le <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> indicateur.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-295">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c9f7e-296">L’exemple de code suivant illustre le comportement interprocessus d’un événement système nommé avec la sécurité de contrôle d’accès.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-296">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="c9f7e-297">L’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> surcharge de méthode pour tester l’existence d’un événement nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-297">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="c9f7e-298">Si l’événement n’existe pas, il est créé avec la propriété initiale et la sécurité de contrôle d’accès qui refuse l’utilisateur actuel le droit d’utiliser l’événement, mais qui accorde le droit de lire et modifier les autorisations sur l’événement.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-298">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="c9f7e-299">Si vous exécutez l’exemple compilé à partir de deux fenêtres de commande, la deuxième copie lève une exception de violation d’accès sur l’appel à <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-299">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="c9f7e-300">L’exception est interceptée et l’exemple utilise le <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode pour attendre l’événement avec les droits nécessaires pour lire et modifier les autorisations.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-300">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="c9f7e-301">Une fois que les autorisations sont modifiées, à l’aide de la <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> méthode, l’événement est ouvert avec les droits requis pour attendre et le signaler.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-301">After the permissions are changed, using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="c9f7e-302">Si vous exécutez l’exemple compilé à partir d’une troisième fenêtre de commande, l’exemple utilise les nouvelles autorisations.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-302">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c9f7e-303"><paramref name="eventSecurity" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-303"><paramref name="eventSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c9f7e-304">L'utilisateur ne détient pas d'autorisations <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-304">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span></span>  
  
<span data-ttu-id="c9f7e-305">ou</span><span class="sxs-lookup"><span data-stu-id="c9f7e-305">-or-</span></span> 
<span data-ttu-id="c9f7e-306">L'événement n'a pas été ouvert avec <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-306">The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="c9f7e-307">L'objet <see cref="T:System.Threading.EventWaitHandle" /> actuel ne représente pas un événement système nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-307">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c9f7e-308">La méthode <see cref="M:System.Threading.WaitHandle.Close" /> a été précédemment appelée sur ce <see cref="T:System.Threading.EventWaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-308">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="c9f7e-309">Vue d’ensemble des primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="c9f7e-309">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c9f7e-310">Ouvre un événement de synchronisation nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-310">Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c9f7e-311">Nom de l’événement de synchronisation système à ouvrir.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-311">The name of the system synchronization event to open.</span></span></param>
        <param name="result"><span data-ttu-id="c9f7e-312">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.EventWaitHandle" /> qui représente l’événement de synchronisation nommé si l’appel a réussi, ou <see langword="null" /> si l’appel a échoué.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-312">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="c9f7e-313">Ce paramètre est traité comme étant non initialisé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-313">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="c9f7e-314">Ouvre l’événement de synchronisation nommé spécifié, s’il existe déjà, et retourne une valeur indiquant si l’opération a réussi.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-314">Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="c9f7e-315"><see langword="true" /> si l’événement de synchronisation nommé a été ouvert ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-315"><see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c9f7e-316">Si l’événement de synchronisation nommé n’existe pas, cette méthode ne le crée pas.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-316">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="c9f7e-317">Pour créer l’événement système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructeurs qui a un `name` paramètre.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-317">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="c9f7e-318">Si vous ne savez pas si un événement de synchronisation nommé existe, utilisez cette surcharge de méthode au lieu du <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> surcharge de méthode qui lève une exception si l’événement de synchronisation n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-318">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="c9f7e-319">Cette surcharge de méthode revient à appeler le <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> surcharge de méthode et en spécifiant <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> et <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> droits, combinés à l’aide de l’opération OR au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-319">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="c9f7e-320">En spécifiant le <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> indicateur permet à un thread à attendre l’événement système nommé et en spécifiant le <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> indicateur permet à un thread d’appeler le <xref:System.Threading.EventWaitHandle.Set%2A> et <xref:System.Threading.EventWaitHandle.Reset%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-320">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="c9f7e-321">Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.EventWaitHandle> de l’objet, même si les objets retournés représentent le même événement système nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-321">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c9f7e-322"><paramref name="name" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-322"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="c9f7e-323">ou</span><span class="sxs-lookup"><span data-stu-id="c9f7e-323">-or-</span></span> 
 <span data-ttu-id="c9f7e-324"><paramref name="name" /> fait plus de 260 caractères.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-324"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c9f7e-325"><paramref name="name" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-325"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c9f7e-326">Une erreur Win32 s’est produite.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-326">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c9f7e-327">L’événement nommé existe mais l’utilisateur ne dispose de l’accès de sécurité nécessaire.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-327">The named event exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c9f7e-328">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-328">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c9f7e-329">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-329">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c9f7e-330">Nom de l’événement de synchronisation système à ouvrir.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-330">The name of the system synchronization event to open.</span></span></param>
        <param name="rights"><span data-ttu-id="c9f7e-331">Combinaison d'opérations de bits des valeurs d'énumération qui représentent l'accès de sécurité voulu.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-331">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="c9f7e-332">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.EventWaitHandle" /> qui représente l'événement de synchronisation nommé si l'appel a réussi, ou <see langword="null" /> si l'appel a échoué.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-332">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="c9f7e-333">Ce paramètre est traité comme étant non initialisé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-333">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="c9f7e-334">Ouvre l'événement de synchronisation nommé spécifié, s'il existe déjà, avec l'accès de sécurité souhaité, puis retourne une valeur indiquant si l'opération a réussi.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-334">Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="c9f7e-335"><see langword="true" /> si l’événement de synchronisation nommé a été ouvert ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-335"><see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c9f7e-336">Si l’événement de synchronisation nommé n’existe pas, cette méthode ne le crée pas.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-336">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="c9f7e-337">Pour créer l’événement système lorsqu’il n’existe pas déjà, utilisez une de la <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructeurs qui a un `name` paramètre.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-337">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="c9f7e-338">Si vous ne savez pas si un événement de synchronisation nommé existe, utilisez cette surcharge de méthode au lieu du <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> surcharge de méthode qui lève une exception si l’événement de synchronisation n’existe pas.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-338">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="c9f7e-339">Le `rights` paramètre doit inclure le <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> indicateur pour permettre aux threads d’attendre l’événement et le <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> indicateur pour permettre d’appeler le <xref:System.Threading.EventWaitHandle.Set%2A> et <xref:System.Threading.EventWaitHandle.Reset%2A> méthodes.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-339">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="c9f7e-340">Plusieurs appels à cette méthode qui utilisent la même valeur pour `name` ne retournent pas nécessairement le même <xref:System.Threading.EventWaitHandle> de l’objet, même si les objets retournés représentent le même événement système nommé.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-340">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c9f7e-341"><paramref name="name" /> est une chaîne vide.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-341"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="c9f7e-342">ou</span><span class="sxs-lookup"><span data-stu-id="c9f7e-342">-or-</span></span> 
 <span data-ttu-id="c9f7e-343"><paramref name="name" /> fait plus de 260 caractères.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-343"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c9f7e-344"><paramref name="name" /> est <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-344"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="c9f7e-345">Une erreur Win32 s’est produite.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-345">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="c9f7e-346">L’événement nommé existe mais l’utilisateur ne dispose de l’accès de sécurité nécessaire.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-346">The named event exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c9f7e-347">requiert une confiance totale pour l’appelant immédiat.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-347">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c9f7e-348">Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</span><span class="sxs-lookup"><span data-stu-id="c9f7e-348">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>